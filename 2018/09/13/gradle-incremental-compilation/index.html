<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sunmoonblog.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文翻译自Gradle 3.4发布时官方发表的技术博客。虽然现在看来Gradle 3.4已经是很老的版本了，但这篇博客中干货满满，解答了我关于Gradle的不少疑问，所以很有必要翻译一下作为学习！">
<meta name="keywords" content="android">
<meta property="og:type" content="article">
<meta property="og:title" content="(翻译)Gradle增量编译">
<meta property="og:url" content="http://www.sunmoonblog.com/2018/09/13/gradle-incremental-compilation/index.html">
<meta property="og:site_name" content="Sunmoon的博客">
<meta property="og:description" content="本文翻译自Gradle 3.4发布时官方发表的技术博客。虽然现在看来Gradle 3.4已经是很老的版本了，但这篇博客中干货满满，解答了我关于Gradle的不少疑问，所以很有必要翻译一下作为学习！">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://www.sunmoonblog.com/2018/09/13/gradle-incremental-compilation/gradle1.jpg">
<meta property="og:image" content="http://www.sunmoonblog.com/2018/09/13/gradle-incremental-compilation/gradle2.jpg">
<meta property="og:updated_time" content="2020-11-13T02:18:58.902Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="(翻译)Gradle增量编译">
<meta name="twitter:description" content="本文翻译自Gradle 3.4发布时官方发表的技术博客。虽然现在看来Gradle 3.4已经是很老的版本了，但这篇博客中干货满满，解答了我关于Gradle的不少疑问，所以很有必要翻译一下作为学习！">
<meta name="twitter:image" content="http://www.sunmoonblog.com/2018/09/13/gradle-incremental-compilation/gradle1.jpg">

<link rel="canonical" href="http://www.sunmoonblog.com/2018/09/13/gradle-incremental-compilation/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>(翻译)Gradle增量编译 | Sunmoon的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sunmoon的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.sunmoonblog.com/2018/09/13/gradle-incremental-compilation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sunmoon">
      <meta itemprop="description" content="移动开发 Android 生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sunmoon的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          (翻译)Gradle增量编译
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-13 14:28:52" itemprop="dateCreated datePublished" datetime="2018-09-13T14:28:52+08:00">2018-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-13 10:18:58" itemprop="dateModified" datetime="2020-11-13T10:18:58+08:00">2020-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文翻译自Gradle 3.4发布时官方发表的<a href="https://blog.gradle.org/incremental-compiler-avoidance" target="_blank" rel="noopener">技术博客</a>。虽然现在看来Gradle 3.4已经是很老的版本了，但这篇博客中干货满满，解答了我关于Gradle的不少疑问，所以很有必要翻译一下作为学习！</p>
<a id="more"></a>
<hr>
<p>这篇文章解答了以下几个问题：</p>
<ul>
<li>什么是增量编译?</li>
<li>Compile avoidance跟增量编译有何区别？</li>
<li>为什么修改常量会影响编译编译？</li>
<li>什么是annotation processor?</li>
<li>为什么annotation processor会影响增量编译？该如何解决？</li>
<li>为什么要用implementation和api替代compile，不然会有如下警告？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Configuration &apos;compile&apos; is obsolete and has been replaced with &apos;implementation&apos; and &apos;api&apos;.</span><br><span class="line">It will be removed at the end of 2018. For more information see: http://d.android.com/r/tools/update-dependency-configurations.html</span><br></pre></td></tr></table></figure>
<p>这篇文章提到了几个有价值的知识点：</p>
<ul>
<li>Making a small change should never result in a long build</li>
<li>Compile avoidance is different from incremental compilation<ul>
<li>Compile avoidance - ABI不兼容的修改，需要重新编译；非ABI不兼容的修改，不需要重新编译</li>
<li>Incremental compilation - 分析类之间的依赖关系，只编译那些发生了变化的类</li>
</ul>
</li>
<li>Not all constants are born equal: a constant value of 0 is much more likely to trigger a full recompilation when changed, than a constant value 188847774</li>
<li>An annotation processor is a Java compiler plugin. It is triggered whenever the Java compiler recognizes an annotation that is handled by a processor</li>
<li>The dependencies of the annotation processor should never leak into your compile classpath</li>
<li>The api bucket is used to declare dependencies that should transitively be visible by downstream consumers when they are compiled. </li>
<li>The implementation bucket is used to declare dependencies which should not leak into the compile classpath of consumers (because they are purely internal details).</li>
</ul>
<p>好吧。开始翻译了。</p>
<hr>
<p>我们很自豪地宣布刚刚发布的Gradle 3.4已经为各种用户构建Java应用进行了非常大的改进。这篇博客将解释我们修复，改进以及增加的各种细节。我们着重关注：</p>
<ul>
<li>快速增量构建</li>
<li>消除compile classpath泄漏问题</li>
</ul>
<p>我们极大地改进了构建速度。这是我们的测量结果：</p>
<p><img src="gradle1.jpg" alt></p>
<p>这个基准测试是<a href="https://github.com/gradle/performance-comparisons" target="_blank" rel="noopener">公开的</a>，你自己可以动手试验一下。该基准测试项目是根据真实用户反馈的问题虚构的一个项目。在持续开发过程中增量构建很重要(即，小的改动不应导致长时间的构建)</p>
<p>以那些在单个项目中有很多源码的场景为例：</p>
<ul>
<li>修改庞大项目中的一个文件，重新编译项目</li>
<li>修改中型项目中的一个文件，重新编译项目</li>
</ul>
<p>以多项目构建为例：</p>
<ul>
<li>在子项目中以ABI兼容的方式进行修改(比如，修改了一个方法中的代码，但没有修改方法签名)，重新编译项目</li>
<li>在子项目中以ABI不兼容的方式进行修改(比如，修改了一个方法的签名)，重新编译项目</li>
</ul>
<p>对上述各个场景，Gradle 3.4构建速度快多了。接下来看看我们是如何做到的。</p>
<h1 id="Compile-avoidance"><a href="#Compile-avoidance" class="headerlink" title="Compile avoidance"></a>Compile avoidance</h1><p>对Java来说，升级到Gradle 3.4就可以享受到它最大的改进之一： <em>compile avoidance</em> 。Compile avoidance不同于增量编译，我们后面会详细解释。那么如何理解compile avoidance呢？很简单。假设你的<code>app</code>项目依赖<code>core</code>项目，而<code>core</code>项目本身又依赖<code>utils</code>项目。</p>
<p>在<code>app</code>项目中有以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        WordCount wc = <span class="keyword">new</span> WordCount();</span><br><span class="line">        wc.collect(<span class="keyword">new</span> File(args[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(<span class="string">"Word count: "</span> + wc.wordCount());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>core</code>项目中有以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;  <span class="comment">// WordCount lives in project `core`</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">collect</span><span class="params">(File source)</span> </span>&#123;</span><br><span class="line">       IOUtils.eachLine(source, WordCount::collectLine);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>utils</code>项目中有以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOUtils</span> </span>&#123; <span class="comment">// IOUtils lives in project `utils`</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eachLine</span><span class="params">(File file, Callable&lt;String&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file))) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，要修改<code>IOUtils</code>的实现。比如，修改<code>eachLine</code>方法，使用utf8编码而不是缺省编码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOUtils</span> </span>&#123; <span class="comment">// IOUtils lives in project `utils`</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eachLine</span><span class="params">(File file, Callable&lt;String&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(file), <span class="string">"utf-8"</span>) )) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在重新构建<code>app</code>项目，会发生什么情况？<code>utils</code>需要重新编译，而由于依赖关系它又会触发<code>core</code>和<code>app</code>重新编译。乍一看，很合理。但真的合理吗？</p>
<p><code>IOUtils</code>的修改只是内部细节的改变。<code>eachLine</code>的实现变了，但它的公开API并没有变化。之前已经编译好的依赖<code>IOUtils</code>的class文件其实仍然有效。Gradle现在可以识别这一点了，这意味着当你修改<code>eachLine</code>时，Gradle只需要编译<code>utils</code>项目，不必再编译<code>core</code>和<code>app</code>了。这个例子看似简单，其实是一种很常见的模式：<code>core</code>项目通常被很多子项目共享，而每个子项目又依赖于其他子项目。<code>core</code>项目的改动会导致所有项目都要重新编译。Gradle 3.4中这种情况不存在了，即，Gradle可以判断是否ABI(Application Binary Interface)不兼容的修改，只有ABI不兼容的修改才会引起所有项目重新编译。</p>
<p>这就是我们所谓的compilation avoidance。即使一些情况下重新编译不可避免，Gradle 3.4的增量编译功能也会让编译速度更快。</p>
<h1 id="改进的增量编译"><a href="#改进的增量编译" class="headerlink" title="改进的增量编译"></a>改进的增量编译</h1><p>长久以来，Gradle有一个实验性的Java增量编译器。在Gradle 3.4中，这个编译器不仅被确定下来，而且我们增加了其稳定性并提升了性能。现在就开始使用增量编译吧：我们不久之后会缺省启用该功能。要使用增量编译，只需在compile选项中设置参数即可：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tasks.withType(JavaCompile) &#123;</span><br><span class="line">   options.incremental = <span class="literal">true</span> <span class="comment">// one flag, and things will get MUCH faster</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>core</code>项目中增加以下类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NGrams</span> </span>&#123;  <span class="comment">// NGrams lives in project `core`</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">collect</span><span class="params">(String source, <span class="keyword">int</span> ngramLength)</span> </span>&#123;</span><br><span class="line">       collectInternal(StringUtils.sanitize(source), ngramLength);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>utils</code>项目中增加以下类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringUtils</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> String <span class="title">sanitize</span><span class="params">(String dirtyString)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们修改了<code>StringUtils</code>类并且重新编译项目，很明显我们只需要重新编译<code>StringUtils</code>和<code>NGrams</code>类，而不必编译<code>WordCount</code>类。<code>NGrams</code>是独立于<code>StringUtils</code>的类。而<code>WordCount</code>并没有使用到<code>StringUtils</code>，那为什么要重新编译它呢？这就是增量编译要解决的问题：分析类之间的依赖关系，只编译那些本身发生改变的类，或者其依赖项发生改变的类。</p>
<p>你之前使用过Java增量编译器时可能发现它在处理带有常量的类的修改时并不那么智能。比如，这个类包含一个常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这个类被修改，Gradle会重新编译项目中的所有类以及依赖这个项目的所有项目。原因是这样的：你要知道，Java编译器会对常量进行内联处理。当我们分析编译结果时，在字节码中会发现它包含字面量123，但无法知道这个字面量是在哪里定义的。可能是这个类自己定义的，也有可能是它的某个依赖定义的。Gradle 3.4开始，我们让这里的处理更为智能，即，只编译那些可能受影响的类。换句话说，如果只是这个类变了，而其中的常量并没有变，不需要重新编译所有类。类似地，如果是常量变了，如果依赖项的字节码中并不包含旧的常量值，那么也就不必对其重新编译：只编译那些包含旧常量值的依赖。这也意味着并不是所有的常量生而平等，修改一个值为0的常量比起修改一个值为188847774的常量，前者更可能触发全量编译。</p>
<p>增量编译器现在使用Gradle daemon中的内存缓存，所以速度比过去要快：从Java类中提取ABI是一个昂贵的操作，而过去只对其进行disk缓存。</p>
<p>所有这些增量编译改进再加上前面说到的compile avoidance，Gradle现在重新编译Java代码已经快多了。值得一提的是，这些改进对外部依赖也有效。假设你从<code>foo-1.0.0</code>升级到<code>foo-1.0.1</code>，如果这两个库之间的差异仅仅是修改bug，并没有改变API，那么compile avoidance也会起作用，所以外部依赖的变化并没有让你的代码重新编译。当然，如果是外部依赖中的API发生了变化，Gradle的增量编译器会在类级别上进行分析，只进行必要的重新编译。</p>
<h1 id="annotation-processor"><a href="#annotation-processor" class="headerlink" title="annotation processor"></a>annotation processor</h1><p>annotation processors是一种强大的机制，可以通过注解的方式生成代码。典型的使用场景包括依赖注入(比如<a href="https://google.github.io/dagger/" target="_blank" rel="noopener">Dagger</a>)，或者是减少样板代码(比如，<a href="https://projectlombok.org/" target="_blank" rel="noopener">Lombok</a>, <a href="https://github.com/google/auto/tree/master/value" target="_blank" rel="noopener">Autovalue</a>, <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">Butterknife</a>)。但是使用annotation processor对构建性能有很多负面影响。</p>
<h2 id="annotation-processor原理"><a href="#annotation-processor原理" class="headerlink" title="annotation processor原理"></a>annotation processor原理</h2><p>annotation processor基本上可以理解成一个Java编译器插件。在Java编译器识别到一个可被processor处理的注解时就会触发这个processor。从构建工具角度而言，它是一个墨盒：我们并不知道annotation processor到底做了什么操作，尤其是annotation processor生成了什么文件，这些文件放在哪里。</p>
<p>因此一旦annotation processor的实现发生了变化，Gradle需要重新编译所有东西。这不算太糟糕，因为不经常发生。但问题是没有明确声明annotation processor时Gradle只能关闭compile avoidance功能。我们来看一下是怎么回事。现在的annotation processor一般都被添加到compile classpath中。</p>
<p>当Gradle发现一个jar文件中包含annotation processor时，它没法判断compile classpath下的其他jar文件是否被那个annotation processor使用。要知道，annotation processor本身也可能是有依赖的。这意味着compile classpath的任何变化都可能以某种Gradle没法理解的方式影响到annotation processor的行为。所以compile classpath发生任何变化都会触发全量编译。</p>
<p>但这个问题有解决办法。</p>
<h2 id="明确声明annotation-processor-classpath"><a href="#明确声明annotation-processor-classpath" class="headerlink" title="明确声明annotation processor classpath"></a>明确声明annotation processor classpath</h2><p>annotation processor作为编译器插件，使用到外部依赖，一定会影响到compile classpath，不是吗？答案是否定的。annotation processor的依赖不应该影响到compile classpath。这也正是为什么<code>javac</code>会提供<code>-processorpath</code>选项的原因，它用来区别于<code>-classpath</code>。你可以使用如下方式在Gradle中声明<code>processorpath</code>。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">    apt</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// The dagger compiler and its transitive dependencies will only be found on annotation processing classpath</span></span><br><span class="line">    apt <span class="string">'com.google.dagger:dagger-compiler:2.8'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// And we still need the Dagger annotations on the compile classpath itself</span></span><br><span class="line">    compileOnly <span class="string">'com.google.dagger:dagger:2.8'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compileJava &#123;</span><br><span class="line">    options.annotationProcessorPath = configurations.apt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中创建了一个<code>apt</code>配置，它包含所有被使用的annotation processor以及annotation processor自身的依赖。然后将<code>apt</code>设置给<code>annotationProcessorPath</code>。它有几个作用：</p>
<ul>
<li>一是关闭了在compile classpath中自动检查annotation processor的功能，这会让任务启动速度变快(更快的up-to-date检查)</li>
<li>二是会用到Java编译器的<code>processorpath</code>选项，可以正确地将compile依赖跟annotation processor自身的依赖区分开来</li>
<li>三是会开启compile avoidance：通过明确声明annotation processor，就能确定classpath中找到的所有东西都是二进制接口(与annotation processor没半点关系)</li>
</ul>
<p>特别是，你会注意到<a href="https://google.github.io/dagger/" target="_blank" rel="noopener">Dagger</a>是如何明确地将其编译器与注解分离开来的：我们使用<code>dagger-compiler</code>作为annotation处理过程的依赖，而将<code>dagger</code>(即注解本身)作为<code>compile</code>依赖。</p>
<p>但是，有些annotation processor并没有将这些关注点恰当地分离(比如<a href="https://projectlombok.org/" target="_blank" rel="noopener">Lombok</a>)，所以导致其实现类被泄露到compile classpath中。但这种场景下compile avoidance仍然起作用：你只需要将同一个jar同时放在<code>apt</code>和<code>compileOnly</code>配置中。</p>
<h2 id="带annotation-processor的增量编译"><a href="#带annotation-processor的增量编译" class="headerlink" title="带annotation processor的增量编译"></a>带annotation processor的增量编译</h2><p>上面说过，有annotation processor时，Gradle并不知道它生成了什么文件，也不知道它基于什么条件在哪里生成了文件。所以有annotation processor时Gradle会关闭Java增量编译器，即使你像刚才那样明确地声明annotation processor。但其实优化这种场景，限制annotation processor的影响，让它只影响到那些真正用到annotation processor的源码。简而言之，你要声明一个不同的source set，这个source set有不同的compile task，会用到annotation processor，而其它的compile task没有任何annotation processor：</p>
<ul>
<li>对那些没有用到的annotation processor的类进行修改时，增量编译仍然有效</li>
<li>对那些有用到annotation processor的类进行修改时，会触发全量编译，但只对对应原source set进行全量编译</li>
</ul>
<p>这里是一个例子：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">    apt</span><br><span class="line">    aptCompile</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    apt <span class="string">'com.google.dagger:dagger-compiler:2.8'</span></span><br><span class="line">    aptCompile <span class="string">'com.google.dagger:dagger:2.8'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sourceSets &#123;</span><br><span class="line">   processed &#123;</span><br><span class="line">       java &#123;</span><br><span class="line">          compileClasspath += configurations.aptCompile</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   main &#123;</span><br><span class="line">       java &#123;</span><br><span class="line">          compileClasspath += processed.output</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compileProcessedJava &#123;</span><br><span class="line">    options.annotationProcessorPath = configurations.apt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然实践中是否容易进行source set隔离，还要看<code>main</code>在多大程度上依赖<code>processed</code>中的类。当然我们也在探索如何在有annotation processor时开启增量编译，所以今后它将不再是一个问题。</p>
<h1 id="Java库"><a href="#Java库" class="headerlink" title="Java库"></a>Java库</h1><p>很久以来Gradle就在解释为什么Maven依赖模块有问题，但没有具体例子的话很难认识这一点，因为用户已经习惯这个问题并且认为它是正常的。尤其是<code>pom.xml</code>文件既用于构建组件，也作为发布时的元数据。Gradle的方式有所不同，它有一个构建脚本用于构建组件以及发布组件，可将组件发布到Maven，Ivy或任何其它库。发布的文件中包括该如何使用的元数据，也就是说我们将用于构建组件的脚本跟该如何使用最终产物的元数据清晰地分离了。将这两个角色分离是非常重要的，这允许Gradle 3.4对Java依赖管理添加基础改进。用户可以从这个基础改进中获得其他好处。首先是性能改进，它是对上述其他性能特性的补充。额外其他好处也很多。</p>
<h2 id="一直在用错误的方式"><a href="#一直在用错误的方式" class="headerlink" title="一直在用错误的方式"></a>一直在用错误的方式</h2><p>当我们在构建Java项目时，有两件事情需要考虑：</p>
<ul>
<li>我要怎样编译项目</li>
<li>我要怎样运行项目</li>
</ul>
<p>所以我们很自然地想在在两种不同的范围里声明依赖：</p>
<ul>
<li><code>compile</code> - 编译项目时的依赖</li>
<li><code>runtime</code> - 运行项目时的依赖</li>
</ul>
<p>过去这些年Maven和Gradle都这么用。但我们一开始就知道这样做是错的。这种视角过于简化，因为它没有考虑你的项目的消费者。要强调的是，Java世界里至少有两种项目：</p>
<ul>
<li>应用，它是可以独立运行的，并且不向外暴露任何API</li>
<li>库，它被其他库或应用使用，用作构建软件的小部件，所以要向外暴露API</li>
</ul>
<p>这种只考虑两种配置(Gradle)或者说两种范围(Maven)的简单方式，其问题在于没有考虑到具体的实现跟公开的API是两码事。换句话说，作为组件，你却将自己的编译依赖泄漏出下游消费者了。</p>
<p>假设我们正在构建一个IoT应用<code>home-automation</code>，它依赖<code>heat-sensor</code>库。<code>heat-sensor</code>库的compile classpath中包含有<code>commons-math3.jar</code>和<code>guava.jar</code>。所以<code>home-automation</code>的compile classpath中也将包含<code>commons-math3.jar</code>和<code>guava.jar</code>。有以下几种结果：</p>
<ul>
<li><code>home-automation</code>可能会使用<code>commons-math3.jar</code>和<code>guava.jar</code>中的类，但没意识到这些类其实是<code>heat-sensor</code>的传递依赖(传递依赖泄漏)</li>
<li>导致<code>home-automation</code>的compile classpath变得更大：<ul>
<li>依赖解析，up-to-date检查，classpath分析，以及<code>javac</code>花费的时间变长</li>
<li>classpath发生变化的可能性变大，导致Gradle的compile avoidance功能失效的可能性变大。尤其是当你又使用了annotation processor，Gradle的增量编译不起作用。最终引起非常大的开销</li>
</ul>
</li>
<li>增加了依赖地狱的可能(dependency hell, classpath中包含同一依赖的不同版本)</li>
</ul>
<p>但最糟糕的问题其实是<code>guava.jar</code>纯粹是<code>heat-sensor</code>的内部细节，而<code>home-automation</code>使用<code>guava.jar</code>中的类仅仅是因为在compile classpath中找到了这些类。<code>heat-sensor</code>的改进和演化变得困难，因为会破坏它的消费者(译者注：这里其实是说，如果哪天发现<code>heat-sensor</code>其实没必要使用<code>guava.jar</code>，或者有比<code>guava.jar</code>更好的库了，但你没办法从<code>heat-sensor</code>中移除或替换<code>guava.jar</code>，因为<code>home-automation</code>也依赖<code>guava.jar</code>)。依赖泄漏是很可怕，它引起不必要的向后兼容问题，导致软件演化过程变得缓慢或是特性僵化。</p>
<p>我们知道自己一直做错了，现在是时间修复这个问题了。所以引入了新的Java Library Plugin。</p>
<h2 id="Java-Library-Plugin"><a href="#Java-Library-Plugin" class="headerlink" title="Java Library Plugin"></a>Java Library Plugin</h2><p>从Gradle 3.4开始，如果你构建Java library，表明目标是构建一个被其他组件消费的组件(即作为其他东西的依赖)，这时应该用<code>apply plugin: &#39;java-library&#39;</code>替代<code>apply plugin: &#39;java&#39;</code>。</p>
<p>它们基本相同。但<code>java-library</code>插件提供API的概念。现在我们对<code>heat-sensor</code>库进行迁移，它自身有两个依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   compile <span class="string">'org.apache.commons:commons-math3:3.6.1'</span></span><br><span class="line">   compile <span class="string">'com.google.guava:guava:21.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你看了<code>heat-sensor</code>的代码后会发现，<code>commons-math3</code>用作公开的API，而<code>guava</code>只是单纯的内部实现。</p>
<p>这意味着假如明天<code>heat-sensor</code>想从Guava迁移到另一个集合库，它并不会对其消费者有任何影响。但实践中我们只有明确区分两种依赖才可能达到这一目的：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   api <span class="string">'org.apache.commons:commons-math3:3.6.1'</span></span><br><span class="line">   implementation <span class="string">'com.google.guava:guava:21.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>api</code>用于声明需要依赖传递，应当对下游消费者可见的依赖。而<code>implementation</code>用于声明不应该泄漏到消费者compile classpath的依赖(因为它们纯粹是内部细节)。</p>
<p>现在当编译<code>heat-sensor</code>的消费者时，它会发现compile classpath中可以找到<code>commons-math3.jar</code>，而没有<code>guava.jar</code>。如果<code>home-automation</code>想使用Guava库中的类，会发现有编译错误。作为消费者<code>home-automation</code>需要自己决定它是否真的需要引入Guava依赖。另一方面，如果<code>home-automation</code>想使用Apache Math3中的类，是可以的。</p>
<h2 id="更好的POMs"><a href="#更好的POMs" class="headerlink" title="更好的POMs"></a>更好的POMs</h2><p><code>implementation</code>什么时候有用呢？它只在运行时有用！这也是为什么现在选择发布到Maven库时Gradle生成的<code>pom.xml</code>要比Maven自己生成的<code>pom.xml</code>更清晰的原因。来看一下<code>maven-publish</code>插件生成的<code>heat-sensor</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.acme<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>heat-sensor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-math3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>21.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面就是发布的<code>pom.xml</code>文件，它被消费者使用。文件告诉我们什么呢？</p>
<ul>
<li><code>compile</code> classpath中需要有<code>commons-math3</code>，才能依赖<code>heat-sensor</code>进行编译</li>
<li><code>runtime</code> classpath中需要有<code>guava</code>，才能依赖<code>heat-sensor</code>运行</li>
</ul>
<p>这跟编译组件和消费组件时使用同一个<code>pom.xml</code>非常不同。因为编译<code>heat-sensor</code>时，<code>compile</code> classpath也要有<code>guava</code>才行。简单来说：相比Mavne，Gradle生成更好的POM文件，因为它准确区分生产者和消费者。</p>
<h2 id="更多场景"><a href="#更多场景" class="headerlink" title="更多场景"></a>更多场景</h2><p>你可能知道<a href="https://blog.gradle.org/introducing-compile-only-dependencies" target="_blank" rel="noopener">Gradle 2.12引入的compileOnly</a>，它用于声明那些只在编译组件时需要而在运行期不需要的依赖(典型的场景是将一个库嵌入到fat jar中，<a href="https://github.com/johnrengelman/shadow" target="_blank" rel="noopener">shadowed</a>)。<code>java-library</code>插件提供一个从<code>java</code>插件平滑迁移的路径：如果你是构建应用，继续使用<code>java</code>插件。否则，如果是library，使用<code>java-library</code>插件。但无论哪种情况都要遵守以下规则：</p>
<ul>
<li>使用<code>implementation</code>替代<code>compile</code></li>
<li>使用<code>runtimeOnly</code>替代<code>runtime</code></li>
<li>解析组件的runtime时，使用<code>runtimeClasspath</code>替代<code>runtime</code></li>
</ul>
<h2 id="对性能的影响"><a href="#对性能的影响" class="headerlink" title="对性能的影响"></a>对性能的影响</h2><p>为了演示对性能的影响，我们对两种场景添加了基准测试：</p>
<ul>
<li>在library中进行ABI兼容的修改，然后重新编译</li>
<li>在library中进行ABI不兼容的修改，然后重新编译</li>
</ul>
<p>只有Gradle 3.4才支持library的概念，所以在Gradle 3.4中使用Java Library Plugin。为了让结果更清晰，基准测试中不使用增量编译(增量编译更快)</p>
<p><img src="gradle2.jpg" alt></p>
<p>可以看到模型变好之外，性能也有很大提升！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Gradle 3.4为Java生态系统带来了巨大的改进。更好增量编译以及compile avoidance会大大提升你的生产率，而清晰地分离API依赖和实现依赖能避免意外的依赖泄漏，从而获得更好的软件模型。我们还会带来更多好处。特别是，分离API和实现是Java 9成功的关键 <a href="http://openjdk.java.net/projects/jigsaw/" target="_blank" rel="noopener">Project Jigsaw</a>。今后我们还会添加给API指定package的方法，以更接近Jigsaw的做法，且支持更老的JDK。</p>
<p>另外，Gradle 4.0将提供build cache，它也能从本文中描述的改进中受益：它是允许在本地机器或网络中复用和共享构建任务结果。典型的使用场景包括切换分支，或者check out一个已被同事或CI编译过的项目。换一种说法就是，如果你或者谁已经构建了某个你需要的东西，你可以从缓存中得到它，而不必在本地重新构建一次。而这要求build cache需要为java compile task生成cache key，key的生成与compile classpath相关。Gradle 3.4的改进会忽略跟消费者不相关的修改(除非是ABI不兼容的修改)，从而让cache key更容易命中。</p>
<p>我们鼓励现在就更新到Gradle 3.4，并且看下<a href="https://docs.gradle.org/current/userguide/java_library_plugin.html" target="_blank" rel="noopener">Java Library plugin的文档</a>，去看看你能用它干什么吧！</p>
<hr>
<p>更新：补充另外一些内容的翻译，内容来自<a href="https://docs.gradle.org/current/userguide/java_plugin.html#sec:incremental_compile" target="_blank" rel="noopener">Gradle 4.10文档</a></p>
<h1 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h1><h2 id="Java增量编译"><a href="#Java增量编译" class="headerlink" title="Java增量编译"></a>Java增量编译</h2><p>Gradle 4.10缺省开启一个复杂的Java增量编译器。</p>
<p>它有以下好处：</p>
<ul>
<li>增量构建速度更快</li>
<li>变更的class文件数量最小。不需要重新编译的类在输出目录中保持不变。一个场景是使用JRebel时，变更的类越少，JVM就能更快地使用变更后的类</li>
</ul>
<p>为了有助于理解增量编译是如何进行的，下面稍加总结：</p>
<ul>
<li>Gradle会重新编译所以被某个变更 <em>影响</em> 的类</li>
<li>一个类被修改，或者它依赖于一个受影响的类，就认为它受到 <em>影响</em> 。注意，不管依赖的类是在同一个项目，还是另一个项目或者外部库，规则都一样</li>
<li>类的依赖是根据字节码中的类型引用确定的</li>
<li>由于常量被内联，对常量进行任何修改都会导致Gradle重新编译所有代码。出于这个理由，你应该尽可能少用常量，或者将常量替换为静态方法</li>
<li>source-retention级别的注解在字节码中不可见，所以修改source-retention级别的注解会导致全量编译</li>
<li>通过使用好的软件设计法则，比如松耦合，可以改进增量编译性能。比如，在具体类和其使用者之间引入接口，只有当接口变化时使用者才会被重新编译，具体类变化时使用者并不需要重新编译</li>
<li>类分析结果保存在项目目录中，所以clean之后首次编译速度会比较慢。构建服务器上应当关闭增量编译功能</li>
</ul>
<h2 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h2><ul>
<li>如果一个由于编译错误导致compile task失败，Gradle下次会进行全量编译</li>
</ul>
<h2 id="增量annotation处理"><a href="#增量annotation处理" class="headerlink" title="增量annotation处理"></a>增量annotation处理</h2><p>从Gradle 4.7开始，增量编译器还支持增量annotation处理。Annotation processor需要根据这个特性进行优化，否则仍然会触发全量编译。</p>
<p>用户可以从<code>--info</code>日志(以<code>gradle --info</code>方式运行)中找到是哪个annotation processor触发全量编译的。在compile task中配置自定义的<code>executable</code>或<code>javaHome</code>，增量annotation处理会失效。</p>
<h2 id="让annotation-processor支持增量处理"><a href="#让annotation-processor支持增量处理" class="headerlink" title="让annotation processor支持增量处理"></a>让annotation processor支持增量处理</h2><p>(译者注：这一块的知识不是很了解，所以翻译得惨不忍睹，建议略过直接看<a href="https://docs.gradle.org/current/userguide/java_plugin.html#making_an_annotation_processor_incremental" target="_blank" rel="noopener">原文</a>)</p>
<p>请先阅读<a href="https://docs.gradle.org/current/userguide/java_plugin.html#sec:incremental_compile" target="_blank" rel="noopener">incremental Java compilation</a>相关内容，因为增量annotation是基于它的。</p>
<p>Gradle为两类anntation processor提供增量编译支持：”isolating”或”aggregating”。可以参考以下内容来确定你的annotation processor属于哪一种。</p>
<p>可以在processor的META-INF目录中使用文件注册processor。格式是每行一个processor，processor类全名以及它的类型，两者用逗号分开</p>
<p>例： 注册增量annotaion processor </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 所在文件 processor/src/main/resources/META-INF/gradle/incremental.annotation.processors</span><br><span class="line">EntityProcessor,isolating</span><br><span class="line">ServiceRegistryProcessor,dynamic</span><br></pre></td></tr></table></figure>
<p>如果只能在运行时确定是否增量处理，可以在META-INF描述文件中将其声明为”dynamic”，并且使用<a href="https://docs.oracle.com/javase/10/docs/api/javax/annotation/processing/Processor.html#getSupportedOptions(" target="_blank" rel="noopener">Processor#getSupportedOptions()</a>)方法在运行返回真正的类型。</p>
<p>例：动态注册增量annotation processor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processor/src/main/java/ServiceRegistryProcessor.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedOptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.singleton(<span class="string">"org.gradle.annotation.processing.aggregating"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论哪种类型，都应该遵守以下限制：</p>
<ul>
<li>它们必须使用<a href="https://docs.oracle.com/javase/10/docs/api/javax/annotation/processing/Filer.html" target="_blank" rel="noopener">Filer API</a>生成文件。使用任何其它方式生成文件都会引起后续的静默失败，因为生成的文件无法被正确清理干净。如果你的processor使用其它方式生成文件，那它就无法进行增量处理</li>
<li>它们不能依赖编译器特定的接口，比如<a href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/Trees.html" target="_blank" rel="noopener">com.sun.source.util.Trees</a>。Gradle包装了这些API，所以尝试强制转换到编译器特定类型时会失败。如果你的processor这么做，那它就无法进行增量处理</li>
<li>如果它们有使用<a href="https://docs.oracle.com/javase/10/docs/api/javax/annotation/processing/Filer.html#getResource(javax.tools.JavaFileManager.Location,java.lang.CharSequence,java.lang.CharSequence" target="_blank" rel="noopener">Filer#getResource</a>)，Gradle会全量编译。见<a href="https://docs.oracle.com/javase/10/docs/api/javax/annotation/processing/Filer.html#getResource(javax.tools.JavaFileManager.Location,java.lang.CharSequence,java.lang.CharSequence" target="_blank" rel="noopener">Filer#getResource</a>)</li>
<li>如果它们有使用<a href="https://docs.oracle.com/javase/10/docs/api/javax/annotation/processing/Filer.html#createResource(javax.tools.JavaFileManager.Location,java.lang.CharSequence,java.lang.CharSequence,javax.lang.model.element.Element..." target="_blank" rel="noopener">Filer#createResource</a>)，Gradle会全量编译。见<a href="https://github.com/gradle/gradle/issues/4702" target="_blank" rel="noopener">gradle/issues/4702</a></li>
</ul>
<p>“isolating” annotation processor</p>
<p>这是最快的一种类型，它们以隔离的方式寻找每个注解元素，为它生成文件或者验证信息。比如<code>EntityProcessor</code>可以为每个带有<code>@Entity</code>注解的类型生成<code>&lt;TypeName&gt;Repository</code>。</p>
<p>例：isolated annotation processor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processor/src/main/java/EntityProcessor.java</span></span><br><span class="line"></span><br><span class="line">Set&lt;? extends Element&gt; entities = roundEnv.getElementsAnnotatedWith(entityAnnotation);</span><br><span class="line"><span class="keyword">for</span> (Element entity : entities) &#123;</span><br><span class="line">    createRepository((TypeElement) entity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isolated annotation processor有以下限制：</p>
<ul>
<li>它们必须基于AST中的信息为注解元素做判断(代码生成，验证信息)。这意味着可以分析类型的父类，方法的返回值，注解等等。但不能根据不相关元素做判断。这么做会引起静默失败，因为后面几乎无法重新编译文件。如果processor需要根据其他不相关元素来联合进行判断，需要将processor标记为”aggregating”</li>
<li>它们必须为使用<code>Filer</code> API生成的每个文件提供一个originating element。如果是0个或多个，Gradle会全量编译</li>
</ul>
<p>如果一个源文件被重新编译，所有由这个文件生成的源文件也会被重新编译。当一个源文件被删除，所以由这个文件生成的源文件都会被删除。</p>
<p>“Aggregating” annotation processors</p>
<p>它们可以将多个源文件合并到一个或多个文件中。比如，<code>ServiceRegistryProcessor</code>可以使用一个方法为每个带<code>@Service</code>注解的类型创建一个单独的<code>ServiceRegistry</code></p>
<p>例：An aggregating annotation processor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processor/src/main/java/ServiceRegistryProcessor.java</span></span><br><span class="line"></span><br><span class="line">JavaFileObject serviceRegistry = filer.createSourceFile(<span class="string">"ServiceRegistry"</span>);</span><br><span class="line">Writer writer = serviceRegistry.openWriter();</span><br><span class="line">writer.write(<span class="string">"public class ServiceRegistry &#123;"</span>);</span><br><span class="line"><span class="keyword">for</span> (Element service : roundEnv.getElementsAnnotatedWith(serviceAnnotation)) &#123;</span><br><span class="line">    addServiceCreationMethod(writer, (TypeElement) service);</span><br><span class="line">&#125;</span><br><span class="line">writer.write(<span class="string">"&#125;"</span>);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure>
<p>“Aggregating” processor有以下限制：</p>
<ul>
<li>它们只能访问<code>CLASS</code>或<code>RUNTIME</code>注解</li>
<li>如果用户使用<code>-parameters</code>参数编译，它们只能读取参数名字</li>
</ul>
<p>Gradle总是重新处理(但是重新编译)所有的注解文件。Gradle总是重新编译processor生成的任何文件。</p>
<h2 id="Compile-avoidance-1"><a href="#Compile-avoidance-1" class="headerlink" title="Compile avoidance"></a>Compile avoidance</h2><p>如果被依赖的项目发生ABI兼容的修改(即只有private API改变)，则对应的java compilation task被认为是up-to-date的。这意味着如果<code>A</code>项目依赖<code>B</code>项目，<code>B</code>中的一个类发生ABI兼容的修改(通常是修改了一个方法中的代码)，那么Gradle不会重新编译<code>A</code>项目。</p>
<p>一些不影响公开API修改以及会被忽略的修改：</p>
<ul>
<li>修改方法中的代码</li>
<li>修改注释</li>
<li>添加，移除，修改private方法、字段或内部类</li>
<li>添加，移除，修改资源</li>
<li>修改classpath中的jar文件名或目录名</li>
<li>重命名参数</li>
</ul>
<p>如果compile classpath中包含annotation processor，compile avoidance功能会失效，因为对于annotation processor而言，代码的具体实现是有影响的。为了避免这种问题，annotation processor应该在<code>annotationProcessor</code>中声明。Gradle 5.0将忽略compile classpath中的annotation processor。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// build.gradle</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    // The dagger compiler and its transitive dependencies will only be found on annotation processing classpath</span><br><span class="line">    annotationProcessor &apos;com.google.dagger:dagger-compiler:2.8&apos;</span><br><span class="line"></span><br><span class="line">    // And we still need the Dagger library on the compile classpath itself</span><br><span class="line">    implementation &apos;com.google.dagger:dagger:2.8&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- https://stackoverflow.com/questions/26424759/what-is-sjavac-who-is-it-for-and-how-do-i-use-it -->
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/09/10/fragment-permission/" rel="prev" title="Fragment权限问题的一个小坑">
      <i class="fa fa-chevron-left"></i> Fragment权限问题的一个小坑
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/10/19/dive-into-run/" rel="next" title="Android Studio是如何运行app的？">
      Android Studio是如何运行app的？ <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Compile-avoidance"><span class="nav-number">1.</span> <span class="nav-text">Compile avoidance</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#改进的增量编译"><span class="nav-number">2.</span> <span class="nav-text">改进的增量编译</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#annotation-processor"><span class="nav-number">3.</span> <span class="nav-text">annotation processor</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#annotation-processor原理"><span class="nav-number">3.1.</span> <span class="nav-text">annotation processor原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#明确声明annotation-processor-classpath"><span class="nav-number">3.2.</span> <span class="nav-text">明确声明annotation processor classpath</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#带annotation-processor的增量编译"><span class="nav-number">3.3.</span> <span class="nav-text">带annotation processor的增量编译</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java库"><span class="nav-number">4.</span> <span class="nav-text">Java库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一直在用错误的方式"><span class="nav-number">4.1.</span> <span class="nav-text">一直在用错误的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-Library-Plugin"><span class="nav-number">4.2.</span> <span class="nav-text">Java Library Plugin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更好的POMs"><span class="nav-number">4.3.</span> <span class="nav-text">更好的POMs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更多场景"><span class="nav-number">4.4.</span> <span class="nav-text">更多场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对性能的影响"><span class="nav-number">4.5.</span> <span class="nav-text">对性能的影响</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#补充内容"><span class="nav-number">6.</span> <span class="nav-text">补充内容</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java增量编译"><span class="nav-number">6.1.</span> <span class="nav-text">Java增量编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#已知问题"><span class="nav-number">6.2.</span> <span class="nav-text">已知问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#增量annotation处理"><span class="nav-number">6.3.</span> <span class="nav-text">增量annotation处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#让annotation-processor支持增量处理"><span class="nav-number">6.4.</span> <span class="nav-text">让annotation processor支持增量处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Compile-avoidance-1"><span class="nav-number">6.5.</span> <span class="nav-text">Compile avoidance</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Sunmoon</p>
  <div class="site-description" itemprop="description">移动开发 Android 生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">143</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sunmoon</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
