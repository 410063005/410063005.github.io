这一部分包含了单元测试基础。

在第一章中，我定义了什么是 _单元_ 以及什么是好的单元测试。我会将单元测试和集成测试进行对比。然后讨论了测试驱动开发(TDD)和它在单元测试中扮演的角色。

第二章中会简单看一下如何使用NUnit写测试，你将了解NUnit的基本API，比如如何断言，如何在NUnit test runner中运行测试。

# 第一章 单元测试基础

本章包括以下内容

+ 单元测试的定义
+ 单元测试跟集成测试对比
+ 看一个简单的单元测试例子
+ 理解TDD

总是会有第一次：第一次写程序，第一次经历项目失败，第一次干成一件你努力完成的事情。你不会忘记你的第一次，我希望你不要忘记你的第一次测试。你可能已经写过一些测试，你甚至可能记得它们有多糟糕，笨拙，缓慢以及不可维护。(大部分人都如此。)更乐观一点，你可能首次单元测试还不错，然后你想通过本书找到更多你以前错过的东西。

这一章首先分析了单元测试的“经典”定义，将其跟集成测试概念进行对比。很多人会将两者弄混。然后我们对比单元测试和集成测试各自的优缺点，并为"好的"单元测试下一个更好的定义。最后会看看TDD，因为它经常跟单元测试相提并论。整章中我会提到某些概念，这些概念会在本书其他位置更详细地解释。

先从如何定义单元测试开始。

## 一步一步定义单元测试
单元测试并不是软件开发中的一个新概论。早在1970年Smalltalk编程语言出现早期就出现了单元测试，一次次表明是开发者提高代码质量并加深对类或方法需求理解的最好方式之一。

Kent Beck在Smalltalk中引入了单元测试概念，然后这个概念逐渐进入其他编程语言，让单元测试成为软件开发领域非常有用的实践。但在我深入展开之前，我需要更好地定义单元测试。这里是来自Wikipedia的经典定义。这个定义会在本章中逐渐演化，并在1.4节有一个最终定义。

> DEFINITION 1.0 _单元测试_ 是一段(通常是一个方法)调用其他代码的代码，并且在调用后检查某些假设的正确性。如何假设出现，单元测试失败。一个 _单元_ 是一个方法或函数。

你对其编写单元测试的那部分，称为待测试系统(SUT)。

> DEFINITION SUT代表 _system under test_ ，另一些人喜欢将其称为 _CUT_ (class under test 或者 code under test)。当你测试某些东西时，你指的是SUT。

我过去觉得(对，是感觉。本书无关科学，只是艺术)单元测试的定义从技术上讲是正确的，但过去几年，我对于什么是 _单元_ 的看法有所改变。对我而言，一个 _单元_ 表示系统中的"工作单元"或者"用例"。

> DEFINITION
> 工作单元是指发生在系统中公开方法调用以及该系统中一个测试的单一可观察结果的总和(A unit of work is the sum of actions that take place between the invocation of a public method in the system and a single noticeable end result by a test of that system)。可观察的结果是指可以不观察系统内部状态或是仅通过系统公开API或行为即可"观察到"。结果(end result)可以是以下某种形式：

+ 被调用的公开方法返回值(即非void方法)
+ 方法调用前后系统状态或行为有明显的变化，不用查询系统内部状态即可判断这些变化。(比如，系统允许之前不存在的用户登录，或者如果系统是个状态机的话，系统属性现在发生变化)
+ 调用了无控制权的第三方系统，而第三方系统不返回任何值，或者它的返回值被忽略。(比如，调用了第三方而非你自己开发日志系统，你并没有代码)

就我而言，工作单元中的 _单元_ ，可以小到一个方法，也可以大到几个协同工作的类或方法。

你可能会觉得你会将待测试的工作单元最小化。之前我也是这么认为的，但现在不这么想了。我相信如果你创建规模更大一点的工作单元，可能它的结果对API的最终用户更容易观察。如果你尝试将工作单元最小化，可能你得到的是对API最终用户来说并不需要的结果，这些不过是通向 _总站_ 的 _停车点_ 。第八章中我会在overspecification这个话题中就这个问题做更多说明。

> DEFINITION 1.1 _单元测试_ 是一段调用一个工作单元的代码，它检查这个工作单元的一个特定的最终结果。如果关于结果的假设是错的，单元测试失败。单元测试可以小到一个方法，或者大到几个类。

无论你使用什么编程语言，定义单元测试最困难的地方是定义什么是好的单元测试。

### 编写好的单元测试的重要性
理解什么是工作单元还不够。

很多尝试对其代码进行单元测试的人要么放弃，要么根本就不是在做单元测试。相反，他们要么是依靠产品生命周期后期的系统测试或集成测试，要么使用自定义的测试应用对代码进行手工测试，或者使用他们开发的最终产品调用自己写的代码。

除非你学会怎么写好的单元测试，不然写糟糕的单元测试并没有任何意义。而学会写好的单元测试是你在该领域的第一步。如果你写了个糟糕的单元测试却并没有意识到，你还不如不写，这样反倒可以在维护和日程安排上省很多麻烦。通过定义什么是好的单元测试，可以确保你不会带着错误的观念去达成你的目标。

为了理解什么是好的单元测试，你需要观察开发者在测试东西时他们是怎么做的。

### (某种程度上)我们都在写单元测试
得知这一点，你可能会吃惊，不过你确实在以你自己的某种方式实现单元测试。你见过完成代码前对代码不进行任何测试的开发者吗？好吧，反正我是没见过。

你可能使用控制台应用来调用类或组件中的某些方法，或者是使用WinForms或Web Forms的GUI应用来检查类或组件的功能，甚至是在实际应用的UI上进行不同的操作进行手工测试以检查代码功能。最终结果是，你可以在某种程度上确保你的代码工作得足够好，可以交付给别人。

图1.1(图略)展示了大部分开发者是如何测试代码的。UI可能有所不同，但套路是通常是一样的：使用外部手工工具来反复检查，或者手动完整运行应用来检查其行为。

这些测试可能有用，它们可能接近单元测试的经典定义，但离我在本书中定义的 _好的单元测试_ 还远远不够。这就给我们引出了开发者在定义单元测试质量时会面对的最重要问题：什么是单元测试，什么不是单元测试？

## 好的单元测试的特点
一个单元测试应当有以下特点：

+ 可自动化，可重复
+ 易于实现
+ 较长的时效性
+ 任何人点一下按钮就可以运行
+ 运行速度快
+ 运行结果具有一致性(两次运行间没有任何修改的话应当返回相同结果)
+ 对被测试的单元具有全部控制权
+ 是完全隔离的(跟其他测试独立)
+ 当测试失败时，易于检查期望值并找到问题根源

很多人将测试软件跟单元测试混为一谈。针对你写的测试提出以下问题：

+ 一周，一月或一年前你写的单元测试还能否运行并返回结果？
+ 组内任何人能运行你两个月前写的单元测试并得到结果？
+ 我可以在几分钟内运行自己写的所有单元测试？
+ 可以点一下按钮就运行所有单元测试？
+ 可以在几分钟内写好一个基本的测试？

如果上述任何一个问题的答案是否，那么你很有可能并不是在写单元测试。你当然是在进行某些形式的测试，而且它跟单元测试一样重要，但对比之下它跟那些全部是"yes"的测试相比有很多缺点。

你会问，那我之前做的到底是什么？答案是，你在做集成测试。

## 集成测试
我认为运行不够快，结果不能保持一致，使用一个或多个真实依赖的测试都是集成测试。比如，在测试中使用真实的系统时间，真实的文件系统，或者真实的数据库，就进入了集成测试的范畴。

如果测试不能控制系统时间，比如，它直接在测试代码中使用`DateTime.Now`，那么每次运行这个测试的话，其实都是在运行一个新的测试，因为它使用了不同的时间。它的结果不具有一致性。

这不一定是坏事。我认为集成测试跟单元测试一样重要，但集成测试应当跟单元测试分离开来，以达到"绿色安全区"的感觉。后文后讨论这个。

当测试使用真实的数据库，那么它就不仅仅是在内存中运行，测试的行为比起在内存中使用模拟数据要难以擦除。测试运行时间也更长，因为它不可控。单元测试快得多，而集成测试通常要慢一些。当你有几百个测试时，不得不考虑运行时间因素。

集成测试增加了另一个问题的风险：一次测试了太多东西。

你的车坏了时你知道是怎么回事吗？你如何知道问题所在，并且独立修好它？一个引擎由许多一起工作的子系统组成，每个都依赖于其他系统来共同产生最终结果：一台可以跑的车。如果车子不能跑，问题可能在任何一个子系统，或者多个子系统。正是多个子系统(或称之为层)集成在一起才能让车子跑。你可以认为让车子在路上跑是最后的集成测试。如果这个测试失败，所有的部分都一起失败了。如果成功，所有部分都成功。

软件中也是这样。大部分开发者通过UI功能来测试代码功能。点击某些按钮会触发一系列的事件，类和组件一起工作产生最终结果。如果测试失败，所有的软件组件作为一个整体失败了，很难知道整个操作失败的原因。

The Complete Guide to Software Testing by Bill Hetzel (Wiley, 1993)中提到，集成测试是整个系统集成后组合后，对软硬件进行的有序的测试过程。(an orderly progression of testing in which software and/or hard- ware elements are combined and tested until the entire system has been integrated.) 而许多人在做的集成测试，可以定义得更简短，并不是系统集成测试的一部分，而是开发和单元测试的一部分。

集成测试更好的定义是这样：

> DEFINITION _集成测试_ 是在不必对工作单元有完整控制的情况下对其进行的测试，工作单元可以使用一个或多个真实依赖，比如时间、网络、数据库、线程、随机数生成器，等等。

总结一下：集成测试使用真实依赖；单元测试将工作单元跟真实依赖隔离开来，所以在结果上有一致性，易于控制，可以模拟工作单元的行为(unit tests isolate the unit of work from its dependencies so that they’re easily consistent in their results and can easily control and simulate any aspect of the unit’s behavior)

1.2节中的问题能让你认识到集成测试的缺点。我们来看看好的单元测试要达到怎样的质量。

图1.2(图略) 从图中你可以看到，集成测试中有很多可能的失败点。所有单元必须一起正常工作，但其实每一个都可能不正常，所以找到bug的根源很困难。

### 相对自动化单元测试非自动化的集成测试的缺点
我们将1.2节中的问题应用到集成测试，并考虑实际中的单元测试你想达到什么程度：

+ _我能运行两周或两个月或两年前自己写的单元测试并得到结果吗？_

如果你不能，你如何确定是你自己破坏了之前写的特性呢？在软件的生命周期中代码会定期变化，如果你不能在修改代码后运行测试(为之前可以工作的特性写的测试)，你可能在不知情的情况下破坏已有功能。我称之为意外引入的bug，貌似这种bug经常出现在软件项目的后期，项目后期开发人员修复已知bug时面临压力容易意外引入bug。有时他们在解决旧bug时引起新bug。能在三分钟内知道你是不是弄出什么问题难道不是很爽吗？你可以在本书中看到是如何做到的。

> DEFINITION _regression_ 是指一个或多个工作单元之前功能正常，但现在有问题

+ _组内任何人能运行我两个月前写的测试并获得结果吗？_

这是伴随前一个问题的另一个问题，但更进一步。你肯定不想在自己修改了某些代码后让别人的代码无法工作。许多开发人员害怕个性旧系统中的 _遗留代码_ ，因为担心改动后别的依赖于这些遗留代码的部分无法工作。其实他们冒着将系统带入稳定性未知状态的风险。

没有什么比较不知道应用能否工作更让人害怕的了，尤其是你修改过并不是你写的代码之后。如果你知道你不会破坏任何功能，你就不那么担心接手别人的代码了，因为你有单元测试这张安全网。

所以说，好的测试应该是任何人都能运行的。

> DEFINITION _遗留代码(Legacy code)_ 在维基百科中的定义是"不再维护的代码，不再生产的操作系统或者其他某些不再被支持的计算机技术"，但很多人也将仍然在维护的旧版本的应用视为遗留系统。具体来说是那些难以使用，难以测试而且通常可读性非常差的代码。

一个客户曾经以更直白地定义遗留代码：那些刚好能运行的代码。很多人喜欢将没有测试的代码看作遗留代码。Working Effectively with Legacy Code by Michael Feathers (Prentice Hall, 2004)就用这个作为遗留代码的官方定义，读这本书时应当留意这个定义。

+ _我可以几分钟内运行之前写的所有测试吗？_

如果不能快速运行测试(越快越好)，你就不会经常运行它们(有可能你几周或几个月才运行)。问题在于，你修改代码时，肯定是越早知道是否有破坏什么功能越好。运行测试之间的间隔时间越长，对代码的修改就越多，当发现某个功能不正常时需要排查bug的地方就越多。

测试应当快速运行

+ _我能否点一下按钮就运行所有测试？_

如果不能，很可能意味着你得对测试进行配置才能正确运行(比如数据库连接配置)，否则它们不能自动进行。如果不能完全自动化单元测试，你很可能不能重复执行这些测试，就像你们组里没人愿意一样。

没人喜欢折腾配置的那些细节，以便可以运行测试来确认系统仍然正常。开发者有更重要的事情做，比如给系统开发更多特性。

好的测试应该在原始状态下就可以很容易执行，不能手动

+ _我能否在几分钟内就写一个基本的测试？_

集成测试最让人诟病的地方在于不仅运行要花时间，而且配置和实现都要花时间。要花时间弄清楚如何写集成测试，因为要清楚它的内部细节以及外部依赖。(数据库可以看作是一个外部依赖。) 如果不能自动化测试，你将失去很多好处。写测试越困难，你越不愿意写多一点的测试，你越不愿意关注测试这些看起来微不足道的小事情。单元测试的一个强大之处在于它倾向于测试每个可能失败的小功能，而不仅是那些大功能。人们深深吃惊地发现很多bug出现在认为很简单、没bug的地方。

当你只专注大的测试，测试代码逻辑上的覆盖率其实很低。代码中的很多核心逻辑没有被测试到(虽然你的测试覆盖了很多组件)，而它们可能存在许多你根本想不到的bug。

只要你知道了测试特定对象模型的套路，好的测试应当是很容易实现的，而且可以快速实现。

一个小警告：即使是有经验的单元测试人员，也要花30分钟更长时间弄清楚之前他们没有测试过的对象模型并开始写第一个测试。这是工作的一部分，很正常。接下来针对相同对象模型的测试应该很容易完成。

从之前我讲到的什么不是单元测试，以及有用的测试需要具备什么样的特点，现在可以开始回答本章的主要问题了：什么是好的单元测试？

## 如何有好的单元测试
