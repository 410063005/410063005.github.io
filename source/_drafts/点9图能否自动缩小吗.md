---
title: 点9图能否自动缩小吗
tags:
  - android
  - ui
---

本文介绍关于了NinePatchDrawable的一些基础知识。

<!-- more -->

# 背景
Android常使用.9图片作为控件背景。[官方文档][ref2]有关于.9图的介绍。而实际开发中我们免不了要动手画.9图，[官方文档][draw9patch]也介绍了操作步骤。

虽然可以比较熟练的画.9图，但我仍然觉得自己不是很理解.9图原理。

+ .9图它能被缩小吗？
+ 为什么apk中看到的.9图跟原始的不一样？
+ .9图到底是怎么被拉伸的？

![](layout.jpg)

![](bg_homepage_auth_container.9.png)

视觉给了我一个大小为 26 * 165px 的.9图用于上图中蓝色线框部分的背景，希望蓝色线框高度适应其内容。但实际上，这个.9图的尺寸过大，导致蓝色线框部分高度为245px。文档中不是说`NinePatchDrawable`图像是可拉伸的位图，当作为View的背景时Android会自动调整其大小以适应View的内容。所以误以为小的.9图能拉伸，而大的.9图能缩小。看来太天真。

为什么apk中看到的.9图跟原始的不一样？下面两个图分别是原始的.9图和编译成apk后的.9图，我辛辛苦苦画好的黑线框好像弄丢了。

![](search_bg.9_source.png)
![](search_bg_compiled.9.png)

不过没有黑线框的.9图好像并不影响应用的运行，该拉伸的地方仍然完全拉伸。这到底是怎么做到的？我们带着问题继续往下看。

# 问题
上面列举了我的几个疑惑。但[这里][ref3]提到了一个很有意思的需求：应用中需要从后台下载图片作为.9图加载，如何实现。

我们从这个需求展开讨论，并一一解答我的疑惑。首先看`NinePatchDrawable`和`NinePatch`这两个相关的类。

+ NinePatchDrawable - 可调整大小的bitmap，你可以定义拉伸区域。这种类型的图片由特殊格式的png文件定义
+ NinePatch - 这个类允许在九个或更多个部分绘制bitmap。本质上，它可以可拉伸的图像。当内容超过正常的边界时，这种图像会按你定义好的方式拉伸

```java
NinePatchDrawable(Resources res, Bitmap bitmap, 
    byte[] chunk, Rect padding, String srcName)
NinePatchDrawable(Resources res, NinePatch patch)
NinePatch(Bitmap bitmap, byte[] chunk)
```

上面是`NinePatchDrawable`和`NinePatch`的构造方法。可以看到，chunk是其中的关键。

# chunk
## 知识点
而在正式说明chunk到底是什么之前，有必要补充一个知识点。Android官方文档中并没有提到这一点，而实际上它对于理解chunk非常关键。这个知识点来自[apktool wiki](https://ibotpeaches.github.io/Apktool/documentation/#9patch-images)。

---

**你绘制的.9图跟最后打包到apk包中的.9图并不一样**，绘制的.9图可以理解为"源文件"，而apk包中的.9图是"编译"后的输出。

+ source - 源文件。简单来说，就是那种边上有黑线的那种图片
+ compiled - 比较神秘不为人所知。图片上没有黑色边框，而9patch数据被写入称为`npTc`字段中。无法轻易地看到和修改这个数据。但Android自己可以处理该数据

随之带来的问题是：

+ 两种格式间需要转换。如果从apk中解压9patch图片，然后直接作为源文件，编译apk时会出错的。反之亦然，不能直接把源文件形式的9patch图片放到apk中
+ 9patch图片的chunk字段并不能被图片处理工具识别。所以修改编译后的9patch图很可能破坏`npTc`，随之损坏整个9patch图

解决这个问题的办法就是提供两种格式间方便的转换方案。编码器(将源文件转换成编译后的文件)已内置到aapt工具中，会在编译apk时自动处理源文件。所以只需要构建一个解码器即可。apktool v1.3.0中已有解码器，会在反编译apk时会自动反编译"已编译"的9patch图片。

如果想修改9patch图片，不应直接操作。而是使用apktool反编译apk(包括9patch图片)，然后再修改图片。当重新将反编译的代码打包成apk时，9patch源文件会被重新编译。

----

直接对比下源文件和编译后的文件，更直观。

![](search_bg.9_source.png)
![](search_bg_compiled.9.png)


![](9patch-source.jpg)
![](9patch-compiled.jpg)

+ 源文件
 + 大小 - 71px*25px, 有黑色边框
 + Horizontal Patch: 18 - 56 px
 + Vertical Patch: 7 - 18 px
 + Horizontal Padding: 1 - 70 px
 + Vertical Patch: 2 - 24 px
+ 编译后的文件
 + 大小 - 69px*23px，无黑色边框

编译后的文件中之所以看不到黑色边框，是因为它被转换成chunk数据写到png文件中去了。

## chunk介绍
byte[] Bitmap.getNinePatchChunk() - 返回bitmap中的一段私有数据，Android UI系统使用这个私有数据处理某些bitmap
boolean NinePatch.isNinePatchChunk - 校验指定的byte数组是否有效的9-patch数据块

从Android的某些代码中，我们可以找到关于chunk的线索。

先从简单的开始吧。我们尝试校验.9图中的chunk字段。我们知道，chunk其实已存在编译后的9patch文件中，所以可以这么做：

```java
InputStream stream = .. // 获取已编译的9patch文件输入流
Bitmap bitmap = BitmapFactory.decodeStream(stream);
byte[] chunk = bitmap.getNinePatchChunk(); // 获取chunk数据
boolean result = NinePatch.isNinePatchChunk(chunk); // 检查是否chunk数据
```

chunk数据用于构造 [Res_png_9patch][Res_png_9patch] 结构体。

```cpp
/** ********************************************************************
 *  PNG Extensions
 *
 *  New private chunks that may be placed in PNG images.
 *
 *********************************************************************** */

/**
 * This chunk specifies how to split an image into segments for
 * scaling.
 *
 * There are J horizontal and K vertical segments.  These segments divide
 * the image into J*K regions as follows (where J=4 and K=3):
 *
 *      F0   S0    F1     S1
 *   +-----+----+------+-------+
 * S2|  0  |  1 |  2   |   3   |
 *   +-----+----+------+-------+
 *   |     |    |      |       |
 *   |     |    |      |       |
 * F2|  4  |  5 |  6   |   7   |
 *   |     |    |      |       |
 *   |     |    |      |       |
 *   +-----+----+------+-------+
 * S3|  8  |  9 |  10  |   11  |
 *   +-----+----+------+-------+
 *
 * Each horizontal and vertical segment is considered to by either
 * stretchable (marked by the Sx labels) or fixed (marked by the Fy
 * labels), in the horizontal or vertical axis, respectively. In the
 * above example, the first is horizontal segment (F0) is fixed, the
 * next is stretchable and then they continue to alternate. Note that
 * the segment list for each axis can begin or end with a stretchable
 * or fixed segment.
 *
 * The relative sizes of the stretchy segments indicates the relative
 * amount of stretchiness of the regions bordered by the segments.  For
 * example, regions 3, 7 and 11 above will take up more horizontal space
 * than regions 1, 5 and 9 since the horizontal segment associated with
 * the first set of regions is larger than the other set of regions.  The
 * ratios of the amount of horizontal (or vertical) space taken by any
 * two stretchable slices is exactly the ratio of their corresponding
 * segment lengths.
 *
 * xDivs and yDivs point to arrays of horizontal and vertical pixel
 * indices.  The first pair of Divs (in either array) indicate the
 * starting and ending points of the first stretchable segment in that
 * axis. The next pair specifies the next stretchable segment, etc. So
 * in the above example xDiv[0] and xDiv[1] specify the horizontal
 * coordinates for the regions labeled 1, 5 and 9.  xDiv[2] and
 * xDiv[3] specify the coordinates for regions 3, 7 and 11. Note that
 * the leftmost slices always start at x=0 and the rightmost slices
 * always end at the end of the image. So, for example, the regions 0,
 * 4 and 8 (which are fixed along the X axis) start at x value 0 and
 * go to xDiv[0] and slices 2, 6 and 10 start at xDiv[1] and end at
 * xDiv[2].
 *
 * The array pointed to by the colors field lists contains hints for
 * each of the regions.  They are ordered according left-to-right and
 * top-to-bottom as indicated above. For each segment that is a solid
 * color the array entry will contain that color value; otherwise it
 * will contain NO_COLOR.  Segments that are completely transparent
 * will always have the value TRANSPARENT_COLOR.
 *
 * The PNG chunk type is "npTc".
 */
struct Res_png_9patch
{
    Res_png_9patch() : wasDeserialized(false), xDivs(NULL),
                       yDivs(NULL), colors(NULL) { }

    int8_t wasDeserialized;
    int8_t numXDivs;
    int8_t numYDivs;
    int8_t numColors;

    // These tell where the next section of a patch starts.
    // For example, the first patch includes the pixels from
    // 0 to xDivs[0]-1 and the second patch includes the pixels
    // from xDivs[0] to xDivs[1]-1.
    // Note: allocation/free of these pointers is left to the caller.
    int32_t* xDivs;
    int32_t* yDivs;

    int32_t paddingLeft, paddingRight;
    int32_t paddingTop, paddingBottom;

    enum {
        // The 9 patch segment is not a solid color.
        NO_COLOR = 0x00000001,

        // The 9 patch segment is completely transparent.
        TRANSPARENT_COLOR = 0x00000000
    };
    // Note: allocation/free of this pointer is left to the caller.
    uint32_t* colors;

    // Convert data from device representation to PNG file representation.
    void deviceToFile();
    // Convert data from PNG file representation to device representation.
    void fileToDevice();
    // Serialize/Marshall the patch data into a newly malloc-ed block
    void* serialize();
    // Serialize/Marshall the patch data
    void serialize(void* outData);
    // Deserialize/Unmarshall the patch data
    static Res_png_9patch* deserialize(const void* data);
    // Compute the size of the serialized data structure
    size_t serializedSize();
};

```


|字节|名字|备注|
|----|----|----|
|0|wasDeserialized|是否存在chunk字段|
|1|numXDivs|X方向S区域数量|
|2|numYDivs|Y方向S区域数量|
|3|numColors|color数量|
|4-7|xDivs指针||
|8-11|yDivs指针||
|12-15|paddingLeft||
|16-19|paddingRight||
|20-23|paddingTop||
|24-27|paddingBottom||
|28-31|colors指针||
|共numXDivs*4字节||xDivs指针指向的内容|
|共numYDivs*4字节||yDivs指针指向的内容|
|共numColors*4字节||colors指针指向的内容|

了解了chunk的数据结构，我们可以打印实际的数据来看看，加深理解。


```java
void printChunk() {
    byte[] chunk = getNinePatchChunk("search_bg.9.png");
    println("isNinePatchChunk? " + NinePatch.isNinePatchChunk(chunk));

    if (chunk != null) {
        println("wasDeserialized " + chunk[0]);
        println("numXDivs " + chunk[1]);
        println("numYDivs " + chunk[2]);
        println("numColors  " + chunk[3]);
        println("*xDivs " + TextUtils.join(",", get(chunk, 4, 4)));
        println("*yDivs " + TextUtils.join(",", get(chunk, 8, 4)));
        println("paddingLeft " + TextUtils.join(",", get(chunk, 12, 4)));
        println("paddingRight " + TextUtils.join(",", get(chunk, 16, 4)));
        println("paddingTop " + TextUtils.join(",", get(chunk, 20, 4)));
        println("paddingBottom " + TextUtils.join(",", get(chunk, 24, 4)));
        println("*colors " + TextUtils.join(",", get(chunk, 28, 4)));

        // 第32个字节开始
        // 首先是xDivs指针指向的内容，其大小为numXDivs个int32_t
        println("xDivs " + TextUtils.join(",", get(chunk, 32, chunk[1] * 4)));
        // 然后是yDivs指针指向的内容，其大小为numYDivs个int32_t
        println("yDivs " + TextUtils.join(",", get(chunk, 32 + chunk[1] * 4, chunk[2] * 4)));
        // 最后是colors指针指向的内容，其大小为numColors个int32_t（ARGB格式）
        println("colors " + TextUtils.join(",", get(chunk, 32 + chunk[1] * 4 + chunk[2] * 4, chunk[3] * 4)));
    }
}

byte[] getNinePatchChunk(String name) {
    InputStream in = null;
    try {
        in = getAssets().open(name);

        Bitmap bitmap = BitmapFactory.decodeStream(in);
        println("bitmap width " + bitmap.getWidth());
        println("bitmap height " + bitmap.getHeight());
        return bitmap.getNinePatchChunk();

    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        close(in);
    }
    return null;
}

Byte[] get(byte[] chunk, int start, int offset) {
    Byte[] data = new Byte[offset];
    for (int i = 0; i < offset; i++) {
        data[i] = chunk[start + i];
    }
    return data;
}
```

输出如下

```
03-01 01:56:01.093 I/System.out: bitmap width 70
03-01 01:56:01.093 I/System.out: bitmap height 24
03-01 01:56:01.093 I/System.out: isNinePatchChunk? true
03-01 01:56:01.093 I/System.out: wasDeserialized 1
03-01 01:56:01.093 I/System.out: numXDivs 2
03-01 01:56:01.093 I/System.out: numYDivs 2
03-01 01:56:01.093 I/System.out: numColors  9
03-01 01:56:01.093 I/System.out: *xDivs 32,0,0,0
03-01 01:56:01.093 I/System.out: *yDivs 40,0,0,0
03-01 01:56:01.093 I/System.out: paddingLeft 0,0,0,0
03-01 01:56:01.093 I/System.out: paddingRight 1,0,0,0
03-01 01:56:01.093 I/System.out: paddingTop 1,0,0,0
03-01 01:56:01.093 I/System.out: paddingBottom 1,0,0,0
03-01 01:56:01.093 I/System.out: *colors 48,0,0,0
03-01 01:56:01.093 I/System.out: xDivs 17,0,0,0,55,0,0,0
03-01 01:56:01.093 I/System.out: yDivs 6,0,0,0,17,0,0,0
03-01 01:56:01.093 I/System.out: colors 1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,-8,-13,-13,-1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0
```

根据输出的日志整理出来的数据如下：

+ paddingLeft: 0
+ paddingRight: 1
+ paddingTop: 1
+ paddingBottom: 1
+ xDivs: 17, 55
+ yDivs: 6, 17

而`struct Res_png_9patch`的注释中说明了xDivs和yDivs是如何来确定stretchable segment和fixed segment的。

+ 最左边x=0，最右边x=图片宽度
+ xDiv[0]和0确定了第一个固定区域的横向坐标
+ xDiv[1]和xDiv[0]确定了第一个扩展区域的横向坐标
+ xDiv[2]和xDiv[1]确定了第二个固定区域的横向坐标 (在这里，由于不存在xDiv[2]，所以实际上是由图片宽度和xDiv[1]确定第二个固定区域的横向坐标)

具体到我们这里的例子，对应的图如下：

```    
    0    18              56    70   
    +-----+--------------+------+ 
    |  0  |      1       |  2   |
  7 +-----+--------------+------+
    |  3  |      4       |  5   |
 18 +-----+--------------+------+
    |  6  |      7       |  8   |
 24 +-----+--------------+------+    
```

![](patch.jpg)

+ Horizontal Patch: 18 - 56 px
+ Vertical Patch: 7 - 18 px
+ Horizontal Padding: 1 - 70 px
+ Vertical Patch: 2 - 24 px
+ Size: 71 * 25 px

对照着看，两个图是不是神似!

## 生成chunk
打印chunk的那段代码中，我们已经知道如何解析chunk了。而[NinePatchChunk](https://android.googlesource.com/platform/packages/apps/Gallery2/+/jb-dev/src/com/android/gallery3d/ui/NinePatchChunk.java)中提供解析chunk数据的更好方法。

对照着[NinePatchChunk](https://android.googlesource.com/platform/packages/apps/Gallery2/+/jb-dev/src/com/android/gallery3d/ui/NinePatchChunk.java)的代码，不难构造自己的chunk。代码如下


```java
byte[] generateNinePatchChunk(int[] xRegions, int[] yRegions) {
    int NO_COLOR = 0x00000001;
    int colorSize = 9;
    int bufferSize = xRegions.length * 4 + yRegions.length * 4 + colorSize * 4 + 32;

    ByteBuffer byteBuffer = ByteBuffer.allocate(bufferSize).order(ByteOrder.nativeOrder());
    // 第一个byte，不为0
    byteBuffer.put((byte) 1);

    //mDivX length
    byteBuffer.put((byte) 2);
    //mDivY length
    byteBuffer.put((byte) 2);
    //mColors length
    byteBuffer.put((byte) colorSize);

    //skip
    byteBuffer.putInt(0);
    byteBuffer.putInt(0);

    //padding 设为0
    byteBuffer.putInt(0);
    byteBuffer.putInt(0);
    byteBuffer.putInt(0);
    byteBuffer.putInt(0);

    //skip
    byteBuffer.putInt(0);

    // mDivX
    byteBuffer.putInt(xRegions[0]);
    byteBuffer.putInt(xRegions[1]);

    // mDivY
    byteBuffer.putInt(yRegions[0]);
    byteBuffer.putInt(yRegions[1]);

    // mColors
    for (int i = 0; i < colorSize; i++) {
        byteBuffer.putInt(NO_COLOR);
    }

    return byteBuffer.array();
}
```

[gist 1](https://gist.github.com/knight9999/86bec38071a9e0a781ee)和[gist 2](https://gist.github.com/briangriffey/4391807)也提供了生成chunk的方法

## 更多
想关于chunk的更多内容，可以看看ResourceTypes.cpp中的`do_9patch`，`isNinePatchChunk`，`Res_png_9patch`和`Res_png_9patch::serialize()`。

+ [do_9patch](http://android.git.kernel.org/?p=platform/frameworks/base.git;a=blob;f=tools/aapt/Images.cpp;h=3c471ca76107cc49b5f8e3ca15e87725ed80faf9;hb=refs/heads/gingerbread)
+ [isNinePatchChunk](http://netmite.com/android/mydroid/1.6/frameworks/base/core/jni/android/graphics/NinePatch.cpp)
+ [struct Res_png_9patch](https://scm.sipfoundry.org/rep/sipX/main/sipXmediaLib/contrib/android/android_2_0_headers/frameworks/base/include/utils/ResourceTypes.h)
+ [Dmitry Skiba stuff](http://code.google.com/p/android4me/source/browse/src/android/graphics/Bitmap.java)


# 总结

aapt是什么时候编译9patch图片的？

编译apk时，aapt会对图片进行压缩处理。而对于.9图，它使用`aapt.exe s -i xx.9.png -o xx.png`命令进行处理。处理后chunk信息被写入到生成的png文件中。

```
aapt.exe s -i c:\search_bg.9.png -o c:\search_bg.png
Crunching single PNG file: c:\search_bg.9.png
        Output file: c:\search_bg.png
```

具体来说，是在[do_9patch()](https://github.com/android/platform_frameworks_base/blob/master/tools/aapt/Images.cpp)方法中处理的。


`isNinePatchChunk`是如何实现的

9patch图为什么不能缩小


# 参考资料

+ http://stackoverflow.com/questions/5079868/create-a-ninepatch-ninepatchdrawable-in-runtime
+ http://dev.qq.com/topic/57c7ff5d53bbcffd68c64411
+ http://blog.csdn.net/hudashi/article/details/6957160
+ https://github.com/android/platform_frameworks_base/tree/master/tools/aapt
+ https://github.com/Anatolii/NinePatchChunk
+ https://android.googlesource.com/platform/packages/apps/Gallery2/+/jb-dev/src/com/android/gallery3d/ui/NinePatchChunk.java

[ref1]: http://blog.csdn.net/hudashi/article/details/6957160
[ref2]: https://developer.android.com/guide/topics/graphics/2d-graphics.html#nine-patch
[Res_png_9patch]: http://android.git.kernel.org/?p=platform/frameworks/base.git;a=blob;f=incl?/utils/ResourceTypes.h
[ref3]: http://stackoverflow.com/questions/5079868/create-a-ninepatch-ninepatchdrawable-in-runtime
[ref4]: https://developer.android.com/guide/topics/graphics/2d-graphics.html#nine-patch
[ref5]: https://ibotpeaches.github.io/Apktool/documentation/#9patch-images
[draw9patch]: https://developer.android.com/studio/write/draw9patch.html