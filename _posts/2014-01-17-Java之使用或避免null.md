---
layout: post
title: Java之使用或避免null
keywords: Java
description: Java基础
categories: [编程语言]
tags: [Java]
group: archive
icon: globe
---
[原文](http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained)

>null 代表着模糊和歧义，会引起让人迷惑的错误。或者有时候，它只是有些让人不舒服。很多 Guava 工具方法快速失败，而非盲目地接受 null。

>将null和空字符串混用是一种常见的代码臭味

#使用和避免 null
使用 null 不小必可能引起各种 bug。通过研究 Google 代码库，我们发现可能 95% 的集合并不支持存放 null，所以快速失败而非静默地接受 null 值会对开发者很有用。

另外，null 有一种令人不愉快的不确定性。返回值为 null 的含义很不明确。比如， `Map.get(key)` 返回 null 可能是因为 map 中的值就为 null，或者值不存在。Null 既可以表示失败，也可以表示成功，甚至可以表示任何意义。使用某些 null 以外的东西可以让你的表达更清楚。

也就是说，有时应当使用 null。从内存和速度的角度，null 的使用很高效。而对象数组中，null 的使用更是不可避免。但与库代码不同，在应用代码中，null 是表意不清的主要原因，它引起难以解决的奇怪 bug，带来让人讨厌的歧义。当 `Map.get` 返回 null，它可能意味着值不存在，或者值为 null。更严格些，null 不能说明它自己的含义。

正是这些原因，大部分 Guava 的工具方法尽可能被设计成 null 快速失败，只要有 null-friendly 的规避措施。另外，Guava 也提供一些方法用于简化 null 的使用。

## 特例
当你尝试在 Set 中使用 null，或使用 null 作为 Map的键。不要这么做。当你在做查询操作时如果能明确将 null 做为特例处理，会更加清晰。

如果要将 null 做为 Map 中的值，最好不要保存对应的条目。使用另外独立的非 null 键或 null 键。非常容易混淆这两种情况：Map 中包含一个键，它的值为 null；或者 Map 中不包含该键。所以最好将这些键独立开来，并且想清楚当某个键对应的值为 null 时到底对你的应用意味着什么。

如果在 List 中使用 null，当 List 数据稀疏时，可能使用 Map<Integer, E> 更好。它也许更高效，且更符合应用的需求。

考虑可以使用自然 null对象 的情况。这种情况不常见。比如，如果是一个枚举，可添加一个表示 null 的常量。再比如，`ava.math.RoundingMode` 有一个 `UNNECESSARY` 值，表示不要取整，当取整是必须的时抛出异常。

## Optional
许多使用 null 的场景是用来表示某种不存在：也许应当有个值，但是没有。比如，当对应于某个键的值不存在时，`Map.get` 返回 null。

Optional<T> 是一种使用非 null 值替换 null 值的一种方法。一个 Optional 可以包含非 null 的 T 引用(表示引用存在)，或者不包含任何东西(表示引用不存在)。没有包含 null 的说法。

	Optional<Integer> possible = Optional.of(5);
	possible.isPresent(); // returns true
	possible.get(); // returns 5 

## 生成 Optional
Optional 包含以下静态方法：

<table>
<tr>
<td>Optional.of(T)</td>
<td>得到一个包含指定的非空值的 Optional，或为空则快速失败</td>
</tr>

<tr>
<td>Optional.absent()</td>
<td>返回某种类型的表示不存在的 Optional</td>
</tr>

<tr>
<td>Optional.fromNullable(T)</td>
<td>将可能为空的引用转换成一个 Optional，将非空视为存在，而空为不存在</td>
</tr>

</table>

## 查询方法
以下这些成员方法来自 Optional<T> 对象

<table>


<tr>
<td>boolean isPresent()</td>
<td>如果 Optional 包含非空实例则返回 true</td>
</tr>

<tr>
<td>T get()</td>
<td>返回包含的 T 实例。如果不存在，则抛出 IllegalStateException</td>
</tr>

<tr>
<td>T or(T)</td>
<td>返回包含的 T 实例。如果不存在，则返回指定的值</td>
</tr>

<tr>
<td>T orNull()</td>
<td>返回包含的 T 实例。如果不存在，则返回 null。它是 fromNullable 的逆操作</td>
</tr>

<tr>
<td>Set&lt;T> asSet()</td>
<td>返回一个不可变的单例 Set，它包含当前 Optional 中的 T 实例。如果 Optional 中没有 T 实例，则返回一个空的不可变的 Set</td>
</tr>

</table>

## 什么是关键
除了可以给 null 指定一个名字以增加可读性，Optional 的最大优点是 idiot-proof-ness。你在编译时不得不主动解包 Optional 并处理 null，所以强迫你积极思考 null 的情况。

这跟你返回一个可能为存在也可能不存在的值一样。在实现 `other.method(a, b)` 方法时， 比起忘记参数 `a` 可能为空，你或其他人更可能会忘记 `other.method(a, b)` 会返回一个空值。如果是返回一个 Optional ，那调用者不可能会忘记这种情况，因为他们必须从 Optional 中解包出真正的对象。

## 便捷方法
当你想使用某些缺省值来代替 null 时，可以使用 `Objects.firstNonNull(T, T)`。正如它的名字所说，如果两个输入都为空，它会立即失败并抛出 NullPointerException。如果你使用 Optional，可以使用更好的替代办法，比如 `first.or(second)`。

Strings 提供了几个用于处理可为空的字符串的方法。比如：

<table>
<tr>
<td>emptyToNull(String)</td>
</tr>

<tr>
<td>isNullOrEmpty(String)</td>
</tr>

<tr>
<td>nullToEmpty(String)</td>
</tr>
</table>

强调下，这些方法主要用于处理一些将 null 和空的字符串混淆的、让人不舒服的 API。