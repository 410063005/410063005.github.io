---
layout: post
title: Java进阶之对象初始化
---
原文链接：[Java对象初始化详解](http://blog.jobbole.com/23939/)

## Java对象何时被初始化
Java对象在其被创建时初始化

除了显式地使用new来创建对象，某些操作会隐式地创建对象。

<!--
初始化必须发生在装载、连接以后，java虚拟机一般会在每个类或接口主动使用时才会对类型进行初始
化。下面六中情形符合主动使用的要求：
1.当创建某个类的新实例时。注：包括创建的所有方式，如new、反射、克隆以及反序列化等
2.当调用某个类的静态方法时
3.当使用某个类或接口的静态字段，或对该静态非常量字段进行赋值时。注意：用final修饰的静态
字段除外，因为在编译阶段时，它就被替换成一个常量表达式
4.调用java API中的某些反射方法时，比如类Class中的方法或java.lang.reflect包中的方法
5.初始化某个类的子类时（某个类初始化时，要求它的超类已经被初始化了）
6.虚拟机启动时，包含有main方法的类


补充： 创建类的新实例的方式主要有四种：
1.明确使用new操作符
2.调用Class或Constructor对象的newInstance()方法
3.调用现有对象的clone()方法
4.通过java.io.ObjectInputStream类的getObject()方法反序列化﻿
-->

## Java如何初始化对象

### 构造方法
略

### 实例变量初始化器

	public class InstanceVariableInitializer {
	    private int i = 1;
	    private int j = i + 1;
	}

### 实例初始化器

	public class InstanceInitializer {
	 
	    private int i = 1;
	    private int j;
	 
	    {
	        j = 2;
	    }
	}
上面代码中花括号内代码，在Java中就被称作实例初始化器，其中的代码会**先于**构造函数被执行

如果我们定义了实例变量初始化器与实例初始化器，那么编译器会将其中的代码放到类的构造函数中去，这些代码会被放在对超类构造函数的调用语句**之后**，构造函数本身的代码**之前**。

	public class InstanceInitializer {
	 
	    private int i = 1;
	    private int j;
	 
	    {
	        j = 2;
	    }
	 
	    public InstanceInitializer() {
	        i = 3;
	        j = 4;
	    }
	}
编译出来的字节码是

	aload_0
	invokespecial    #11; //Method java/lang/Object."<init>":()V
	aload_0
	iconst_1
	putfield #13; //Field i:I
	aload_0
	iconst_2
	putfield #15; //Field j:I
	aload_0
	iconst_3
	putfield #13; //Field i:I
	aload_0
	iconst_4
	putfield #15; //Field j:I
	return

注意:
>Java是按照编程顺序来执行实例变量初始化器和实例初始化器中的代码的，并且不允许顺序靠前的实例初始化器或者实例变量初始化器使用在其后被定义和初始化的实例变量

根据上述规则，以下代码无法通过编译：

	public class InstanceInitializer {
	    {
	        j = i;
	    }
	 
	    private int i = 1;
	    private int j;
	}
	 
	public class InstanceInitializer {
	    private int j = i;
	    private int i = 1;
	}
下面这段代码可以绕开前面的规则：

	public class InstanceInitializer {
	    private int j = getI();
	    private int i = 1;
	 
	    public InstanceInitializer() {
	        i = 2;
	    }
	 
	    private int getI() {
	        return i;
	    }
	 
	    public static void main(String[] args) {
	        InstanceInitializer ii = new InstanceInitializer();
	        System.out.println(ii.j);
	    }
	}
打印的结果是0，原因见下面的字节码

	public Str();
	  Code:
	   Stack=2, Locals=1, Args_size=1
	   0:   aload_0
	   1:   invokespecial   #1; //Method java/lang/Object."<init>":()V
	   4:   aload_0
	   5:   aload_0
	   6:   invokespecial   #2; //Method getI:()I
	   9:   putfield        #3; //Field j:I
	   12:  aload_0
	   13:  iconst_1
	   14:  putfield        #4; //Field i:I
	   17:  return
	  LineNumberTable:
	   line 2: 0
	   line 4: 4
	   line 5: 12

## 类的初始化
[Java规范](http://docs.oracle.com/javase/specs/jvms/se7/jvms7.pdf)中关于类在何时被初始化有详细的介绍，在3.0规范中的12.4.1节可以找到，这里就不再多说了。简单来说，就是*当类被第一次使用的时候会被初始化，而且只会被一个线程初始化一次*

静态变量初始化器和静态初始化器基本同实例变量初始化器和实例初始化器相同，也有相同的限制(按照编码顺序被执行，不能引用后定义和初始化的类变量)。静态变量初始化器和静态初始化器中的代码会被编译器放到一个名为static的方法中(static是Java语言的关键字，因此不能被用作方法名，但是JVM却没有这个限制)，在类被第一次使用时，这个static方法就会被执行。

	public class StaticInitializer {
	    static int i = 1;
	 
	    static {
	        i = 2;
	    }
	}
以上代码后生成如下的一个static方法

	static {};
	  Code:
	   Stack=1, Locals=0, Args_size=0
	   0:   iconst_1
	   1:   putstatic       #4; //Field i:I
	   4:   iconst_2
	   5:   putstatic       #4; //Field i:I
	   8:   return