---
layout: post
title: Runtime的陷阱
keywords: Java
description: Java基础
categories: [编程语言]
tags: [Java]
group: archive
icon: globe
---
[原文](http://www.oschina.net/question/565065_58500?sort=time)来自 oschina 上的一篇博客，转自csdn。查了一下，感觉应该是翻译的，真正的出处找不到了。

# 0. Runtime类简介
`java.lang.Runtime` 的静态方法 `getRuntime()` 可以用来获取当前 Java 运行环境。这是获取 `Runtime` 对象的唯一办法。得到该对象后，可以调用其 `exec()` 方法来运行外部程序。比如，启动浏览器来显示应用的帮助页面。

有四个重载的`exec()`方法：

+ `public Process exec(String command)`
+ `public Process exec(String [] cmdArray)`
+ `public Process exec(String command, String [] envp)`
+ `public Process exec(String [] cmdArray, String [] envp)`

以上方法会传递命令及参数)给操作系统进行调用。操作系统创建一个进程，并返回代表这个进程的 `Process` 引用给Java虚拟机。`Process` 是一个抽象类。(容易理解，不同操作系统上的JDK中 `Process` 会有不同的具体子类)。

上述方法可以接收三类参数：

1. 一个字符串，其中既包含程序也包含程序参数
2. 一个字符串数组，分别代表程序和它的参数
3. 一组环境变量

注意环境变量参数的形式是 `name=value`。

# 1. Runtime.exec()的常见问题

## 1.1 抛出IllegalThreadStateException 
`Runtime.exec()` 相关的第一个问题是 `IllegalThreadStateException` 。使用 `exec()` 方法执行外部进程后，可以通过 `exitValue()` 得到该进程的执行结果。如下：

	public static void main(String[] args) throws IOException {
		Process process = Runtime.getRuntime().exec(
				"calc");
		System.out.println(process.exitValue());
	}

但这段代码很可能得到出现以下异常：

	Exception in thread "main" java.lang.IllegalThreadStateException: process has not exited
		at java.lang.ProcessImpl.exitValue(Unknown Source)
		at pack.BadExecJavac.main(BadExecJavac.java:11)

问题的原因很简单：该进程还没有结束，所以`exitValue()`会抛出异常。虽然JDK文档中提到了这点，但如果`exitValue()`阻塞直到进程结束再返回一个值岂不更好？事实上，另一个 `waitFor()` 方法正是这么做的。

`waitFor()`和`exitValue()`不可同时使用，你必须二选一。如果`exitValue()`方法接受一个`waitFor`参数该多好，`waitFor`为`true`时当前线程阻塞并等待，否则继续运行。另外，`exitValue()`这个名字也更好。而且没必要仅仅因为条件不同，就对功能相同的方法使用不同的名字。

综上，避免这个问题很简单，捕获`IllegalThreadStateException`，或者等待进程结束。

## 1.2 Runtime.exec方法阻塞
如下代码：

		Process proc = Runtime.getRuntime().exec(
				"calc");
		proc.waitFor();
		System.out.println("cannot reach here");

很可能不能输出`cannot reach here`，除非结束`calc`进程。

JDK文档中提到了这一点
>Because some native platforms only provide limited buffer size for standard input and output streams, failure to promptly write the input stream or read the output stream of the subprocess may cause the subprocess to block, and even deadlock

某些平台仅为标准输入输出流提供有限大小的缓存，不及时写子进程的输入流或读子进程的输出流可能会导致子进程阻塞甚至死锁。

虽然文档告诉了你需要处理进程的输入输出流，但很遗憾没有告诉你到底该怎么做。

这里考虑`exec("javac")`。当执行`javac`时不带任何参数，会输出javac的用法。注意，这些是通过`stderr`输出的，所以可以在程序中读取`stderr`来避免进程阻塞。但是，仅仅读取`stderr`是不够的。更好的做法是，同时处理`stderr`和`stdout`。

		Process proc = Runtime.getRuntime().exec(
				"javac");

		 InputStream stderr = proc.getErrorStream();
         InputStreamReader isr = new InputStreamReader(stderr);
         BufferedReader br = new BufferedReader(isr);
         String line = null;
         
         // Empty stderr
         while ( (line = br.readLine()) != null)
             System.out.println(line);

综上，解决`exec()`阻塞问题很简单：如果启动的进程会生成输出或期待输入，在程序中正确处理输入输出流即可。

## 1.3 传入错误的命令
某些在shell或cmd下可以执行的命令并不是一个独立的可执行文件。比如，cmd下的`dir`和`copy`是Windows的命令行的一部分，而非一个可执行文件，所以`exec()`调用时传入`dir`和`copy`时可能出错。

搜索一下，的确没有`dir.exe'和`copy.exe`

	C:\Windows\System32>d:\cygwin\bin\find  -name "cmd.exe"
	./cmd.exe
	
	C:\Windows\System32>d:\cygwin\bin\find  -name "dir.exe"
	
	C:\Windows\System32>d:\cygwin\bin\find  -name "copy.exe"

试试`exec("copy")`

	Process proc = Runtime.getRuntime().exec(
				"copy");

异常如下：

	Exception in thread "main" java.io.IOException: Cannot run program "copy": CreateProcess error=2, ?????????
		at java.lang.ProcessBuilder.start(Unknown Source)
		at java.lang.Runtime.exec(Unknown Source)
		at java.lang.Runtime.exec(Unknown Source)
		at java.lang.Runtime.exec(Unknown Source)
		at pack.BadExecJavac.main(BadExecJavac.java:11)
	Caused by: java.io.IOException: CreateProcess error=2, ?????????
		at java.lang.ProcessImpl.create(Native Method)
		at java.lang.ProcessImpl.<init>(Unknown Source)
		at java.lang.ProcessImpl.start(Unknown Source)
		... 5 more

通常，返回值为0表示成功；而非0值表示错误。当前，返回值的含义还跟操作系统有关。Win32平台上返回值为2表示`file not foud`。这里表示找不到`copy`这个命令。

要避免第3个问题，一定不能想当然认为某个命令就是一个真正的可执行文件。

注意：获取进程输出流的方法是`getInputStream()`。记住：这个API是从Java程序的角度出发的，而不是外部进程。因此，外部进程的输出是Java程序的输入。这个逻辑同样适用于外部进程的输入流，这个输入流是作为Java程序的输出流。

## 1.4 误以为Runtime.exec方法是命令行
可以是因为`exec()`方法的参数名为`command`，容易误以为`exec()`方法接受一个`String`作为命令。所以错误地传入可以在命令行中执行的命令给这个方法，而非可执行文件名及其参数。比如，下面的例子会执行一个命令并且将重定向该命令的输出。

		Process proc = Runtime.getRuntime().exec(
				"java >test.txt");

		 InputStream stderr = proc.getErrorStream();
         InputStreamReader isr = new InputStreamReader(stderr);
         BufferedReader br = new BufferedReader(isr);
         String line = null;
         
         // Empty stderr
         while ( (line = br.readLine()) != null)
             System.out.println(line);
         
         int exitVal = proc.waitFor();
         
         System.out.println("Process exitValue: " + exitVal);

错误如下：

	错误: 找不到或无法加载主类 >test.txt
	Process exitValue: 1

直接在命令行下运行`java >test.txt`可以成功重定向

	C:\>java > test.txt
	
	C:\>

牢记，`exec()`不是shell解释器! `exec()`如果要重定向流，使用`java.io`中相关的类编程实现。

# 2. 总结
以下是避免使用 `Runtime.exec()` 时出现问题的几条经验：

1. 外部进程未结束时**不能**得到其退出状态码
2. 应及时处理外部进程的输入输出流及错误流
3. 使用 `Runtime.exec()` 用来执行 **程序**
4. `Runtime.exec()` **不是** 命令行