---
layout: post
title: 转_Java检测端口的占用情况
keywords: Java
description: Java基础
categories: [编程语言]
tags: [Java]
group: archive
icon: globe
---
原文地址: [Java检测端口的占用情况][Java检测端口的占用情况]

有时候需要判断本地的某一个端口号是否被占用，网上通用的一种方法是：

	public boolean isPortAvailable(int port) {
	    try {
	        ServerSocket server = new ServerSocket(port);
	        System.out.println("The port is available.");
	        return true;
	    } catch (IOException e) {
	    	System.out.println("The port is occupied.");
	    }
	    return false;
	}

通过新建一个ServerSocket来判断端口是否被占用，但是实际上这个检测方式是有漏洞的，有些情况不能够覆盖得到。例如，一个运行在WebLogic之上的应用它的端口为8406，则通过命令

	netstat -aon | findstr 8406

得到的结果可能为：

	TCP    192.168.1.101:8406    111.111.111.111:80    SYN_SENT        112

可见8406绑定的内部IP地址为本机的IP地址192.168.1.101，这时通过如上的方式得到的结果为这个端口没有被使用。原因在于通过ServerSocket建立的连接绑定的IP为0.0.0.0，这一小小的差异导致了如上方法没有通用性，找到一种比较好的方法为：

	private void bindPort(String host, int port) throws Exception {
	    Socket s = new Socket();
	    s.bind(new InetSocketAddress(host, port));
	    s.close();
	}

	public boolean isPortAvailable(int port) {
	    Socket s = new Socket();
	    try {
	        bindPort("0.0.0.0", port);
	        bindPort(InetAddress.getLocalHost().getHostAddress(), port);
	        return true;
	    } catch (Exception e) {
	        return false;
	    }
	}

通过一个socket分别尝试去绑定0.0.0.0和本机IP上的port，当这两个port都可以被绑定时，则这个端口真的没有被占用。在linux上这一方法同样适用，但是有一种情况需要注意，当本机通过hostname不能解析到本机的IP地址时InetAddress.getLocalHost().getHostAddress()这个函数会抛错，导致从结果来看端口被占用着。因此需要确保在/etc/hosts文件中存在着这么一条映射：
<hostname> <local_ip>

<hostname>为你在终端执行hostname返回的本机名，<local_ip>则为在终端执行ifconfig得到的本机真实IP，JAVA提供的这个函数会去这个文件中找<hostname>对应的IP地址，不然会因为找不到而抛错。确保这一条之后，在linux上也能正确检测指定端口的占用情况~

---
补充：开发web地图定位功能时需要在手机本地开启一个web服务器，用于支持web页面的jsonp调用。但Android手机上app众多，为降低端口被其他app占用的风险，我们在预定两个端口，尝试绑定第一个端口失败后会再次尝试绑定第二个端口。代码如下：

			try {
				server.bind(new InetSocketAddress(8888/*一个未占用的端口*/));
				System.out.println("bind 8888");
			} catch (BindException e) {
				e.printStackTrace();
				server.bind(new InetSocketAddress(58465/*一个已占用的端口*/));
				System.out.println("bind 58465");
			}

但我们不能保证第一个端口一定没被占用，如下情形会出现异常：

			try {
				server.bind(new InetSocketAddress(/*一个已占用的端口*/));
			} catch (BindException e) {
				e.printStackTrace();
				server.bind(new InetSocketAddress(/*一个未占用的端口*/));
			}

Windows 上的异常如下：

	Exception in thread "main" java.net.SocketException: Unrecognized Windows Sockets error: 0: JVM_Bind
		at java.net.PlainSocketImpl.socketBind(Native Method)
		at java.net.PlainSocketImpl.bind(Unknown Source)
		at java.net.ServerSocket.bind(Unknown Source)
		at java.net.ServerSocket.bind(Unknown Source)
		at T.main(T.java:17)


而Android 上的异常则是 `socket is closed`。总之，无法正常工作。

使用这篇文章中的检测端口占用的方法，非常完美地解决了上面的问题。伪代码如下：

	int port1 = ...
	int port2 = ...
	if (port1未被占用) {
		绑定port1
	} else if (port2未被占用) {
		绑定port2
	} else {
		出错
	}

需要注意的是， `InetAddress.getLocalHost().getHostAddress()` 涉及网络操作，不能在主线程中进行，否则会抛出下面的异常：

	06-20 17:02:40.365: E/port(17344): android.os.NetworkOnMainThreadException
	06-20 17:02:40.365: E/port(17344): 	at android.os.StrictMode$AndroidBlockGuardPolicy.onNetwork(StrictMode.java:1099)
	06-20 17:02:40.365: E/port(17344): 	at java.net.InetAddress.lookupHostByName(InetAddress.java:391)
	06-20 17:02:40.365: E/port(17344): 	at java.net.InetAddress.getLocalHost(InetAddress.java:371)


[Java检测端口的占用情况]: http://www.linuxidc.com/Linux/2013-09/90532.htm
