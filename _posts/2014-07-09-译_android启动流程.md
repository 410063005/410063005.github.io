---
layout: post
title: 译_android启动流程
keywords: Android
description: Android
categories: [Android]
tags: [Android]
group: archive
icon: globe
---
http://www.360doc.com/content/10/1004/19/3700464_58405073.shtml

本文中你将了解到关于 android 进程管理的一些知识。我们首先看一下 android 启动过程中运行的进程列表：

![launched_process]({{ site.url }}/assets/20140709/launched_process.PNG)

# Root Process
`init` [TODO] 是 kernel 启动后第一个运行的进程。它的主要作用是：
+ 解析和执行 `init.rc` 以及 `init.%hardware%.rc`
+ 自动生成 `/dev` 下的设备节点
+ 启动 log 和 property 服务
+ 监听设备、property集以及子进程的退出事件

# Native Application Process
根据 `init.rc` 的内容，`init` 会 fork 出以下的本地应用进程：

console：启动 shell

servicemanager：启动 binder IPC service manager [TODO]

mountd：启动后，将挂载 `/system/etc/mountd.conf` 中定义的所有文件系统，并接收来自 local
socket 的指令以挂载其他的文件系统

debuggerd：启动 debug 系统

rild：启动 radio 接口层的后台服务

zygote [TODO]：启动 android Java VM 运行时，并启动 system server。它是最重要的进程

mediaserver：启动 AudioFlinger，MediaPlayerService 和 CamearService [TODO]

installd：启动应用包安装后台服务

# Java Application Process
每个 Java 应用进程都是从 zygote fork出来的。system server 是一个特殊的 Java 进程，它直接从
zygote fork出来。而其他的 Java 进程是从 ActivityManagerService (运行在 system server 进程中)
创建出来的，如下所示：

	int pid = Process.start("android.app.ActivityThread", 
		mSimpleProcessManagement ? app.processName: null, uid, uid, gids, 
		((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0), null);

`Process.java` 使用 UNIX domain socket 跟 zygote 通信。整个过程如下图所示：

![zygote TODO]({{ site.url }}/assets/20140709/zygote.jpg)

## system server
它是 zygote 启动的第一个 Java 应用。system server是 android 的核心引擎， 会启动主要的 android service，比如 ActivityManager，WindowManager，PackageManager等等。

## persistent application
系统启动时，`ActivityManagerService.systemReady()` 会启动所有的 persistent 应用。

	List apps = 	ActivityThread.getPackageManager()
		.getPersistenApplications(PackageManager.GET_SHARED_LIBRARY_FILES)
	if (apps != null) {
		int N = apps.size();
		int i;
		for (i = 0; i < N; i++) {
			ApplicationInfo info = (ApplicationInfo) apps.get(i);
			if (info != null && !info.packageName.equals("android")) {
				addAppLocked(info);
			}
		}
	}

目前只有 `Phone` (通话应用)是 persistent 应用，它的 manifest 如下：

	<application android:name="PhoneApp" android:persistent="true">
	
所以在启动过程中，只有通话应用是自动启动的，即 `com.android.phone` 进程。

> 关于 [persistent][persistent] 属性

> Whether or not the application should remain running at all times -- "true" if
it should, and "false" if not. The default value is "false". Application should 
not normally set this flag; persistence mode is intended only for certain system
applications.

## 第一个 Activity
第一个 activity 是由 ActivityManagerService 发送的 Intent.CATEGORY_HOME intent 启动的：

	Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);
	intent.setComponent(mTopComponent);
	if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
		intent.addCategory(Intent.CATEGORY_HOME);
	}
	ActivityInfo aInfo = intent.resolveActivityInfo(mContext.getPackageManager(), 
		PackageManager.GET_SHARED_LIBRARY_FILES);
	if (aInfo != null) {
		intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));
		
		// don't do this if the home app is currently being instrumented.
		ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid);
		if (app == null || app.instrumentionClass == null) {
			intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
			startActivityLocked(null, intent, null, null, 0, aInfo, null, null, 0, 0, 0, false);
		}
	}
	
这个 activity 所在进程即 "android.process.acore" 进程。

## 系统启动后的自启动应用
当 ActivityManagerService 检查到当前空闲时，会第一时间发送 `ACTION_BOOT_COMPLETED` [TODO] 广播:

	if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
		// tell anyone interested that we are done booting!
		synchronized(this) {
			broadcastsIntentLocked(null, null, new Intent(Intent.ACTION_BOOT_COMPLETED, null),
				null, null, 0, null, null, android.Manifest.permission.RECEIVE_BOOT_COMPLETED,
				false, false, MY_PID, Process.SYSTEM_ID);
		}	
	}
	
当前，MSS、AlarmClock、Calendar、MediaProvider、VoiceDialer 和 IM 等应用在 manifest 中注册接收 `ACTION_BOOT_COMPLETED`。所以它们会自动启动。

虽然 Email 应用也注册接收 `ACTION_BOOT_COMPLETED`，但是它定义了 `android:enabled=false` 属性。所以不会被启动。

	<receiver android:name=".service.BootReceiver" android:enabled="false">
		<intent-filter>
			<action android:name="android.intent.action.BOOT_COMPLETED" />
		</intent-filter>
	</receiver>
	
DownloadProvider 同样也注册接收 `ACTION_BOOT_COMPLETED`，但跟 Email 一样，它定义了 `android:enabled=false` 属性，也不会被启动。

## Behind the Java Process
system server 是个特例。它调用 `ActivityThread.java` [TODO] 的 `systemMain` [TODO] 这个静态方法，该方法会创建 ActivityThread 实例。ActivityThread 之后将创建 ApplicationThread，Application，Application Context 实例。

而其他 Java 进程以另外一种方式工作。It's controlled by system_server while forked by zygote。当其他 Java 进程由
zygote fork出来时，会自动调用 `ActivityThread.java` 的 main 静态方法(见 `Process.java` 及以下的代码片断)：

	try {
		ZygoteInit.invokeStaticMain(cloader, className, mainArgs);
	} catch (RuntimeException ex) {
		logAndPrintError(newStderr, "Error starting. ", ex);
	}
	
`ActivityThread.java` 的主方法会创建 ActivityThread 实例。 ApplicationThread 作为 IBinder 对象跟  system_server 中的 ActivityManagerService 进行交互。刚启动时新的进程会等待 system_server 的 IPC 调用，
其他什么也不干。而 Application 和 ApplicationContext 对象此时并不会创建。这两个对象会延迟到进程实际开始
工作时才创建，比如，启动 Activity，接收广播，或者启动 Service。

比如，启动 Activity时，ActivityManagerService 知道被启动的 Activity 应当在哪个进程中运行，所以它会通过
RPC调用 ApplicationThread [TODO] 的 `scheduleLaunchActivity` 来在这个进程中启动一个新的 Activity。
随后 ApplicationThread 会发送一个消息让 ActivityThread 知道它需要启动一个 Activity。这时 ActivityThread
才会创建 `Application` 和 `ApplicationContext` 对象。随后，它将调用 `Instrumentation` [TODO]，而 `Instrumentation` 最终调用 Java dalvik VM 来创建实际的 Activity Java 对象。


[persistent]: http://developer.android.com/guide/topics/manifest/application-element.html
