<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sunmoon的博客</title>
  
  <subtitle>点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sunmoonblog.com/"/>
  <updated>2020-11-13T02:18:59.051Z</updated>
  <id>http://www.sunmoonblog.com/</id>
  
  <author>
    <name>Sunmoon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>h5-dev</title>
    <link href="http://www.sunmoonblog.com/2020/09/24/h5-dev/"/>
    <id>http://www.sunmoonblog.com/2020/09/24/h5-dev/</id>
    <published>2020-09-24T11:29:29.000Z</published>
    <updated>2020-11-13T02:18:59.051Z</updated>
    
    <content type="html"><![CDATA[<p>离职中。离职前最后一个项目是前端项目，用到了一些之前不了解的工具，也遇到不少的问题。预计接下来几年都不会再接触前端开发工作，但记录一下以备忘、拓展知识广度总是好的。</p><a id="more"></a><p>具体分成三类话题。</p><ul><li>工具</li><li>问题</li><li>技巧</li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>首先谈谈<strong>开发工具</strong>。Chrome Devtools 真是个神器。<a href="(https://juejin.im/post/5f1542e16fb9a07e6f7b80fe">这里</a>)有篇介绍 Devtools 的文章。只挑几个我觉得特别有用的功能说说。</p><p><img src="/images/16009472822261.jpg" alt="-w451"></p><p>一是选择机型，便于在不同分辨率下调试。二是选中元素开关(点击一下后变成蓝色)，打开后选择 html 页面中的元素非常方便</p><p><img src="/images/16009474285734.jpg" alt="-w444"></p><p>第三个是 Replay XHR 功能。只会刷新页面来重新发送 XHR 请求，太 low 了。其实 Replay 一下就足够了！</p><p>另一个好用的开发工具是 Vue.js devtools。怎么好用呢？看图。直接在 Vue.js devtools 中修改数据，UI 也随之变化。调试界面非常方便！</p><p><img src="/images/vuejs-devtools.gif" alt="vuejs-devtools"></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>再来说说遇到的问题(或者说是坑)。</p><h2 id="DOM-与-Vue-js"><a href="#DOM-与-Vue-js" class="headerlink" title="DOM 与 Vue.js"></a>DOM 与 Vue.js</h2><p>首先要说的一个坑就是在 Vue.js 中使用 zepto 操作真实DOM节点引起的一个看似诡异其实很好理解的愚蠢问题。你肯定会质疑为什么 Vue.js 会使用 zepto。实际情况是前端输出的重构文件中用到的 zepto，一是我懒二是确实也不知如何准确地将 zepto 代码翻译成 Vue.js，所以就出现 Vue.js 与 zepto 混用的情况。</p><p>大部分场景下这种做并不会有问题，直接这个点击用户名后编辑的功能：</p><p><img src="/images/edit-name.gif" alt="edit-name"></p><p>伪代码类似这样，其关键在于 <code>vm.inputTeamName = newtxt</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;inputTeamName&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更改名称</span></span><br><span class="line">$(<span class="string">".btn-change"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> td = $(<span class="keyword">this</span>).siblings(<span class="string">'span'</span>);</span><br><span class="line"><span class="keyword">var</span> txt = td.text();</span><br><span class="line"><span class="keyword">var</span> input = $(<span class="string">"&lt;input type='text'value='"</span> + txt + <span class="string">"'/&gt;"</span>);</span><br><span class="line">td.html(input);</span><br><span class="line">input.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line">input.trigger(<span class="string">"focus"</span>);</span><br><span class="line">input.blur(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> newtxt = $(<span class="keyword">this</span>).val();</span><br><span class="line"><span class="keyword">if</span>(newtxt != txt) &#123;</span><br><span class="line">  <span class="comment">// 更新 inputTeamName</span></span><br><span class="line">  vm.inputTeamName = newtxt</span><br><span class="line">td.html(newtxt);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">td.html(newtxt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不过这段代码时灵时不灵。我疑惑了好久。但仔细一想又很简单：操作 span 这个<font color="red">真实DOM节点后</font>，就不能指望 <code></code> 是可靠的了 (毕竟它跟 Vue.js 的<font color="red">虚拟DOM节点</font>相关)</p><p>类似的情况还有操作过真实DOM节点后，<code>v-model</code>指令失效。原因也类似。</p><h2 id="重名组件"><a href="#重名组件" class="headerlink" title="重名组件"></a>重名组件</h2><p>封装了一个 <code>RegisterDialog</code> 组件，组件中指定了 id。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pop-wrap pop-bg02 pop-box01"</span> <span class="attr">id</span>=<span class="string">"pop-box01"</span> <span class="attr">style</span>=<span class="string">"display: none"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"p-title"</span>&gt;</span>绑定手机<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"phone-input"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>RegisterDialog</code> 组件被多处使用。如下图：</p><p><img src="/images/16010202840140.jpg" alt="-w502"></p><p>发现有时操作不能按预期方式操作 <code>RegisterDialog</code>。比如，头像和昵称无法正常显示。推测问题原因是 <code>RegisterDialog</code> 导致 html 页面内元素 ID 冲突。</p><p>一种解决方式是使用更合理的页面结构，保证只有一个 <code>RegisterDialog</code>。如下图：</p><p><img src="/images/16010202885727.jpg" alt="-w503"></p><p>另一种解决方式是避免 <code>RegisterDialog</code> 组件中 div 元素的 ID 写死为 <code>pop-box01</code>，而是使用动态ID。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pop-wrap pop-bg02 pop-box01"</span> <span class="attr">:id</span>=<span class="string">"myID"</span> <span class="attr">style</span>=<span class="string">"display: none"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"p-title"</span>&gt;</span>绑定手机<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"phone-input"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="分享图白边"><a href="#分享图白边" class="headerlink" title="分享图白边"></a>分享图白边</h2><p>我们的H5在某些机型上生成的分享图会出现一条白边。如下图：</p><p><img src="/images/16010220630144.jpg" alt="-w383"></p><p>白边问题的原因是rem和px转化存在小数点。提前将rem转换成px即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fixDimen(domId) &#123;</span><br><span class="line">  <span class="keyword">const</span> ele = <span class="built_in">document</span>.getElementById(domId);</span><br><span class="line">  <span class="keyword">if</span> (ele) &#123;</span><br><span class="line">    <span class="comment">// 解决rem和px转化存在小数点，导致的白边问题</span></span><br><span class="line">    ele.style.width = <span class="string">`<span class="subst">$&#123;ele.offsetWidth&#125;</span>px`</span>;</span><br><span class="line">    ele.style.height = <span class="string">`<span class="subst">$&#123;ele.offsetHeight&#125;</span>px`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="图片跨域"><a href="#图片跨域" class="headerlink" title="图片跨域"></a>图片跨域</h2><p>dom2img 库用于将 DOM 节点转换成图片。使用 dom2img 时要注意图片跨域问题。一种简单的解决办法是将托管在图片服务器上的图片保存到本地，同时修改部分css代码。</p><p>修改前：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://image-1251917893.cos.ap-guangzhou.myqcloud.com/gp-match/css/match.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://image-1251917893.cos.ap-guangzhou.myqcloud.com/gp-match/css/match.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"match.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后本地新增一个 <code>match.css</code> 文件。这个css会重写几个样式(主要是将背景图片指向本地图片，而非图片服务器)以覆盖前一个css中某些规则，以避免图片跨域问题。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.xspr1</span> &#123; <span class="attribute">background-image</span>: <span class="built_in">url</span>(img/xspr1.png); <span class="attribute">background-repeat</span>: no-repeat; <span class="attribute">background-size</span>: <span class="number">9.94rem</span> <span class="number">5.18rem</span>; &#125;</span><br><span class="line"><span class="selector-class">.xspr</span> &#123; <span class="attribute">background-image</span>: <span class="built_in">url</span>(img/xspr.png); <span class="attribute">background-repeat</span>: no-repeat; <span class="attribute">background-size</span>: <span class="number">9.92rem</span> <span class="number">11.21rem</span>; &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="内联CSS"><a href="#内联CSS" class="headerlink" title="内联CSS"></a>内联CSS</h2><p>有时需要在 Vue.js 中内联 css 文件。</p><p>比如我遇到这样一个问题。一些图片和css文件在测试环境中可以正常访问，但发布到正式环境就不行。</p><ul><li>测试环境中能正常访问<ul><li><a href="https://test.igame.qq.com/newcss/admin/hp-match/match.css" target="_blank" rel="noopener">https://test.igame.qq.com/newcss/admin/hp-match/match.css</a></li><li><a href="https://test.igame.qq.com/newcss/admin/hp-match/img/share1.jpg" target="_blank" rel="noopener">https://test.igame.qq.com/newcss/admin/hp-match/img/share1.jpg</a></li></ul></li><li>正式环境中不能正常访问<ul><li><a href="https://igame.qq.com/newcss/admin/hp-match/match.css" target="_blank" rel="noopener">https://igame.qq.com/newcss/admin/hp-match/match.css</a></li><li><a href="https://igame.qq.com/newcss/admin/hp-match/img/share1.jpg" target="_blank" rel="noopener">https://igame.qq.com/newcss/admin/hp-match/img/share1.jpg</a></li></ul></li></ul><p>看 Chrome 提示推测是正式服务器 <code>content-type</code> 配置有问题，它将css文件的作为html返回了，所以无法正常加载css。随之引起图片跨域问题(该css是专门用来解决跨域问题的)</p><p><img src="/images/16010240487770.jpg" alt="-w936"></p><p>无奈我没权限修改正式服务器配置。于是换另一种思路，将 css 内存到 Vue.js。</p><p>修改前：在 <code>index.html</code> 引入 <code>match.css</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"match.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后：在 <code>App.vue</code> 引入 <code>match.css</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./../../../public/match.css'</span>;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><p>修改后成功绕过正式服务器的 <code>content-type</code> 配置问题，可正常加载 <code>match.css</code>，避免了随之而来的图片跨域问题！</p><h2 id="使用图片"><a href="#使用图片" class="headerlink" title="使用图片"></a>使用图片</h2><p>vue 文件中也可以直接使用图片。方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register-dialog.vue</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;img <span class="class"><span class="keyword">class</span></span>=<span class="string">"info-txt-1"</span> :src=<span class="string">"imgs.share_text"</span> alt /&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import head_name from 'src/m</span>odule/xxx/img/head-name.png<span class="string">'</span></span><br><span class="line"><span class="string">import headbox from '</span>src/<span class="built_in">module</span>/xxx/img/headbox.png<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  data() &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      imgs: &#123;</span></span><br><span class="line"><span class="string">        head_name: head_name,</span></span><br><span class="line"><span class="string">        headbox: headbox</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="保存分享图"><a href="#保存分享图" class="headerlink" title="保存分享图"></a>保存分享图</h2><p>一个需求是这样的：用户长按h5保存图片时，实际保存的图片上要求有一个二维码和提示。</p><p><a href="https://blog.csdn.net/w20101310/article/details/60580241/" target="_blank" rel="noopener">微信中如何长按图片保存的是另一张图片_小朱的专栏-CSDN博客</a>中介绍了一种解决方案。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><img src="/images/16009498051466.jpg" alt="-w102"></p><ul><li>chrome devtools 中快速qq登录 (一直觉得H5中QQ登录很麻烦，实际上是没有掌握技巧。使用 Toggle device toolbar 将浏览器切换成PC模式而不是Mobile模式，可以拉起PC端的QQ登录页，然后手机QQ扫一扫登录，非常方便)</li><li>部署不同的 url 的环境 (修改 <code>publish.js</code> 脚本)</li><li>beforeDestroy 响应back 键回退时，以关闭 layer</li><li>同名组件问题 (同ref或同ID)</li><li>无法获取角色信息问题确认</li><li>卡在ssl.ptlogin2.qq.com的问题 (短时间同一测试QQ号在多个Android机器上登录时容易出现这个问题)</li><li>分环境部署 (修改 <code>publish.js</code> 中的 <code>desc</code> 即可)</li><li>css 作用域问题 (dialog 样式)</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/5f1542e16fb9a07e6f7b80fe" target="_blank" rel="noopener">脱离996，Chrome DevTools 面板全攻略！！！ - 掘金</a></li><li><a href="https://blog.csdn.net/w20101310/article/details/60580241/" target="_blank" rel="noopener">微信中如何长按图片保存的是另一张图片_小朱的专栏-CSDN博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;离职中。离职前最后一个项目是前端项目，用到了一些之前不了解的工具，也遇到不少的问题。预计接下来几年都不会再接触前端开发工作，但记录一下以备忘、拓展知识广度总是好的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 内存优化之优化 so 文件</title>
    <link href="http://www.sunmoonblog.com/2020/07/22/flutter-mmamp-memory/"/>
    <id>http://www.sunmoonblog.com/2020/07/22/flutter-mmamp-memory/</id>
    <published>2020-07-22T05:29:59.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>优化 so 大小能否减少 Android 应用的内存？从原理上讲是可以的，实际效果如何？一起来看看吧。</p><a id="more"></a><p>(本文待完善)</p><p>相关文章：</p><ul><li><a href="https://www.sunmoonblog.com/2020/07/16/flutter-split-debug-info/">Flutter split-debug-info 用法介绍</a> - 使用 split-debug-info 可以优化 Flutter libapp.so 大小</li><li><a href="https://www.sunmoonblog.com/2020/07/15/flutter-app-memory-test/">Flutter App 内存测试</a> - 在若干简单场景下测试 Flutter 应用内存，为内存优化提供指导</li></ul><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们知道，Android 应用占用的内存有一类是 <code>Code</code>。<code>dumpsys meminfo</code> 命令的输出中可以看到 Code 类别的内存：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949713220131.jpg" alt></p><p>关于 Code 内存，官网是这样解释的：</p><blockquote><p>Memory that your app uses for code and resources, such as dex bytecode, optimized or compiled dex code, .so libraries, and fonts <a href="https://developer.android.com/studio/profile/memory-profiler#how-counted" target="_blank" rel="noopener">来源</a></p></blockquote><p>简单计算一下，发现 Code 内存大致包括 <code>.so mmap</code> 和 <code>.apk mmap</code>。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949717854679.jpg" alt></p><p>我们可以观察 so 优化前后 <code>.so mmap</code> 的变化来判断优化是否有效果。</p><p>不过还有另外一个问题：Android 应用中通常有很多 so，所以没法通过 <code>.so mmap</code> 来判断单个 so 的优化效果。该怎么办？</p><h1 id="maps-文件"><a href="#maps-文件" class="headerlink" title="maps 文件"></a>maps 文件</h1><p>判断单个 so 的优化效果的方法是查看和分析进程对应的 <code>proc/&lt;pid&gt;/maps</code> 文件。</p><p><a href="https://stackoverflow.com/questions/1401359/understanding-linux-proc-id-maps" target="_blank" rel="noopener">Understanding-linux-proc-id-maps</a> 对 <code>maps</code> 文件有介绍。</p><blockquote><p>Each row in /proc/$PID/maps describes a region of contiguous virtual memory in a process or thread. Each row has the following fields:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">address           perms offset  dev   inode   pathname</span><br><span class="line">08048000-08056000 r-xp 00000000 03:0c 64593   /usr/sbin/gpm</span><br></pre></td></tr></table></figure><ul><li>address - 进程地址空间的起始地址</li><li>permissions - 访问权限</li><li>pathname - 如果该区域是从文件映射来的，pathname 为文件名</li></ul><p>注意，直接在 adb shell 用 cat 查看 maps 文件可能会遇到 permission denied 问题。可以 <code>run-as</code> 命令来避免该问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ ✗ adb shell</span><br><span class="line">HWANE:/ $ run-as</span><br><span class="line">run-as: usage: run-as &lt;package-name&gt; [--user &lt;uid&gt;] &lt;command&gt; [&lt;args&gt;]</span><br><span class="line">run-as com.example.flutter.image.flutter_image_demo  cat /proc/7331/maps \ </span><br><span class="line">  | grep libapp.so</span><br></pre></td></tr></table></figure><p>以下示例查看 <code>com.example.flutter.image.flutter_image_demo</code> 的 maps 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HWANE:/ $ run-as com.example.flutter.image.flutter_image_demo  cat /proc/7331/maps | grep libandroid</span><br><span class="line">7016edb000-7016ef6000 r-xp 00000000 fd:00 7502                           /system/lib64/libandroid.so</span><br><span class="line">7016ef7000-7016efb000 r--p 0001b000 fd:00 7502                           /system/lib64/libandroid.so</span><br></pre></td></tr></table></figure><p>方便起见，可以写个脚本来解析 maps 文件以快速统计每个 so 文件占用内存的总大小。源码见 <a href="https://gist.github.com/410063005/eb8d405d1605e9990620c9f4135762b2" target="_blank" rel="noopener">gist</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">data_list = []</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">    raw_data = input(<span class="string">'paste maps string here: '</span> <span class="keyword">if</span> len(data_list) == <span class="number">0</span> <span class="keyword">else</span> <span class="string">''</span>)</span><br><span class="line">    <span class="keyword">if</span> (raw_data.strip() == <span class="string">''</span>): </span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    data_list.append(raw_data)</span><br><span class="line"></span><br><span class="line">mem_map = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> data_list:</span><br><span class="line">    tmp = item.split(<span class="string">' '</span>)</span><br><span class="line">    addr = tmp[<span class="number">0</span>].split(<span class="string">'-'</span>)</span><br><span class="line">    <span class="keyword">if</span> len(addr) == <span class="number">2</span>:</span><br><span class="line">        mem = (int(addr[<span class="number">1</span>], <span class="number">16</span>) - int(addr[<span class="number">0</span>], <span class="number">16</span>)) / <span class="number">1024.0</span> / <span class="number">1024.0</span></span><br><span class="line"></span><br><span class="line">        key = tmp[<span class="number">-1</span>][<span class="number">-30</span>:]</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> mem_map:</span><br><span class="line">            mem_map[key].append(mem)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            li = []</span><br><span class="line">            li.append(mem)</span><br><span class="line">            mem_map[key] = li</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">for</span> (k, v) <span class="keyword">in</span> mem_map.items():</span><br><span class="line">    print(k, <span class="string">' '</span>, sum(v), <span class="string">'MB'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949755118549.jpg" alt="-w785"></p><h1 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h1><ul><li>测试目标：FlutterImageDemo、Flutter 项目优化前、Flutter 项目优化后</li><li>测试工具：<code>dumpsys meminfo</code> 和 <code>run-as</code></li><li>测试指标：<ul><li><code>libflutter.so</code> 和 <code>libapp.so</code> 文件大小</li><li><code>.so mmap</code></li><li>maps 文件中 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小</li></ul></li></ul><p>数据如下。</p><h2 id="FlutterImageDemo"><a href="#FlutterImageDemo" class="headerlink" title="FlutterImageDemo"></a>FlutterImageDemo</h2><p>FlutterImageDemo 是一个简单的 Flutter 应用。</p><ul><li>包名 <code>com.example.flutter.image.flutter_image_demo</code></li><li>进程号 7331</li><li>APK 包解压出来的 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小分别是 13.9MB 和 6.1MB</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949758838686.jpg" alt></p><p>不得不吐槽下 Mac 上文件大小的计算方式对开发人员实现不友好。我重新算了一下，准确的大小分别是 13.2MB 和 5.8MB。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949759493938.jpg" alt="-w778"></p><p><code>.so mmap</code> 数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys meminfo com.example.flutter.image.flutter_image_demo</span><br><span class="line"></span><br><span class="line">** MEMINFO in pid 7331 [com.example.flutter.image.flutter_image_demo] **</span><br><span class="line">                   Pss  Private  Private  SwapPss     Heap     Heap     Heap</span><br><span class="line">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free</span><br><span class="line">                ------   ------   ------   ------   ------   ------   ------</span><br><span class="line">     .so mmap    14010      584    12600       47</span><br></pre></td></tr></table></figure><p>maps 数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HWANE:/ $ run-as com.example.flutter.image.flutter_image_demo  cat /proc/7331/maps | grep libflutter.so</span><br><span class="line">6fffee6000-70005d9000 r--p 00000000 103:08 39455                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libflutter.so</span><br><span class="line">70005e6000-7000ae9000 r-xp 00700000 103:08 39455                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libflutter.so</span><br><span class="line">7000af6000-7000bd6000 rw-p 00c10000 103:08 39455                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libflutter.so</span><br><span class="line">7000bd6000-7000c25000 r--p 00cf0000 103:08 39455                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libflutter.so</span><br><span class="line">HWANE:/ $ run-as com.example.flutter.image.flutter_image_demo  cat /proc/7331/maps | grep libapp.so</span><br><span class="line">6fff5c3000-6fff5c5000 rw-p 00000000 103:08 45222                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libapp.so</span><br><span class="line">6fff5c5000-6fff85d000 r-xp 00002000 103:08 45222                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libapp.so</span><br><span class="line">6fff85d000-6fffb94000 r--p 0029a000 103:08 45222                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libapp.so</span><br><span class="line">6fffb94000-6fffb95000 rw-p 005d1000 103:08 45222                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libapp.so</span><br></pre></td></tr></table></figure><p>maps 解析后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/lib/arm64/libflutter.so   13.14453125 MB</span><br><span class="line">/lib/arm64/libapp.so   5.8203125 MB</span><br></pre></td></tr></table></figure><h2 id="Flutter-项目优化前"><a href="#Flutter-项目优化前" class="headerlink" title="Flutter 项目优化前"></a>Flutter 项目优化前</h2><p>从优化前的 APK 包解压出来的 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小分别是 5.9MB 和 9.6MB</p><p><code>.so mmap</code> 数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys meminfo com.t.t.i.host</span><br><span class="line">** MEMINFO in pid 15191 [com.t.t.i.host] **</span><br><span class="line">                   Pss  Private  Private  SwapPss     Heap     Heap     Heap</span><br><span class="line">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free</span><br><span class="line">                ------   ------   ------   ------   ------   ------   ------</span><br><span class="line">     .so mmap    16194      452    13896      127</span><br></pre></td></tr></table></figure><p>maps 数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HWANE:/ $ run-as com.t.t.i.host cat /proc/15191/maps  | grep libflutter.so</span><br><span class="line">c16c1000-c17ef000 r--p 00000000 103:08 132483                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libflutter.so</span><br><span class="line">c17ef000-c1baa000 r-xp 0012e000 103:08 132483                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libflutter.so</span><br><span class="line">c1baa000-c1c87000 rw-p 004e9000 103:08 132483                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libflutter.so</span><br><span class="line">c1c87000-c1caf000 r--p 005c6000 103:08 132483                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libflutter.so</span><br><span class="line">HWANE:/ $ run-as com.t.t.i.host cat /proc/15191/maps  | grep libapp.so</span><br><span class="line">c0a0f000-c0a11000 rw-p 00000000 103:08 129024                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libapp.so</span><br><span class="line">c0a11000-c0f55000 r-xp 00002000 103:08 129024                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libapp.so</span><br><span class="line">c0f55000-c13a6000 r--p 00546000 103:08 129024                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libapp.so</span><br><span class="line">c13a6000-c13a7000 rw-p 00997000 103:08 129024                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libapp.so</span><br></pre></td></tr></table></figure><p>maps 解析后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ccpa7w==/lib/arm/libflutter.so   5.9296875 MB</span><br><span class="line">FaZeCcpa7w==/lib/arm/libapp.so   9.59375 MB</span><br></pre></td></tr></table></figure><h2 id="Flutter-项目优化后"><a href="#Flutter-项目优化后" class="headerlink" title="Flutter 项目优化后"></a>Flutter 项目优化后</h2><p>从优化后的 APK 包解压出来的 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小分别是 5.9MB 和 8.6MB</p><p><code>.so mmap</code> 数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys meminfo com.t.t.i.host</span><br><span class="line"></span><br><span class="line">** MEMINFO in pid 14331 [com.t.t.i.host] **</span><br><span class="line">                   Pss  Private  Private  SwapPss     Heap     Heap     Heap</span><br><span class="line">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free</span><br><span class="line">                ------   ------   ------   ------   ------   ------   ------</span><br><span class="line">     .so mmap    16053      452    13572      117</span><br></pre></td></tr></table></figure><p>maps 数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127|HWANE:/ $ run-as com.t.t.i.host cat /proc/14331/maps | grep libflutter.so</span><br><span class="line">c154b000-c1679000 r--p 00000000 103:08 136617                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libflutter.so</span><br><span class="line">c1679000-c1a34000 r-xp 0012e000 103:08 136617                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libflutter.so</span><br><span class="line">c1a34000-c1b11000 rw-p 004e9000 103:08 136617                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libflutter.so</span><br><span class="line">c1b11000-c1b39000 r--p 005c6000 103:08 136617                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libflutter.so</span><br><span class="line">HWANE:/ $ run-as com.t.t.i.host cat /proc/14331/maps | grep libapp.so</span><br><span class="line">c0a8d000-c0a8f000 rw-p 00000000 103:08 131577                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libapp.so</span><br><span class="line">c0a8f000-c0fd2000 r-xp 00002000 103:08 131577                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libapp.so</span><br><span class="line">c0fd2000-c1328000 r--p 00545000 103:08 131577                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libapp.so</span><br><span class="line">c1328000-c1329000 rw-p 0089b000 103:08 131577                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libapp.so</span><br></pre></td></tr></table></figure><p>maps 解析后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V1HTdA==/lib/arm/libflutter.so   5.9296875 MB</span><br><span class="line">0xhjV1HTdA==/lib/arm/libapp.so   8.609375 MB</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>对比 <code>libflutter.so</code> 和 <code>libapp.so</code> 文件大小及 maps 的解析结果，发现数值几乎一致</li><li>对比 <code>.so mmap</code> 内存，看起来跟 so 文件大小相关性不明显 (<font color="red">??? 哪里出错了？</font>)</li></ul><table><thead><tr><th></th><th>libflutter.so文件</th><th>libapp.so文件</th><th><code>.so mmap</code></th><th>maps文件解析</th></tr></thead><tbody><tr><td>FlutterImageDemo</td><td>13.2MB</td><td>5.8MB</td><td>13.7MB</td><td>13.1MB和5.8MB</td></tr><tr><td>优化前</td><td>5.9MB</td><td>9.6MB</td><td>15.8MB</td><td>5.9MB和9.6MB</td></tr><tr><td>优化后</td><td>5.9MB</td><td>8.6MB</td><td>15.7MB</td><td>5.9MB和8.6MB</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;优化 so 大小能否减少 Android 应用的内存？从原理上讲是可以的，实际效果如何？一起来看看吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.sunmoonblog.com/tags/android/"/>
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>(译) Flutter State 生命周期</title>
    <link href="http://www.sunmoonblog.com/2020/07/21/flutter-state-lifecycle/"/>
    <id>http://www.sunmoonblog.com/2020/07/21/flutter-state-lifecycle/</id>
    <published>2020-07-21T09:48:26.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自 <a href="https://medium.com/flutter-community/flutter-lifecycle-for-android-and-ios-developers-8f532307e0c7" target="_blank" rel="noopener">Flutter Lifecycle for Android and iOS Developers | Medium</a>。类比 Android 和 iOS，了解 Flutter State 的生命周期。</p><a id="more"></a><!--One of the most confusing ideas transitioning from Android and/or iOS is to understand how Flutter handles its lifecycle.--><p>从 Android 或 iOS 转到 Flutter 开发，最让人疑惑的是 Flutter 如何处理生命周期。</p><p><strong>onCreate()</strong> 在哪里？<strong>viewDidLoad()</strong> 呢？我应该将业务逻辑放在哪里？为什么只有一个 <code>build</code> 方法？</p><p>本文将解答这些疑惑。</p><h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><p><strong>Activity</strong> 生命周期是 Android 开发必须记住的：</p><ul><li>onCreate</li><li>onStart</li><li>onResume</li></ul><hr><ul><li>onPause</li><li>onStop</li><li>onRestart</li><li>onDestroy</li></ul><p>大部分业务逻辑放在 <strong>onCreate</strong> 方法：初始化 view、数据库、监听器等等。<strong>onResume</strong> 和 <strong>onPause</strong> 是判断用户离开或进入当前页面的好时机。</p><h1 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h1><p>UIViewController 的生命周期如下：</p><ul><li>viewDidLoad</li><li>viewWillAppear</li><li>viewDidAppear</li></ul><hr><ul><li>viewWillDisappear</li><li>viewDidDisappear</li><li>viewDidUnload</li></ul><p>如你所见，两个平台均使用几乎一致的步骤来创建或销毁页面。大部分业务逻辑放在 <strong>viewDidLoad()</strong>，而 <strong>Will/Did Appear/Disappear</strong> 用于保存信息，判断用户何时离开页面等等。</p><h1 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h1><p>在 Flutter 中呢？Widget 也遵循类似规则吗？</p><p>Flutter 中主要有两种 Widget：<strong>StatelessWidget</strong> 和 <strong>StatefulWidget</strong>。本文重点放在 <strong>StatefulWidget</strong>，因为它有点像 <strong>Android</strong> 和 <strong>iOS</strong> 中的某些概念。</p><h2 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2><p>StatefulWidget 是最重要的 Widget，因为它持有 <strong>State</strong>，它知道何时发生变化并进行必要的重绘。它的生命周期如下：</p><ul><li>createState</li><li>initState</li><li>didChangeDependencies</li><li>build</li><li>(didUpdateWidget)</li></ul><p>— — — — — — — — — — —</p><ul><li>deactivate</li><li>dispose</li></ul><p>你可能会注意到创建阶段的 state 比销毁阶段的多，这是因为创建/重建 Widget 及其 State 更复杂。</p><h3 id="createState"><a href="#createState" class="headerlink" title="createState():"></a>createState():</h3><p>构建新的 StatefulWidget 时将调用 createState()，StatefulWidget 的子类必须覆盖这个方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyScreen</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyScreenState createState() =&gt; _MyScreenState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initState"><a href="#initState" class="headerlink" title="initState()"></a>initState()</h3><p>通常需要重写这个方法。它是 Widget 创建后调用的第一个方法，可以理解成 <strong>onCreate()</strong> 或 <strong>viewDidLoad()</strong> 的等价物。在这个方法中可以检查 Widget 某些相关属性：是否有被渲染？当前是否处理 mounted 状态？</p><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>每个 Widget 都有这个属性。当为 Widget.buildContext 赋值后 mounted 的值变成 <strong>true</strong>，Widget 在树中。直到 <strong>dispose</strong> 方法被调用前，mounted 一直为 true。</p><h3 id="addPostFrameCallback"><a href="#addPostFrameCallback" class="headerlink" title="addPostFrameCallback"></a>addPostFrameCallback</h3><p>可以在 <strong>initState</strong> 方法中按如下方式调用 <code>addPostFrameCallback</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/scheduler.dart'</span>;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">  <span class="keyword">super</span>.initState();</span><br><span class="line">  SchedulerBinding.instance.addPostFrameCallback((_) =&gt; &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法为一帧结束时添加回调，回调方法只会调用一次，通知 Widget 构建已完成。</p><h3 id="didChangeDependencies"><a href="#didChangeDependencies" class="headerlink" title="didChangeDependencies"></a>didChangeDependencies</h3><p>widget 构建时第一次调用 initState() 后立即会调用 didChangeDependencies()。如果 <strong>StatefulWidgets</strong> 依赖某个 <strong>InheritedWidget</strong>，后者发生变化时会导致 didChangeDependencies() 再次被调用。</p><h3 id="build"><a href="#build" class="headerlink" title="build()"></a>build()</h3><p>可以肯定地说这是最重要的方法。这个方法依赖整个待渲染的 Widget 树，在 <strong>didChangeDependencies()</strong> 立即被调用。所有的 GUI 渲染发生在这个方法，每次 UI 需要重新渲染时都会调用这个方法。(重新渲染是很廉价的操作)</p><h3 id="didUpdateWidget"><a href="#didUpdateWidget" class="headerlink" title="didUpdateWidget()"></a>didUpdateWidget()</h3><p>这是一个不太常见的生命周期方法。一旦 parent widget 有变化需要重绘 UI 时会调用 didUpdateWidget()。这个方法有一个 <strong>oldWidget</strong> 参数，可以将它跟当前 <strong>widget</strong> 进行比较以执行某些额外的业务逻辑。</p><h3 id="deactivate"><a href="#deactivate" class="headerlink" title="deactivate()"></a>deactivate()</h3><p>这个生命周期方法也不太常见。这个方法被调用时，意味着 Widget 开始进入”死亡”阶段。</p><p>当 framework 从树中移除 State 时会调用本方法。某些情况下，framework 会重新将 State 对象加入到树中。</p><h3 id="dispose"><a href="#dispose" class="headerlink" title="dispose()"></a>dispose()</h3><p>这个方法也非常重要。当 Widget 及其 State 从树中永久移除时会调用这个方法。此后 Widget 不会再被构建。</p><p>你需要在这个方法中做取消对 stream 的监听、销毁动画等操作。它是 <strong>initState</strong> 的反操作。</p><h1 id="WidgetsBindingObserver"><a href="#WidgetsBindingObserver" class="headerlink" title="WidgetsBindingObserver"></a>WidgetsBindingObserver</h1><p>如果我们想监听应用何时进入后台该怎么办？</p><p>可以这样做。对 <strong>StatefulWidget</strong> 做些小改动：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyScreen</span>&gt; <span class="title">with</span> <span class="title">WidgetsBindingObserver</span></span></span><br></pre></td></tr></table></figure><p>我们让 <code>_MyScreenState</code> 实现了抽象类 <strong>WidgetsBindingObserver</strong>，之后就可以观察应用的生命周期状态。在 <strong>initState</strong> 方法中开始观察：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WidgetsBinding.instance.addObserver(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>在 <strong>dispose</strong> 方法中停止观察：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WidgetsBinding.instance.removeObserver(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>接下来在 <strong>didChangeAppLifecycleState</strong> 接收生命周期的变化即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> didChangeAppLifecycleState(AppLifecycleState state) &#123;</span><br><span class="line">  <span class="keyword">super</span>.didChangeAppLifecycleState(state);</span><br><span class="line">  <span class="keyword">if</span> (state == AppLifecycleState.paused) &#123;</span><br><span class="line">    <span class="comment">// went to Background</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (state == AppLifecycleState.resumed) &#123;</span><br><span class="line">    <span class="comment">// came back to Foreground</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个技巧很有用。如果你想在应用进入后台时弹出 notification，或者保存数据，又或者在用户点 back 回退时弹出 popup，都可以使用这个技巧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自 &lt;a href=&quot;https://medium.com/flutter-community/flutter-lifecycle-for-android-and-ios-developers-8f532307e0c7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flutter Lifecycle for Android and iOS Developers | Medium&lt;/a&gt;。类比 Android 和 iOS，了解 Flutter State 的生命周期。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
      <category term="翻译" scheme="http://www.sunmoonblog.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Flutter split-debug-info 用法介绍</title>
    <link href="http://www.sunmoonblog.com/2020/07/16/flutter-split-debug-info/"/>
    <id>http://www.sunmoonblog.com/2020/07/16/flutter-split-debug-info/</id>
    <published>2020-07-16T09:34:18.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>介绍如何使用 Flutter 1.7 提供的 <code>split-debug-info</code> 编译选项来减小包大小。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>先介绍下什么是 <a href="https://en.wikipedia.org/wiki/Obfuscation_(software" target="_blank" rel="noopener">Code obfuscation</a>)。Code obfuscation 翻译过来就是代码混淆。代码混淆是修改应用二进制文件以增加理解难度的过程。混淆会隐藏编译后的 Dart 代码中的函数名和类名，让攻击者难以对应用进行逆向工程。</p><p>目前 Flutter (v1.7.14) stable 分支仅在 <a href="https://flutter.dev/docs/testing/build-modes" target="_blank" rel="noopener">release build</a> 中支持代码混淆。<a href="https://github.com/flutter/flutter/pull/49650" target="_blank" rel="noopener">Pull Request #49650 · flutter/flutter</a> 添加了这个功能。</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>同时使用 <code>--obfuscate</code> 和 <code>--split-debug-info</code> 标志来在 release 版本的应用中开启混淆。<code>--split-debug-info</code> 用于指定一个目录来存放 debug 文件，即 symbol map。目前 Flutter (v1.7.14) stable 分支支持 <code>apk</code>、<code>appbundle</code>、<code>ios</code> 和 <code>ios-framework</code>，master 和 dev 分支上还支持 <code>macos</code> 和 <code>aar</code>。</p><p>示例：编译并混淆一个 APK，在 <code>tmp</code> 目录下保存 symbol map。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter build apk --release --target-platform android-arm64 \</span><br><span class="line"> --obfuscate \</span><br><span class="line"> --split-debug-info=tmp/</span><br></pre></td></tr></table></figure><p>对于 Android 项目，也可以通过在 <code>&lt;project&gt;/app/gradle.properties</code> 中添加如下配置来<a href="https://github.com/flutter/flutter/wiki/Obfuscating-Dart-Code" target="_blank" rel="noopener">开启代码混淆</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extra-gen-snapshot-options=--obfuscate</span><br></pre></td></tr></table></figure><p>编译完成后 <code>tmp</code> 目录将生成一个后缀名为 <code>.symbols</code> 的文件。</p><p>注意：也可以单独使用 <code>--split-debug-info</code>。实际上这个参数是用来减小代码大小的 (即 <code>libapp.so</code> 的大小)</p><p>分别使用如下命令编译 APK。第一条命令生成优化前的 APK，第二条命令生成优化后的 APK。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter build apk --release --target-platform android-arm64</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter build apk --release --target-platform android-arm64 \</span><br><span class="line"> --obfuscate \</span><br><span class="line"> --split-debug-info=tmp/</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/16/15948669243081.jpg" alt></p><p>使用 <code>--split-debug-info</code> 优化后，APK 大小较之前减少 435KB。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/16/15948672793669.jpg" alt="-w727"></p><ul><li>优化前未压缩状态下 <code>libapp.so</code> 大小是 9.7MB</li><li>优化后未压缩状态下 <code>libapp.so</code> 大小是 8.6MB</li></ul><p>真正的减少来自 <code>libapp.so</code>，约 1.1MB。正如文档所言，<code>--split-debug-info</code> 可以减少代码大小。不过考虑到 APK 是压缩包，所以 <code>libapp.so</code> 的减小反映在 APK 包大小变化上并不明显。</p><h1 id="优化效果"><a href="#优化效果" class="headerlink" title="优化效果"></a>优化效果</h1><p>我们项目以 AAR 产物方式集成 Flutter。我从我们最新发布的 APK 中解压出 <code>libapp.so</code>，不作称为 <code>libapp-当前发布包.so</code>。</p><p><code>flutter build aot --release --target-platform android-arm</code> 编译结果为 <code>libapp-优化前.so</code></p><p><code>flutter build aot --release --target-platform android-arm</code> 加上 <code>--obfuscate</code> 和 <code>--split-debug-info</code> 的编译结果为 <code>libapp-优化后.so</code>。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/16/15948868220974.jpg" alt></p><p>可以看到前两个 so 文件大小接近，后一个 so 文件小了将近 0.9MB。(注意：这里的 so 是32位，不同于上一节中的64位，所以文件大小变化不同)。这里的 0.9MB(减小约11%) 并不太起眼，不过考虑到最小的 <code>libapp.so</code> 也有将近 3.7MB，所以其实还是很可观的。</p><table><thead><tr><th>文件</th><th>大小</th><th>备注</th></tr></thead><tbody><tr><td>最小的 <code>libapp.so</code></td><td>3.7MB</td><td>从 <code>flutter create</code> 创建的工程编译而来</td></tr><tr><td><code>libapp-当前发布包.so</code></td><td>8.3MB</td><td>从最新发布的APK解压而来</td></tr><tr><td><code>libapp-优化后.so</code></td><td>7.4MB</td><td>使用 <code>split-debug-info</code> 编译编译</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>官方 <a href="https://flutter.dev/docs/perf/app-size#reducing-app-size" target="_blank" rel="noopener">Measuring your app’s size - Flutter</a> 中提供了几种减小 Flutter 包大小的方法，可以作为参考</p><ul><li>Remove unused resources</li><li>Minimize resource imported from libraries</li><li>Support a limited number of screen densities</li><li>Compress PNG and JPEG files</li></ul><p>其他资料：</p><ul><li><a href="https://github.com/flutter/flutter/wiki/Obfuscating-Dart-Code" target="_blank" rel="noopener">Obfuscating-Dart-Code</a></li><li><a href="https://flutter.dev/docs/deployment/obfuscate" target="_blank" rel="noopener">Obfuscating Dart code - Flutter</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍如何使用 Flutter 1.7 提供的 &lt;code&gt;split-debug-info&lt;/code&gt; 编译选项来减小包大小。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flutter Overlay 用法简介</title>
    <link href="http://www.sunmoonblog.com/2020/07/15/flutter-overlay-usage/"/>
    <id>http://www.sunmoonblog.com/2020/07/15/flutter-overlay-usage/</id>
    <published>2020-07-15T10:20:29.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter Overlay 用法简介。</p><a id="more"></a><h1 id="Overlay-基本用法"><a href="#Overlay-基本用法" class="headerlink" title="Overlay 基本用法"></a>Overlay 基本用法</h1><p><code>Overlay</code> 实际上是一个 <code>Stack</code>，所以 <code>OverlayEntry</code> 的内容可以是 <code>Positioned</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> overlayEntry = OverlayEntry(builder: (context) =&gt; Positioned(...););</span><br><span class="line">Overlay.of(context).insert(overlayEntry);</span><br></pre></td></tr></table></figure><ul><li>显示 Overlay - 使用 <code>Overlay.of(context).insert()</code> 方法</li><li>隐藏 Overlay - 使用 <code>overlayEntry.remove()</code> 方法</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/overlaybasic.gif" alt="overlay-basic"></p><h1 id="Overlay-高级用法"><a href="#Overlay-高级用法" class="headerlink" title="Overlay 高级用法"></a>Overlay 高级用法</h1><h2 id="指定位置"><a href="#指定位置" class="headerlink" title="指定位置"></a>指定位置</h2><p>有时我们想指定 Overlay 的显示位置，实现方式如下：</p><ul><li>先使用 <code>BuildContext.findRenderObject()</code> 来找到当前 Widget 对应的 RenderObject</li><li>再使用 <code>RenderBox.localToGlobal()</code> 找到 Widget 在屏幕上的位置</li></ul><p>具体见 <code>_calcPos()</code> 方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyButton</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> PosCallback callback;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> _MyButton(&#123;Key key, <span class="keyword">this</span>.callback&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  __MyButtonState createState() =&gt; __MyButtonState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">__MyButtonState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">_MyButton</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; _calcPos() &#123;</span><br><span class="line">    RenderBox renderBox = context.findRenderObject();</span><br><span class="line">    <span class="keyword">var</span> size = renderBox.size;</span><br><span class="line">    <span class="keyword">var</span> offset = renderBox.localToGlobal(Offset.zero);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [offset.dx, offset.dy + size.height];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RaisedButton(</span><br><span class="line">      onPressed: () &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; list = _calcPos();</span><br><span class="line">        widget.callback(list[<span class="number">0</span>], list[<span class="number">1</span>]);</span><br><span class="line">      &#125;,</span><br><span class="line">      child: Text(<span class="string">'show overlay'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/overlaypos.gif" alt="overlay-pos"></p><h2 id="跟随滚动"><a href="#跟随滚动" class="headerlink" title="跟随滚动"></a>跟随滚动</h2><p>使用 <a href="https://api.flutter.dev/flutter/rendering/LayerLink-class.html" target="_blank" rel="noopener">LayerLink</a> 来让 Overlay 跟随指定的 Widget 来滚动。</p><ul><li>LayerLink 用于联系 <a href="https://api.flutter.dev/flutter/rendering/LeaderLayer-class.html" target="_blank" rel="noopener">LeaderLayer</a> 和 <a href="https://api.flutter.dev/flutter/rendering/FollowerLayer-class.html" target="_blank" rel="noopener">FollowerLayer</a></li><li>使用 <a href="https://api.flutter.dev/flutter/widgets/CompositedTransformTarget-class.html" target="_blank" rel="noopener">CompositedTransformTarget</a> 来创建 LeaderLayer</li><li>使用 <a href="https://api.flutter.dev/flutter/widgets/CompositedTransformFollower-class.html" target="_blank" rel="noopener">CompositedTransformFollower</a> 来创建 FollowLayer</li></ul><p>代码篇幅较长，这里就不贴上来了。完整代码见 <a href="https://gist.github.com/410063005/4034c395f3305feeb262482a96d4278e" target="_blank" rel="noopener">gist</a>。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/overlayscroll.gif" alt="overlay-scroll"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://medium.com/saugo360/https-medium-com-saugo360-flutter-using-overlay-to-display-floating-widgets-2e6d0e8decb9" target="_blank" rel="noopener">Flutter: Using Overlay to display floating widgets | by AbdulRahman AlHamali | SAUGO 360 | Medium</a></li><li><a href="https://api.flutter.dev/flutter/rendering/LayerLink-class.html" target="_blank" rel="noopener">LayerLink class - rendering library - Dart API</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter Overlay 用法简介。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter App 内存测试</title>
    <link href="http://www.sunmoonblog.com/2020/07/15/flutter-app-memory-test/"/>
    <id>http://www.sunmoonblog.com/2020/07/15/flutter-app-memory-test/</id>
    <published>2020-07-15T06:12:49.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter 应用内存测试数据。</p><a id="more"></a><h1 id="内存测试一-简单-UI"><a href="#内存测试一-简单-UI" class="headerlink" title="内存测试一 - 简单 UI"></a>内存测试一 - 简单 UI</h1><p>分别<strong>使用 Android 和 Flutter 实现最简单的界面</strong>。</p><ul><li>显示一个文本</li><li>显示一个图片</li></ul><p>使用 TextView 显示 “Hello World!” 的 Android Demo，布局如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Hello World!"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 Text Widget 显示 “Hello World!” 的 Flutter Demo，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Center(child: Text(<span class="string">'Hello World!'</span>)),</span><br></pre></td></tr></table></figure><p>显示图片的 Demo 非常类似，这里略过。</p><p>测试数据显示：<strong>Flutter 应用比原生应用占用更多内存，多出来的部分主要包括 Other、Code、Native、Graphics</strong>。(注意：Android Studio 中无法正常显示 Other 部分变化，<code>adb shell dumpsys meminfo</code> 及 Flutter DevTools 中可正常观察到)</p><p>以下是具体测试数据。</p><h2 id="数据一"><a href="#数据一" class="headerlink" title="数据一"></a>数据一</h2><p>机型及配置：华为 Nova 2，Android 8.0，分辨率480dp(3x)。</p><p>Android Text Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944369530168.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944406815956.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944408053563.jpg" alt></p><p>Android Image Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944370128933.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944407225565.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944408363481.jpg" alt></p><p>Flutter Text Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944384753825.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944408943099.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944440141932.jpg" alt></p><p>Flutter Image Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944385231943.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944409251967.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944440514423.jpg" alt></p><h2 id="数据二"><a href="#数据二" class="headerlink" title="数据二"></a>数据二</h2><p>机型及配置：小米 8，分辨率440dp(2.8x)</p><p>Android Text Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944403017361.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944441459158.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944443093212.jpg" alt></p><p>Android Image Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944404063442.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944441807084.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944443368308.jpg" alt></p><p>Flutter Text Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944399044259.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944442195175.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944443788400.jpg" alt></p><p>Flutter Image Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944399984819.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944442627978.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944444195039.jpg" alt></p><h1 id="内存测试二-分配大对象"><a href="#内存测试二-分配大对象" class="headerlink" title="内存测试二 - 分配大对象"></a>内存测试二 - 分配大对象</h1><p>持续在 Dart 代码中分配对象。观察内存变化。</p><p>测试数据显示：<strong>从 Android 角度看，Dart Heap 中分配的对象归类为 “Private Other” 内存</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Uint8List&gt; _memList = <span class="built_in">List</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _addToMemList() &#123;</span><br><span class="line">    <span class="comment">// 点击一次, 分配 10MB 内存</span></span><br><span class="line">    _memList.add(_createData(<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15945451536123.jpg" alt="-w1428"></p><p>随着分配的 Dart 对象，Dart 内存和 Android 内存都在增加</p><ul><li>左图是 Dart 内存<ul><li>Dart Heap Capacity (绿线区域)一直在增长</li><li><font color="red">Dart Heap Used (浅蓝色区域)一直在增长</font></li><li>Dart External (蓝色区域)几乎不变</li></ul></li><li>右图是 Android 内存<ul><li>Total (绿线)一直在增长</li><li><font color="red">Other (紫线)一直在增长</font></li><li>其他几乎不变</li></ul></li></ul><h1 id="内存测试三-显示图片"><a href="#内存测试三-显示图片" class="headerlink" title="内存测试三 - 显示图片"></a>内存测试三 - 显示图片</h1><p>持续在 Dart 代码中<strong>加载并显示</strong>本地图片(1024x1024)。观察内存变化。</p><p>测试数据显示：<strong>Flutter 应用中图片在 Graphics 内存中分配</strong></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947280277523.jpg" alt="-w1666"></p><p>随着加载和显示的图片增多，Dart 内存和 Android 内存都在增加</p><ul><li>左图是 Dart 内存<ul><li>Dart Heap Capacity (绿线区域)一直在增长</li><li>Dart Heap Used (浅蓝色区域)几乎不变</li><li><font color="red">Dart External (蓝色区域)一直在增长</font></li></ul></li><li>右图是 Android 内存<ul><li>Total (绿线)一直在增长</li><li><font color="red">Graphics (橙色区域)波浪形增长</font></li><li>其他几乎不变</li></ul></li></ul><h1 id="内存测试四-预加载图片"><a href="#内存测试四-预加载图片" class="headerlink" title="内存测试四 - 预加载图片"></a>内存测试四 - 预加载图片</h1><p>持续在 Dart 代码中<strong>预加载但不显示</strong>本地图片(1024x1024)。观察内存变化。</p><p>测试数据显示：<strong>Flutter 应用中图片在 Graphics 内存中分配</strong></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947294740934.jpg" alt="-w1294"></p><p>随着预加载的图片增多，Dart 内存和 Android 内存都在增加</p><ul><li>左图是 Dart 内存<ul><li>Dart Heap Capacity (绿线区域)一直在增长</li><li>Dart Heap Used (浅蓝色区域)几乎不变</li><li><font color="red">Dart External (蓝色区域)一直在增长</font></li></ul></li><li>右图是 Android 内存<ul><li>Total (绿线)一直在增长</li><li><font color="red">Graphics (橙色区域)波浪形增长</font></li><li>其他几乎不变</li></ul></li></ul><h1 id="内存测试五-启动多个-Flutter-引擎"><a href="#内存测试五-启动多个-Flutter-引擎" class="headerlink" title="内存测试五 - 启动多个 Flutter 引擎"></a>内存测试五 - 启动多个 Flutter 引擎</h1><p>持续启动 Flutter 引擎，每次增加一个。观察内存变化。</p><p>测试数据显示：<strong>每开启一个 Flutter 引擎，Native 内存大约有5-6MB增长，Private Other 有10MB左右增长</strong></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947866240369.jpg" alt="-w1302"></p><p>随着 Flutter 引擎数量增多，Dart 内存和 Android 内存都在增加</p><ul><li>左图是 Dart 内存<ul><li><font color="red">Dart Heap Used (浅蓝色区域)几乎不变</font></li><li>Dart External (蓝色区域)一直在增长</li></ul></li><li>右图是 Android 内存<ul><li>Total (绿线)一直在增长</li><li><font color="red">Other (紫色区域)一直在快速增长</font></li><li><font color="red">Native (蓝色区域)一直在较快增长</font></li><li>Graphics (橙色区域)无增长</li></ul></li></ul><p>在 Android Studio 中测试结果如下：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947848408890.jpg" alt></p><p>随着 Flutter 引擎数量增多，</p><ul><li>Private Other 一直在增长 (注：注意：Android Studio 中无法正常显示 Other 部分变化，<code>adb shell dumpsys meminfo</code> 及 Flutter DevTools 中可正常观察到)</li><li>Native 内存(蓝色区域)一直在增长</li></ul><h1 id="测试结论"><a href="#测试结论" class="headerlink" title="测试结论"></a>测试结论</h1><ul><li>Flutter 应用比原生应用占用更多内存，多出来的部分主要包括 Other、Code、Native、Graphics <a href="https://developer.android.com/studio/profile/memory-profiler#how-counted" target="_blank" rel="noopener">内存分类</a> <a href="https://developer.android.com/studio/command-line/dumpsys#meminfo" target="_blank" rel="noopener">meminfo</a></li><li>从 Android 角度看，Dart Heap 属性 “Private Other” 内存。Dart 中创建对象会导致 Private Other 内存增长</li><li>Flutter 应用中图片在 Graphics 内存中分配 <a href="https://www.yuque.com/xytech/flutter/avmyht" target="_blank" rel="noopener">闲鱼技术 Android Flutter实践内存初探</a></li><li>每开启一个 Flutter 引擎，Native 内存大约有5-6MB增长，Private Other 有10MB左右增长</li></ul><p>为什么 Flutter 应用会比原生应用占用更多内存？官网给出的一些数据也许能解释部分原因。以下翻译自 <a href="https://flutter.dev/docs/development/add-to-app/performance#memory-and-latency" target="_blank" rel="noopener">Load sequence, performance, and memory - Flutter</a></p><blockquote><p>展示 Flutter UI 会有一定不可忽视的延迟。可以提前启动 Flutter 引擎来减少这个延迟。</p><p>集成 Flutter 到已有应用时要评估预加载 Flutter 引擎(即，加载 Flutter 库、启动 Dart VM、运行 isolate 入口程序)带来的内存开销及延迟。</p><p>在 2015 年的一款低端手机上，Flutter v1.10.3 release-AOT 模式下预热 <code>FlutterEngine</code> 开销如下：</p><ul><li><strong>Android</strong> 42 MB 和 1530 ms。其中有 330 ms 会阻塞主线程</li><li><strong>iOS</strong>  22 MB 和 860 ms。其中有 260 ms 会阻塞主线程</li></ul><p>内存方面，一个测试样本数据如下(根据使用场景会有所变化)</p><ul><li>~4 MB OS’s memory usage for creating pthreads.</li><li>~10 MB GPU driver memory.</li><li>~1 MB for Dart runtime-managed memory.</li><li>~5 MB for Dart-loaded font maps.</li></ul><p>延迟方面，一个测试样本数据如下(根据使用场景会有所变化)</p><ul><li>~20 ms to collect the Flutter assets from the application package.</li><li>~15 ms to dlopen the Flutter engine library.</li><li>~200 ms to create the Dart VM and load the AOT snapshot.</li><li>~200 ms to load Flutter-dependent fonts and assets.</li><li>~400 ms to run the entrypoint, create the first widget tree, and compile the needed GPU shader programs.</li></ul><p>预热 Flutter 引擎的时机应该足够晚，以减小内存占用；同时还要足够早，以避免 Flutter 引擎启动时间跟首帧延迟叠加在一起(否则会感觉启动慢，体验非常糟糕)</p><p>具体预热时机要根据应用的实际结构来决定。通常经验是在将显示 Flutter 页面的前一个页面中预热</p><p>假设引擎已经预热，关联 UI 时的首帧开销如下：</p><ul><li><strong>Android</strong> 320 ms 以及额外的 12 MB (跟屏幕的物理像素尺寸非常相关，physical pixel size)</li><li><strong>iOS</strong> 200 ms 以及额外的 16 MB (跟屏幕的物理像素尺寸非常相关，physical pixel size)</li></ul><p>内存方面，开销主要来自用于渲染的 graphical memory buffer (跟屏幕尺寸相关)</p><p>延迟方面，开销主要是等原生系统回调(提供 surface)以及编译 shader 程序(原文: compiling the remaining shader programs that are not pre-emptively predictable)的时间。这里的延迟仅在第一帧</p><p>Flutter UI 释放后，相关内存也会释放。这里的内存释放跟 <code>FlutterEngine</code> 中的 Flutter State 无关，除非 <code>FlutterEngine</code> 也释放了</p></blockquote><h1 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h1><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947301347638.jpg" alt></p><p>Flutter 应用内存可优化的点分别是：</p><ul><li>Private Others，Dart 代码分配的对象属于这一类。优化点是减少 Dart 代码中不必要的对象分配，尤其是大对象</li><li>Code - 用于处理代码和资源，如 dex 字节码，so 库和字体。优化点是减少 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小</li><li>Graphics - 图形缓冲区队列向屏幕显示像素（包括 GL 表面、GL 纹理等等）所使用的内存。比较好入手的一个优化是减少 Dart 代码中图片占用的内存。另外可以考虑优化 Flutter UI 这一块(同样使用 skia，为什么 Android 原生 UI 占用的内存比 Flutter UI 少？)</li><li>Native - C 或 C++ 代码分配的对象的内存。优化点是减少 Flutter 引擎占用的内存，比如单引擎比多引擎使用更少的内存</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947874114688.jpg" alt="-w1261"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter 应用内存测试数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>(译) Flutter 原理</title>
    <link href="http://www.sunmoonblog.com/2020/07/11/how-flutter-works/"/>
    <id>http://www.sunmoonblog.com/2020/07/11/how-flutter-works/</id>
    <published>2020-07-11T06:29:22.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter 是如何工作的？<br><a id="more"></a></p><p>要点如下：</p><ul><li>Flutter 框架更像一个游戏引擎，而不是传统的应用框架</li><li>Flutter 应用由 Widget 构成，Widget 被渲染到 Skia canvas，最后发送到平台</li><li>Flutter 引擎在对应的平台 shell 中运行</li><li>Flutter UI 发生变化时会被构建和渲染到 Skia Canvas</li><li>Flutter 以 60fps 来更新 UI，并且使用 GPU 完成大部分工作</li></ul><p>原文翻译如下。</p><p>跟其他框架相比，Flutter 以一种全新的方式构建，它更像一个游戏引擎而不是传统应用框架。我想讲讲在大层面上 Flutter 是如何工作的，以及它如何实现高性能。从大的层面来讲，<strong>应用由 Widget 构成，Widget 被渲染到 Skia canvas，最后发送到平台。平台显示 canvas，并且按要求返回事件</strong>。</p><p><img src="/images/15944494180838.jpg" alt></p><p>应用在平台上以 AOT 直接运行 (Your app runs on the platform in natively, Ahead of Time complied.)</p><h1 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h1><p>Flutter 在平台上提供 <code>Shell</code>，用作 Dart VM 和宿主。Shell 是平台相关的，提供对平台原生 API 的访问支持并且建立平台相关的 canvas。</p><p><img src="/images/15944503631949.jpg" alt></p><p>Shell 还用于和 IMEs 和系统应用生命周期事件通信。</p><h1 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h1><p>引擎是平台之上的层，提供 Dart 运行时、Skia、Platform Channel 及其他内容。Flutter Wiki 中的<a href="https://github.com/flutter/engine/wiki#architecture-diagram" target="_blank" rel="noopener">架构图</a>中有更多细节。</p><p><img src="/images/15944505039484.jpg" alt></p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>Flutter 引擎跟应用开发者最相关。它包含你开发应用时需要交互的所有内容。</p><p><img src="/images/15944513053707.jpg" alt></p><p>Flutter 只需简单使用对应的风格就能保持跟 iOS 或 Android 原生一致风格。iOS 使用 Cupertino 风格，Android 使用 Material 风格。</p><p>Flutter 不使用原生组件，而是 Widget。Widget 是 Flutter 应用的组件。Flutter 将 UI 绘制到 Skia Canvas。</p><p>一旦 UI 完成渲染，就进入引擎环境。</p><h1 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h1><p>Flutter 更像游戏引擎，而不是应用框架。Flutter UI 发生变化时会被构建和渲染到 Skia Canvas。Flutter 以 60fps 来更新 UI，并且使用 GPU 完成大部分工作。(所以 Flutter UI 这么流畅)</p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>这里只是大体上讲了一下 Flutter 是如何工作的，实际上 Flutter 底层有许多细节。可以参考这些资料</p><p>代码库：</p><ul><li><a href="https://github.com/flutter/flutter" target="_blank" rel="noopener">Flutter Framework</a></li><li><a href="https://github.com/flutter/engine" target="_blank" rel="noopener">Flutter Engine</a></li></ul><p>技术文档：</p><ul><li><a href="https://docs.google.com/presentation/d/1cw7A4HbvM_Abv320rVgPVGiUP2msVs7tfGbkgdrTy0I/edit#slide=id.p" target="_blank" rel="noopener">Flutter System Architecture Diagrams</a></li><li><a href="https://flutter.io/technical-overview/" target="_blank" rel="noopener">Technical Overview</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter 是如何工作的？&lt;br&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
      <category term="翻译" scheme="http://www.sunmoonblog.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Dart VM Service 简介</title>
    <link href="http://www.sunmoonblog.com/2020/07/07/dart-vm-service/"/>
    <id>http://www.sunmoonblog.com/2020/07/07/dart-vm-service/</id>
    <published>2020-07-07T07:28:13.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter 开发工具 DevTools 是不是有些神奇？移动端开发中用到的性能工具通常是原生应用，而 DevTools 却是基于浏览器的。为什么要基于浏览器开发，Dart VM Service Protocol 又是什么？简单了解一下。</p><a id="more"></a><p>Dart DevTools 提供 hot reload、UI 调试和内存分析等各种功能。</p><p><img src="/images/15941055868454.jpg" alt></p><h1 id="Dart-VM-Service-Protocol"><a href="#Dart-VM-Service-Protocol" class="headerlink" title="Dart VM Service Protocol"></a>Dart VM Service Protocol</h1><p>先来看看 Dart VM Service Protocol 是什么。</p><p><a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#rpcs-requests-and-responses" target="_blank" rel="noopener">Dart VM Service Protocol 3.36</a> 介绍如下：</p><blockquote><p>Service Protocol 协议用于跟运行中的 Dart VM 通信</p><p>使用 <code>--observe</code> 启动 Dart VM 后就能使用 Service Protocol。VM 会启动一个 webserver 并通过 WebSocket 为 protocol request 提供服务。也可发送 HTTP (非WebSocket)请求，但这种情况下无法访问 VM <em>event</em></p><p>Service Protocol 使用 <a href="http://www.jsonrpc.org/specification" target="_blank" rel="noopener">JSON-RPC 2.0</a> 来通信</p></blockquote><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>通过 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#getversion" target="_blank" rel="noopener">getVersion</a> 这个例子来看看 RPC 请求和响应。</p><p>RPC request 是一个发送到 server 的 JSON 对象。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>, <span class="comment">// jsonprc 属性可选</span></span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"getVersion"</span>, <span class="comment">//</span></span><br><span class="line">  <span class="attr">"params"</span>: &#123;&#125;, <span class="comment">// params 属性在 Dart 代码中以 named parameters 形式提供</span></span><br><span class="line">  <span class="attr">"id"</span>: <span class="string">"1"</span> <span class="comment">// id 属性可以是 string, number, null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RPC response 也是一个 JSON 对象。</p><p>这是一个成功的 RPC response：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"result"</span>: &#123; <span class="comment">// 请求成功时返回 result 属性</span></span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"Version"</span>, <span class="comment">// type 参数可用于判断准确的返回类型，它是 Response 类的子类</span></span><br><span class="line">    <span class="attr">"major"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"minor"</span>: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">"id"</span>: <span class="string">"1"</span> <span class="comment">// id 属性跟对应请求中的 id 匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个失败的 RPC response：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"error"</span>: &#123; <span class="comment">// 请求失败时返回 error 属性，它包括 code, message 和 data</span></span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">103</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"Stream already subscribed"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">      <span class="attr">"details"</span>: <span class="string">"The stream 'GC' is already subscribed"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">"id"</span>: <span class="string">"2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="error codes">JSON-RPC 规范</a>的基础上，Service Protocol 定义了一些额外的错误码。具体错误见 Service Protocol 文档，这里不展开。</p><h2 id="Event-和-Binary-Event"><a href="#Event-和-Binary-Event" class="headerlink" title="Event 和 Binary Event"></a>Event 和 Binary Event</h2><ul><li>通过使用 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#streamlisten" target="_blank" rel="noopener">streamListen</a> 和 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#streamcancel" target="_blank" rel="noopener">streamCancel</a> RPC，客户端可以收到 VM 中特定 stream 上的事件通通知</li><li>每个 stream 跟一个 <em>stream id</em> 关联</li><li>每个 stream 跟某种类型的事件关联。比如 <em>Isolate</em> stream 提供 isolate 相关的创建和销毁等事件</li><li>客户端通过 WebSocket 异步接收 stream event</li><li>某些事件跟二进制数据关联，通过 WebSocket binary frame 而不是 text frame 发送这些事件</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"json-rpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"streamNotify"</span>,</span><br><span class="line">  <span class="attr">"params"</span>: &#123; <span class="comment">// 参数中包括 streamId 和 event 属性</span></span><br><span class="line">    <span class="attr">"streamId"</span>: <span class="string">"Isolate"</span>,</span><br><span class="line">    <span class="attr">"event"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Event"</span>,</span><br><span class="line">      <span class="attr">"kind"</span>: <span class="string">"IsolateExit"</span>,</span><br><span class="line">      <span class="attr">"isolate"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"@Isolate"</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"isolates/33"</span>,</span><br><span class="line">        <span class="attr">"number"</span>: <span class="string">"51048743613"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"worker-isolate"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>Service Protocol 中的每个响应或事件均有 <code>type</code> 属性，它是 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#response" target="_blank" rel="noopener">Response</a> 子类。客户端可以通过 <code>type</code> 属性判断每种响应或事件的准确类型。</p><ul><li>以 <code>@</code> 开头的 type 表示当前响应是一个 <code>reference</code></li><li>不以 <code>@</code> 开头的 type 表示当前响应是一个 <code>object</code></li></ul><p><code>reference</code> 可提供的信息是 <code>object</code> 的子集</p><h1 id="Dart-VM-Service-Protocol-Extension"><a href="#Dart-VM-Service-Protocol-Extension" class="headerlink" title="Dart VM Service Protocol Extension"></a>Dart VM Service Protocol Extension</h1><p><a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service_extension.md" target="_blank" rel="noopener">Dart VM Service Protocol Extension</a> 与 VM 通信的方式跟 Service Protocol 类似跟类似，但它们并不是核心 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md" target="_blank" rel="noopener">Dart VM Service Protocol</a> 的一部分，仅允许通过某些核心库访问。</p><p>通过添加前缀名来调用对应的 RPC 接口，类似 “ext.dart.libraryName”。比如，调用 <code>ext.dart.io.getSocketProfile</code> 来执行 dart:io 暴露的 <code>getSocketProfile</code> RPC 接口。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单了解 Dart VM Service Protocol 和 Dart VM Service Protocol Extension 后，我们有以下认识：</p><ul><li>Service Protocol 和 Service Protocol Extension 是一套 RPC-JSON 协议</li><li>Service Protocol 兼容性好，可以很容易地集成到现有 IDE</li><li>VM 会启动一个 webserver 并通过 WebSocket 为客户端提供服务</li></ul><p>为什么要基于浏览器来开发 DevTools？有以下几个原因</p><ul><li>浏览器天生支持 WebSocket，所以基于浏览器开发 DevTools 是水到渠成</li><li>基于浏览器开发 DevTools，可兼容多平台</li><li>当前的 DevTools 是使用 Flutter 框架开发的 (没错，Flutter。以前是纯 Dart 开发)，部署成 Web 应用很方便</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#rpcs-requests-and-responses" target="_blank" rel="noopener">sdk/service.md at master · dart-lang/sdk</a></li><li><a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service_extension.md" target="_blank" rel="noopener">sdk/service_extension.md at master · dart-lang/sdk</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652058622&amp;idx=1&amp;sn=3551e237325a72a99ac71ec8c8747a43&amp;chksm=808c93bbb7fb1aad62acae899e59e36596d719c1194a912b26cccf565641c5a2683e675b691e&amp;mpshare=1&amp;scene=1&amp;srcid=0707V7mgrCqByikjM5WbdfpD&amp;sharer_sharetime=1594105478505&amp;sharer_shareid=b5535657e3516bd6d7252ce5f5ed09f4#rd" target="_blank" rel="noopener">​我们用 Flutter 写了一套全新的 Flutter 开发者工具</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter 开发工具 DevTools 是不是有些神奇？移动端开发中用到的性能工具通常是原生应用，而 DevTools 却是基于浏览器的。为什么要基于浏览器开发，Dart VM Service Protocol 又是什么？简单了解一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
      <category term="Dart" scheme="http://www.sunmoonblog.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 引擎崩溃分析方法简介</title>
    <link href="http://www.sunmoonblog.com/2020/07/04/flutter-engine-crash-track/"/>
    <id>http://www.sunmoonblog.com/2020/07/04/flutter-engine-crash-track/</id>
    <published>2020-07-04T02:48:41.000Z</published>
    <updated>2020-11-13T02:18:59.049Z</updated>
    
    <content type="html"><![CDATA[<p>Android 项目信息 Flutter 后上线，偶尔会遇到一些 Flutter 引擎的崩溃。简单记录下如何还原引擎崩溃日志，方便在源码中定位问题。</p><a id="more"></a><h1 id="Flutter-Engine-Crash-堆栈还原"><a href="#Flutter-Engine-Crash-堆栈还原" class="headerlink" title="Flutter Engine Crash 堆栈还原"></a>Flutter Engine Crash 堆栈还原</h1><p>首先，在 <code>bin/internal/engine.version</code> 找到 flutter engine revision</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b851c718295a896918dc93cb1ff14f2f895a1b90</span><br></pre></td></tr></table></figure><p>第二步，下载带符号表的 <code>libflutter.so</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://console.cloud.google.com/storage/browser/flutter_infra/flutter/b851c718295a896918dc93cb1ff14f2f895a1b90</span><br></pre></td></tr></table></figure><p>第三步，利用 <code>ndk-stack</code> 还原堆栈信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/path/to/android-ndk-r16b/ndk-stack -sym /path/to/symbols/armeabi-v7a -dump /path/to/stacktrace.txt</span><br></pre></td></tr></table></figure><p>如果是将 crash 上报到 bugly 平台，则不必使用 <code>ndk-stack</code>，直接在 bugly 上配置符号表即可。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/04/15938295883428.jpg" alt></p><p>配置成功后就能在 bugly 平台上看到 native crash 堆栈信息。</p><p>原始堆栈信息<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/04/15938297243231.jpg" alt></p><p>还原后的堆栈信息<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/04/15938297398367.jpg" alt></p><p>拿到还原后的堆栈信息，就可以对着源码分析问题了。</p><h1 id="一个疑问"><a href="#一个疑问" class="headerlink" title="一个疑问"></a>一个疑问</h1><p>官方提到每个 <code>libflutter.so</code> 文件中有一个 build id，native crash 堆栈中见到的 <code>BuildId</code> 要跟 <code>libflutter.so</code> 的匹配，否则没法还原 native crash 堆栈信息。原文如下：</p><blockquote><p>The build system sets a build id for each libflutter.so file. In the tombstones, you would see the ID like so:</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; #00 pc 000000000062d6e0  /data/app/com.app-tARy3eLH2Y-QN8J0d0WFog==/lib/arm64/libflutter.so!libflutter.so (offset 0x270000) (BuildId: 34ad5bdf0830d77a)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>This equals to a build id of 34ad5bdf0830d77a. The libflutter.so debug files downloaded as shown above could be verified using the file command:</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; % file ~/Downloads/libflutter.so</span><br><span class="line">&gt; /Users/user/Downloads/libflutter.so: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, BuildID[xxHash]=34ad5bdf0830d77a, with debug_info, not stripped</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Ensure the build IDs match, else you will not be able to symbolicate.</p></blockquote><p>不过我往 bugly 上传了一个非严格匹配的符号表(上报 crash 的 app 使用的是自己编译的 <code>libflutter.so</code>，符号表是官方提供的 <code>libflutter.so</code>)，也能还原出来。让人很是疑惑。</p><p>观察了下，bugly 上看到的 native crash 日志中并没有找到类似 <code>(BuildId: 34ad5bdf0830d77a)</code> 这样的信息。<em>推测</em>由此导致匹配变得不严格，所以也能还原出来。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>某个 native crash 还原后得到如下堆栈信息。</p><p><img src="/images/15938315565456.jpg" alt></p><p>首先看到的是 <code>message_loop_impl.cc</code> 中的 <code>MessageLoopImpl::RunExpiredTasksNow</code>。这个方法会立即执行任务队列中的已过期任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageLoopImpl::FlushTasks</span><span class="params">(FlushType type)</span> </span>&#123;</span><br><span class="line">  TRACE_EVENT0(<span class="string">"fml"</span>, <span class="string">"MessageLoop::FlushTasks"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;fml::closure&gt; invocations;</span><br><span class="line"></span><br><span class="line">  task_queue_-&gt;GetTasksToRunNow(queue_id_, type, invocations);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; invocation : invocations) &#123;</span><br><span class="line">    invocation();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;fml::closure&gt; observers =</span><br><span class="line">        task_queue_-&gt;GetObserversToNotify(queue_id_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; observer : observers) &#123;</span><br><span class="line">      observer();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageLoopImpl::RunExpiredTasksNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FlushTasks(FlushType::kAll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看到的是 <code>platform_view_android_jni.cc</code> 中的 <code>FlutterViewUpdateSemantics</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FlutterViewUpdateSemantics</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">                                jobject buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                jobjectArray strings)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用 g_update_semantics_method (Java 层方法)</span></span><br><span class="line">  env-&gt;CallVoidMethod(obj, g_update_semantics_method, buffer, strings);</span><br><span class="line">  <span class="comment">// 检查 Java 代码是否发生异常，有异常则写入 fml 日志中</span></span><br><span class="line">  FML_CHECK(CheckException(env));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RegisterApi</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// g_update_semantics_method 对应的是 </span></span><br><span class="line">  <span class="comment">// Java 层中的 FlutterJNI.updateSemantics() 方法</span></span><br><span class="line">  g_update_semantics_method =</span><br><span class="line">      env-&gt;GetMethodID(g_flutter_jni_class-&gt;obj(), <span class="string">"updateSemantics"</span>,</span><br><span class="line">                       <span class="string">"(Ljava/nio/ByteBuffer;[Ljava/lang/String;)V"</span>);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 Java 代码是否发生异常</span></span><br><span class="line"><span class="comment">// 发生异常时返回 false，否则返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckException</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (env-&gt;ExceptionCheck() == JNI_FALSE)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  jthrowable exception = env-&gt;ExceptionOccurred();</span><br><span class="line">  env-&gt;ExceptionClear();</span><br><span class="line">  FML_LOG(ERROR) &lt;&lt; fml::jni::GetJavaExceptionInfo(env, exception);</span><br><span class="line">  env-&gt;DeleteLocalRef(exception);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后看到的是 <code>logging.cc</code> 第92行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">LogMessage::~LogMessage() &#123;</span><br><span class="line">  stream_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_ANDROID)</span></span><br><span class="line">  android_LogPriority priority =</span><br><span class="line">      (severity_ &lt; <span class="number">0</span>) ? ANDROID_LOG_VERBOSE : ANDROID_LOG_UNKNOWN;</span><br><span class="line">  <span class="keyword">switch</span> (severity_) &#123;</span><br><span class="line">    <span class="keyword">case</span> LOG_INFO:</span><br><span class="line">      priority = ANDROID_LOG_INFO;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LOG_WARNING:</span><br><span class="line">      priority = ANDROID_LOG_WARN;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LOG_ERROR:</span><br><span class="line">      priority = ANDROID_LOG_ERROR;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LOG_FATAL:</span><br><span class="line">      priority = ANDROID_LOG_FATAL;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  __android_log_write(priority, <span class="string">"flutter"</span>, stream_.str().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(OS_IOS)</span></span><br><span class="line">  syslog(LOG_ALERT, <span class="string">"%s"</span>, stream_.str().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; stream_.str();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span>.flush();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (severity_ &gt;= LOG_FATAL) &#123;</span><br><span class="line">    <span class="comment">// 最终的 crash 由这里产生</span></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初看起来可能会有点不明白 crash 如何产生，梳理一下就渐渐明了：</p><ul><li>调用 <code>RunExpiredTasksNow</code> 立即执行队伍中的过期任务</li><li>过期任务中的某一个任务调用了 <code>FlutterViewUpdateSemantics()</code> (C++层)</li><li><code>FlutterViewUpdateSemantics()</code> 调用 <code>FlutterJNI.updateSemantics()</code> (Java层)</li><li><code>FlutterViewUpdateSemantics()</code> 调用 <code>CheckException()</code> 检查 Java 代码执行后是否产生异常</li><li><code>FlutterViewUpdateSemantics()</code> 调用 <code>FML_CHECK()</code> 记录错误日志 (如有 Java 异常)</li></ul><p>所以我们可以把怀疑目标锁定到 <code>FlutterJNI.updateSemantics()</code> 方法。剩下的工作就是进入 Java 层分析该方法的出错原因了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Keep</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterJNI</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Invoked by native to send semantics tree updates from Flutter to Android.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The &#123;<span class="doctag">@code</span> buffer&#125; and &#123;<span class="doctag">@code</span> strings&#125; form a communication protocol that is implemented here:</span></span><br><span class="line"><span class="comment">   * https://github.com/flutter/engine/blob/master/shell/platform/android/platform_view_android.cc#L207</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateSemantics</span><span class="params">(@NonNull ByteBuffer buffer, @NonNull String[] strings)</span> </span>&#123;</span><br><span class="line">    ensureRunningOnMainThread();</span><br><span class="line">    <span class="keyword">if</span> (accessibilityDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">      accessibilityDelegate.updateSemantics(buffer, strings);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO(mattcarroll): log dropped messages when in debug mode (https://github.com/flutter/flutter/issues/25391)</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://fucknmb.com/2019/10/20/%E8%8E%B7%E5%8F%96%E5%B9%B6%E8%BF%98%E5%8E%9FFlutter-Engine-Crash%E5%A0%86%E6%A0%88/" target="_blank" rel="noopener">获取并还原 Flutter Engine Crash 堆栈 | 区长</a></li><li><a href="https://github.com/flutter/flutter/wiki/Crashes" target="_blank" rel="noopener">Crashes · flutter/flutter Wiki</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 项目信息 Flutter 后上线，偶尔会遇到一些 Flutter 引擎的崩溃。简单记录下如何还原引擎崩溃日志，方便在源码中定位问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>mockjs 入门</title>
    <link href="http://www.sunmoonblog.com/2020/07/02/mockjs-basic/"/>
    <id>http://www.sunmoonblog.com/2020/07/02/mockjs-basic/</id>
    <published>2020-07-02T08:17:46.000Z</published>
    <updated>2020-11-13T02:18:59.049Z</updated>
    
    <content type="html"><![CDATA[<p>感觉 mockjs 真是个好东西。简单了解下用法。<br><a id="more"></a></p><h1 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h1><p>先直接上文档 <a href="http://mockjs.com/examples.html#Image" target="_blank" rel="noopener">Mock.js</a>。文档中列出了 mockjs 可以模拟的数据类型，包括：</p><ul><li>string</li><li>number</li><li>bool</li><li>array</li><li>object</li><li>guid</li><li>id</li><li>title</li><li>paragraph</li><li>image</li><li>address</li><li>date</li><li>time</li><li>url</li><li>email</li><li>ip</li><li>regexp</li></ul><p>不要小看这个文档，<strong>你可以打开控制台，随意地试验这些方法。</strong></p><p><img src="/images/15936783153589.jpg" alt="-w795"></p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>这里列举几个我用到的模拟数据。</p><p>模拟 title：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Mock.mock(&#123;<span class="string">'title'</span>: <span class="string">'@title(1)'</span>&#125;)</span><br><span class="line"><span class="comment">// &#123;title: "Qoqhdl"&#125;</span></span><br><span class="line">&gt; Mock.mock(&#123;<span class="string">'title'</span>: <span class="string">'@csentence(6)'</span>&#125;)</span><br><span class="line"><span class="comment">// &#123;title: "容约声量局有。"&#125;</span></span><br></pre></td></tr></table></figure><p>模拟图片：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Mock.mock(&#123;<span class="string">'head'</span>: <span class="string">'@image()'</span>&#125;)</span><br><span class="line"><span class="comment">// &#123;head: "http://dummyimage.com/234x60"&#125;</span></span><br></pre></td></tr></table></figure><p>模拟图片打开之后的效果如下：</p><p><img src="/images/15936788801014.jpg" alt="-w938"></p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>mockjs 的语法还是比较简单易懂的，感觉不必花时间专门研究。不过不妨找一批较全的示例，实在不记得怎么写时可以照着示例来写。这里直接贴上一个示例，它来自<a href="https://github.com/ToNiQian/mockjs" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Mock</span></span><br><span class="line"><span class="keyword">let</span> Mock = <span class="built_in">require</span>(<span class="string">'mockjs'</span>);</span><br><span class="line">Mock.mock(<span class="string">'http://1.json'</span>,<span class="string">'get'</span>,&#123;</span><br><span class="line">    <span class="comment">// 属性 list 的值是一个数组，其中含有 1 到 3 个元素</span></span><br><span class="line">    <span class="string">'list|1-3'</span>: [&#123;</span><br><span class="line">        <span class="comment">// 属性 sid 是一个自增数，起始值为 1，每次增 1</span></span><br><span class="line">        <span class="string">'sid|+1'</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="comment">// 属性 userId 是一个5位的随机码</span></span><br><span class="line">        <span class="string">'userId|5'</span>: <span class="string">''</span>,</span><br><span class="line">        <span class="comment">// 属性 sex 是一个bool值</span></span><br><span class="line">        <span class="string">"sex|1-2"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 属性 city对象 是对象值中2-4个的值</span></span><br><span class="line">        <span class="string">"city|2-4"</span>: &#123;</span><br><span class="line">            <span class="string">"110000"</span>: <span class="string">"北京市"</span>,</span><br><span class="line">            <span class="string">"120000"</span>: <span class="string">"天津市"</span>,</span><br><span class="line">            <span class="string">"130000"</span>: <span class="string">"河北省"</span>,</span><br><span class="line">            <span class="string">"140000"</span>: <span class="string">"山西省"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//属性 grade 是数组当中的一个值</span></span><br><span class="line">        <span class="string">"grade|1"</span>: [</span><br><span class="line">            <span class="string">"1年级"</span>,</span><br><span class="line">            <span class="string">"2年级"</span>,</span><br><span class="line">            <span class="string">"3年级"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">//属性 guid 是唯一机器码</span></span><br><span class="line">        <span class="string">'guid'</span>: <span class="string">'@guid'</span>,</span><br><span class="line">        <span class="comment">//属性 id 是随机id</span></span><br><span class="line">        <span class="string">'id'</span>: <span class="string">'@id'</span>,</span><br><span class="line">        <span class="comment">//属性 title 是一个随机长度的标题</span></span><br><span class="line">        <span class="string">'title'</span>: <span class="string">'@title()'</span>,</span><br><span class="line">        <span class="comment">//属性 paragraph 是一个随机长度的段落</span></span><br><span class="line">        <span class="string">'paragraph'</span>: <span class="string">'@cparagraph'</span>,</span><br><span class="line">        <span class="comment">//属性 image 是一个随机图片 参数分别为size, background, text</span></span><br><span class="line">        <span class="string">'image'</span>: <span class="string">"@image('200x100', '#4A7BF7', 'Hello')"</span>,</span><br><span class="line">        <span class="comment">//属性 address 是一个随机地址</span></span><br><span class="line">        <span class="string">'address'</span>: <span class="string">'@county(true)'</span>,</span><br><span class="line">        <span class="comment">//属性 date 是一个yyyy-MM-dd 的随机日期</span></span><br><span class="line">        <span class="string">'date'</span>: <span class="string">'@date("yyyy-MM-dd")'</span>,</span><br><span class="line">        <span class="comment">//属性 time 是一个 size, background, text 的随机时间</span></span><br><span class="line">        <span class="string">'time'</span>: <span class="string">'@time("HH:mm:ss")'</span>,</span><br><span class="line">        <span class="comment">//属性 url 是一个随机的url</span></span><br><span class="line">        <span class="string">'url'</span>: <span class="string">'@url'</span>,</span><br><span class="line">        <span class="comment">//属性 email 是一个随机email</span></span><br><span class="line">        <span class="string">'email'</span>: <span class="string">'@email'</span>,</span><br><span class="line">        <span class="comment">//属性 ip 是一个随机ip</span></span><br><span class="line">        <span class="string">'ip'</span>: <span class="string">'@ip'</span>,</span><br><span class="line">        <span class="comment">//属性 regexp 是一个正则表达式匹配到的值 如aA1</span></span><br><span class="line">        <span class="string">'regexp'</span>: <span class="regexp">/[a-z][A-Z][0-9]/</span>,</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="其他模拟方式"><a href="#其他模拟方式" class="headerlink" title="其他模拟方式"></a>其他模拟方式</h1><p>以下是另外两个 mock 库，看起来更为强大。</p><ul><li><a href="https://github.com/APIJSON/APIJSON" target="_blank" rel="noopener">APIJSON/APIJSON: 🏆码云最有价值开源项目 🚀后端接口和文档自动化，前端(客户端) 定制返回 JSON 的数据和结构！🏆Gitee Most Valuable Project 🚀A JSON Transmission Protocol and an ORM Library for automatically providing APIs and Docs.</a></li><li><a href="https://github.com/chinesedfan/parrot-mocker-web/blob/master/README-zh.md" target="_blank" rel="noopener">parrot-mocker-web/README-zh.md at master · chinesedfan/parrot-mocker-web</a></li></ul><p><a href="https://segmentfault.com/a/1190000011230904" target="_blank" rel="noopener">AntDesign结合mockjs随机生成图片</a> 提供了另外一种思路：上传一批图片到云端(保证名字有规律)，再使用 mockjs 来拿到图片地址，从而实现在模拟自定义图片。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>mockjs 本身并不是特别有用，不过它结合 vue-admin-template 中的 mock-server，可以直接模拟线上接口，方便在后台尚未提供接口的情况下开始前端页面开发。这一点在某些情况下特别有用，如果事先后台能提供接口协议，保证模拟接口跟实际接口基本一致，生产力应该能大大提高。</p><p>vue-admin-template 中 mock-server 的用法见<a href="https://www.sunmoonblog.com/2020/07/01/vue-mockserver-watch-not-working/">前一篇</a>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">nuysoft/Mock: A simulation data generator</a></li><li><a href="http://mockjs.com/examples.html#Image" target="_blank" rel="noopener">Mock.js</a></li><li><a href="https://github.com/ToNiQian/mockjs" target="_blank" rel="noopener">ToNiQian/mockjs: 一个webpack 搭建的 mock 案例演示</a></li><li><a href="https://juejin.im/post/599c1bfaf265da248d0cc6b6" target="_blank" rel="noopener">Mockjs,再也不用追着后端小伙伴要接口了 - 掘金</a></li><li><a href="https://juejin.im/post/5ce2a960e51d455a2f2201c3" target="_blank" rel="noopener">vue-vue项目中mock.js的使用 - 掘金</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉 mockjs 真是个好东西。简单了解下用法。&lt;br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://www.sunmoonblog.com/tags/javascript/"/>
    
      <category term="Vue" scheme="http://www.sunmoonblog.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-admin-template 中 mock-server 的用法</title>
    <link href="http://www.sunmoonblog.com/2020/07/01/vue-mockserver-watch-not-working/"/>
    <id>http://www.sunmoonblog.com/2020/07/01/vue-mockserver-watch-not-working/</id>
    <published>2020-07-01T12:03:07.000Z</published>
    <updated>2020-11-13T02:18:59.049Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一下 vue-admin-template 中 mock-server 的用法。<br><a id="more"></a></p><p>最近刚接触一个 vue 项目。发现该项目是基于 vue-admin-template 的，但并没有很好地利用 vue-admin-template 的 <a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/mock-api.html" target="_blank" rel="noopener">Mock Data</a> 功能。这个功能正好能解决我目前的痛点：后台接口预计很久之后才能给到，而缺少接口的情况下前端页面中很多边边角角的工作并不好处理。</p><p>所以我了解了下如何使用在 vue-admin-template 中模拟数据。</p><p>vue-admin-template 提供两种模拟方式：</p><ul><li>本地模拟 - 这是使用 <a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">mockjs</a> 进行纯前端模拟。其原理是拦截了所有的请求并代理到本地，然后进行数据模拟。大部分情况下够用，但有几个问题：一是调试工具中看不到网络数据；二是s可能影响依赖 <code>XMLHttpRequest</code> 的库</li><li>线上模拟 - 本地启动一个 mock-server 来模拟数据，其模拟数据仍然来自 <a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">mockjs</a></li></ul><p>我们重点看线上模拟这种方式。</p><h1 id="配置和用法"><a href="#配置和用法" class="headerlink" title="配置和用法"></a>配置和用法</h1><p>先安装 <code>mockjs</code> 和 <code>chokidar</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install mockjs</span><br><span class="line">npm install chokidar</span><br></pre></td></tr></table></figure><p><a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/mock-api.html#%E7%A7%BB%E9%99%A4" target="_blank" rel="noopener">官方 Wiki</a> 提到的配置方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">  // change xxx-api/login =&gt; mock/login</span><br><span class="line">  // detail: https://cli.vuejs.org/config/#devserver-proxy</span><br><span class="line">  [process.env.VUE_APP_BASE_API]: &#123;</span><br><span class="line">    target: `http://localhost:$&#123;port&#125;/mock`,</span><br><span class="line">    changeOrigin: true,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      [&apos;^&apos; + process.env.VUE_APP_BASE_API]: &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">after: require(&apos;./mock/mock-server.js&apos;)</span><br></pre></td></tr></table></figure><p>但这个文档较旧，跟当前<a href="https://github.com/PanJiaChen/vue-admin-template/blob/permission-control/vue.config.js" target="_blank" rel="noopener">最新源码</a> 中的配置有较大差异。源码的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  port: port,</span><br><span class="line">  open: true,</span><br><span class="line">  overlay: &#123;</span><br><span class="line">    warnings: false,</span><br><span class="line">    errors: true</span><br><span class="line">  &#125;,</span><br><span class="line">  before: require(&apos;./mock/mock-server.js&apos;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>注意<strong>之前的 <code>after</code> 变成了 <code>before</code>，并且不再需要为 devServer 配置 proxy 了</strong>。 </p><p><img src="/images/15936059512268.jpg" alt></p><p>之后就可以在 <code>mock</code> 目录下写模拟数据了。 </p><p><img src="/images/15936061733008.jpg" alt></p><p><code>mock</code> 目录下各个文件的作用如下：</p><ul><li><code>mock-server.js</code> - mock-server 的源码</li><li><code>index.js</code> - 引入用到的模拟数据文件</li><li>其他 js 文件 - 模拟数据文件</li></ul><p><code>mock</code> 目录下各个文件的依赖关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mock-server.js</span><br><span class="line"> -&gt; index.js</span><br><span class="line">  -&gt; 其他 js 文件</span><br></pre></td></tr></table></figure><p>来看一个实例。</p><p>第一步，在 <code>register.js</code> 文件中定义一条模拟数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  &#123;</span><br><span class="line">    url: <span class="string">'/cm/reg/sendcode'</span>,</span><br><span class="line">    type: <span class="string">'post'</span>,</span><br><span class="line">    response: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> items = data.items</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        r: <span class="number">0</span>,</span><br><span class="line">        msg: <span class="string">'hello22'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>第二步，在 <code>index.js</code> 文件引入 <code>register.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> register <span class="keyword">from</span> <span class="string">'./register'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mocks = [</span><br><span class="line">  ...user,</span><br><span class="line">  ...table,</span><br><span class="line">  ...register</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>第三步，在 vue 文件中请求上面定义的模拟数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">post(&#123;</span><br><span class="line">  url: &apos;/cm/reg/sendcode&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意这里的 <code>post()</code> 方法用到一个 <code>axios</code> 实例，该 <code>axios</code> 实例的 baseUrl 为 <code>https://localhost/dev-api</code>。所以模拟请求的目标地址为 <code>https://localhost/dev-api/cm/reg/sendcode</code>。如下图，</p><p><img src="/images/15936068577258.jpg" alt="-w434"></p><p><img src="/images/15936068933224.jpg" alt="-w428"></p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>mock-server 有一个很赞的功能，每次修改 <code>mock</code> 目录下文件后，mock-server 会执行 hot reload，重新加载最新的数据。如下图，注意可以看到 “Mock Server hot reload success!”</p><p><img src="/images/15936071064085.jpg" alt></p><p>但我遇到一个小坑，无论如何修改 <code>mock</code> 目录下的文件都不会出现 hot reload。</p><p>反复检查后发现，我目前开发的这个 vue 项目虽然是基于 vue-admin-template 的，但是将原始工程中的部分源文件路径调整了。其中一个调整是将 <code>mock</code> 调整成 <code>src/mock</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockDir = path.join(process.cwd(), <span class="string">'mock'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// watch files, hot reload mock server</span></span><br><span class="line">  chokidar.watch(mockDir, &#123;</span><br><span class="line">    ignored: <span class="regexp">/mock-server/</span>,</span><br><span class="line">    ignoreInitial: <span class="literal">true</span></span><br><span class="line">  &#125;).on(<span class="string">'all'</span>, (event, path) =&gt; &#123; ... &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但 mock-server 监听的是 cwd 中的 <code>mock</code> 目录，所以修改 <code>mock</code> 目录中的模拟数据文件后，无法 hot reload。解决办法很简单，调整一下路径，改成监听 cwd 中的 <code>src/mock</code> 目录即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockDir = path.join(process.cwd(), <span class="string">'src/mock'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// watch files, hot reload mock server</span></span><br><span class="line">  chokidar.watch(mockDir, &#123;</span><br><span class="line">    ignored: <span class="regexp">/mock-server/</span>,</span><br><span class="line">    ignoreInitial: <span class="literal">true</span></span><br><span class="line">  &#125;).on(<span class="string">'all'</span>, (event, path) =&gt; &#123; ... &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他可能遇到的问题见 <a href="https://github.com/PanJiaChen/vue-element-admin/issues?page=2&amp;q=mock+server" target="_blank" rel="noopener">issues</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/mock-api.html" target="_blank" rel="noopener">Mock Data</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单记录一下 vue-admin-template 中 mock-server 的用法。&lt;br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://www.sunmoonblog.com/tags/javascript/"/>
    
      <category term="Vue" scheme="http://www.sunmoonblog.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vant Toast 无法显示的问题</title>
    <link href="http://www.sunmoonblog.com/2020/07/01/vue-toast-not-show/"/>
    <id>http://www.sunmoonblog.com/2020/07/01/vue-toast-not-show/</id>
    <published>2020-07-01T02:17:34.000Z</published>
    <updated>2020-11-13T02:18:59.049Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Vant Toast 时发现有些场景下无法显示。简单记录一下问题原因和解决方法。</p><a id="more"></a><h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>问题是这样的：界面上有一个注册对话框，当检查到用户输入有误使用 Vant Toast 弹出错误提示信息。比如，当用户没有输入手机号时，提示手机号为不能为空。</p><p><img src="/images/15935700432089.jpg" alt="-w371"></p><p>弹出错误提示 Toast 的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toast.fail(<span class="string">'手机号不能为空'</span>)</span><br></pre></td></tr></table></figure><p>但发现 Toast 始终无法显示。</p><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>检查样式后发现对话框的 <code>z-index</code> 过大。这里看到的是 9999</p><p><img src="/images/15935702844010.jpg" alt="-w1049"></p><p>Toast 实际已经弹出，但是它的 <code>z-index</code> 小于对话框的 <code>z-index</code>，导致 Toast 被对话框挡住，所以无法显示。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>解决办法很简单。</p><p>首先，在 vue 文件里写一个简单的 <code>toast</code> 样式，指定其 <code>z-index</code> 为 10000 (确保比对话框的大就行)。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- app.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.toast &#123;</span><br><span class="line">z-index: 10000 !important;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，弹出 Toast 时指定相应的样式即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toast.fail(&#123;<span class="attr">message</span>: <span class="string">'手机号不能为空'</span>, <span class="attr">className</span>: <span class="string">'toast'</span>&#125;)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.w3schools.com/cssref/pr_pos_z-index.asp" target="_blank" rel="noopener">CSS z-index property</a></li><li><a href="https://github.com/youzan/vant/issues/3145" target="_blank" rel="noopener">如果Toast先弹出过，因为z-indx计算，会被后使用的popup组件遮住，如果在popup里面需要使用Toast的话，就会被遮住了，这该如何解决？ · Issue #3145 · youzan/vant</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Vant Toast 时发现有些场景下无法显示。简单记录一下问题原因和解决方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://www.sunmoonblog.com/tags/javascript/"/>
    
      <category term="Vue" scheme="http://www.sunmoonblog.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Dart VM</title>
    <link href="http://www.sunmoonblog.com/2020/06/30/dartvm/"/>
    <id>http://www.sunmoonblog.com/2020/06/30/dartvm/</id>
    <published>2020-06-30T01:20:30.000Z</published>
    <updated>2020-11-13T02:18:59.049Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自 <a href="https://mrale.ph/dartvm/" target="_blank" rel="noopener">Dart VM</a>，非常详细地介绍了 Dart 代码运行机制。<br><a id="more"></a><br>Dart VM 是一个用于原生地执行 Dart 代码的组件集合。它主要包含如下部分：</p><ul><li>运行时系统<ul><li>对象模型</li><li>GC</li><li>Snapshot</li></ul></li><li>核心库</li><li>通过 <em>service protocol</em> 访问的 Development Experience 组件<ul><li>调试</li><li>分析</li><li>热加载</li></ul></li><li>Just-in-Time (JIT) 和 Ahead-of-Time (AOT) 编译流水线</li><li>解释器</li><li>ARM 模拟器</li></ul><p>Dart VM 这个名字是历史遗留的。在某种意义上 Dart VM 能为上层编程语言提供执行环境，但这个名字并不意味着 Dart VM 中 Dart 代码总是解释执行或 JTI 编译的。比如，可以使用 Dart VM AOT 流水线将 Dart 代码编译成机器码，然后在精简版本的 Dart VM 中执行，称之为 <em>precompiled runtime</em>，它既不包含任何编译器组件，也不能动态加载 Dart 源码。</p><h1 id="Dart-VM-是如何运行代码的？"><a href="#Dart-VM-是如何运行代码的？" class="headerlink" title="Dart VM 是如何运行代码的？"></a>Dart VM 是如何运行代码的？</h1><p>Dart VM 有多种方式执行代码，比如：</p><ul><li>使用 JIT 从源码或 Kernel binary</li><li>从 snapshot<ul><li>AOT snapshot</li><li>AppJIT snapshot</li></ul></li></ul><p>这些方式之间的主要不同在于 VM 将 Dart 源码转换成可执行代码的时机和方式。执行代码的运行时环境是相同的。</p><p>VM 中的 Dart 代码运行在 <em>isolate</em>，对 isolate 的最好描述是这样的：一个隔离的 Dart 世界，有其自己的内存(<em>heap</em>)，通常有自己的线程(<em>mutator thread</em>)。可以有多个 isolate 并发执行 Dart 代码，但 isolate 不能直接共享任何状态，只能通过 <em>port</em> 发送消息来通信(不要将这里的 port 跟 network port 混淆)。</p><p><img src="https://mrale.ph/dartvm/images/isolates.png" alt></p><p>OS 线程跟 isolate 之间的关系比较模糊，具体依赖于 VM 是如何 embed 到应用中的。只能保证如下几个规则：</p><ul><li>OS 线程同一时刻只能进入一个 isolate。如果线程想进入另一个 isolate，它必须离开当前 isolate</li><li>同一时刻一个 isolate 只能有一个 <em>mutator</em> 线程。mutator 线程是指执行 Dart 代码并能访问 VM 公开 C API 的线程</li></ul><p>当然，同一个 OS 线程可以先进入一个 isolate，执行 Dart 代码，然后离开这个 isolate 并进入另一个 isolate。类似的，多个不同的线程可以进入同一个 isolate 并执行代码，只要不是同时发生。</p><p>除了单个 mutator 线程外，一个 isolate 还能跟多个辅助线程关联，比如：</p><ul><li>一个后台运行的 JIT 编译器线程</li><li>多个 GC sweeper 线程</li><li>多个并发 GC maker 线程</li></ul><p>VM 内部使用线程池(<a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/thread_pool.h#L14" target="_blank" rel="noopener">ThreadPool</a>)管理 OS 线程，代码围绕 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/thread_pool.h#L17" target="_blank" rel="noopener">ThreadPool::Task</a> 而非 OS 线程来组织。比如，GC VM 向全局 VM 线程池提交 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/heap/sweeper.cc#L100" target="_blank" rel="noopener">SweeperTask</a> 后并不是生成一个专门的线程来执行后台清理工作，线程池可能会选择一个空闲的线程，或者在没有线程可用时生成一个新线程。类似的，用于 isolate 消息处理的 event loop 的缺省实现也并不是真的生成专门的 event loop 线程，而是在新消息到达时向线程池提交 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/message_handler.cc#L19" target="_blank" rel="noopener">MessageHandlerTask</a>。</p><p>源码清单：</p><ul><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/isolate.h#L151" target="_blank" rel="noopener">Isolate</a> 类代表 isolate</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/heap/heap.h#L28" target="_blank" rel="noopener">Heap</a> 类代表 isolate 的 heap</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/thread.h#L204" target="_blank" rel="noopener">Thread</a> 类描述与 isolate 关联的线程的状态。注意这里的名字 Thread 容易让人混淆，因为实际上所有作为 mutator 关联到同一个 isolate 的所有的操作系统线程会重用同一个 Thread 实例。</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/dart_api_impl.cc#L1586" target="_blank" rel="noopener">Dart_RunLoop</a> 和 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/message_handler.h#L17" target="_blank" rel="noopener">MessageHandler</a> 是 isolate 消息处理的缺省实现</li></ul><h2 id="JIT-模式源码运行"><a href="#JIT-模式源码运行" class="headerlink" title="JIT 模式源码运行"></a>JIT 模式源码运行</h2><p>这一节是关于在命令行下执行 Dart 时的过程。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// hello.dart</span><br><span class="line">main() =&gt; <span class="built_in">print</span>(<span class="string">'Hello, World!'</span>);</span><br><span class="line">$ dart hello.dart</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><p>Dart 2 开始 VM 不再支持直接从原始代码执行 Dart，而是执行指定的 <em>Kernel binaries</em> (也称之为 <em>dill files</em>)，其中包含系列化后的 <a href="https://github.com/dart-lang/sdk/blob/master/pkg/kernel/README.md" target="_blank" rel="noopener">Kernel ASTs</a>。Dart 源码转换成 Kernel AST 的任务由 <a href="https://github.com/dart-lang/sdk/tree/master/pkg/front_end" target="_blank" rel="noopener">common front-end (CFE)</a> 完成，CFE 由 Dart 写成，在不同的 Dart 工具共享(比如 VM，dart2js，Dart Dev Compiler)。</p><p><img src="/images/15934867158439.jpg" alt></p><p>为了保留直接执行 Dart 代码的便捷性，标准的 <code>dart</code> 执行命令带有一个叫 <em>kernel service</em> 的 isolate，它负责将 Dart 源码编译成 Kernel binary。之后 VM 后运行生成的 Kernel binary。</p><p><img src="/images/15934867009562.jpg" alt></p><p>不过这并非 CFE 和 VM 运行 Dart 代码唯一的组合方式。比如，Flutter 完全将 <em>compilation to Kernel</em> 和      <em>execution from Kernel</em> 两个过程分离到不同的设备上：编译发生在开发机(<em>host</em>)，而执行发生在移动设备(<em>device</em>)，它接收通过 <code>flutter</code> tool 发送来的 Kernel binary。</p><p><img src="/images/15934866911219.jpg" alt><br><img src="https://mrale.ph/dartvm/images/flutter-cfe.png" alt></p><p>注意 <code>flutter</code> tool 自己并不解析 Dart，它启动另一个进程 <code>frontend_server</code>。<code>frontend_server</code> 是对 CFE 的包装，并且进行某些 Flutter 特定的 Kernel-to-Kernel 转换。<code>frontend_server</code> 将 Dart 代码转换成 Kernel binary 文件，<code>flutter</code> tool 将这些文件发送到设备。当开发者想使用 <em>hot reload</em> 特性时，就需要 <code>frontend_server</code> 是常驻进程了：<code>frontend_server</code> 可以根据前一次编译来重用 CFE 状态，只编译发生实际变动的代码。</p><p>Kernel binary 加载到 VM 后会被解析成代码不同程序实体的对象。不过解析是延迟进行的：最初只加载库和类的基本信息。每个来自 Kernel binary 的实体都有一个指向 Kernel binary 的指针，以便之后需要时能加载更多信息。</p><blockquote><p>使用 <code>Raw...</code> 前缀来指代 VM 内部分配的特定对象。这是 VM 的命名习惯：VM 内部对象布局由一个位于 <code>raw_object.h</code> 头文件中以 Raw 开头的 C++ 类来定义。比如 <code>RawClass</code> 是一个描述 Dart 类的 VM 对象，而 <code>RawField</code> 是一个描述 Dart 类中 Dart 字段的对象。在后台讨论运行时系统和对象模型那节中我们还会回到这个话题。</p></blockquote><p><img src="/images/15934878531318.jpg" alt></p><p>类的信息只在之后运行时需要时才完全反序列化(比如，查找类成员，分配对象等等)。这一阶段，类成员读取自 Kernel binary。不过，此时只有成员签名，完整的函数方法此时并没有完全反序列化。</p><p><img src="/images/15934880714981.jpg" alt></p><p>这时运行时已经从 Kernel binary 加载了足够信息，可以成功解析和调用方法。比如，它可以从一个库中解析和调用 <code>main</code> 函数。</p><p>源码清单：</p><ul><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/kernel/lib/ast.dart" target="_blank" rel="noopener">package:kernel/ast.dart</a> 定义了描述 Kernel AST 的类</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/front_end" target="_blank" rel="noopener">package:front_end</a> 用于解析 Dart 源码并从源码构建 AST</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/kernel_loader.cc#L211" target="_blank" rel="noopener">kernel::KernelLoader::LoadEntireProgram</a> 是将 Kernel AST 反序列化成对应 VM 对象的入口</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/vm/bin/kernel_service.dart" target="_blank" rel="noopener">pkg/vm/bin/kernel_service.dart</a> 实现了 Kernel Service isolate</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/kernel_isolate.cc" target="_blank" rel="noopener">runtime/vm/kernel_isolate.cc</a> 将 Dart 实现跟 VM 的其他部分粘合起来</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/vm" target="_blank" rel="noopener">package:vm</a> 包含基于 Kernel 的 VM 的大部分功能，比如不同的 Kernel-to-Kernel 转换，由于一些历史原因一些 VM 特定的转换仍然放在 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/kernel" target="_blank" rel="noopener">package:kernel</a> 中</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/kernel/lib/transformations/continuation.dart" target="_blank" rel="noopener">package:kernel/transformations/continuation.dart</a> 是一个复杂转换的好例子，它对 <code>async</code>、<code>async*</code> 以及 <code>sync*</code> 函数进行脱糖处理 </li></ul><p>动手尝试！如果你对 Kernel binary 格式以及 VM 用法感兴趣，可以使用 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/vm/bin/gen_kernel.dart" target="_blank" rel="noopener">pkg/vm/bin/gen_kernel.dart</a> 来从 Dart 源码生成一个 Kernel binary 文件。生成的 binary 文件可以使用 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/vm/bin/dump_kernel.dart" target="_blank" rel="noopener">pkg/vm/bin/dump_kernel.dart</a> 进行 dump 操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Take hello.dart and compile it to hello.dill Kernel binary using CFE.</span></span><br><span class="line">$ dart pkg/vm/bin/gen_kernel.dart                        \</span><br><span class="line">       --platform out/ReleaseX64/vm_platform_strong.dill \</span><br><span class="line">       -o hello.dill                                     \</span><br><span class="line">       hello.dart</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dump textual representation of Kernel AST.</span></span><br><span class="line">$ dart pkg/vm/bin/dump_kernel.dart hello.dill hello.kernel.txt</span><br></pre></td></tr></table></figure><p>当你尝试使用 <code>gen_kernel.dart</code> 时你你发现它需要一个名为 <em>platform</em> 的东西，这个参数用于指定一个包含所有核心库(例如 <code>dart:core</code>，<code>dart:async</code>)的 AST 的文件。如果你本地编译过 Dart SDK，可以使用 out 目录下的 platform 文件，比如 <code>out/ReleaseX64/vm_platform_strong.dill</code>。(译者注：如果你本地编译过 Flutter 引擎，也可以使用 <code>engine/src/out/host_debug_unopt/vm_platform_strong.dill</code>)。另外，你也可以使用 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/front_end/tool/_fasta/compile_platform.dart" target="_blank" rel="noopener">pkg/front_end/tool/_fasta/compile_platform.dart</a> 生成 platform。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Produce outline and platform files using the given libraries list.</span></span><br><span class="line">$ dart pkg/front_end/tool/_fasta/compile_platform.dart \</span><br><span class="line">       dart:core                                       \</span><br><span class="line">       sdk/lib/libraries.json                          \</span><br><span class="line">       vm_outline.dill vm_platform.dill vm_outline.dill</span><br></pre></td></tr></table></figure><p>译者注：我在本地操作了一把，成功！</p><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 dill</span></span><br><span class="line">$ dart /Users/cm/wd/engine/src/third_party/dart/pkg/vm/bin/gen_kernel.dart \</span><br><span class="line">--platform /Users/cm/wd/engine/src/out/host_debug_unopt/vm_platform_strong.dill \</span><br><span class="line">-o hello.dill \</span><br><span class="line">   hello.dart</span><br><span class="line"><span class="comment"># dump dill</span></span><br><span class="line">$ dart /Users/cm/wd/engine/src/third_party/dart/pkg/vm/bin/dump_kernel.dart \</span><br><span class="line">hello.dill hello.kernel.txt</span><br></pre></td></tr></table></figure><p><img src="/images/15934899027428.jpg" alt></p><p><img src="/images/15934899450735.jpg" alt></p><p>所有函数体初始时只有占位符而不是实际的可执行代码：占位符指向 <code>LazyCompileStub</code>，它只是请求运行时系统为当前函数生成可执行代码并且对新生成的代码进行尾调用(tail-calls this newly generated code)。</p><p><img src="/images/15934979827846.jpg" alt></p><p>函数第一次编译时以上过程由 <em>unoptimizing compiler</em> 完成。</p><p><img src="/images/15934980438450.jpg" alt></p><p><em>Unoptimizing compiler</em> 按以下两个步骤生成机器码：</p><ol><li>遍历函数体的序列化后的 AST，为函数体生成 <em>control flow graph</em> (CFG)。CFG 由 <em>intermediate language</em> (IL) 指令块组成。这个阶段使用的 IL 指令类似基于栈的 VM 中的指令：从栈中取出操作数，执行操作后将结果放回同一个栈 (注意：实际上并不是所有的函数都有实际的 Dart/Kernel AST 函数体，比如 C++ 中定义的 native 方法或 artificial tear-off functions generated by Dart VM，这些场景中 IL 是从从头构造的而不是从 Kernel AST 生成的)</li><li>生成的 CFG 直接编译成机器码：每个 IL 指令扩展成多个机器语言指令</li></ol><p>这个阶段中没有进行优化，unoptimizing compiler 的主要目标是快速生成可执行代码。</p><p>This also means that unoptimizing compiler does not attempt to statically resolve any calls that were not resolved in Kernel binary, so calls (MethodInvocation or PropertyGet AST nodes) are compiled as if they were completely dynamic. VM 目前不使用任何形式的基于的 <em>virtual table</em> 或 <em>interface table</em> 的分发方法，而是使用 <a href="https://en.wikipedia.org/wiki/Inline_caching" target="_blank" rel="noopener">inline caching</a> 实现动态调用。</p><p>inline caching 背后的主要思想是在 call site specific cache 中保存方法解析的结果(The core idea behind inline caching is to cache results of method resolution in a call site specific cache.)。注意：原始的 inline caching 实现实际上是用来对函数的 native 代码打补丁。VM 使用的 inline caching 有如下组成：</p><ul><li>call site specific cache (RawICData 对象)，将接收方的类映射成方法，如果接收方的类匹配上就调用这个方法。这个 cache 还保存一些辅助信息，比如调用计数，用于记录指定类在这个 call site 中出现的次数</li><li>shared lookup stub，实现方法调用的快捷路径。该 stub 在指定 cache 中检查是否包含能跟接收方的类匹配的 entry，如果有，则 stub 将增调用频率计数。否则，stub 将请求运行时系统进行方法解析。解析方法后会更新 cache，之后的方法调用不必再经过运行时系统。</li></ul><p>下图展示了跟 <code>animal.toFace()</code> call site 关联的 inline cache 的结构和方法，这个方法在一个 <code>Dog</code> 实例上执行两次，在另一个 <code>Cat</code> 实例上执行一次。</p><p><img src="/images/15934995543159.jpg" alt></p><p>Unoptimizing compiler 本身足够执行任意 Dart 代码。但它生成的代码非常慢，这也是为什么 VM 还实现了 <em>adaptive optimizing</em> 编译流水线。adaptive optimizing 背后的思想是对一个运行中的程序的执行分析结果来驱动优化决策：</p><p>unoptimized code (未经优化的代码) 运行时会收集以下信息：</p><ul><li>dynamic call site 对应的 inline cache 收集接收者的类型信息</li><li>每个函数和块的执行计数器记录代码热点</li></ul><p>当一个函数的执行计数数达到某个阈值时，该函数被提交给 <em>background optimizing compiler</em> 进行优化。</p><p>优化编译以跟未优化编译相同的方式开始：遍历序列化后的 Kernel AST 来为待优化的函数构建未优化的 IL。不过，现在跟直接将 unoptimized IL 转成机器码不同的是，optimizing compiler 将 unoptimized IL 转换成 static single assignment (SSA) 格式的 optimized IL。SSA 格式的 IL 接下来会基于收集到的类型反馈来进行一系列常规的以及 Dart 特有的优化：比如  e.g. inlining, range analysis, type propagation, representation selection, store-to-load and load-to-load forwarding, global value numbering, allocation sinking, etc. 最后，使用 linear scan register allocator 将 optimized IL 转换成机器码。</p><p>优化编译完成后 background compiler 要求 mutator thread 进入一个安全点，并且将优化后的代码关联到待优化的函数。下次函数执行时，它将使用优化后的代码。</p><p>注意：有些函数包含长时间执行的循环，所以在函数运行期间从 unoptimized code 切换到 optimized code 也是有意义的。这个过程称为 <em>on stack replacement</em> (OSR)，它的名字来自于这样一个事实：栈帧从函数的某个版本被透明地替换成同一函数的另一个版本。</p><p><img src="/images/15935012109939.jpg" alt></p><p>源码清单：</p><ul><li>编译器源码见 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler" target="_blank" rel="noopener">runtime/vm/compiler</a> 目录</li><li>编译流水线入口见 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/jit/compiler.cc#L701" target="_blank" rel="noopener">CompileParsedFunctionHelper::Compile</a></li><li>IL 由 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/backend/il.h" target="_blank" rel="noopener">runtime/vm/compiler/backend/il.h</a> 定义</li><li>Kernel-to-IL 的转换从 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/frontend/kernel_binary_flowgraph.cc#L1929" target="_blank" rel="noopener">kernel::StreamingFlowGraphBuilder::BuildGraph</a> 开始</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/stub_code_x64.cc#L1795" target="_blank" rel="noopener">StubCode::GenerateNArgsCheckInlineCacheStub</a> 为 inline-cache stub 生成机器码，<a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/runtime_entry.cc#L1073" target="_blank" rel="noopener">InlineCacheMissHandler</a> 处理 IC 缺失</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/compiler_pass.cc" target="_blank" rel="noopener">runtime/vm/compiler/compiler_pass.cc</a> 定义 optimizing compiler pass 和 order</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/jit/jit_call_specializer.h#L12" target="_blank" rel="noopener">JitCallSpecializer</a> 完成大部分 type-feedback based specialization</li></ul><p>动手尝试！VM 提供一些选项用于控制 JIT，并能 dump 由 JIT 编译的函数的 IL 和机器码.</p><p>Flag    Description<br>–print-flow-graph[-optimized]    Print IL for all (or only optimized) compilations<br>–disassemble[-optimized]    Disassemble all (or only optimized) compiled functions<br>–print-flow-graph-filter=xyz,abc,…    Restrict output triggered by previous flags only to the functions which contain one of the comma separated substrings in their names<br>–compiler-passes=…    Fine control over compiler passes: force IL to be printed before/after a certain pass. Disable passes by name. Pass help for more information<br>–no-background-compilation    Disable background compilation, and compile all hot functions on the main thread. Useful for experimentation, otherwise short running programs might finish before background compiler compiles hot function</p><p>例如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Run test.dart and dump optimized IL and machine code for</span><br><span class="line"># function(s) that contain(s) &quot;myFunction&quot; in its name.</span><br><span class="line"># Disable background compilation for determinism.</span><br><span class="line">$ dart --print-flow-graph-optimized         \</span><br><span class="line">       --disassemble-optimized              \</span><br><span class="line">       --print-flow-graph-filter=myFunction \</span><br><span class="line">       --no-background-compilation          \</span><br><span class="line">       test.dart</span><br></pre></td></tr></table></figure><p>另外需要强调的是 optimizing compiler 是基于对应用执行结果分析而得出的假设来生成优化后的代码的。比如，观察到动态调用只将 <code>C</code> 类作为接收者，会将这个动态调用转换成直接调用，并验证接收者的类型为 <code>C</code>。但是，后续的调用可能打破这种假设：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> printAnimal(obj) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Animal &#123;'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'  <span class="subst">$&#123;obj.toString()&#125;</span>'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'&#125;'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call printAnimal(...) a lot of times with an intance of Cat.</span></span><br><span class="line"><span class="comment">// As a result printAnimal(...) will be optimized under the</span></span><br><span class="line"><span class="comment">// assumption that obj is always a Cat.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++)</span><br><span class="line">  printAnimal(Cat());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now call printAnimal(...) with a Dog - optimized version</span></span><br><span class="line"><span class="comment">// can not handle such an object, because it was</span></span><br><span class="line"><span class="comment">// compiled under assumption that obj is always a Cat.</span></span><br><span class="line"><span class="comment">// This leads to deoptimization.</span></span><br><span class="line">printAnimal(Dog());</span><br></pre></td></tr></table></figure><p>任何时候如果 optimized code 做了某种假设，但这些假设并不来自静态不可变信息，则应该防范假设被打破，并且能在打破假设的场景中恢复。</p><p>这种恢复过程称为 <em>deoptimization</em> (反优化)：无论何时当 optimized code 不能处理某种 case 时，简单地切换成 unoptimized code 对应的匹配点并继续执行。unoptimized code 没有做任何假设，所以能处理任何可能的输入。</p><blockquote><p>注意：进入 unoptimized 函数正确的执行点非常重要，因为方法有副作用。比如上面的例子中，deoptimization 发生在调用第一个 <code>print</code> 调用后。Matching instructions that deoptimize to positions in the unoptimized code in VM is done using deopt ids</p></blockquote><p>VM 通常会在 deoptimization 发生时抛弃函数的 optimized 版本，并且在之后使用更新后的 type feedback 重新进行优化。</p><p>VM 有两种方式来防范编译做出的假设被破坏：</p><ul><li>inline check (比如，<code>CheckSmi</code> 和 <code>CheckClass</code> IL 指令) 用于在编译器做出假设的 use site 中验证假设仍然成立。比如，将动态调用转换成直接调用时编译器会在直接调用前增加检查。检查失败时发生的 deoptimization 被称为 <em>eager deoptimization</em>，因为检查后它马上发生</li><li>全局守卫，用于提示运行时在 optimized code 依赖的东西被修改后抛弃这些 optimized code。比如，optimizing compiler 可能发现 <code>C</code> 类没有被其他类继承，并且在类型传递时使用了这个信息。但是接下来动态加载的代码可能引入了一个继承自 <code>C</code> 类的类，所以之前假设不成立。这时运行时需要抛弃所有基于 <code>C</code> 类没有子类这个假设优化得到的 optimized code。运行时可能发现某些失效的 optimized code 在执行栈中，这种情况下受影响的栈帧需要被标记以反优化。这种 deoptimization 称为 <em>lazy deoptimization</em>：因为它会延迟到控制流回到 optimized code 时才发生</li></ul><p>代码清单：</p><ul><li>Deoptimizer 机制见 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/deopt_instructions.cc" target="_blank" rel="noopener">runtime/vm/deopt_instructions.cc</a>。它实际上是一个用于 <em>deoptimization instructions</em> 的迷你解释器，用于描述从 optimized code 状态重建必要的 unoptimized code 状态</li><li><p>Deoptimization 指令由 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/backend/flow_graph_compiler_x64.cc#L68" target="_blank" rel="noopener">CompilerDeoptInfo::CreateDeoptInfo</a> 为 optimized code 中每个潜在的 deoptimization location 生成 deoptimization 指令</p></li><li><p><code>--trace-deoptimization</code> 用于 VM 输出每个 deoptimization 的原因和位置</p></li><li><code>--trace-deoptimization-verbose</code> 用于 VM 为每个 deoptimization instruction 输出一行日志</li></ul><h2 id="从-snapshot-运行"><a href="#从-snapshot-运行" class="headerlink" title="从 snapshot 运行"></a>从 snapshot 运行</h2><p>VM 具备对 isolate 堆(更准确地说是堆中的对象图)序列化成二进制 <em>snapshot</em> 的能力。snapshot 可用于启动 VM isolate 时重建相同状态。</p><p><img src="/images/15935061109366.jpg" alt></p><p>snapshot 使用低级格式，便于快速启动。它实际上是待创建对象的列表，以及如何联系这些对象的指令。snapshot 背后的初始思想是：相比解析 Dart 源码来逐步创建 VM 内部数据结构，VM 可以快速从 snapshot 得到所有必要的数据结构来启动 isolate。</p><p>最初，snapshot 中并不包含机器码。后来随着 AOT compiler 的开发，snapshot 中也可包含机器码。开发 AOT compiler 以及 snapshots-with-code 的目的是允许 VM 用于 JITing 不可用(平台本身限制)的那些平台。</p><p>snapshots-with-code 跟普通 snapshot 几乎相同，一个小的区别在于：前者包含一个 code section，这个区域跟其他区域不同，并不需要反序列化。code section 允许映射到内存时直接作为 heap 的一部分。</p><p><img src="/images/15935067498616.jpg" alt></p><p>代码清单：</p><ul><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/clustered_snapshot.cc" target="_blank" rel="noopener">runtime/vm/clustered_snapshot.cc</a> 处理 snapshot 的序列化与反序列化。有一系列 Dart_CreateXyzSnapshot[AsAssembly] 方法用于将 heap 导出成 snapshot，例如 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/dart_api_impl.cc#L6238" target="_blank" rel="noopener">Dart_CreateAppJITSnapshotAsBlobs</a> 和 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/dart_api_impl.cc#L5986" target="_blank" rel="noopener">Dart_CreateAppAOTSnapshotAsAssembly</a></li></ul><h2 id="从-AppJIT-snapshot-运行"><a href="#从-AppJIT-snapshot-运行" class="headerlink" title="从 AppJIT snapshot 运行"></a>从 AppJIT snapshot 运行</h2><p>引入 AppJIT snapshot 是为解决大型 Dart 应用的启动时间，例如 <code>dartanalyzer</code> 或 <code>dart2js</code>。这些工具用于小工程时完成实际工作的时间跟 VM 花在 JIT 上的时间一样多(译者注：言下之意是，VM 花了太多时间对大型 Dart 应用进行 JIT 处理，而这些应用用于处理小工程时实际工作本身并不会耗时太多？)</p><p>AppJIT snapshot 可用于处理这种问题：一个应用可以在 VM 使用一些模拟的训练数据运行，之后将生成的代码和 VM 内部数据结构序列化成 AppJIT snapshot。不同于以源码和 Kernel binary 形式来分发应用，而是分发 AppJIT snapshot。当在实际数据上执行时的 execution profile 无法匹配到训练阶段时观察到的 execution profile，从这种 snapshot 启动的 VM 仍然可以 JIT—</p><p><img src="/images/15935079364904.jpg" alt></p><p>动手尝试！给 <code>dart</code> 命令传 <code>--snapshot-kind=app-jit --snapshot=path-to-snapshot</code> 参数会生成 AppJIT snapshot。如下的例子为 <code>dart2js</code> 生成和使用 AppJIT snapshot。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run from source in JIT mode.</span></span><br><span class="line">$ dart pkg/compiler/lib/src/dart2js.dart -o hello.js hello.dart</span><br><span class="line">Compiled 7,359,592 characters Dart to 10,620 characters JavaScript <span class="keyword">in</span> 2.07 seconds</span><br><span class="line">Dart file (hello.dart) compiled to JavaScript: hello.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># Training run to generate app-jit snapshot</span></span><br><span class="line">$ dart --snapshot-kind=app-jit --snapshot=dart2js.snapshot \</span><br><span class="line">       pkg/compiler/lib/src/dart2js.dart -o hello.js hello.dart</span><br><span class="line">Compiled 7,359,592 characters Dart to 10,620 characters JavaScript <span class="keyword">in</span> 2.05 seconds</span><br><span class="line">Dart file (hello.dart) compiled to JavaScript: hello.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run from app-jit snapshot.</span></span><br><span class="line">$ dart dart2js.snapshot -o hello.js hello.dart</span><br><span class="line">Compiled 7,359,592 characters Dart to 10,620 characters JavaScript <span class="keyword">in</span> 0.73 seconds</span><br><span class="line">Dart file (hello.dart) compiled to JavaScript: hello.js</span><br></pre></td></tr></table></figure><h2 id="从-AppAOT-snapshot-运行"><a href="#从-AppAOT-snapshot-运行" class="headerlink" title="从 AppAOT snapshot 运行"></a>从 AppAOT snapshot 运行</h2><p>AOT snapshot 初始是为无法开启 JIT 编译的平台引入的，但它们也可用于快速启动以及性能强一致性(可接受潜在性能损失)的场景。</p><blockquote><p>关于 JIT 和 AOT 性能特性之间的比较常常有很多混淆。JIT 能访问到准确的本地类型信息，以及应用运行期间的 execution profile，但它付出的代价是较慢的预热过程。AOT 可以推断和验证全局属性(代价是较长的编译时间)，但没有应用如何实际执行的信息。换句话说，AOT 编译的代码实际没有预热过程，启动后几乎就能达到性能峰值。当前 Dart VM JIT 有最好的性能峰值，而 Dart VM AOT 有最短的启动时间。</p></blockquote><p>无法 JIT 意味着：</p><ol><li>AOT snapshot 必须包含应用执行期间每个可能被调用的函数的可执行代码</li><li>这些可执行代码不能依赖任何在执行期间可能被违反的假设</li></ol><p>为了满足这些需求，AOT 编译时会进行全局静态分析(<em>type flow analysis</em>，TFA)以确定从一些已知的入口出发，应用的哪些部分是可达的；会分配哪些类的实例；以及程序的 type flow 是怎样的。所有这些分析都是保守的：即它们更看重正确性。这与 JIT 更看重高性能是截然不同的。JIT 总是可以在必要时”反优化”到 unoptimized code 来实现正确的行为。</p><p>所有潜在可达的函数被编译成 native code，不做任何推测优化(All potentially reachable functions are then compiled to native code without any speculative optimizations)。当然，仍然会使用 type flow 信息对代码进行处理(比如，取消虚调用 devirtualize calls)。</p><p>所以函数编译完成后生成 snapshot。生成的 snapshot 可以在 <em>precompiled runtime</em>，这是一个特别的 Dart VM，没有 JIT 组件及动态加载代码的能力。</p><p><img src="/images/15935100043901.jpg" alt></p><p>源码清单：</p><ul><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/vm/lib/transformations/type_flow/transformer.dart" target="_blank" rel="noopener">package:vm/transformations/type_flow/transformer.dart</a> 是 type flow 分析及基于 TFA 转换的入口</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/aot/precompiler.cc#L190" target="_blank" rel="noopener">Precompiler::DoCompileAll</a> 是   VM 中 AOT 编译循环(the AOT compilation loop in the VM)的入口</li></ul><p>动手尝试！目前 Dart SDK 并不包含 AOT 编译流水线，那些依赖这个特性的项目(比如 Flutter)必须自行从 SDK 构建这个功能。<a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/vm/tool/precompiler2" target="_blank" rel="noopener">pkg/vm/tool/precompiler2</a> 脚本是个不错的参考，它演示了流水线是如何组织的，哪些二进制产物必须被构建。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Need to build normal dart executable and runtime for running AOT code.</span></span><br><span class="line">$ tool/build.py -m release -a x64 runtime dart_precompiled_runtime</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now compile an application using AOT compiler</span></span><br><span class="line">$ pkg/vm/tool/precompiler2 hello.dart hello.aot</span><br><span class="line"></span><br><span class="line"><span class="comment"># Execute AOT snapshot using runtime for AOT code</span></span><br><span class="line">$ out/ReleaseX64/dart_precompiled_runtime hello.aot</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><p>注意：如果想检查生成的 AOT 代码，类似 <code>--print-flow-graph-optimized</code> 或 <code>--disassemble-optimized</code> 这些参数也可以传给 <code>precompiler2</code> 脚本。</p><h1 id="Runtime-System"><a href="#Runtime-System" class="headerlink" title="Runtime System"></a>Runtime System</h1><p>敬请期待 (译者注：原文还在完善中)</p><h1 id="Object-Model"><a href="#Object-Model" class="headerlink" title="Object Model"></a>Object Model</h1><p>敬请期待 (译者注：原文还在完善中)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自 &lt;a href=&quot;https://mrale.ph/dartvm/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dart VM&lt;/a&gt;，非常详细地介绍了 Dart 代码运行机制。&lt;br&gt;
    
    </summary>
    
    
      <category term="Dart" scheme="http://www.sunmoonblog.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>(译) 使用 DevTools 分析 Flutter 内存</title>
    <link href="http://www.sunmoonblog.com/2020/06/29/flutter-memory/"/>
    <id>http://www.sunmoonblog.com/2020/06/29/flutter-memory/</id>
    <published>2020-06-29T12:34:41.000Z</published>
    <updated>2020-11-13T02:18:59.049Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自 <a href="https://raw.githubusercontent.com/flutter/website/master/src/docs/development/tools/devtools/memory.md" target="_blank" rel="noopener">Using the Memory view</a>，学习如何使用 DevTools 中的来分析 Flutter 应用的内存。</p><a id="more"></a><p>个人感觉目前 DevTools (0.8.0)还不太稳定，我的 Mac 机器上查看内存一段时间后经常无响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; flutter pub global list</span><br><span class="line">devtools 0.8.0+2</span><br></pre></td></tr></table></figure><h2 id="它是什么"><a href="#它是什么" class="headerlink" title="它是什么?"></a>它是什么?</h2><p>使用类构建方法(比如，<code>new MyClass()</code> 或 <code>MyClass()</code>)分配的 Dart 对象存活于称为堆的内存中。</p><!--DevTools Memory pane lets you peek at how an isolate is usingmemory at a given moment. This pane, using Snapshot andReset, can display accumulator counts. The accumulatorscan be used to study the rate of memory allocations,if you suspect your application is leaking memory or hasother bugs relating to memory allocation.--><p>DevTools 的内存面板用于查看指定时刻时的 isolate 内存。这个面板使用 Snapshot 和 Reset 来展示 accumulator 计数。如果你怀疑应用中存在内存泄漏或其他内存相关的 bug，可以使用 accumulator 分析内存分配情况。</p><!--Memory profiling consists of four parts, each increasingin granularity:--><p>内存分析由四部分组成，精细度从低到高分别是:</p><ul><li>Memory overview chart</li><li>Event timeline</li><li>Snapshot classes</li><li>Class instances</li></ul><!--<p>  <strong>Use [profile mode][] when running your app to analyze performance.</strong><br>  Memory usage is not indicative of release performance unless your<br>  application is run in profile mode. In general, memory usage is<br>  fairly accurate, in relative terms, between debug, release, or<br>  profile modes. Profile mode might show higher absolute memory usage<br>  because a service isolate is created to profile your application.<br>  This isolate won’t exist in release mode. Absolute memory used might<br>  also be higher in debug versus release mode. In release mode,<br>  work can be computed and optimized ahead of time, while in debug<br>  mode that same work might have to be computed at runtime,<br>  requiring more information.<br>–&gt;</p><blockquote><p><strong>分析性能时请以 [profile mode][<a href="https://flutter.dev/docs/testing/build-modes#profile]">https://flutter.dev/docs/testing/build-modes#profile]</a> 启动应用。</strong> 除非以 profile mode 运行，否则看到的内存使用量并不代表实际发布模式的内存使用量。无论是 debug, release 还是 profile 模式，测出来的内存值都是相当准确的。不过由于要启动一个 service isolate 用于分析应用，所以 profile mode 可能会显示更高的绝对内存使用量。这个 isolate 在发布模式下并不存在。相比发布模式，debug 模式的绝对内存使用量也会更高。在发布模式中，可以提前进行计算或优化处理，而在 debug 模式中相同工作只能在运行时进行，所以需要更多信息(译者注: 也意味占用更多内存)。</p></blockquote><!--## Memory anatomy--><h2 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h2><!--Use a timeseries graph to visualize the state of the Flutter memoryat successive intervals of time. Each data point on the chartcorresponds to the timestamp (x-axis) of measured quantities (y-axis)of the heap, for example, usage, capacity, external, garbagecollection, and resident set size.--><p>使用时间序列图形来可视化一段连续时间内的 Flutter 内存状态。图表中的每个数据点分别对应堆(heap)的时间戳(x轴)和测量值(y轴)。测量值有多种，比如 usage, capacity, external, garbage<br>collection, 和 resident set size</p><p><img src="/images/15952331308847.jpg" alt></p><!--<dl markdown="1"><dt markdown="1">**Legend**</dt><dd>All collected measurements regarding the memory.    Clicking a legend name hides or shows that data.</dd><dt markdown="1">**Range selector**</dt><dd>All memory data collected (timeseries).    The left-most or first time/data (memory information),    in the selector is when the application was launched.    The right-most or last time/data is the continual memory    information being received (live) until the application is    stopped.</dd><dt markdown="1">**Range selector view**</dt><dd>Detailed view of the data collected    for this timeseries range (non-gray area).</dd><dt markdown="1">**X-axis timestamp**</dt><dd>Time of the collected memory information    (capacity, used, external, RSS (resident set size),    and GC (garbage collection).</dd><dt markdown="1">**Hover information of collected data**</dt><dd>At a particular time (x-axis) the detailed collected    memory data.</dd><dt markdown="1">**Garbage collection occurred**</dt><dd>Compaction of the heap occurred.</dd><dt markdown="1">**Event timeline**</dt><dd>When a user action occurred (such as the    Snapshot or Reset button being clicked).</dd><dt markdown="1">**Snapshot**</dt><dd markdown="1">Display a table of current active    memory objects (see    [Snapshot classes](#snapshot-classes)).<dt markdown="1">**Reset accumulator**</dt><dd markdown="1">Reset values, to zero, under the    Accumulator column in the Snapshot classes table.<dt markdown="1">**Filtering classes**</dt><dd>PENDING</dd><dt markdown="1">**Snapshot classes**</dt><dd>Clicking the Snapshot button (top right area)    displays a table of current memory objects.    The memory objects can be sorted by class name,    size, allocated instances, and so on.</dd><dt markdown="1">**Accumulator counts since reset**</dt><dd>Clicking the Reset button (top right area) resets    the accumulated instances count. Clicking Snapshot    after a reset displays the number of new instances    allocated since last reset.    This is useful for finding memory leaks.</dd><dt markdown="1">**Class instances**</dt><dd>Clicking a class in the Snapshot class table    displays the number of active instances for that class.</dd><dt markdown="1">**Inspecting contents of an instance**</dt><dd>PENDING</dd><dt markdown="1">**Total active objects and classes in the heap**</dt><dd>Total classes allocated in the heap and total objects    (instances) in the heap.</dd>--><p><strong>图例</strong></p><p>所有收集到的内存相关的测量值。点击图例名会隐藏或显示对应数据。</p><p><strong>Range selector</strong></p><p>所有收集到的内存数据(时间线)。selector 中最左边/第一个 time/data(或 memory information)对应于应用启动时，最右边/最后一个 time/data 对应于应用结束时收到内存信息。</p><p><strong>Range selector view</strong></p><p>timeserie range 中收集到的的数据的详细视图。</p><p><strong>X轴 时间戳</strong></p><p>收集到内存信息时对应的时间(capacity, used, external, RSS (resident set size),<br>   和 GC (garbage collection)。</p><p><strong>Hover information of collected data</strong></p><p>特定时间(x-axis)详细的内存数据。</p><p><strong>Garbage collection occurred</strong></p><p>Compaction of the heap occurred.</p><p><strong>Event timeline</strong></p><p>用户操作发生的时间 (such as the Snapshot or Reset button being clicked)</p><p><strong>Snapshot</strong></p><p>以表格形式显示内存中存活的对象</p><p><strong>Reset accumulator</strong></p><p>将 Snapshot class 表中 Accumulator 那一列下的值重置为 0</p><p><strong>Filtering classes</strong></p><p>PENDING</p><p><strong>Snapshot classes</strong></p><p>点击右上角的 Snapshot 按钮将显示以表格形式显示内存中的对象。这些对象可以按类名、大小、实例等条件排序。</p><p><strong>Accumulator counts since reset</strong></p><p>点击右上角的 Reset 按钮将重置 accumulated instances count。点击重置之后再点击 Snapshot 将展示上次重置之后新分配的实例。这在查找内存泄漏时非常有用。</p><p><strong>Class instances</strong></p><p>点击 Snapshot class 表中的 class 将展示该类对应的存活实例。</p><p><strong>Inspecting contents of an instance</strong></p><p>PENDING</p><p><strong>Total active objects and classes in the heap</strong></p><p>堆中分配的全部类以及全部对象</p><h2 id="Memory-overview-chart"><a href="#Memory-overview-chart" class="headerlink" title="Memory overview chart"></a>Memory overview chart</h2><p><img src="/images/15952347134525.jpg" alt></p><p>这是一个用于帮助可视化展示不同时间 heap 内存情况的时间序列图。</p><p>图中的 x-axis 是时间线。它在应用运行时每 500ms 读取一次内存值。y-axis 上(从上到下)的分别是：</p><p><strong>Capacity</strong></p><p>当前堆大小</p><p><strong>GC</strong></p><p>是事发生 GC。更多关于 Dart 如何处理 GC 请参考 <a href="https://medium.com/flutter/flutter-dont-fear-the-garbage-collector-d69b3ff1ca30" target="_blank" rel="noopener">Don’t Fear the Garbage Collector</a></p><p><strong>Used</strong></p><p>堆中的 Dart 对象</p><p><strong>External</strong></p><p>不在 Dart 堆中但仍然是总内存的一部分的那部分内存。在 external 内存中的对象是 native object(比如，已解码的图片)。原生系统使用 Dart embedder 向 Dart VM 暴露这些对象。Dart embedder 创建 Dart wrapper 用于 Dart 代码跟这些原生资源通信。</p><!--<dd markdown="1">Memory that is not in the Dart heap but is still part  of the total memory footprint. Objects in external memory would be  native objects (for example, from a memory read from a file,  or a decoded image). The native objects are exposed to the Dart  VM from the native OS (such as Android, Linux, Windows, iOS)  using a Dart embedder. The embedder creates a Dart wrapper with  a finalizer, allowing Dart code to communicate with these native  resources. Flutter has an embedder for Android and iOS.  For more information, see [Dart on the Server][server] or  [Custom Flutter Engine Embedders][embedder].--><p><img src="/images/15952351903784.jpg" alt></p><p>想查看 RSS (resident set size)，在图例中点击 RSS 的名字即可。</p><!--To view RSS (resident set size), click the name of the RSS locatedin the legend.--><ul><li>RSS 显示了进程使用的全部内存。它不包含被 swap out 的内存，但包含已加载的 shared library 内存，以及全部的栈内存和堆内存。</li></ul><!--* The resident set size displays the amount of memory to a process.  It doesn't include memory that is swapped out. It includes memory  from shared libraries that are loaded, as well as all stack and  heap memory.--><!--For more information, see [Dart VM internals][vm].--><p>更多信息请参考 <a href="https://mrale.ph/dartvm/" target="_blank" rel="noopener">Dart VM internals</a>。</p><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p><img src="/images/15952353620278.jpg" alt></p><p>这个图表展示了 DevTools 事件与跟内存时间线的关系。停在时间线的标记上将展示事件发生的时机。这个功能有助于发现可能的内存泄漏。</p><!--This chart displays DevTools events (such as Snapshot and Reset buttonclicks) in relation to the memory chart timeline. Hovering over themarkers in the Event timeline displays the time when the event occurred.This helps identify when a memory leak might have occurred in thetimeline (x-axis).--><!--Clicking the **Snapshot** button shows the current state of the heap withregard to all active classes and their instances. When the **Reset** buttonis pressed, the accumulator for all classes resets to zero.The reset is temporally tied, using a faint blue horizontal bar,to the previous snapshot. Clicking the **Reset** button again resets theaccumulators since the last reset and temporally ties the latestreset to the previous reset.--><p><strong>Snapshot</strong> 按钮将显示当前堆中所有存活的 class 及其实例。点击 <strong>Reset</strong> 按钮时，所有 accumulator 重置成 0。使用浅蓝色水平条将 Reset 跟之前的 Snapshot 连接。再次点击 <strong>Reset</strong> 按钮时重置 accumulator 并且暂时将最新的 reset 跟上次 reset 连接。</p><h2 id="Snapshot-classes"><a href="#Snapshot-classes" class="headerlink" title="Snapshot classes"></a>Snapshot classes</h2><p><img src="/images/15952357576151.jpg" alt></p><p>这个面板显示堆中分配的 class 及其所有实例，已分配内存大小，以及 accumulator (从上次 reset 开始计起)</p><!--This pane shows classes allocated in the heap, total instances,total bytes allocated, and an accumulator of allocations sincethe last reset.--><p><strong>Size</strong></p><p>堆中当前对象占用的全部内存</p><p><strong>Count</strong></p><p>堆中当前对象数量</p><p><strong>Accumulator</strong></p><p>上次 reset 后堆中的对象数量</p><p><strong>Class</strong></p><p>当前 class 的对象数量。点击类名会显示该类的实例列表</p><h2 id="Class-instances"><a href="#Class-instances" class="headerlink" title="Class instances"></a>Class instances</h2><!--Displays a list of class instances by their handle name.[PENDING: add a link to inspecting data values.]--><p>展示类实例列表。</p><h2 id="Memory-actions"><a href="#Memory-actions" class="headerlink" title="Memory actions"></a>Memory actions</h2><p><img src="/images/15952458407426.jpg" alt></p><h3 id="Liveness-of-the-memory-overview-chart"><a href="#Liveness-of-the-memory-overview-chart" class="headerlink" title="Liveness of the memory overview chart"></a>Liveness of the memory overview chart</h3><p><strong>Pause</strong></p><p>暂停 memory overview 以查看当前数据。注意：此时仍然会接收数据；Range selector 继续往右更新。</p><p><strong>Resume</strong></p><p>memory overview 正在运行中，展示最新时间以及最新的内存数据。</p><h3 id="Managing-the-objects-and-statistics-in-the-heap"><a href="#Managing-the-objects-and-statistics-in-the-heap" class="headerlink" title="Managing the objects and statistics in the heap"></a>Managing the objects and statistics in the heap</h3><p><strong>Snapshot</strong></p><p>返回堆中的存活对象列表。Accumulator 那一列展示了上次 reset 后分配对象的数量</p><p><strong>Reset</strong></p><p>重置 Snapshot classes table 中的 Accumulator 列，并刷新数据</p><p><strong>Filter</strong></p><p>Snapshot classes table 只展示选中的 package 下的 class</p><p><strong>GC</strong></p><p>发起 GC</p><!--## Glossary of VM terms--><h2 id="VM-术语汇总"><a href="#VM-术语汇总" class="headerlink" title="VM 术语汇总"></a>VM 术语汇总</h2><!--Here are some computer science concepts that will help you betterunderstand how your application uses memory.--><p>这里是一些有助于你更好理解应用是如何使用内存的计算机科学基础概念。</p><!--<dd>GC is the process of searching the    heap to locate, and reclaim, regions of "dead" memory&mdash;memory    that is no longer being used by an application. This process    allows the memory to be re-used and minimizes the risk of an    application running out of memory, causing it to crash. Garbage    collection is performed automatically by the Dart VM. In DevTools,    you can perform garbage collection on demand by clicking the    GC button.</dd>--><p><dl markdown="1"></dl></p><p><dt markdown="1"><strong>Garbage collection (GC)</strong></dt></p><dd>GC 是指在堆中定位和回收已”死亡”的内存的过程&mdash;即不再被应用使用的内存。这个过程允许内存被重新使用，将应用内存不足导致崩溃的风险最小化。Dart VM 自动回收垃圾。在 DevTools 中可以点击 GC 按钮主动回收垃圾。</dd><br><dt markdown="1"><strong>Heap</strong></dt><br><dd>Dart 对象在内存上动态分配，这块内存称之为堆。堆上分配的对象不再被引用时(由 GC 完成)或应用结束时将会释放。一个对象不被引用时，认为它已死亡。一个对象被引用时，它则是存活的。</dd><br><dt markdown="1"><strong>Isolates</strong></dt><br><dd markdown="1">Dart 通过 isolate 来支持并发。可以将 isolate 理解成无开销的进程。每个 isolate 有自己的内存和代码，它们不会被其他 isolate 影响。详情请参考 [The Event Loop and Dart][event-loop].<br><dt markdown="1"><strong>Memory leak</strong></dt><br><dd>当对象仍然存活(意味着另一个对象引用它)，却不再被使用(即其他对象不应引用它)时认为发生了内存泄漏。这种对象无法被 GC，所以会仍然占用堆空间，导致内存碎片。内存泄漏给 VM 带来不必要的压力，难以调试。</dd><br><dt markdown="1"><strong>Virtual machine (VM)</strong></dt><br><dd>Dart 虚拟机是直接执行 Dart 代码的软件。</dd><p>[embedder]: /flutter/flutter/wiki/Custom-Flutter-Engine-Embedders<br>[vm]: <a href="https://mrale.ph/dartvm/" target="_blank" rel="noopener">https://mrale.ph/dartvm/</a><br>[event-loop]: NaN/articles/archive/event-loop<br>[profile mode]: /docs/testing/build-modes#profile<br>[release mode]: /docs/testing/build-modes#release<br>[debug mode]: /docs/testing/build-modes#debug<br>[Don’t Fear the Garbage Collector]: NaN/flutter-dont-fear-the-garbage-collector-d69b3ff1ca30</p></dd>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自 &lt;a href=&quot;https://raw.githubusercontent.com/flutter/website/master/src/docs/development/tools/devtools/memory.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Using the Memory view&lt;/a&gt;，学习如何使用 DevTools 中的来分析 Flutter 应用的内存。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
      <category term="翻译" scheme="http://www.sunmoonblog.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Dart Protobuf 用法简介</title>
    <link href="http://www.sunmoonblog.com/2020/06/24/dart-protobuf/"/>
    <id>http://www.sunmoonblog.com/2020/06/24/dart-protobuf/</id>
    <published>2020-06-24T02:25:14.000Z</published>
    <updated>2020-11-13T02:18:59.048Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录下如何在 Dart 中使用 Protobuf。</p><a id="more"></a><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developers.google.com/protocol-buffers/docs/reference/dart-generated" target="_blank" rel="noopener">Dart Generated Code</a></li><li><a href="https://github.com/dart-lang/protobuf/tree/master/protoc_plugin" target="_blank" rel="noopener">dart-lang/protobuf</a></li></ul><p>注意点：</p><ul><li>Protobuf 编译器依赖独立安装的<a href="https://github.com/dart-lang/dart-protoc-plugin" target="_blank" rel="noopener">Dart 插件</a>来生成 Dart 代码 <a href="https://developers.google.com/protocol-buffers/docs/reference/dart-generated" target="_blank" rel="noopener">参考来源</a></li><li>Dart 要求 Protobuf 编译器版本为 3.0.0 及以上 <a href="https://github.com/dart-lang/protobuf/tree/master/protoc_plugin" target="_blank" rel="noopener">参考来源</a></li><li>Dart 只支持 <a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">proto3</a> scheme <a href="https://github.com/dart-lang/protobuf/tree/master/protoc_plugin" target="_blank" rel="noopener">参考来源</a> <del>Dart 只支持 <a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">proto2</a> scheme <a href="https://github.com/dart-lang/protobuf/tree/master/protoc_plugin" target="_blank" rel="noopener">参考来源</a></del></li></ul><h1 id="安装和编译"><a href="#安装和编译" class="headerlink" title="安装和编译"></a>安装和编译</h1><p>第一步，安装 Protobuf 编译器。可以从 <a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">Protobuf release</a> 页面下载和安装，也可以 <code>brew install protobuf</code> 安装。</p><p>第二步，安装 Protobuf Dart 插件。</p><ul><li>下载<a href="https://github.com/dart-lang/protobuf.git" target="_blank" rel="noopener">代码</a>。<code>git clone https://github.com/dart-lang/protobuf.git</code></li><li><strong>编译插件</strong>。调用 <code>pub install</code> 编译插件，编译后源码 <code>bin</code> 目录下可以找到 <code>proto-gen-dart</code> 文件。如果出错，可以使用 <code>pub --trace install</code> 查看详细错误日志</li><li>使用插件。将插件配置到 PATH 路径中，或者调用 <code>protoc</code> 时使用 <code>--plugin</code> 参数指定插件路径</li></ul><p>第三步，运行 protoc 编译生成 <code>.proto.dart</code> 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  aproj_pub_proj git:(cm) ✗ protoc --proto_path=proto --dart_out=build/gen --plugin=/Users/xxx/Documents/GitHub/protobuf/protoc_plugin/bin proto/aproj/comm_conn.proto</span><br><span class="line">protoc-gen-dart: program not found or is not executable</span><br><span class="line">--dart_out: protoc-gen-dart: Plugin failed with status code 1.</span><br><span class="line">➜  aproj_pub_proj git:(cm) ✗ protoc --proto_path=proto --dart_out=build/gen --plugin=/Users/xxx/Documents/GitHub/protobuf/protoc_plugin/bin/protoc-gen-dart proto/aproj/comm_conn.proto</span><br><span class="line">/Users/kingcmchen/Documents/GitHub/protobuf/protoc_plugin/bin/protoc-gen-dart: line 3: dart: command not found</span><br><span class="line">--dart_out: protoc-gen-dart: Plugin failed with status code 127.</span><br></pre></td></tr></table></figure><ul><li>第一次出错是因为 <code>--plugin</code> 指定的 Dart 插件路径不正确，应当指定具体文件而不是文件所在的目录</li><li>第二次出错是因为 Dart 插件依赖 <code>dart</code> 命令，要确保 PATH 中有配置 <code>dart</code>。 </li></ul><p>PATH 中配置 <code>dart</code> 命令方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DART_PATH=&quot;$HOME/flutter/bin/cache/dart-sdk/bin&quot;</span><br></pre></td></tr></table></figure><p>编译成功！</p><p><img src="media/15635014696032/15635045817933.jpg" alt="-w770"></p><h1 id="发送字符串"><a href="#发送字符串" class="headerlink" title="发送字符串"></a>发送字符串</h1><p>先使用 Dart 实现简单的服务器端 <code>SimpleServer</code> 和客户端 <code>SimpleClient</code>，代码分别如下。</p><p><code>SimpleServer</code> 收到客户端发送的数据，转换成大写的 UTF-8 后发回客户端，并关闭 Socket。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  ServerSocket serverSocket =</span><br><span class="line">      <span class="keyword">await</span> ServerSocket.bind(InternetAddress.anyIPv4, <span class="number">6760</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Started'</span>);</span><br><span class="line"></span><br><span class="line">  serverSocket.listen((Socket socket) &#123;</span><br><span class="line">    socket.listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; event) <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> msg = utf8.decode(event);</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Received <span class="subst">$msg</span>'</span>);</span><br><span class="line">      socket.write(msg.toUpperCase());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">await</span> socket.close();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SimpleClient</code> 向服务器端发送 ‘hello’，并且接收和输出服务器端的响应。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  Socket socket = <span class="keyword">await</span> Socket.connect(<span class="string">'127.0.0.1'</span>, <span class="number">6760</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Connected'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// listen to the received data event stream</span></span><br><span class="line">  socket.listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; event) &#123;</span><br><span class="line">    <span class="built_in">print</span>(utf8.decode(event));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send hello</span></span><br><span class="line">  socket.add(utf8.encode(<span class="string">'hello'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait 5 seconds</span></span><br><span class="line">  <span class="keyword">await</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .. and close the socket</span></span><br><span class="line">  socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="发送-Protobuf-数据"><a href="#发送-Protobuf-数据" class="headerlink" title="发送 Protobuf 数据"></a>发送 Protobuf 数据</h1><p>如何在使用 Protobuf 数据在 <code>SimpleServer</code> 和 <code>SimpleClient</code> 之间通信？</p><p>注意，生成的 <code>.pb.dart</code> 文件中有如下 <code>import</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:fixnum/fixnum.dart&apos;;</span><br><span class="line">import &apos;package:protobuf/protobuf.dart&apos; as $pb;</span><br></pre></td></tr></table></figure><p>所以相应地需要在 <code>pubspec.yaml</code> 中添加对应的依赖。</p><p>第一步，为工程添加 <code>fixnum</code> 和 <a href="https://pub.dev/packages/protobuf" target="_blank" rel="noopener">protobuf</a> 依赖。添加后记得运行 <code>flutter pb get</code> 同步一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  http: 0.12.0+2</span><br><span class="line">  fixnum: 0.10.9</span><br><span class="line">  protobuf: 0.13.15</span><br></pre></td></tr></table></figure><p>第二步，将生成的 <code>.pb.dart</code> 文件拷贝到工程，供 <code>SimpleServer</code> 和 <code>SimpleClient</code> 引用。</p><p>第三步，修改服务器端 <code>SimpleServer</code> 和客户端 <code>SimpleClient</code> 代码，使用 Protobuf 通信。修改后的代码分别如下：</p><p><code>SimpleServer</code> 收到客户端发送的 Protobuf 数据并以 JSON 格式打印出来，然后向客户端发送 Protobuf 数据 <code>CommRsp</code>，最后关闭 Socket。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'comm_conn.pb.dart'</span>;</span><br><span class="line"></span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  ServerSocket serverSocket =</span><br><span class="line">      <span class="keyword">await</span> ServerSocket.bind(InternetAddress.anyIPv4, <span class="number">6760</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Started'</span>);</span><br><span class="line"></span><br><span class="line">  serverSocket.listen((Socket socket) &#123;</span><br><span class="line">    socket.listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; event) <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> msg = CommReq.fromBuffer(event).writeToJson();</span><br><span class="line"></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Received <span class="subst">$msg</span>'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> rsp = CommRsp.create();</span><br><span class="line">      rsp.cmd = <span class="number">0</span>;</span><br><span class="line">      rsp.result = <span class="number">0</span>;</span><br><span class="line">      rsp.uid = <span class="string">'41006'</span>;</span><br><span class="line">      <span class="comment">// socket.write(writeToBuffer);</span></span><br><span class="line">      socket.add(rsp.writeToBuffer());</span><br><span class="line">      socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SimpleClient</code> 向服务器端发送 Protobuf 数据 <code>CommReq</code>，并且接收和打印服务器端的响应。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'comm_conn.pb.dart'</span>;</span><br><span class="line"></span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  Socket socket = <span class="keyword">await</span> Socket.connect(<span class="string">'127.0.0.1'</span>, <span class="number">6760</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Connected'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// listen to the received data event stream</span></span><br><span class="line">  socket.listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; event) &#123;</span><br><span class="line">    <span class="built_in">print</span>(CommRsp.fromBuffer(event));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send hello</span></span><br><span class="line">  <span class="keyword">var</span> req = CommReq.create();</span><br><span class="line">  req.cmd = <span class="number">0</span>;</span><br><span class="line">  req.uid = <span class="string">'cm'</span>;</span><br><span class="line">  req.ext1 = <span class="string">'hello'</span>;</span><br><span class="line">  socket.add(req.writeToBuffer());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .. and close the socket</span></span><br><span class="line">  <span class="keyword">await</span> socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意以下两点：</p><ul><li>注意 Protobuf 数据字段分为 required 字段和 optional 字段</li><li>使用 <code>socket.add()</code> 发送数据而不是 <code>socket.write()</code>。注意 <code>socket.write()</code> 先对要发送的数据编码后再调用 <code>socket.add()</code>，实际发送的是编码后的数据</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> write(<span class="built_in">Object</span> obj) &#123;</span><br><span class="line">  <span class="built_in">String</span> string = <span class="string">'<span class="subst">$obj</span>'</span>;</span><br><span class="line">  <span class="keyword">if</span> (string.isEmpty) <span class="keyword">return</span>;</span><br><span class="line">  add(_encoding.encode(string));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何在 Dart 中创建和解析 Protobuf 数据，请参考<a href="https://developers.google.com/protocol-buffers/docs/reference/dart-generated" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单记录下如何在 Dart 中使用 Protobuf。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dart" scheme="http://www.sunmoonblog.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>Dart 入门笔记</title>
    <link href="http://www.sunmoonblog.com/2020/06/23/dart-basic/"/>
    <id>http://www.sunmoonblog.com/2020/06/23/dart-basic/</id>
    <published>2020-06-23T12:41:26.000Z</published>
    <updated>2020-11-13T02:18:59.048Z</updated>
    
    <content type="html"><![CDATA[<p>Dart 基础知识笔记。</p><a id="more"></a><h1 id="tour"><a href="#tour" class="headerlink" title="tour"></a>tour</h1><p><a href="http://s0dart0dev.icopy.site/guides/language/language-tour" target="_blank" rel="noopener">http://s0dart0dev.icopy.site/guides/language/language-tour</a></p><ul><li><code>main()</code> 函数是 Dart 程序的入口</li><li><code>main()</code> 函数返回 <code>void</code> 并具有可选的 <code>List&lt;String&gt;</code> 参数作为参数</li><li>所有对象都从 <code>Object</code> 类继承</li><li>Dart 是强类型</li><li>当您想明确地不希望有任何类型时，使用特殊类型 <code>dynamic</code></li><li>Dart 可以在函数内创建函数（ 嵌套 函数或局部函数 ），可以创建匿名函数</li><li>Dart 支持顶级变量</li><li>标识符以下划线（_）开头时表示私有成员变量</li><li>Dart 支持类型推断，<code>var name = &#39;Bob&#39;;</code> 这里的 name 类型推断为 String</li><li>未初始化的变量的初始值为 <code>null</code>，包括数字类型</li><li>Dart 字符串是 UTF-16 代码单元(code unit)的序列，在字符串中表示32位 Unicode 值时需要特殊语法 <code>Runes</code></li><li>在字符串前添加 r 来创建”原始”字符串，<code>var s = r&#39;In a raw string</code></li><li>在Dart中，数组是 <code>List</code> 对象</li><li>Dart 支持集合字面量，<code>var halogens = {&#39;fluorine&#39;, &#39;chlorine&#39;}</code></li><li><code>{}</code> 默认为 Map 类型，<code>var names = {};</code> 创建了 <code>Map</code> 而不是 <code>Set</code></li><li>Dart <code>new</code> 关键字是可选的 (Dart 2开始)</li><li>Dart 中函数也是对象，其类型为 <code>Function</code>，可以将函数分配给变量或作为参数传递给其他函数</li><li>Dart 中的箭头语法 <code>=&gt; expr</code> 用于简化仅包含一个表达式的函数</li><li>Dart 函数可以具有两种类型的参数： required和optional . 首先列出必需的参数，然后列出所有可选参数</li><li>Dart 函数的可选参数可以是命名参数，也可以是位置参数</li><li>Dart 函数可以使用 <code>=</code> 来定义命名参数和位置参数的默认值。默认值必须是编译时常量</li><li><code>~/</code> 返回除法的整数结果</li><li>Dart 中的 <code>switch</code> 语句使用 <code>==</code> 比较整数、字符串、枚举或编译时常量</li><li>Dart的所有异常都是未经检查的异常</li><li>Dart 提供 <code>Exception</code> 和 <code>Error</code> 类型，并且支持将任何非 <code>null</code> 对象作为异常抛出</li><li>某些语言（例如Java）将文件的组织与类的组织联系在一起-每个文件只能定义一个顶级类. Dart没有此限制</li><li>Dart 是一种具有类和基于 Mixin 的继承的面向对象语言</li><li>Object 的 <code>runtimeType</code> 属性返回对象类型</li><li>所有实例变量都会生成一个隐式的 getter 方法. 非 final 的实例变量还会生成隐式的 setter 方法</li><li>Dart 中每个类都隐式定义一个接口</li><li>Dart 泛型在运行时会携带其类型信息 (相反，Java中 的泛型使用了 erasure ，这意味着在运行时会删除泛型类型参数. 在 Java 中，您可以测试对象是否为 List，但不能测试对象是否为 List<string> )</string></li><li>Dart 使用 async 和 await 关键字支持异步编程，使您可以编写看起来类似于同步代码的异步代码</li><li>可以使用 Future API 或 <code>async/await</code> 关键字处理 Future 结果</li><li>可以使用 Stream API 或 <code>await for</code> 处理 Stream 结果</li><li>仅 dart2js 支持延迟加载库. Flutter，Dart VM和dartdevc不支持延迟加载</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟导入库</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:greetings/hello.dart'</span> <span class="keyword">deferred</span> <span class="keyword">as</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用库</span></span><br><span class="line">Future greet() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> hello.loadLibrary();</span><br><span class="line">  hello.printGreeting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>开发过程中可以使用 <code>assert(condition , optionalMessage)</code> 断言，检查某些条件是否为真。断言通常由工具或框架决定是否生效：</p><ul><li>Flutter 在 debug 模式下启用断言</li><li>默认情况下，仅开发工具（例如 <a href="http://s0dart0dev.icopy.site/tools/dartdevc" target="_blank" rel="noopener">dartdevc</a>）启用断言</li><li>某些工具，比如 <a href="http://s0dart0dev.icopy.site/server/tools/dart-vm" target="_blank" rel="noopener">dart</a> 通过 <code>--enable-asserts</code> 标志启用断言</li></ul><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>Dart 中的构造函数跟 Java 中的构造函数还是有不小的区别，所以值得独立作为一节来讨论。</p><p>这里先列出了 Dart 构造函数相关的一些术语。</p><ul><li>Default constructors</li><li>Named constructors</li><li>Initializer list</li><li>Redirecting constructors</li><li>Constant constructors</li><li>Factory constructors</li></ul><p>如果你清楚这些术语，说明你已经基本掌握了 Dart 构造函数，完全可以略过本节。如果不清楚，不妨往下看。</p><p>Dart 中通过创建一个与其类具有相同名称的函数来声明一个构造函数。可以很方便地将构造函数参数赋值给实例变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Syntactic sugar for setting x and y</span></span><br><span class="line">  <span class="comment">// before the constructor body runs.</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dart 中使用命名构造函数可为一个类实现多个构造函数或提供额外的清晰度：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Named constructor</span></span><br><span class="line">  Point.origin() &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建函数的执行顺序如下：</p><ul><li>初始化列表</li><li>超类的无参数构造函数</li><li>主类的无参数构造函数</li></ul><p>注意：如果超类没有未命名，无参数的构造函数，则必须手动调用超类中的构造函数之一</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  Employee() : <span class="keyword">super</span>.fromJson(getDefaultData());</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现并非总是创建其类的新实例的构造函数时，要使用 <code>factory</code> 关键字。示例如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _cache is library-private, thanks to</span></span><br><span class="line">  <span class="comment">// the _ in front of its name.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache =</span><br><span class="line">      &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">return</span> _cache.putIfAbsent(</span><br><span class="line">        name, () =&gt; Logger._internal(name));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mute) <span class="built_in">print</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h1><p>每个类都隐式定义一个接口。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A person. The implicit interface contains greet().</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// In the interface, but visible only in this library.</span></span><br><span class="line">  <span class="keyword">final</span> _name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not in the interface, since this is a constructor.</span></span><br><span class="line">  Person(<span class="keyword">this</span>._name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In the interface.</span></span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">'Hello, <span class="subst">$who</span>. I am <span class="subst">$_name</span>.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An implementation of the Person interface.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Impostor</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> _name =&gt; <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">'Hi <span class="subst">$who</span>. Do you know who I am?'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h1><p>Mixins是在多个类层次结构中重用类代码的一种方式。</p><p>首先看如何实现 mixin。使用 <code>mixin</code> 关键字创建一个扩展自 Object 且不声明构造函数的类。还可以使用 <code>on</code> 关键字来限定可以使用该 mixin 的类</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> Musical &#123;</span><br><span class="line">  <span class="built_in">bool</span> canPlayPiano = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canCompose = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canConduct = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> entertainMe() &#123;</span><br><span class="line">    <span class="keyword">if</span> (canPlayPiano) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Playing piano'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (canConduct) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Waving hands'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Humming to self'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> MusicalPerformer <span class="keyword">on</span> Musician &#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看如何使用 mixin</p><h1 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h1><p>从设计者角度来说是一些锦上添花的语言特性，但从开发者角度来确实很方便。</p><p>类型推断</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">num</span> highScore(<span class="built_in">List</span>&lt;<span class="built_in">num</span>&gt; scores) &#123;</span><br><span class="line">  <span class="keyword">var</span> highest = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> score <span class="keyword">in</span> scores) &#123;</span><br><span class="line">    <span class="keyword">if</span> (score &gt; highest) highest = score;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> highest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展操作符 <code>...</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> list2 = [<span class="number">0</span>, ...list];</span><br><span class="line"><span class="keyword">assert</span>(list2.length == <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>nullable 扩展操作符 <code>...?</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list;</span><br><span class="line"><span class="keyword">var</span> list2 = [<span class="number">0</span>, ...?list];</span><br><span class="line"><span class="keyword">assert</span>(list2.length == <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>命名参数 (Named parameters) <code>paramName : value</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义命名参数</span></span><br><span class="line"><span class="comment">/// Sets the [bold] and [hidden] flags ...</span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定命名参数</span></span><br><span class="line">enableFlags(bold: <span class="keyword">true</span>, hidden: <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>位置参数 (Positional parameters) </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用[]标记一组可选的位置参数</span></span><br><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>级联操作符 <code>..</code>。这个操作符可以节省创建临时变量的步骤。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">querySelector</span>(<span class="string">'#sample_text_id'</span>)</span><br><span class="line">    ..text = <span class="string">'Click me!'</span></span><br><span class="line">    ..onClick.listen(reverseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="string">'apples'</span>, <span class="string">'bananas'</span>, <span class="string">'oranges'</span>];</span><br><span class="line">list.forEach((item) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;list.indexOf(item)&#125;</span>: <span class="subst">$item</span>'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>??=</code> 操作符。这个操作符让代码更简洁</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assign value to b if b is null; otherwise, b stays the same</span></span><br><span class="line">b ??= value;</span><br></pre></td></tr></table></figure><p><code>??</code> 操作符。这个操作符让代码更简洁</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 name 为 null 则返回 'Guest'</span></span><br><span class="line"><span class="built_in">String</span> playerName(<span class="built_in">String</span> name) =&gt; name ?? <span class="string">'Guest'</span>;</span><br></pre></td></tr></table></figure><p><code>?.</code> 操作符，表示有条件的成员访问，最左边的操作数可以为 null</p><p>typedef 用于给函数类型提供一个名称</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Compare = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedCollection</span> </span>&#123;</span><br><span class="line">  Compare compare;</span><br><span class="line"></span><br><span class="line">  SortedCollection(<span class="keyword">this</span>.compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initial, broken implementation.</span></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  SortedCollection coll = SortedCollection(sort);</span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> <span class="built_in">Function</span>);</span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> Compare);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h1><ul><li>使用 <code>operator</code> 来重载操作符</li><li>noSuchMethod</li><li>callable class。对于实现了 <code>call()</code> 方法的类，可以像调用函数一样调用该类的实例</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://renato.athaydes.com/posts/interesting-dart-features.html#quick-dart-overview" target="_blank" rel="noopener">https://renato.athaydes.com/posts/interesting-dart-features.html#quick-dart-overview</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dart 基础知识笔记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dart" scheme="http://www.sunmoonblog.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 引擎编译、运行与调试</title>
    <link href="http://www.sunmoonblog.com/2020/06/10/compile-flutter-engine/"/>
    <id>http://www.sunmoonblog.com/2020/06/10/compile-flutter-engine/</id>
    <published>2020-06-10T11:36:30.000Z</published>
    <updated>2020-11-13T02:18:59.048Z</updated>
    
    <content type="html"><![CDATA[<p>介绍 Flutter 引擎编译、运行与调试的操作步骤。<br><a id="more"></a></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ul><li>安装 <a href="https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html#_setting_up" target="_blank" rel="noopener"><code>depot_tools</code></a> 并<font color="red">添加到环境变量</font>。<code>gclient</code> 来自 depot_tools 工具</li><li>fork <a href="https://github.com/flutter/engine" target="_blank" rel="noopener">flutter/engine</a> (注意配置 ssh 访问)</li><li>创建空的 <code>engine</code> 目录并在目录中创建 <code>.gclient</code> 配置文件</li><li>在 <code>engine</code> 目录中执行 <code>gclient sync</code> (它会 <code>git clone</code> 必要的项目及其依赖)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line"><span class="built_in">export</span> PATH=/path/to/depot_tools:<span class="variable">$PATH</span></span><br><span class="line">mkdir engine</span><br><span class="line"><span class="built_in">cd</span> engine</span><br><span class="line">touch .gclient</span><br><span class="line"></span><br><span class="line"><span class="comment"># edit .gclient</span></span><br><span class="line">gclient sync</span><br></pre></td></tr></table></figure><p><code>.gitclient</code> 配置如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">solutions = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"managed"</span>: False,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"src/flutter"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"https://github.com/&lt;your_name&gt;/engine.git"</span>,</span><br><span class="line">    <span class="attr">"custom_deps"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"deps_file"</span>: <span class="string">"DEPS"</span>,</span><br><span class="line">    <span class="attr">"safesync_url"</span>: <span class="string">""</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><font color="red">切换源码</font>。编译前的一个重要操作是将源码切换到 <strong>本地 Flutter SDK</strong> 的 engine version  (一个 commit id) 对应的提交点，避免可能出现的报错</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地 Flutter SDK 引擎版本, 这个文件中是包含对应的 commit id </span></span><br><span class="line">vim src/flutter/bin/internal/engine.version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整代码</span></span><br><span class="line"><span class="built_in">cd</span> engine/src/flutter</span><br><span class="line">git reset --hard &lt;commit id&gt;</span><br><span class="line">gclient sync -D --with_branch_heads --with_tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备构建文件</span></span><br><span class="line"><span class="built_in">cd</span> engine/src</span><br><span class="line"></span><br><span class="line"><span class="comment"># flutter 1.12 使用以下命令生成 host_debug_unopt 编译配置</span></span><br><span class="line"><span class="comment"># ./flutter/tools/gn --runtime-mode debug</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># flutter 1.17 使用以下命令生成 host_debug_unopt 编译配置</span></span><br><span class="line">./flutter/tools/gn --unoptimized</span><br><span class="line"></span><br><span class="line"><span class="comment"># android arm (armeabi-v7a) 编译配置</span></span><br><span class="line">./flutter/tools/gn --android --unoptimized</span><br><span class="line"></span><br><span class="line"><span class="comment"># android arm64 (armeabi-v8a) 编译配置</span></span><br><span class="line">./flutter/tools/gn --android --unoptimized --runtime-mode=debug --android-cpu=arm64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">ninja -C out/host_debug_unopt -j 16</span><br><span class="line">ninja -C out/android_debug_unopt -j 16</span><br><span class="line">ninja -C out/android_debug_unopt_arm64 -j 16</span><br></pre></td></tr></table></figure><p>尤其注意这里的 <code>ninja -C out/host_debug_unopt</code> 命令。官方文档提到它是必要的：</p><blockquote><p>Note that if you use particular android or ios engine build, you will need to have corresponding host build available next to it: if you use android_debug_unopt, you should have built host_debug_unopt, android_profile -&gt; host_profile, etc.</p></blockquote><p>这个命令的编译结果包含 <code>dart-sdk</code>，使用自己构建的 Flutter 引擎编译 App 时会调用 <code>dart-sdk</code> 中相关工具。</p><p>编译完成后的目录如下：</p><p><img src="/images/15917899522184.jpg" alt="编译后的Flutter产物"></p><h2 id="常见编译问题"><a href="#常见编译问题" class="headerlink" title="常见编译问题"></a>常见编译问题</h2><p>编译 Flutter 其实并不复杂，运气好的话不会遇到任何问题，运气不好的话会遇到一些错误。不过出错通常是因为环境问题。</p><p>如果遇到错误，不妨先检查以下几项：</p><ul><li>确认当前使用的是 <font color="red">Python 2.7</font> - <code>flutter/tools/gn</code> 依赖的是 Python 2。如果当前环境中使用 Python 3 会出现各种诡异错误</li><li>确认已经将 <code>depot_tools</code> 工具添加到环境变量 - <code>depot_tools</code> 工具包含几个用于编译 Flutter 引擎的命令 <code>gclient</code> 和 <code>ninja</code>。如果找不到这些命令，也会编译失败</li><li>切换引擎源码 - Flutter 引擎源码和本地 Flutter SDK 不匹配时可能会编译失败，编译前应确认已经将 Flutter 引擎源码切换到对应的提交点</li></ul><h3 id="Python-版本问题"><a href="#Python-版本问题" class="headerlink" title="Python 版本问题"></a>Python 版本问题</h3><p>这里简单记录一下我<strong>编译 Flutter 引擎时遇到的 Python 版本问题及解决方法</strong>。如果你没有遇到 Python 版本问题，可以直接忽略这一节。</p><p>我的 MacBook 系统内置了 Python 2.7，安装的第三方软件 Anaconda 自带的 Python 3.7。命令行下 <code>python</code> 默认的是 Anaconda 的 Python 3.7，不做任何处理时调用 <code>flutter/tools/gn</code> 会报 Python 语法错误。</p><p>推荐使用 <a href="https://pypi.org/project/virtualenv/" target="_blank" rel="noopener">virtualenv</a> 来为 Flutter 引擎源码工程创建虚拟的 Python 2.7 环境，激活该环境后再来编译 Flutter 源码，可以有效避免各种 Python 版本折腾。操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到 Flutter 引擎源码目录</span></span><br><span class="line"><span class="built_in">cd</span> path/to/engine/<span class="built_in">source</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建名为 myenv 的 Python 2.7 环境</span></span><br><span class="line">virtualenv -p /usr/bin/python myenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活 myenv 环境</span></span><br><span class="line"><span class="built_in">source</span> myenv/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 Flutter 引擎</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 myenv 环境</span></span><br><span class="line">deactivate</span><br></pre></td></tr></table></figure><h3 id="缺省头文件"><a href="#缺省头文件" class="headerlink" title="缺省头文件"></a>缺省头文件</h3><p>在云主机(Centos 7)上编译 Flutter 引擎源码时，glfw 库报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">../../third_party/glfw/src/x11_platform.h:39:10: fatal error: &apos;X11/Xcursor/Xcursor.h&apos; file not found</span><br><span class="line">#include &lt;X11/Xcursor/Xcursor.h&gt;</span><br><span class="line">         ^~~~~~~~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure><p><a href="https://www.glfw.org/docs/latest/compile.html#compile_deps_x11" target="_blank" rel="noopener">glfw</a> 提到解决办法如下：</p><blockquote><p> For example, on Ubuntu and other distributions based on Debian GNU/Linux, you need to install the xorg-dev package, which pulls in all X.org header packages.</p></blockquote><p>安装相关的库即可，方式如下(你可能要根据实际情况调整)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install libX11-devel</span><br><span class="line">yum install libXcursor-devel</span><br><span class="line">yum install libXrandr-devel</span><br><span class="line">yum install libXxf86vm-devel</span><br></pre></td></tr></table></figure><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><h2 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>命令行中使用自定义引擎：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 Flutter 工程</span></span><br><span class="line">flutter create --org com.yourdomain your_app_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用本地引擎运行 Flutter App</span></span><br><span class="line">flutter run</span><br><span class="line">  --<span class="built_in">local</span>-engine-src-path &lt;engine path&gt;/src</span><br><span class="line">  --<span class="built_in">local</span>-engine=android_debug_unopt_arm64</span><br></pre></td></tr></table></figure><p>IDE 中使用自定义引擎：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 Flutter 工程</span></span><br><span class="line">flutter create --org com.yourdomain your_app_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Android Studio 中打开 以上工程</span></span><br><span class="line"><span class="comment"># 注意这里是 Android 工程视角，即打开目录为  your_app_name/android</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 gradle.properties 文件中添加 localEngineOut 属性</span></span><br></pre></td></tr></table></figure><p>在 gradle.properties 文件中添加 localEngineOut 属性，配置如下：</p><p><img src="/images/15919469811663.jpg" alt="配置 localEngineOut"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localEngineOut=&lt;engine_dir&gt;/out/android_debug_unopt_arm64</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>应当指定的本地引擎应当跟 Android 系统架构匹配，比如 armeabi-v8a 机器上使用 <code>android_debug_unopt_arm64</code></li><li>尤其注意<font color="red">某些项目通过自行将 Flutter SDK <code>libflutter.so</code> 拷贝到代码库的方式来集成 Flutter，这会导致上述方式失效，实际运行时并不会加载指定的本地引擎</font>。解决方法是将拷贝对应的目录下(如 <code>android_debug_unopt_arm64</code>)的 <code>libflutter.so</code> 覆盖代码库中已有有 <code>libflutter.so</code> 即可</li></ul><h2 id="常见运行错误"><a href="#常见运行错误" class="headerlink" title="常见运行错误"></a>常见运行错误</h2><p>最常见的问题是找不到指定的引擎导致无法运行 Flutter App。原因通常包括：</p><ul><li>引擎文件路径写错</li><li>架构不匹配。以我手头的测试机华为 Nova 2 为例，它要求使用 arm64 类型的引擎，而我编译时没有注意到这一点，选择的是 arm 类型，最后发现引擎架构不匹配</li><li>缺少 <code>host</code> 产物。错误提示如下图</li></ul><p><img src="/images/15917910631520.jpg" alt></p><p>我自己遇到另外一个比较奇特的错误，通常应该不会遇到，但这里也记录下供参考。</p><p>事情经过是这样的：我的 MacBook 硬盘只有 256G，目前空间已经偏紧张，考虑编译 Flutter 引擎占 CPU 影响本地机器性能外加占用太多硬盘空间，所以我突发奇想。</p><ul><li>首先在个人的 Linux 云主机上编译 Flutter 引擎(果然比本地快很多)</li><li>然后将 Linux 云主机的硬盘挂在 MacBook 当本地文件使用</li><li>最后使用远程机器上的 Flutter 引擎运行 App：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载远程机器目录</span></span><br><span class="line">sshfs root@dev-host:/data/github/ ~/RemoteMount</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用远程机器上的 Flutter 引擎</span></span><br><span class="line">flutter run --<span class="built_in">local</span>-engine-src-path ~/RemoteMount/src --<span class="built_in">local</span>-engine=android_debug_unopt_arm6</span><br></pre></td></tr></table></figure><p>最后出错，错误信息如下：</p><p><img src="/images/15917915426079.jpg" alt="无法执行 dart 命令"></p><p>无法执行 dart 命令！Mac 系统当然无法执行 Linux 平台的二进制文件。</p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>断点调试 Flutter 引擎来一步步观察引擎代码如何运行，是学习 Flutter 引擎代码的一个好办法。在介绍如何调试 Flutter 引擎前我们先来看看 Flutter 开发中可能遇到哪些调试场景：</p><ol><li>调试 Flutter App Dart 代码</li><li>调试 Flutter SDK Dart 代码</li><li>调试 Flutter 引擎 Java 代码</li><li>调试 Flutter 引擎 C++ 代码</li></ol><p>第一种场景非常简单，只要在 VS Code 中给 Flutter App 中的 Dart 代码打上断点即可进行调试。</p><p>第二种场景也比较简单，在 VS Code 中配置 Dart &amp; Flutter 插件，允许调试第三方库和 Flutter SDK Dart 代码即可在相关源码中设置断点进行调试</p><p><img src="/images/15919475359354.jpg" alt="允许调试第三方库"></p><h2 id="调试-Java-代码"><a href="#调试-Java-代码" class="headerlink" title="调试 Java 代码"></a>调试 Java 代码</h2><p>再来看第三种场景，调试 Flutter 引擎中的 Java 代码。主要是参考以下资料(建议动手操作一下)：</p><ul><li><a href="https://github.com/flutter/flutter/wiki/Debugging-the-engine#debugging-android-builds-with-android-studio" target="_blank" rel="noopener">Debugging Android builds with Android Studio</a> </li></ul><p>步骤如下：</p><ul><li>第一步，将 <code>engine/src/flutter/shell/platform/android</code> 工程(称之为<em>Flutter 引擎工程</em>)导入到 Android Studio。注意一定是这个目录！另外，确认该工程的 Android SDK 和 JDK 版本正确 (当前分别是 29 和 8)</li><li>第二步，使用自定义 Flutter 引擎运行 Flutter App(称之为<em>Flutter App 工程</em>)，具体见上文描述</li><li>第三步，<em>Flutter 引擎工程</em> 中给源码设置断点并启动 Debugger 连接到已启动的 Flutter App 进程</li></ul><p>各步骤的截图如下：</p><p>第一步，<em>Flutter 引擎工程</em>导入到 Android</p><p><img src="/images/15917938999628.jpg" alt="导入引擎工程"></p><p><img src="/images/15917940191380.jpg" alt="引擎工程结构"></p><p>第二步，Android Studio 中打开<em>Flutter App 工程</em> 并启动 Flutter App</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 创建 Flutter App</span><br><span class="line">flutter create --org com.yourdomain your_app_name</span><br><span class="line"></span><br><span class="line"># 在 Android Studio 中打开 Flutter App 工程</span><br><span class="line"># 注意工程路径是 your_app_name/android</span><br></pre></td></tr></table></figure><p><img src="/images/15919478792182.jpg" alt="Android Studio 中启动 Flutter App"></p><p>第三步，在 <em>Flutter 引擎工程</em> 将 Debugger 连接到已启动 Flutter App</p><p><img src="/images/15917949940372.jpg" alt="AttachDebugger"></p><p><img src="/images/15917950421254.jpg" alt="选择应用进程"></p><p><img src="/images/15917952600049.jpg" alt="进入调试状态"></p><p>有时候，我们想在更早的地方设置断点调试，比如在 libflutter.so 被加载前加断点调试，如何实现？</p><p>技巧在于第二步启动 Flutter App 时选择一个 <em>合适的时机</em>(通常是在断点之前) 调用 <a href="https://developer.android.com/reference/android/os/Debug.html#waitForDebugger(" target="_blank" rel="noopener">Debug.waitForDebugger</a>) 方法让应用启动后进入等待 Debugger 的状态。</p><p>示例：在 <code>Application.onCreate()</code> 中调用 <code>Debug.waitForDebugger()</code>，应用一直处于等待状态，直到有 Debugger 连接上来才继续执行。</p><p><img src="/images/15917945368597.jpg" alt="让应用等待Debugger"></p><p><img src="/images/15917947943674.jpg" alt="应用等待Debugger中"></p><h2 id="调试-C-代码"><a href="#调试-C-代码" class="headerlink" title="调试 C++ 代码"></a>调试 C++ 代码</h2><p>最后来看怎样调试 Flutter 引擎 C++ 代码。主要参考资料是：</p><ul><li><a href="https://fucknmb.com/2019/12/06/Flutter-Engine-C-%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2/" target="_blank" rel="noopener">Flutter Engine C++ 源码调试初探 | 区长</a></li><li><a href="https://xinbaos.github.io/Flutter%20Engine%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/" target="_blank" rel="noopener">Flutter Engine源码调试 | xinbao的书屋</a></li></ul><p>简单来说，是使用 lldb 来调试 Flutter 引擎 C++ 代码。可以使用不同的方式来完成 lldb 调试，但实际操作起都比较麻烦。</p><p>个人理解主要麻烦之处在于，一是如何将 <code>lldb_server</code> 推送到开发设备并运行起来，二是如何从开发机正确地启动 <code>lldb_client</code>。</p><p>从这些麻烦的方法中，我选择了一个相对简单的动手实践了一下并加以总结。步骤概括如下：</p><table><thead><tr><th>步骤</th><th>操作</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>第一步</td><td>编译 Flutter 引擎</td><td>生成自定义引擎用于调试</td><td></td></tr><tr><td>第二步</td><td>导入 Flutter 引擎源码到 VS Code</td><td>支持 Flutter 引擎源码跳转及断点跟踪</td><td>后文称<em>VS Code Flutter 引擎工程</em></td></tr><tr><td>第三步</td><td>安装 VS Code 插件 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools" target="_blank" rel="noopener">C/C++ for Visual Studio Code</a> 和 <a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb" target="_blank" rel="noopener">CodeLLDB</a></td><td>在 VS Code 中集成 lldb 调试功能</td><td></td></tr><tr><td>第四步</td><td>安装 <a href="https://mirrors.tencent.com/AndroidSDK/" target="_blank" rel="noopener">lldb</a> 和 <a href="https://github.com/lizhangqu/flutter_lldb" target="_blank" rel="noopener">flutter_lldb</a></td><td>1、lldb 用于调试 C++ 代码，2、flutter_lldb 用于简化 lldb 的使用</td><td></td></tr><tr><td>第五步</td><td>运行 Flutter App</td><td>加载和运行自定义引擎</td><td><code>flutter run</code> 或 Android Studio 中运行均可</td></tr><tr><td>第六步</td><td>执行 <code>flutter_lldb</code> 命令</td><td>1、生成调试配置参数，2、在调试设备上启动 <code>lldb_server</code></td><td></td></tr><tr><td>第七步</td><td><em>VS Code Flutter 引擎工程</em> 中配置 lldb 调试配置参数</td><td></td><td></td></tr><tr><td>第八步</td><td><em>VS Code Flutter 引擎工程</em> 中设置断点，F5 启动调试</td><td></td></tr></tbody></table><p>为了便于理解和动手操作操作，这里给出一些截图。</p><p>第一步，编译 Flutter 引擎。注意确认已生成 <code>out/host_debug_unopt</code></p><p><img src="/images/15917899522184.jpg" alt="编译后的Flutter产物"></p><p>第二步，导入 Flutter 引擎源码到 VS Code</p><ul><li>先将 <a href="[JSON Compilation Database Format Specification](https://clang.llvm.org/docs/JSONCompilationDatabase.html">engine/src/out/compile_commands.json</a>) 拷贝到 <code>engine/src/flutter/</code></li><li>VS Code 中打开 <code>engine/src/flutter/</code></li></ul><p>第三步，安装 VS Code 插件，集成 lldb 调试功能</p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools" target="_blank" rel="noopener">C/C++ for Visual Studio Code</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb" target="_blank" rel="noopener">CodeLLDB</a></li></ul><p><img src="/images/15920201317113.jpg" alt></p><p>第四步，安装 <a href="https://mirrors.tencent.com/AndroidSDK/" target="_blank" rel="noopener">lldb</a> 和 <a href="https://github.com/lizhangqu/flutter_lldb" target="_blank" rel="noopener">flutter_lldb</a>。</p><p>注意：</p><ul><li>lldb 安装在 Android SDK 中。如 Android SDK 已有 lldb，则可略过这一步</li><li>有一个坑，目前 Android Studio 内置 lldb，但却并不安装在 Android SDK 中，所以外部工具无法方便地调用 AS 内置 lldb，而 Android SDK Manager 软件列表中目前不再提供 lldb 安装，所以只能手工下载和安装 <a href="https://mirrors.tencent.com/AndroidSDK/" target="_blank" rel="noopener">lldb</a> </li></ul><p><img src="/images/15919488081458.jpg" alt></p><p>第五步，运行 Flutter App</p><p>第六步，执行 <code>flutter_lldb</code> 命令</p><p><img src="/images/15919495376462.jpg" alt></p><p><code>flutter_lldb</code> 输出的配置参数类似如下这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"remote_lldb"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"lldb"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"attach"</span>,</span><br><span class="line">            <span class="attr">"pid"</span>: <span class="string">"28006"</span>,</span><br><span class="line">            <span class="attr">"initCommands"</span>: [</span><br><span class="line">                <span class="string">"platform select remote-android"</span>,</span><br><span class="line">                <span class="string">"platform connect unix-abstract-connect:///data/data/com.yourdomain.your_app_name/debug.socket"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"postRunCommands"</span>: [</span><br><span class="line">                <span class="string">"add-dsym /Users/abc/wd/engine/src/out/android_debug_unopt_arm64/libflutter.so"</span>,</span><br><span class="line">                <span class="string">"settings set target.source-map /Users/abc/wd/engine/src /Users/chenming/wd/engine/src"</span></span><br><span class="line">            ],</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>flutter_lldb</code> 脚本基于 Python 2.7，使用前请确认当前 Python 环境</li><li><code>flutter_lldb</code> 脚本与调试设备通信，使用前请确认<font color="red">已连接调试设备且已启动应用</font></li></ul><p>第七步，在 VS Code 中配置 lldb 命令调试参数。直接将上一步中 <code>flutter_lldb</code> 输出的配置参数拷贝到 <code>launch.json</code> 中即可</p><p><img src="/images/15919505100224.jpg" alt></p><p>第八步，<em>VS Flutter 引擎工程</em> 中设置断点，F5 启动调试</p><p>一切正常的话，Debugger 将成功连接应用进程，进入调试状态，如下图：</p><p><img src="/images/15919523220636.jpg" alt="进t入调试状态"></p><p>Debug Console 输出显示已经成功连接到指定的进程</p><p><img src="/images/15919524582827.jpg" alt="成功连接指定的进程"></p><p>千万不要被上述繁琐的步骤吓到了。实际上，第一步到第四步只是准备阶段(只需准备一次)，第五步到第八步才是真正的操作步骤(调试时需反复多次操作)。用一张图来总结下第五步到第八步：</p><p><img src="/images/15919533524350.jpg" alt="-w767"></p><p>操作几次之后，你会发现实际过程更简单。其实并不用真的的每次都要重新配置 <code>launch.json</code>，只不过是修改下 pid 而已。</p><p>UPDATE：使用小米手机能正常调试 Flutter 引擎，但华为手机 Nova 2 上可以成功到 <code>Attached to process</code> 却无法进入调试状态。使用 NDK Sample 中的 HelloJNI 华为 Nova 2 验证，发现也不能正常调试，所以推测是华为手机问题。</p><p>(2020-07-24 更新：以下是 iOS 上调试 Flutter 引擎的步骤)</p><ol><li>将 Flutte Engine 工程的 <code>products.xcodeproj</code> 拖进需要调试的 Flutter Demo 工程目录</li><li><code>Genrated.xcconfig</code> 中添加如下配置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FLUTTER_ROOT=$&#123;FlutterSDK 路径&#125;</span><br><span class="line">FLUTTER_APPLICATION_PATH=$&#123;Demo工程路径&#125;</span><br><span class="line">FLUTTER_TARGET=$&#123;Demo工程路径&#125;/lib/main.dart</span><br><span class="line">FLUTTER_BUILD_DIR=build</span><br><span class="line">SYMROOT=$&#123;SOURCE_ROOT&#125;/../build/ios</span><br><span class="line">FLUTTER_FRAMEWORK_DIR=$&#123;Flutter_Engine代码路径&#125;/src/out/ios_debug_sim_unopt</span><br><span class="line">FLUTTER_BUILD_NAME=1.0.0</span><br><span class="line">FLUTTER_BUILD_NUMBER=1</span><br><span class="line">FLUTTER_ENGINE=$&#123;Flutter_Engine代码路径&#125;</span><br><span class="line">LOCAL_ENGINE=$&#123;输出的路径（ios_debug_sim_unopt）&#125;</span><br><span class="line">ARCHS=$&#123;支持的架构(arm64)&#125;</span><br></pre></td></tr></table></figure><p>之后即可单步调试。</p><!-- 详细步骤见 https://docs.qq.com/doc/DR21rc21wZ0dKUFhu --><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>简单介绍如何编译 Flutter 引擎，以及常见问题</li><li>介绍如何从命令行和 IDE 运行自定义 Flutter 引擎，以及常见问题</li><li>简单介绍如何调试 Flutter App 及 Flutter SDK 中的 Dart 代码</li><li>详细介绍如何调试 Flutter 引擎中的 Java 代码和 C++ 代码</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/flutter/flutter/wiki/Compiling-the-engine" target="_blank" rel="noopener">编译 Flutter 引擎</a></li><li><a href="https://www.jianshu.com/p/ff84455fb451" target="_blank" rel="noopener">Flutter Engine与SDK的定制化与编译 - 简书</a></li><li><a href="https://github.com/flutter/flutter/wiki/Debugging-the-engine#debugging-android-builds-with-android-studio" target="_blank" rel="noopener">Debugging the engine · flutter/flutter Wiki</a></li><li><a href="https://fucknmb.com/2019/12/06/Flutter-Engine-C-%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2/" target="_blank" rel="noopener">Flutter Engine C++ 源码调试初探 | 区长</a></li><li><a href="https://xinbaos.github.io/Flutter%20Engine%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/" target="_blank" rel="noopener">Flutter Engine源码调试 | xinbao的书屋</a></li><li><a href="https://zhuanlan.zhihu.com/p/38626359" target="_blank" rel="noopener">调试Flutter Native Engine初探 - 知乎</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍 Flutter 引擎编译、运行与调试的操作步骤。&lt;br&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Dart File</title>
    <link href="http://www.sunmoonblog.com/2020/06/04/dart-file/"/>
    <id>http://www.sunmoonblog.com/2020/06/04/dart-file/</id>
    <published>2020-06-04T08:55:08.000Z</published>
    <updated>2020-11-13T02:18:59.048Z</updated>
    
    <content type="html"><![CDATA[<p>简单了解 Dart File 类的用法。</p><a id="more"></a><h1 id="Dart-File-类"><a href="#Dart-File-类" class="headerlink" title="Dart File 类"></a>Dart File 类</h1><p>原文见<a href="https://api.dartlang.org/stable/2.4.0/dart-io/File-class.html" target="_blank" rel="noopener">这里</a></p><p>File 表示文件系统中某个文件的引用。</p><p>File 实例是个对象，它持有 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/path.html" target="_blank" rel="noopener">path</a> 并对其进行操作。可以使用 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/FileSystemEntity/parent.html" target="_blank" rel="noopener">parent</a> getter 获取父目录，<code>parent</code> 属性继承自 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/FileSystemEntity-class.html" target="_blank" rel="noopener">FileSystemEntity</a>。</p><p>使用 pathname 创建新的 File 对象来访问文件系统上的文件。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFile = <span class="keyword">new</span> File(<span class="string">'file.txt'</span>);</span><br></pre></td></tr></table></figure><p>File 类包含操作文件及其内容的方法。使用这些方法，可以打开和关闭文件，读写文件，创建和删除文件，以及检查文件是否存在。</p><p>读写文件时，可以使用 stream (通过 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/openRead.html" target="_blank" rel="noopener">openRead</a>)，随机访问操作 (通过 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/open.html" target="_blank" rel="noopener">open</a>)，或者类似 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/readAsString.html" target="_blank" rel="noopener">readAsString</a> 这样的便捷方法。</p><p>File 类中的方法大部分都有同步和异步两种形式，比如 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/readAsString.html" target="_blank" rel="noopener">readAsString</a> 和 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/readAsStringSync.html" target="_blank" rel="noopener">readAsStringSync</a>。除非有特别的理由，通常应当使用异步方法以避免阻塞程序。</p><p>如果构造 File 对象的 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/path.html" target="_blank" rel="noopener">path</a> 是一个符号链接，而非文件，则 File 类的方法会操作链接指向的最终目标文件。不过，<a href="https://api.dartlang.org/stable/2.4.0/dart-io/FileSystemEntity/delete.html" target="_blank" rel="noopener">delete</a> 和 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/FileSystemEntity/deleteSync.html" target="_blank" rel="noopener">deleteSync</a> 方法除外，这两个方法是对符号链接进行操作。</p><h1 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h1><p>下面示例代码使用异步的 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/readAsString.html" target="_blank" rel="noopener">readAsString</a> 方法读取文件，它将整个文件内容视为一个字符串：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">new</span> File(<span class="string">'file.txt'</span>).readAsString().then((<span class="built_in">String</span> contents) &#123;</span><br><span class="line">    <span class="built_in">print</span>(contents);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更灵活更有用的方法是使用 <a href="https://api.dartlang.org/stable/2.4.0/dart-async/Stream-class.html" target="_blank" rel="noopener">Stream</a> 方式读文件。调用 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/openRead.html" target="_blank" rel="noopener">openRead</a> 方法打开文件，该方法返回 stream，这个 stream 以字节块的方式返回文件数据。可以监听 stream 来获取数据并进行必要的处理。可以继续使用不同的 transformer 操作数据来得到想要的数据格式。</p><p>可以使用 stream 方式来读取大文件，并提供 transformer 来操作数据。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">final</span> file = <span class="keyword">new</span> File(<span class="string">'file.txt'</span>);</span><br><span class="line">  Stream&lt;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;&gt; inputStream = file.openRead();</span><br><span class="line"></span><br><span class="line">  inputStream</span><br><span class="line">    .transform(utf8.decoder)       <span class="comment">// Decode bytes to UTF-8.</span></span><br><span class="line">    .transform(<span class="keyword">new</span> LineSplitter()) <span class="comment">// Convert stream to individual lines.</span></span><br><span class="line">    .listen((<span class="built_in">String</span> line) &#123;        <span class="comment">// Process results.</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'<span class="subst">$line</span>: <span class="subst">$&#123;line.length&#125;</span> bytes'</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      onDone: () &#123; <span class="built_in">print</span>(<span class="string">'File is now closed.'</span>); &#125;,</span><br><span class="line">      onError: (e) &#123; <span class="built_in">print</span>(e.toString()); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h1><p>使用 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/writeAsString.html" target="_blank" rel="noopener">writeAsString</a> 方法写文件。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> filename = <span class="string">'file.txt'</span>;</span><br><span class="line">  <span class="keyword">new</span> File(filename).writeAsString(<span class="string">'some content'</span>)</span><br><span class="line">    .then((File file) &#123;</span><br><span class="line">      <span class="comment">// Do something with the file.</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用 <a href="https://api.dartlang.org/stable/2.4.0/dart-async/Stream-class.html" target="_blank" rel="noopener">Stream</a> 来写入文件。调用 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/openWrite.html" target="_blank" rel="noopener">openWrite</a> 方法打开文件，返回结果是 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/IOSink-class.html" target="_blank" rel="noopener">IOSink</a>，可以向 IOSink 写入数据。记得操作完成后调用 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/IOSink/close.html" target="_blank" rel="noopener">IOSink.close</a> 关闭 sink。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> file = <span class="keyword">new</span> File(<span class="string">'file.txt'</span>);</span><br><span class="line">  <span class="keyword">var</span> sink = file.openWrite();</span><br><span class="line">  sink.write(<span class="string">'FILE ACCESSED <span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>\n'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Close the IOSink to free system resources.</span></span><br><span class="line">  sink.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用-Future"><a href="#使用-Future" class="headerlink" title="使用 Future"></a>使用 Future</h1><p>为避免意外阻塞程序，File 类的一些方法使用 <a href="https://api.dartlang.org/stable/2.4.0/dart-async/Future-class.html" target="_blank" rel="noopener">Future</a> 作为返回值。比如，<a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/length.html" target="_blank" rel="noopener">length</a> 方法用于获取文件长度，返回的是 Future。调用 <code>then</code> 方法注册回调函数，获取到文件长度后会回调这个函数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">final</span> file = <span class="keyword">new</span> File(<span class="string">'file.txt'</span>);</span><br><span class="line"></span><br><span class="line">  file.length().then((len) &#123;</span><br><span class="line">    <span class="built_in">print</span>(len);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 <code>length()</code> 外，其他几个方法也返回 Future，包括：<a href="https://api.dartlang.org/stable/2.4.0/dart-io/FileSystemEntity/exists.html" target="_blank" rel="noopener">exists</a>，<a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/lastModified.html" target="_blank" rel="noopener">lastModified</a>，<a href="https://api.dartlang.org/stable/2.4.0/dart-io/FileSystemEntity/stat.html" target="_blank" rel="noopener">stat</a> 等等。</p><h1 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h1><ul><li><a href="https://www.dartlang.org/dart-by-example/#files-directories-and-symlinks" target="_blank" rel="noopener">Dart by Example</a> provides additional task-oriented code samples that show how to use various API from the Directory class and the related File class.</li><li>I<a href="https://www.dartlang.org/docs/dart-up-and-running/ch03.html#dartio---io-for-command-line-apps" target="_blank" rel="noopener">I/O for Command-Line Apps</a> a section from A Tour of the Dart Libraries covers files and directories.</li><li><a href="https://www.dartlang.org/docs/tutorials/cmdline/" target="_blank" rel="noopener">Write Command-Line Apps</a>, a tutorial about writing command-line apps, includes information about files and directories.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单了解 Dart File 类的用法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dart" scheme="http://www.sunmoonblog.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>FutureBuilder 与 StreamBuilder</title>
    <link href="http://www.sunmoonblog.com/2020/06/04/future-builder-stream-builder/"/>
    <id>http://www.sunmoonblog.com/2020/06/04/future-builder-stream-builder/</id>
    <published>2020-06-04T08:40:20.000Z</published>
    <updated>2020-11-13T02:18:59.048Z</updated>
    
    <content type="html"><![CDATA[<p>翻译一些 Future 和 FutureBuilder 以及 Stream 和 StreamBuilder 相关的资料。</p><a id="more"></a><h1 id="FutureBuilder"><a href="#FutureBuilder" class="headerlink" title="FutureBuilder"></a>FutureBuilder</h1><p>FutureBuilder 是一个基于 Future 最后一次结果进行构建的 Widget。</p><p>Future 必须在较早的时间点获取，比如 <a href="https://api.flutter.dev/flutter/widgets/State/initState.html" target="_blank" rel="noopener">State.initState</a>、<code>State.didUpdateConfig</code> 或 <a href="https://api.flutter.dev/flutter/widgets/State/didChangeDependencies.html" target="_blank" rel="noopener">State.didChangeDependencies</a>。<font color="red">一定不要在 <a href="https://api.flutter.dev/flutter/widgets/State/build.html" target="_blank" rel="noopener">State.build</a> 或 <a href="https://api.flutter.dev/flutter/widgets/StatelessWidget/build.html" target="_blank" rel="noopener">StatelessWidget.build</a> 方法中构建 FutureBuilder 的同时去获取 Future</font>。如果创建 FutureBuilder 的同时也去创建 Future，FutureBuilder 的父节点每次构建时会导致异步任务也重启。</p><p>Future 结束时调用 <a href="https://api.flutter.dev/flutter/widgets/State/setState.html" target="_blank" rel="noopener">State.setState</a> 以便让 Widget 重建。Flutter 流水线决定如何调用 <a href="https://api.flutter.dev/flutter/widgets/FutureBuilder/builder.html" target="_blank" rel="noopener">builder</a> 回调，该回调接收一个跟时间无关的、代表 Future 交互过程的 snapshot 序列 (receive a timing-dependent sub-sequence of the snapshots that represent the interaction with the future)</p><h2 id="Builder-contract"><a href="#Builder-contract" class="headerlink" title="Builder contract"></a>Builder contract</h2><p>假设 <a href="https://api.flutter.dev/flutter/widgets/FutureBuilder/initialData.html" target="_blank" rel="noopener">initialData</a> 为 null，对于成功结束的 Future <code>builder</code> 被回调两次(<code>waiting</code> 和 <code>done</code>)或一次(<code>done</code>)</p><ul><li><code>waiting</code> - <code>new AsyncSnapshot&lt;String&gt;.withData(ConnectionState.waiting, null)</code></li><li><code>done</code> - <code>new AsyncSnapshot&lt;String&gt;.withData(ConnectionState.done, &#39;some data&#39;)</code></li></ul><p>对于出错的 Future <code>builder</code> 被回调两次(<code>waiting</code> 和 <code>error</code>)或一次 (<code>done</code>)</p><ul><li><code>waiting</code> - <code>new AsyncSnapshot&lt;String&gt;.withData(ConnectionState.waiting, null)</code></li><li><code>error</code> - <code>new AsyncSnapshot&lt;String&gt;.withError(ConnectionState.done, &#39;some error&#39;)</code></li></ul><p>通过 <a href="https://api.flutter.dev/flutter/widgets/FutureBuilder/initialData.html" target="_blank" rel="noopener">initialData</a> 来指定初始的 snapshot (initial snapshot data)。使用这个字段来保证 <code>builder</code> 在 Future 结束之前也被调用一次，这时的 snapshot 持有的值即 <code>initialData</code> 而非缺省的 <code>null</code>。</p><p>The data and error fields of the snapshot change only as the connection state field transitions from waiting to done, and they will be retained when changing the FutureBuilder configuration to another future. If the old future has already completed successfully with data as above, changing configuration to a new future results in snapshot pairs of the form:</p><p>只在连接状态字段 (the connection state field) 从 <code>waiting</code> 变成 <code>done</code> 时 snapshot 的 <code>data</code> 和 <code>error</code> 字段才会变化。FutureBuilder 的 future 由原先切换成新的 future 时 <code>data</code> 和 <code>error</code> 并不变化。</p><p>If the old future has already completed successfully with data as above, changing configuration to a new future results in snapshot pairs of the form:</p><p>仅当旧的 future 成功结束时，切换到一个新的 Future 才会导致出现如下变化：</p><ul><li><code>new AsyncSnapshot&lt;String&gt;.withData(ConnectionState.none, &#39;data of first future&#39;)</code></li><li><code>new AsyncSnapshot&lt;String&gt;.withData(ConnectionState.waiting, &#39;data of second future&#39;)</code></li></ul><p>In general, the latter will be produced only when the new future is non-null, and the former only when the old future is non-null.</p><p>A FutureBuilder behaves identically to a StreamBuilder configured with future?.asStream(), except that snapshots with ConnectionState.active may appear for the latter, depending on how the stream is implemented.</p><h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>原文见<a href="https://itnext.io/how-to-use-streams-in-dart-part-1-4503fec0cdd7" target="_blank" rel="noopener">这里</a>。</p><p>对多数想要深入了解 Dart (或者有类似概念)的程序员来说 Stream 是个理解起来有挑战的话题，因为想要弄懂这个概念需要尝试一些例子。本文尝试讲清 Dart Stream 的用法，并且在系列文章中构建一些能感知的例子加强理解。</p><h2 id="Dart-Stream-用法"><a href="#Dart-Stream-用法" class="headerlink" title="Dart Stream 用法"></a>Dart Stream 用法</h2><p>原文见<a href="https://itnext.io/how-to-use-streams-in-dart-part-1-4503fec0cdd7" target="_blank" rel="noopener">这里</a>。</p><p>对多数想要深入了解 Dart (或者有类似概念)的程序员来说 Stream 是个理解起来有挑战的话题，因为想要弄懂这个概念需要尝试一些例子。本文尝试讲清 Dart Stream 的用法，并且在系列文章中构建一些能感知的例子加强理解。</p><h2 id="Stream-是什么"><a href="#Stream-是什么" class="headerlink" title="Stream 是什么"></a>Stream 是什么</h2><p>Dart 官方文档中是这样定义 Stream 的：</p><blockquote><p>A source of asynchronous data events. A Stream provides a way to receive a sequence of events. Each event is either a data event, also called an element of the stream, or an error event, which is a notification that something has failed. When a stream has emitted all its event, a single “done” event will notify the listener that the end has been reached.</p><p>api.dartlang.org</p></blockquote><p>翻译如下(发现跟 <a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a> 中 <a href="http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/Flowable.html" target="_blank" rel="noopener">Flowable</a> 的概念基本一样的)</p><blockquote><p>它是异步数据事件源。Stream 提供接收事件序列的方法。每个事件要么是数据事件，也称为 stream 元素；要么是错误事件，它代表某个失败。当 stream 发射完所有事件后，会使用 “done” 事件通知监听器 stream 已结束。</p></blockquote><p>Stream 指的是数据从 A 流动到的 B 的通道。在这个通道中可以在到达 B 之前对”读入”的数据进行不同的变换。以小块来传输而不是整体传输数据时这个通道非常有用。</p><p>Dart 中使用 SDK 提供的工具类来使用 Stream。这些工具类提供方法将数据推到 stream 中，并通知 stream 的监听器捕获数据。</p><p>代表 stream 的最通用的类是 <code>Stream&lt;T&gt;</code>。但通常不直接使用这个类，而是在 Dart 库的其他类中向外暴露这个类。所以可以将其视为用于跟数据流动通道交互的接口。</p><h2 id="Basic-example-with-StreamController"><a href="#Basic-example-with-StreamController" class="headerlink" title="Basic example with StreamController"></a>Basic example with StreamController<t></t></h2><p><code>StreamController&lt;T&gt;</code> 包含一个 stream，允许消费者向它发送数据事件、结束事件以及错误事件。可以使用 <code>streamController.stream</code> 访问及调用<a href="[documentation](https://api.dartlang.org/stable/2.1.1/dart-async/Stream-class.html?source=post_page---------------------------">文档</a>)中定义的方法。</p><p>来看个 <code>StreamController&lt;T&gt;</code> 类的例子:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> streamController = StreamController();</span><br><span class="line"><span class="comment">// Accessing the stream and listening for data event</span></span><br><span class="line">streamController.stream.listen((data) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Got eem! <span class="subst">$data</span>'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上代码片断允许监听 stream 通道上输入的数据块。我们对这个数据的响应方式是将其打印到控制台。</p><p>我猜接下来的疑问是：<em>如何触发监听器事件呢？</em> 答案是：<em>向 stream 喂数据。</em> 通过 <code>EventSink&lt;T&gt;</code> 的 <code>add()</code> 方法向 stream 喂数据。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">streamController.sink.add(<span class="string">'Added this string'</span>);</span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line"><span class="comment">// Got eem! Added this string</span></span><br></pre></td></tr></table></figure><p>stream 上的 <code>listen()</code> 方法也能用于捕获错误信息。监听 stream 时会生成一个 <code>StreamSubscription&lt;T&gt;</code> 对象。这个对象可用于处理不同的事件，比如数据、数据、结束 (调用 stream 的 <code>close()</code> 方法时产生结束事件)。</p><p>这是 <code>listen()</code> 方法的完整定义：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StreamSubscription&lt;T&gt; listen (</span><br><span class="line">  <span class="keyword">void</span> onData(T event), </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">Function</span> onError,</span><br><span class="line">    <span class="keyword">void</span> onDone(), <span class="comment">// Invoked when the stream is closed</span></span><br><span class="line">    <span class="built_in">bool</span> cancelOnError <span class="comment">// Kills the stream when an error occurs</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>像这样调用 “error” 和 “done” 事件：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">streamController.sink.addError(<span class="string">'Houston, we have a problem!'</span>); <span class="comment">// Got an error! Houston, we have a problem!</span></span><br><span class="line">streamController.sink.close(); <span class="comment">// Mission complete!</span></span><br></pre></td></tr></table></figure><p><a href="https://dartpad.dartlang.org/3baf3a9c229dcfa962878905e478a1a7?source=post_page---------------------------" target="_blank" rel="noopener">Try this on DartPad</a></p><h2 id="Streams-exposed-through-libraries"><a href="#Streams-exposed-through-libraries" class="headerlink" title="Streams exposed through libraries"></a>Streams exposed through libraries</h2><p>尽管 <code>StreamController&lt;T&gt;</code> 允许我们更好精细地控制 stream，但内置的 Dart 库其实内部也大量使用 Stream。比如，以下代码创建一个服务器： </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> server = <span class="keyword">await</span> HttpServer.bind(<span class="string">'localhost'</span>, <span class="number">8080</span>);</span><br><span class="line">  <span class="comment">// HttpServer exposes a Stream&lt;T&gt; interface</span></span><br><span class="line">  server.listen((HttpRequest request) &#123;</span><br><span class="line">    request.response.write(<span class="string">'Hello, World!'</span>);</span><br><span class="line">    request.response.close();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码初始化一个 <code>HttpServer</code> 用于创建 web 服务器。这个类暴露 <code>Stream&lt;T&gt;</code> 接口，这意味着我们可以监听这个 stream，它包含用户在浏览器访问该 web 服务器时发出的请求。</p><p>另一个例子是 web 浏览器也暴露 stream：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:html'</span>;</span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">querySelector</span>(<span class="string">'button'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `onClick` is a Stream&lt;T&gt; instance that receives user click data events</span></span><br><span class="line">  button.onClick.listen((_) =&gt; <span class="built_in">print</span>(<span class="string">'Button clicked!'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器中用户交互行为有点击，滚动及输入等等，这些行为作为”数据”事件发射到 stream 中。另外，HTML 元素也暴露 <code>Stream&lt;T&gt;</code> 用于处理用户在页面上的交互。</p><p>还有很多类使用 Stream。这里想要说的是，你不必直接初始化 <code>Stream&lt;T&gt;</code> 对象，而是 SDK 库中的类为你初始化。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Stream 提供一种强大的数据块处理方式。由于是以异步的方式操作，所以得到的好处是以非阻塞式的方式来运行代码。建议阅读文章，尤其是 <code>dart:async</code> 库，它包含有用于异步编程的 <code>Streams</code> 和 <code>Futures</code>。</p><p>下一篇将介绍如何对 stream 进行变换，并且展示了 stream 用法的常用设计模式。</p><hr><p>原文见<a href="https://creativebracket.com/how-to-use-streams-in-dart-2/?source=post_page---------------------------" target="_blank" rel="noopener">这里</a>。</p><p>是前一篇中我们学习了 stream，以及两种跟 stream 交互的方式，另外还看到了使用 <code>StreamController&lt;T&gt;</code> 类型处理 stream 的灵活性，以及 Dart 库暴露 <code>Stream&lt;T&gt;</code> 类型供监听和数据处理。</p><p>本篇将先看看如何使用 Stream Transformers 对 stream 进行变换。之后学习 stream 用法的常用设计模式。</p><h2 id="Stream-Transformer-是什么"><a href="#Stream-Transformer-是什么" class="headerlink" title="Stream Transformer 是什么?"></a>Stream Transformer 是什么?</h2><p>Stream Transformer 允许对 stream 进行数据变换。这些变换被推进 stream，并且被所有监听器接收。</p><p>Dart 使用 <code>StreamTransformer&lt;S,T&gt;</code> 类进行 stream 变换，它有三种不同的形式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Creates a transformer based on the provided `onListen` callback</span></span><br><span class="line">StreamTransformer(</span><br><span class="line">  StreamSubscription&lt;T&gt; onListen(</span><br><span class="line">    Stream&lt;S&gt; stream,</span><br><span class="line">    <span class="built_in">bool</span> cancelOnError</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 2. Creates a transformer based on the provided `bind` callback fn</span></span><br><span class="line">StreamTransformer.fromBind(</span><br><span class="line">  Stream&lt;T&gt; bind(Stream&lt;S&gt;)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 3. Creates a transformer that will delegate events to the</span></span><br><span class="line"><span class="comment">// provided `handleData`, `handleError` and `handleDone` callback functions</span></span><br><span class="line">StreamTransformer.fromHandlers(&#123;</span><br><span class="line">  <span class="keyword">void</span> handleData(</span><br><span class="line">    S data,</span><br><span class="line">    EventSink&lt;T&gt; sink</span><br><span class="line">  ),</span><br><span class="line">  <span class="keyword">void</span> handleError(</span><br><span class="line">    <span class="built_in">Object</span> error,</span><br><span class="line">    StackTrace stackTrace,</span><br><span class="line">    EventSink&lt;T&gt; sink</span><br><span class="line">  ),</span><br><span class="line">  <span class="keyword">void</span> handleDone(</span><br><span class="line">    EventSink&lt;T&gt; sink</span><br><span class="line">  ), </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>For this post I will focus on </p><p>本文重点介绍 <code>StreamTransformer.fromHandlers(...)</code>，因为它最容易使用。以下是一个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> streamTransformer = StreamTransformer&lt;<span class="built_in">num</span>, <span class="built_in">num</span>&gt;.fromHandlers(</span><br><span class="line">    handleData: (<span class="built_in">num</span> data, EventSink sink) &#123;</span><br><span class="line">      <span class="comment">// The actual transformation we're making</span></span><br><span class="line">      <span class="comment">// here is multiplying $data by 2</span></span><br><span class="line">      sink.add(data * <span class="number">2</span>);</span><br><span class="line">    &#125;, </span><br><span class="line">    handleError: (<span class="built_in">Object</span> error, StackTrace stacktrace, EventSink sink) &#123;</span><br><span class="line">      sink.addError(<span class="string">'Something went wrong: <span class="subst">$error</span>'</span>);</span><br><span class="line">    &#125;, </span><br><span class="line">    handleDone: (EventSink sink) =&gt; sink.close(),</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p><code>StreamTransformer.fromHandlers(...)</code> 命名构造方法接收回调函数，有三个命名参数：</p><ul><li><code>handleData</code>: 这个方法响应 stream 发射的任意数据事件。它的参数是发射事件中的数据，<code>EventSink&lt;T&gt;</code> 实例则是当前变换所属的 stream 的成员。<code>EventSink&lt;T&gt;.add()</code> 方法用于向 stream 的监听器重传变换后的数据。</li><li><code>handleError</code>: 这个方法响应 stream 发射的任意错误事件。它的参数包含错误信息，stack trace 以及 <code>EventSink&lt;T&gt;</code> 实例。该实例的 <code>addError()</code> 方法用于向监听器发送自定义的错误信息。</li><li><code>handleDone</code>: 当 stream 中没有更多数据需要处理时运行这个方法。调用 stream 的 <code>EventSink&lt;T&gt;</code> 实例的 <code>close()</code> 方法时会出现没有数据需要处理的情况。</li></ul><p>使用时，将 <code>streamTransformer</code> 作为 stream 的 <code>transform()</code> 方法参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> controller = StreamController&lt;<span class="built_in">num</span>&gt;();</span><br><span class="line"><span class="comment">// Call the `transform` method on the controller's stream</span></span><br><span class="line"><span class="comment">// while passing in the stream transformer</span></span><br><span class="line"><span class="keyword">var</span> controllerStream = controller.stream.transform(streamTransformer);</span><br><span class="line"><span class="comment">// Just print out transformations to the console</span></span><br><span class="line">controllerStream.listen(<span class="built_in">print</span>);</span><br><span class="line"><span class="comment">// Add data to stream to see transformations in effect</span></span><br><span class="line">controller.sink.add(<span class="number">1</span>); <span class="comment">// 2</span></span><br><span class="line">controller.sink.add(<span class="number">2</span>); <span class="comment">// 4</span></span><br><span class="line">controller.sink.add(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">controller.sink.add(<span class="number">4</span>); <span class="comment">// 8</span></span><br><span class="line">controller.sink.add(<span class="number">5</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h2 id="Single-subscription-vs-Broadcast-streams"><a href="#Single-subscription-vs-Broadcast-streams" class="headerlink" title="Single subscription vs Broadcast streams"></a>Single subscription vs Broadcast streams</h2><p>有两种形式的 stream：单个订阅或者广播。概念上的区别是单个订阅只一个监听器。添加多个监听器抛出异常：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">controllerStream.listen(<span class="built_in">print</span>);</span><br><span class="line">controllerStream.listen(<span class="built_in">print</span>); <span class="comment">// Throws the error below:</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="comment">// Uncaught exception: Bad state: Stream has already been listened to.</span></span><br></pre></td></tr></table></figure><p>但广播 stream 允许定义多个数据监听器。使用广播 stream 修正以上代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> controller = StreamController&lt;<span class="built_in">num</span>&gt;.broadcast();</span><br></pre></td></tr></table></figure><p>再测试一次，结果如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">controllerStream.listen(<span class="built_in">print</span>);</span><br><span class="line">controllerStream.listen(<span class="built_in">print</span>)</span><br><span class="line"><span class="comment">// --</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h2 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h2><p>Dart Stream 的优雅之处在于所有平台的 API 以一致的方式来实现，无论是 web，服务器端还是移动端。这一事实展示了 “light bulb moment”，你能跨平台写可重用的逻辑，只要它用的是 Stream API。 (原文：This fact presents a “light bulb moment” where we can write reusable logic for use across the platforms as long as it utilizes the Stream API.)</p><p>这种模式可称为 Business Logic Components ( 简称 BLoC)，我们将在第三部分介绍它。</p><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="https://www.dartlang.org/tutorials/language/streams" target="_blank" rel="noopener">Asynchronous Programming: Streams</a></li><li><a href="https://api.dartlang.org/stable/2.2.0/dart-async/StreamTransformer-class.html" target="_blank" rel="noopener">StreamTransformer&lt;S, T&gt; Class Documentation</a></li></ul><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html" target="_blank" rel="noopener">FutureBuilder class - widgets library - Dart API</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译一些 Future 和 FutureBuilder 以及 Stream 和 StreamBuilder 相关的资料。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 应用集成浅析</title>
    <link href="http://www.sunmoonblog.com/2020/03/10/flutter-add-to-app/"/>
    <id>http://www.sunmoonblog.com/2020/03/10/flutter-add-to-app/</id>
    <published>2020-03-09T20:07:50.000Z</published>
    <updated>2020-11-13T02:18:59.047Z</updated>
    
    <content type="html"><![CDATA[<p>简单分析下 Flutter 如何集成到现有 Android 应用中。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>截止目前 Flutter (1.12.13+hotfix.5)，集成到 Android 应用已经非常简单了。</p><blockquote><p>Flutter can be embedded into your existing Android application piecemeal, as a source code Gradle subproject or as AARs.</p></blockquote><p>无非两种集成方式：源码集成或 AAR 产物集成。，这里不再赘述，仅做简单总结。</p><ul><li>Android Studio 3.6 + Flutter IntelliJ plugin (version 42及以上) 可以方便快速地自动集成 Flutter 模块</li><li>Flutter 的 Android 引擎使用 Java 8 特性，所以要记得开启 1.8 兼容，否则会提示 “default interface methods” 问题</li><li><a href="https://flutter.dev/docs/development/add-to-app/android/project-setup#option-b---depend-on-the-modules-source-code" target="_blank" rel="noopener">源码集成</a> 时注意 Android 工程和 Flutter 工程在同级目录下</li><li>注意编译模式及CPU架构，不匹配的话会出现找不到 <code>libflutter.so</code> 的问题</li><li>Flutter 的 AOT(ahead of time) 编译产物只支持 <code>armeabi-v7a</code> 和 <code>arm64-v8a</code>，x86 下可进行 debug (Just-In-Time, JIT 模式)，但不能安装 release 包</li></ul><h1 id="产物集成"><a href="#产物集成" class="headerlink" title="产物集成"></a>产物集成</h1><p>产物集成相比源码集成更简单。主要步骤如下，具体过程可参考<a href="https://flutter.dev/docs/development/add-to-app/android/project-setup#create-a-flutter-module" target="_blank" rel="noopener">官方文档</a>。</p><p>第一步，生成 AAR。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd flutter_project</span><br><span class="line">flutter build aar</span><br></pre></td></tr></table></figure><p>缺省编译所有模式下的产物，包括 debug, profile 和 release。不想编译 profile 模式产物的话，加上 <code>--no-profile</code> 即可。</p><p>另外注意编译 AAR 有限制，仅能为 plugin 或 module 工程编译 AAR 产物，否则提示如下错误。</p><p><img src="/images/15843459718378.jpg" alt="-w541"></p><p>第二步，添加产物仓库及依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">  // AAR 产物本地仓库</span><br><span class="line">  maven &#123;</span><br><span class="line">      url &apos;/Users/user/wd/xyz/build/host/outputs/repo&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  // Flutter 框架官方仓库</span><br><span class="line">  maven &#123;</span><br><span class="line">      url &apos;http://download.flutter.io&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  debugImplementation &apos;com.tencent.xyz:flutter_debug:1.0</span><br><span class="line">  profileImplementation &apos;com.tencent.xyz:flutter_profile:1.0</span><br><span class="line">  releaseImplementation &apos;com.tencent.xyz:flutter_release:1.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/15843474921970.jpg" alt="-w700"></p><h1 id="源码集成"><a href="#源码集成" class="headerlink" title="源码集成"></a>源码集成</h1><p>第一步，创建 Flutter 项目。在 host app 的同级目录下创建 <code>my_flutter</code> 项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd some/path/</span><br><span class="line">$ flutter create -t module --org com.example my_flutter</span><br></pre></td></tr></table></figure><p>第二步，引入 Flutter 项目并作为模块。在 host app 的 <code>settings.gradle</code> 文件中添加如下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">setBinding(<span class="keyword">new</span> Binding([<span class="string">gradle:</span> <span class="keyword">this</span>]))                                 <span class="comment">// new</span></span><br><span class="line">evaluate(<span class="keyword">new</span> File(                                                      <span class="comment">// new</span></span><br><span class="line">  settingsDir.parentFile,                                               <span class="comment">// new</span></span><br><span class="line">  <span class="string">'my_flutter/.android/include_flutter.groovy'</span>                          <span class="comment">// new</span></span><br><span class="line">)) </span><br><span class="line">include <span class="string">':my_flutter'</span></span><br><span class="line">project(<span class="string">':my_flutter'</span>).projectDir = <span class="keyword">new</span> File(<span class="string">'../my_flutter'</span>)</span><br></pre></td></tr></table></figure><p>这段配置的作用不妨视作黑魔法，其作用如下：</p><ul><li>将 <code>my_flutter</code> <strong>Flutter Project</strong> 作为名为 <code>:flutter</code> 的 <strong>Android Library Module</strong>，引入到当前 <strong>Android Project</strong></li><li>查找并保存 <code>my_flutter</code> 依赖的 Flutter 插件</li></ul><p>第三步，添加对 <code>:flutter</code> module 的依赖。在 host app 的 <code>build.gradle</code> 中加上以下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation project(<span class="string">':flutter'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是手工操作步骤。在 Android 3.6 中可以自动操作，同样也会产生跟上面相同的配置。</p><p>Android Studio 3.6 中打开 host app，并新建一个 Flutter Module：</p><p><img src="/images/15837916714301.jpg" alt="-w633"></p><p>创建完成后生成的配置如下：</p><p><img src="/images/15837922861555.jpg" alt="-w1185"></p><p>可见，无论手工操作还是自动操作，源码集成的关键在于这几个脚本：</p><ul><li><del>my_flutter/.android/include_flutter.groovy</del> - 黑魔法，用于在 Android 工程引入 Flutter 工程，我们略过</li><li><code>my_flutter/.android/Flutter/build.gradle</code> - 这个脚本决定 Flutter 工程如何构建，它引入 Flutter SDK 中的 <code>flutter.gradle</code> 脚本</li><li><code>&lt;Flutter SDK&gt;/packages/flutter_tools/gradle/flutter.gradle</code> - 集成 Flutter 工程的核心</li></ul><p>接下来我将分析 <code>build.gradle</code> 和 <code>flutter.gradle</code> 两个脚本是如何将 Flutter 集成到 Android 应用的。</p><h1 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h1><p>先来分析 <code>my_flutter/.android/Flutter/build.gradle</code>。</p><p>第一步，加载并解析 <code>.android</code> 目录下的 <code>local.properties</code> 文件。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载 .android 目录下的 local.properties 文件</span></span><br><span class="line"><span class="keyword">def</span> localProperties = <span class="keyword">new</span> Properties()</span><br><span class="line"><span class="keyword">def</span> localPropertiesFile = <span class="keyword">new</span> File(buildscript.sourceFile.parentFile.parentFile, <span class="string">'local.properties'</span>)</span><br><span class="line"><span class="keyword">if</span> (localPropertiesFile.exists()) &#123;</span><br><span class="line">    localPropertiesFile.withReader(<span class="string">'UTF-8'</span>) &#123; reader -&gt;</span><br><span class="line">        localProperties.load(reader)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 flutter.sdk(必选)</span></span><br><span class="line"><span class="keyword">def</span> flutterRoot = localProperties.getProperty(<span class="string">'flutter.sdk'</span>)</span><br><span class="line"><span class="keyword">if</span> (flutterRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="string">"Flutter SDK not found. Define location with flutter.sdk in the local.properties file."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 flutter.versionCode(可选)</span></span><br><span class="line"><span class="keyword">def</span> flutterVersionCode = localProperties.getProperty(<span class="string">'flutter.versionCode'</span>)</span><br><span class="line"><span class="keyword">if</span> (flutterVersionCode == <span class="literal">null</span>) &#123;</span><br><span class="line">    flutterVersionCode = <span class="string">'1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 flutter.versionName(可选)</span></span><br><span class="line"><span class="keyword">def</span> flutterVersionName = localProperties.getProperty(<span class="string">'flutter.versionName'</span>)</span><br><span class="line"><span class="keyword">if</span> (flutterVersionName == <span class="literal">null</span>) &#123;</span><br><span class="line">    flutterVersionName = <span class="string">'1.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，引入 <code>flutter.gradle</code> 脚本并通过 <code>flutter</code> 插件指定 <strong>Flutter Project</strong> 源码位置。<code>flutter</code> 插件来自 <code>flutter.gradle</code> 脚本中的 <code>FlutterPlugin</code>。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">from:</span> <span class="string">"$flutterRoot/packages/flutter_tools/gradle/flutter.gradle"</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定的 Flutter 源码路径</span></span><br><span class="line">flutter &#123;</span><br><span class="line">    source <span class="string">'../..'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="flutter-gradle"><a href="#flutter-gradle" class="headerlink" title="flutter.gradle"></a><a href="https://github.com/flutter/flutter/blob/master/packages/flutter_tools/gradle/flutter.gradle" target="_blank" rel="noopener">flutter.gradle</a></h1><p>再来看 <code>&lt;Flutter SDK&gt;/packages/flutter_tools/gradle/flutter.gradle</code>。<code>flutter</code> 插件的具体实现在 <code>apply()</code> 方法。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用 FlutterPlugin</span></span><br><span class="line">apply <span class="string">plugin:</span> FlutterPlugin</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义名为 flutter 的 FlutterPlugin 插件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line">    <span class="keyword">private</span> Project project</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        <span class="keyword">this</span>.project = project</span><br><span class="line">        <span class="comment">// 创建名为 flutter 的 FlutterExtension</span></span><br><span class="line">        project.extensions.create(<span class="string">"flutter"</span>, FlutterExtension) </span><br><span class="line">        <span class="comment">// 添加 Flutter Task</span></span><br><span class="line">        project.afterEvaluate <span class="keyword">this</span>.&amp;addFlutterTasks</span><br><span class="line">        <span class="comment">// 配置 APK。修改 project.android (android插件)的配置</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 获取 Flutter 相关信息</span></span><br><span class="line">        <span class="comment">// 添加 Flutter Dependency</span></span><br><span class="line">        project.android.buildTypes.each <span class="keyword">this</span>.&amp;addFlutterDependencies</span><br><span class="line">        project.android.buildTypes.whenObjectAdded <span class="keyword">this</span>.&amp;addFlutterDependencies</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>apply()</code> 主要流程概括如下：</p><ul><li>创建 FlutterExtension。这个插件很简单，只包括<ul><li><code>source</code>(源码路径)</li><li><code>target</code>(Dart入口，通常是 <code>lib/main.dart</code>)</li></ul></li><li><strong>添加 Flutter Task</strong></li><li>配置 APK<ul><li>针对 Target Platform 生成 multiple APK 或 fat APK</li><li>配置 build type，例如是否压缩资源</li></ul></li><li>获取 Flutter 相关信息<ul><li>本地 Flutter SDK 路径</li><li><code>flutter</code> 命令</li><li>引擎版本</li><li>引擎路径 (来自 <code>gradle.properties</code> 文件的 <code>local-engine-out</code> 属性 )</li></ul></li><li><strong>添加 Flutter Dependency</strong></li></ul><p>接下来我们挑重点说，</p><ul><li>添加 Flutter Task</li><li>添加 Flutter Dependency</li></ul><p>简单来说，添加 Flutter Task 是<font color="red">添加一些 Task 用于处理三类 Flutter 相关的资源，库、资源、插件</font>：</p><ul><li>库 - 库是编译过程中生成jar文件和so文件。库文件应正确地打包到 AAR 或 APK</li><li>资源 - 资源是 <code>pubspec.yaml</code> 文件添加指定的各类资源，如图片、字体等。资源文件应正确地打包到 AAR 或 APK</li><li>插件 - 插件是 <code>pubspec.yaml</code> 文件添加的各种 Dart 库。插件的处理比较麻烦，一是某些插件包含原生Java或OC代码，二是插件之间有依赖关系</li></ul><p>而<font color="red">添加 Flutter Dependency 则是将 Flutter 框架(包括引擎)添加为 Android 工程的依赖</font>，具体包括：</p><ul><li><code>flutter_embedding.jar</code> - Flutter Framework，即 <code>io.flutter.embedding.android.FlutterActivity</code> 所在的 Java 库</li><li><code>libflutter.so</code> - Flutter 引擎</li></ul><hr><p>跟以上流程相关的几个辅助方法：</p><ul><li><code>useLocalEngine()</code> - 判断是否使用本地 Flutter 引擎，来自 <code>gradle.properties</code> 文件的 <code>local-engine-repo</code> 属性</li><li><code>getTargetPlatforms</code> - 获取 Target Platform，来自 <code>gradle.properties</code> 文件的 <code>target-platform</code> 属性</li><li><code>shouldSplitPerAbi()</code> - 判断是否生成 multiple APK (即针对每种架构生成一个 APK，与之对应的是 fat APK)，来自 <code>gradle.properties</code> 文件的 <code>split-per-abi</code> 属性，缺省为 <code>false</code></li><li><code>getPluginList()</code> - 解析 <code>.flutter-plugins</code> 文件获取插件列表</li><li><code>getPluginDependencies()</code> - 解析 <code>.flutter-plugins-dependencies</code> 文件获取插件依赖</li></ul><hr><h2 id="添加-Flutter-Task"><a href="#添加-Flutter-Task" class="headerlink" title="添加 Flutter Task"></a>添加 Flutter Task</h2><p><code>addFlutterTasks()</code> 是最复杂的方法。精简后的代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> addFlutterTasks(Project project) &#123;</span><br><span class="line">    <span class="comment">// 1. 参数检查</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2. 从 `gradle.properties` 获取各种参数</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 3. 定义 addFlutterDeps 匿名方法</span></span><br><span class="line">    <span class="keyword">def</span> addFlutterDeps = &#123; variant -&gt; </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 4. 为所有 applicationVariants 或 libraryVariants 添加 Flutter 依赖</span></span><br><span class="line">    <span class="keyword">if</span> (project.android.hasProperty(<span class="string">"applicationVariants"</span>)) &#123;</span><br><span class="line">        project.android.applicationVariants.all addFlutterDeps</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        project.android.libraryVariants.all addFlutterDeps</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 配置插件依赖</span></span><br><span class="line">    configurePlugins()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第3步和第4步处理库和资源</li><li>第5步处理插件</li></ul><h3 id="addFlutterDeps"><a href="#addFlutterDeps" class="headerlink" title="addFlutterDeps"></a>addFlutterDeps</h3><p>首先看第3步 <code>addFlutterDeps</code> 的创建。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 compileTask。FlutterTask 实际是对 flutter build 命令的包装</span></span><br><span class="line">FlutterTask compileTask = project.tasks.create(<span class="string">name:</span> taskName, <span class="string">type:</span> FlutterTask) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建 packFlutterAppAotTask。将第1步中的编译结果打包成 libs.jar 文件</span></span><br><span class="line">Task packFlutterAppAotTask = project.tasks.create(<span class="string">name:</span> <span class="string">"packLibs$&#123;FLUTTER_BUILD_PREFIX&#125;$&#123;variant.name.capitalize()&#125;"</span>, <span class="string">type:</span> Jar) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将第2步生成的 libs.jar 文件添加为依赖 </span></span><br><span class="line">addApiDependencies(project, variant.name, project.files &#123;</span><br><span class="line">    packFlutterAppAotTask</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建 copyFlutterAssetsTask。</span></span><br><span class="line">Task copyFlutterAssetsTask = project.tasks.create(</span><br><span class="line"><span class="symbol">    name:</span> <span class="string">"copyFlutterAssets$&#123;variant.name.capitalize()&#125;"</span>,</span><br><span class="line"><span class="symbol">    type:</span> Copy,</span><br><span class="line">) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flutter 项目可能作为插件编译或子项目编译(分别对应AAR产物集成和源码集成)</span></span><br><span class="line"><span class="comment">//  a) 当作为插件编译时，编译产物为 AAR</span></span><br><span class="line"><span class="comment">//  b) 当作为子项目编译时，编译产物为 APK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为插件编译和作为子项目编译时对 assets 的处理是不一样的</span></span><br><span class="line"><span class="comment">// 第5步和第6步分别对这两种情况进行处理</span></span><br><span class="line"><span class="keyword">boolean</span> isUsedAsSubproject = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 处理作为插件编译时的 assets 拷贝</span></span><br><span class="line"><span class="keyword">if</span> (!isUsedAsSubproject) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 处理作为子项目编译时的 assets 拷贝</span></span><br><span class="line"><span class="comment">// Flutter module included as a subproject in add to app.</span></span><br><span class="line">Project appProject = project.rootProject.findProject(<span class="string">':app'</span>)</span><br><span class="line">appProject.afterEvaluate &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><code>FlutterTask</code> 继承自 <code>BaseFlutterTask</code>。<code>BaseFlutterTask</code> 实际是对 <code>flutter build</code> 命令的包装，具体包装过程可以参数 <a href="https://github.com/flutter/flutter/blob/master/packages/flutter_tools/gradle/flutter.gradle#L819" target="_blank" rel="noopener">BaseFlutterTask.buildBundle()</a>。</p><h3 id="configurePlugins"><a href="#configurePlugins" class="headerlink" title="configurePlugins"></a>configurePlugins</h3><p>再来看 <code>configurePlugins()</code> 如何配置插件依赖。仍然分两种情况处理：源码集成和产物集成。代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configures the Flutter plugin dependencies.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The plugins are added to pubspec.yaml. Then, upon running `flutter pub get`,</span></span><br><span class="line"><span class="comment"> * the tool generates a `.flutter-plugins` file, which contains a 1:1 map to each plugin location.</span></span><br><span class="line"><span class="comment"> * Finally, the project's `settings.gradle` loads each plugin's android directory as a subproject.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> configurePlugins() &#123;</span><br><span class="line">    <span class="comment">// 第1种情况，源码集成</span></span><br><span class="line">    <span class="comment">// 配置源码集成时的插件</span></span><br><span class="line">    <span class="keyword">if</span> (!buildPluginAsAar()) &#123;</span><br><span class="line">        <span class="comment">// 1. 将 plugin 工程添加为 Android 工程的依赖</span></span><br><span class="line">        getPluginList().each <span class="keyword">this</span>.&amp;configurePluginProject</span><br><span class="line">        <span class="comment">// 2. 将 plugin 工程的依赖添加为 Android 工程的依赖</span></span><br><span class="line">        getPluginDependencies().each <span class="keyword">this</span>.&amp;configurePluginDependencies</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第2种情况，产物集成</span></span><br><span class="line">    <span class="comment">// 配置产物集成时的插件</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 将 plugin 工程的编译输出目录添加为 Android 工程的 maven 库</span></span><br><span class="line">    project.repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">"$&#123;getPluginBuildDir()&#125;/outputs/repo"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 将 plugin AAR 产物添加为 Android 工程的依赖</span></span><br><span class="line">    getPluginList().each &#123; pluginName, pluginPath -&gt;</span><br><span class="line">        configurePluginAar(pluginName, pluginPath, project)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，注释中提到了几个很重要的信息：</p><blockquote><p>插件在 pubspec.yaml 中添加。当运行 <code>flutter pub get</code> 命令时，工具会生成 <code>.flutter-plugins</code> 和 <code>.flutter-plugins-dependencies</code> 文件。<code>.flutter-plugins</code> 包含每个插件的位置，<code>.flutter-plugins-dependencies</code> 包含每个插件的依赖项</p><p>Android 项目的 <code>settings.gradle</code> 文件会加载每个插件为子工程</p></blockquote><p>以我们的项目为例。<code>.flutter-plugins</code> 文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># This is a generated file; do not edit or check into version control.</span><br><span class="line">flutter_integration=/Users/abc/flutter/.pub-cache/hosted/pub.dartlang.org/flutter_integration-0.0.1/</span><br><span class="line">flutter_mmkv_cache=/Users/abc/flutter/.pub-cache/hosted/pub.dartlang.org/flutter_mmkv_cache-0.0.2/</span><br><span class="line">path_provider=/Users/abc/flutter/.pub-cache/hosted/pub.dartlang.org/path_provider-1.3.0/</span><br><span class="line">sensors=/Users/abc/flutter/.pub-cache/hosted/pub.dartlang.org/sensors-0.4.1+8/</span><br><span class="line">sqflite=/Users/abc/flutter/.pub-cache/hosted/pub.dartlang.org/sqflite-1.1.7+1/</span><br></pre></td></tr></table></figure><p>该项目在 Android Studio 中看到的工程结构如下：</p><p><img src="/images/15839842720995.jpg" alt="-w249"></p><h2 id="添加-Flutter-Dependency"><a href="#添加-Flutter-Dependency" class="headerlink" title="添加 Flutter Dependency"></a>添加 Flutter Dependency</h2><p><font color="red"><code>apply()</code> 的另一个要点是添加 Flutter 依赖，由 <code>addFlutterDependencies()</code> 实现</font>。相比添加 Flutter Task，添加 Flutter 依赖则简单得多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        ...   </span><br><span class="line">        project.android.buildTypes.each <span class="keyword">this</span>.&amp;addFlutterDependencies</span><br><span class="line">        project.android.buildTypes.whenObjectAdded <span class="keyword">this</span>.&amp;addFlutterDependencies</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * addFlutterDependencies() 方法为 Flutter 工程添加 embedding 和 libflutter.so 依赖 </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Adds the dependencies required by the Flutter project.</span></span><br><span class="line"><span class="comment">     * This includes:</span></span><br><span class="line"><span class="comment">     *    1. The embedding</span></span><br><span class="line"><span class="comment">     *    2. libflutter.so</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFlutterDependencies</span><span class="params">(buildType)</span> </span>&#123;</span><br><span class="line">        String flutterBuildMode = buildModeFor(buildType)</span><br><span class="line">        <span class="keyword">if</span> (!supportsBuildMode(flutterBuildMode)) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 添加 Flutter 引擎仓库，默认使用 MAVEN_REPO </span></span><br><span class="line">        <span class="comment">// MAVEN_REPO 仓库地址 http://download.flutter.io</span></span><br><span class="line">        String repository = useLocalEngine()</span><br><span class="line">            ? project.property(<span class="string">'local-engine-repo'</span>)</span><br><span class="line">            : MAVEN_REPO</span><br><span class="line"></span><br><span class="line">        project.rootProject.allprojects &#123;</span><br><span class="line">            repositories &#123;</span><br><span class="line">                maven &#123;</span><br><span class="line">                    url repository</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 添加 embedding 依赖</span></span><br><span class="line">        <span class="comment">// Add the embedding dependency.</span></span><br><span class="line">        addApiDependencies(project, buildType.name,</span><br><span class="line">                <span class="string">"io.flutter:flutter_embedding_$flutterBuildMode:$engineVersion"</span>)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        platforms.each &#123; platform -&gt;</span><br><span class="line">            String arch = PLATFORM_ARCH_MAP[platform].replace(<span class="string">"-"</span>, <span class="string">"_"</span>)</span><br><span class="line">            <span class="comment">// 3. 添加 libflutter.so 依赖</span></span><br><span class="line">            <span class="comment">// Add the `libflutter.so` dependency.</span></span><br><span class="line">            addApiDependencies(project, buildType.name,</span><br><span class="line">                    <span class="string">"io.flutter:$&#123;arch&#125;_$flutterBuildMode:$engineVersion"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>通过看 <code>buid.gradle</code> 和 <code>flutter.gradle</code> 源码，我们对 Flutter 如何集成到 Android 项目中有一定的了解了。现在结合两个实例来加深理解，这里以一个编译失败问题和 so 加载失败问题为例。</p><h2 id="编译失败-Cause-assert-appProject-null"><a href="#编译失败-Cause-assert-appProject-null" class="headerlink" title="编译失败 Cause: assert appProject != null"></a>编译失败 Cause: assert appProject != null</h2><p>Flutter 1.12.13+hotfix.5 有一个编译失败的 <a href="https://github.com/flutter/flutter/issues/42214" target="_blank" rel="noopener">Issue #42214</a>，错误日志如下：</p><p><img src="/images/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_d5221a9a-5eea-4c5d-9c8b-8f99449e06c6.png" alt="企业微信截图_d5221a9a-5eea-4c5d-9c8b-8f99449e06"></p><p>问题来源：这个问题实际上来自 <code>flutter.gradle</code> 脚本中的一处 bug， 见<a href="https://github.com/flutter/flutter/pull/41333/files" target="_blank" rel="noopener">Pull #41333</a><br>问题分析：<code>addFlutterTasks()</code> 方法中第4步存在硬编码问题，<a href="https://github.com/flutter/flutter/blob/master/packages/flutter_tools/gradle/flutter.gradle#L724" target="_blank" rel="noopener">默认所有的 app module 名为 <code>app</code></a>。实际项目中 app module 名很可能不是 <code>app</code>，所以断言失败，导致集成 Flutter 后编译出错</p><p>解决办法：要么将 app module 改名为 <code>app</code>，要么给本地的 <code>flutter.gradle</code> 打上如下补丁。注意要将 <code>IGame</code> 替换成实际项目名。</p><p><img src="/images/15839996052765.jpg" alt="-w824"></p><h2 id="找不到-libflutter-so-或-libapp-so"><a href="#找不到-libflutter-so-或-libapp-so" class="headerlink" title="找不到  libflutter.so 或 libapp.so"></a>找不到  <code>libflutter.so</code> 或 <code>libapp.so</code></h2><p>一些年代比较久远的 Android 项目中，so 往往放在 <code>lib/armeabi</code> 目录。</p><p><img src="/images/15840141266883.jpg" alt="-w322"></p><p>而 Flutter 的 AOT 产物只支持 <code>x86_64</code>、 <code>armeabi-v7a</code> 和 <code>arm64-v8a</code> 三种架构。另外，<strong>Flutter 的构建流程默认将会将 so 文件打包到对应的目录中</strong>，</p><p><img src="/images/15840143123117.jpg" alt="-w323"><br>所以会出现找不到 <code>libflutter.so</code> 的问题。一种简单而粗暴的解决方案见 <a href="https://tech.meituan.com/2018/08/09/waimai-flutter-practice.html" target="_blank" rel="noopener">Flutter原理与实践 - 美团技术团队</a>。</p><p>Flutter 构建流程中 <code>packFlutterAppAotTask</code> 会将生成的 <code>app.so</code> 移动并重命名为 <code>lib/&lt;abi&gt;/libapp.so</code>。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Task packFlutterAppAotTask = project.tasks.create(</span><br><span class="line"><span class="symbol">  name:</span> <span class="string">"packLibs$&#123;FLUTTER_BUILD_PREFIX&#125;$&#123;variant.name.capitalize()&#125;"</span>, <span class="string">type:</span> Jar) &#123;</span><br><span class="line">    destinationDir libJar.parentFile</span><br><span class="line">    archiveName libJar.name</span><br><span class="line">    dependsOn compileTask</span><br><span class="line">    targetPlatforms.each &#123; targetPlatform -&gt;</span><br><span class="line">        String abi = PLATFORM_ARCH_MAP[targetPlatform]</span><br><span class="line">        from(<span class="string">"$&#123;compileTask.intermediateDir&#125;/$&#123;abi&#125;"</span>) &#123;</span><br><span class="line">            include <span class="string">"*.so"</span></span><br><span class="line">            <span class="comment">// Move `app.so` to `lib/&lt;abi&gt;/libapp.so`</span></span><br><span class="line">            rename &#123; String filename -&gt;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"lib/$&#123;abi&#125;/lib$&#123;filename&#125;"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改一：注意这里的 <code>&lt;abi&gt;</code> 只支持上述提到的三种架构，并不包括 <code>armeabi</code>。我们可以修改 <code>packFlutterAppAotTask</code>，修改后将 <code>app.so</code> 移动并重命名为 <code>lib/armeabi/libapp.so</code> 的目的。</p><p>修改二：修改原始的 embedding jar 包(<code>libflutter.so</code> 从原始的 <code>lib/armeabi-v7a</code> 移到 <code>lib/armeabi</code> 目录)，并在 <code>gradle.properties</code> 中提供 <code>local-engine-repo</code>，将其指向修改后的 embedding jar 包。具体见 <a href="https://github.com/flutter/flutter/blob/master/packages/flutter_tools/gradle/flutter.gradle#L198" target="_blank" rel="noopener">addFlutterDependencies()</a></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the dependencies required by the Flutter project.</span></span><br><span class="line"><span class="comment"> * This includes:</span></span><br><span class="line"><span class="comment"> *    1. The embedding</span></span><br><span class="line"><span class="comment"> *    2. libflutter.so</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> addFlutterDependencies(buildType) &#123;</span><br><span class="line">    String flutterBuildMode = buildModeFor(buildType)</span><br><span class="line">    <span class="keyword">if</span> (!supportsBuildMode(flutterBuildMode)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    String repository = useLocalEngine()</span><br><span class="line">        ? project.property('local-engine-repo')</span><br><span class="line">        : MAVEN_REPO</span><br><span class="line"></span><br><span class="line">    project.rootProject.allprojects &#123;</span><br><span class="line">        repositories &#123;</span><br><span class="line">            maven &#123;</span><br><span class="line">                url repository</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://flutter.dev/docs/development/add-to-app/android/project-setup" target="_blank" rel="noopener">Integrate a Flutter module into your Android project - Flutter</a></p><p><a href="https://tech.youzan.com/you-zan-flutter-hun-bian-fang-an/" target="_blank" rel="noopener">有赞 Flutter 混编方案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单分析下 Flutter 如何集成到现有 Android 应用中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
  </entry>
  
</feed>
