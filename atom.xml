<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sunmoon的博客</title>
  
  <subtitle>点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sunmoonblog.com/"/>
  <updated>2022-10-13T12:10:49.527Z</updated>
  <id>http://www.sunmoonblog.com/</id>
  
  <author>
    <name>Sunmoon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次Git仓库瘦身</title>
    <link href="http://www.sunmoonblog.com/2022/10/12/reducing-git-repo-size/"/>
    <id>http://www.sunmoonblog.com/2022/10/12/reducing-git-repo-size/</id>
    <published>2022-10-12T13:12:16.000Z</published>
    <updated>2022-10-13T12:10:49.527Z</updated>
    
    <content type="html"><![CDATA[<p>网上同类文章比较多，不过正好有个项目自己需要动手实践一把，记录之。纸上得来终觉浅，绝知此事要躬行。<br><a id="more"></a></p><h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>对于Pods目录是否应该纳入版本控制，<a href="https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control" target="_blank" rel="noopener">CocoaPods官网</a>并未给出明确结论。官方原文如下：</p><blockquote><p>Whether or not you check in your Pods folder is up to you, as workflows vary from project to project. We recommend that you keep the Pods directory under source control, and don’t add it to your .gitignore. But ultimately this decision is up to you:</p></blockquote><blockquote><p>Benefits of checking in the Pods directory</p><ul><li>After cloning the repo, the project can immediately build and run, even without having CocoaPods installed on the machine. There is no need to run pod install, and no Internet connection is necessary.</li><li>The Pod artifacts (code/libraries) are always available, even if the source of a Pod (e.g. GitHub) were to go down.</li><li>The Pod artifacts are guaranteed to be identical to those in the original installation after cloning the repo.</li></ul><p>Benefits of ignoring the Pods directory</p><ul><li>The source control repo will be smaller and take up less space.</li><li>As long as the sources (e.g. GitHub) for all Pods are available, CocoaPods is generally able to recreate the same installation. (Technically there is no guarantee that running pod install will fetch and recreate identical artifacts when not using a commit SHA in the Podfile. This is especially true when using zip files in the Podfile.)</li><li>There won’t be any conflicts to deal with when performing source control operations, such as merging branches with different Pod versions.</li></ul><p>Whether or not you check in the Pods directory, the Podfile and Podfile.lock should always be kept under version control.</p></blockquote><p>简单来说就是：</p><ul><li>官方建议将Pods目录纳入版本控制，不建议将其添加到<code>.gitignore</code></li><li>Pods目录纳入版本控制的好处<ul><li>无需<code>pod install</code>(甚至无需安装CocoaPods)就能运行项目</li><li>永远可用的Pod artifacts</li><li>一致的Pod artifacts</li></ul></li><li>Pods目录不纳入版本控制的好处<ul><li>较小的Git仓库</li><li>无需处理Pod artifacts相关的代码冲突</li></ul></li></ul><p>值得一提的是，<code>Podfile</code>和<code>Podfile.lock</code>必须纳入版本控制。</p><p>我们按官方建议将Pods目录纳入版本控制。早期Git仓库体积不是问题，两年后的今天仓库体积大小增加到3GB。</p><p><img src="/images/16655834905586.jpg" alt="-w980"></p><p>仓库体积过大带来一系列问题：</p><ul><li>影响CI性能(代码都拉不下来，C什么I？)</li><li>切换git分支速度缓慢</li><li>无法使用git branch作为Pod依赖</li></ul><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ul><li><code>git filter-branch</code><ul><li><a href="https://www.cnblogs.com/oloroso/p/13367120.html" target="_blank" rel="noopener">删除 git 仓库中无用大文件 - 乌合之众 - 博客园</a></li><li><code>git filter-brach</code>速度太慢</li><li>命令较为复杂</li><li>功能强大</li><li>无日志</li></ul></li><li><a href="https://rtyley.github.io/bfg-repo-cleaner/" target="_blank" rel="noopener">BFG</a> <ul><li><a href="https://juejin.cn/post/7011545611551899662" target="_blank" rel="noopener">对 Git 仓库进行瘦身 - 掘金</a></li><li>速度极快</li><li>功能简单</li><li>有日志</li><li>bfg简单易用，傻瓜式</li></ul></li><li><a href="https://github.com/newren/git-filter-repo" target="_blank" rel="noopener">git-filter-repo</a><ul><li>功能强大</li></ul></li></ul><p><a href="https://docs.gitlab.com/ee/user/project/repository/reducing_the_repo_size_using_git.html#repository-cleanup" target="_blank" rel="noopener">GitLab官方</a>建议优先考虑使用 <a href="https://github.com/newren/git-filter-repo" target="_blank" rel="noopener">git-filter-repo</a>，其次才是 <a href="https://git-scm.com/docs/git-filter-branch" target="_blank" rel="noopener">git filter-branch</a> 或 <a href="https://rtyley.github.io/bfg-repo-cleaner/" target="_blank" rel="noopener">BFG</a>。不过我们的场景其实特别简单，即删除Git仓库中的<code>Pods</code>目录以减少仓库大小，所以使用 bfg 完全就够了。</p><p>使用<code>git filter-branch</code>删除Pods目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --force --index-filter </span><br><span class="line"> \ &apos;git rm -r --cached --ignore-unmatch &lt;path-to-pods&gt;&apos; </span><br><span class="line"> \ --prune-empty --tag-name-filter cat -- --all </span><br><span class="line"> </span><br><span class="line">git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</span><br></pre></td></tr></table></figure></p><p>使用<code>bgf</code>删除Pods目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -jar ~/Downloads/bfg-1.14.0.jar </span><br><span class="line"> \ --delete-folders Pods --no-blob-protection </span><br><span class="line"> \ &lt;path-to-repo&gt;</span><br><span class="line"> </span><br><span class="line">git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</span><br></pre></td></tr></table></figure></p><h1 id="实施过程"><a href="#实施过程" class="headerlink" title="实施过程"></a>实施过程</h1><p>先说主要步骤。</p><ul><li>第一步，备份Git仓库</li><li>第二步，删除大文件</li><li>第三步，更新.gitignore</li><li>第四步，推送Git仓库</li></ul><h2 id="备份Git仓库"><a href="#备份Git仓库" class="headerlink" title="备份Git仓库"></a>备份Git仓库</h2><p>有不同的方式来备份Git仓库。</p><p>一种方式是通过<a href="https://docs.gitlab.com/ee/user/project/settings/import_export.html#export-a-project-and-its-data" target="_blank" rel="noopener">Gitlab的仓库导出功能</a>来备份数据。这种方式的好处是导出的数据比较全，包括Issues、Merge Requests以及工程配置等</p><p>另一种方式是<code>git clone --bare</code>。</p><p>我采用第二种方式，操作比较简单。</p><h2 id="删除大文件"><a href="#删除大文件" class="headerlink" title="删除大文件"></a>删除大文件</h2><p>使用 <code>bgf</code> 删除 Pods 目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 删除所有的Pods目录</span><br><span class="line">java -jar ~/Downloads/bfg-1.14.0.jar </span><br><span class="line"> \ --delete-folders Pods --no-blob-protection </span><br><span class="line"> \ &lt;path-to-repo&gt;</span><br><span class="line"># 修改git历史记录</span><br><span class="line">git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</span><br></pre></td></tr></table></figure></p><p>上述操作完成后，可以发现两个变化：</p><ul><li>一个变化是原先的各个 <code>Pods</code> 目录没有了</li><li>另一个变化是仓库大小大大减小。</li></ul><p><code>git count-objects -vH</code>查看瘦身前后的仓库大小。从原来的2.04G减少到现在的93M，优化效果非常明显。</p><p><img src="/images/16655880382380.jpg" alt></p><h2 id="更新-gitignore"><a href="#更新-gitignore" class="headerlink" title="更新.gitignore"></a>更新.gitignore</h2><p>为了防止 <code>Pods</code> 目录再次被提交到仓库。我们在 <code>.gitignore</code> 文件中添加新的配置项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**/Pods/</span><br></pre></td></tr></table></figure><hr><p>我经常不太记得住 .gitignore 的写法。这里提供几个常见示例，备忘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#注释           .gitignore的注释</span><br><span class="line">*.txt           忽略所有 .txt 后缀的文件</span><br><span class="line">!src.a          忽略除 src.a 外的其他文件</span><br><span class="line">/todo           仅忽略项目根目录下的 todo 文件，不包括 src/todo</span><br><span class="line">build/          忽略 build/目录下的所有文件，过滤整个build文件夹；</span><br><span class="line">doc/*.txt       忽略doc目录下所有 .txt 后缀的文件，但不包括doc子目录的 .txt 的文件</span><br><span class="line"> </span><br><span class="line">bin/:           忽略当前路径下的 bin 文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件</span><br><span class="line">/bin:           忽略根目录下的 bin 文件</span><br><span class="line">/*.c:           忽略 cat.c，不忽略 build/cat.c</span><br><span class="line">debug/*.obj:    忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj</span><br><span class="line">**/foo:         忽略/foo, a/foo, a/b/foo等</span><br><span class="line">a/**/b:         忽略a/b, a/x/b, a/x/y/b等</span><br><span class="line">!/bin/run.sh    不忽略bin目录下的run.sh文件</span><br><span class="line">*.log:          忽略所有 .log 文件</span><br><span class="line">config.js:      忽略当前路径的 config.js 文件</span><br><span class="line"> </span><br><span class="line">/mtk/           忽略整个文件夹</span><br><span class="line">*.zip           忽略所有.zip文件</span><br><span class="line">/mtk/do.c       忽略某个具体文件</span><br></pre></td></tr></table></figure><hr><h2 id="推送Git仓库"><a href="#推送Git仓库" class="headerlink" title="推送Git仓库"></a>推送Git仓库</h2><p>将修改历史记录后的Git库推送到原仓库还是比较麻烦的。我们直接新建一个空仓库，然后推送到新仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --mirror &lt;新仓库&gt;</span><br></pre></td></tr></table></figure><h1 id="优化效果"><a href="#优化效果" class="headerlink" title="优化效果"></a>优化效果</h1><p>不得不说瘦身后的仓库用起来清爽多了！</p><p><img src="/images/16656629733856.jpg" alt></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.cnblogs.com/oloroso/p/13367120.html" target="_blank" rel="noopener">删除 git 仓库中无用大文件 - 乌合之众 - 博客园</a></li><li><a href="https://juejin.cn/post/7011545611551899662" target="_blank" rel="noopener">对 Git 仓库进行瘦身 - 掘金</a></li><li><a href="http://www.huamo.online/2017/11/22/%E4%B8%BAGit%E4%BB%93%E5%BA%93%E7%98%A6%E8%BA%AB/" target="_blank" rel="noopener">为Git仓库瘦身 | 花木兰</a></li><li><a href="https://docs.gitlab.com/ee/user/project/repository/reducing_the_repo_size_using_git.html#repository-cleanup" target="_blank" rel="noopener">Reduce repository size | GitLab</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上同类文章比较多，不过正好有个项目自己需要动手实践一把，记录之。纸上得来终觉浅，绝知此事要躬行。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2022.10.9梅沙尖徒步</title>
    <link href="http://www.sunmoonblog.com/2022/10/12/hiking/"/>
    <id>http://www.sunmoonblog.com/2022/10/12/hiking/</id>
    <published>2022-10-12T13:01:38.000Z</published>
    <updated>2022-10-12T13:14:31.546Z</updated>
    
    <content type="html"><![CDATA[<p>记2022.10.9梅沙尘徒步。<br><a id="more"></a><br>国庆7天长假后紧接着就是7天上班。考虑到连上7天班实在难熬，而剩余年假还有10天，便毫不犹豫地请假休息1天。送皮皮上学，再送可可去托班，剩余的时间便是我自己的。跟老婆商量了一下，定好去爬梅沙尖。</p><p>梅沙尖坐落于广东省深圳市盐田区盐田街道，最高峰海拔753米，是深圳的第三高峰。从宝体开车到梅沙尖，大概1个半小时，一路通畅好心情。</p><p>导航目的地是”梅沙尖”，结果导到了北山道旁边的三盐公路上，三盐公路往梅沙尖需要通行证。只好将错就错把车停下，人继续沿三盐公路往梅沙尖步行，由于开启了一段误打误撞却别有趣味的一段徒步。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/10/12/16654086891544.jpg" alt="w500"></p><p>需要提一下的是，北山道往北山立交方向一直开到路尽头就是盐田海鲜街。开车去往梅沙尖，正确的导航目的地应该是”孙中山庚子首义园”，建议走北环大道-罗沙路-惠深沿海高速-盐三路。</p><p>三盐公路既能通车(需要通行证)，也是一条绿道。这条绿道可以到达梅沙尖。<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/10/12/imgv26c6e94d9dd3d4ed28c1978641747823g.jpg" alt="img_v2_6c6e94d9-dd3d-4ed2-8c19-78641747823g"></p><p>绿道上一共有9个休息节点。不过短短的一段路，却迂回得让人绝望。<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/10/12/imgv2dcc6208de029481b963501f46be697cg.jpg" alt="img_v2_dcc6208d-e029-481b-9635-01f46be697cg"></p><p>一路上的风景，多数是这样。<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/10/12/imgv2cca94d7b298c41abb15ccb4e6cd0971g.jpg" alt="img_v2_cca94d7b-298c-41ab-b15c-cb4e6cd0971g"></p><p>运气好的话，路上可以买到瓶装水。记得自觉扫码。<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/10/12/16654100488247.jpg" alt></p><p>我们在翠岭水库稍作停留，在桥下凳子上吃了点东西。然后从桥下小路去往梅沙尖。注意看路标，要看准梅沙尖方向。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/10/12/16654104716291.jpg" alt></p><p>接下来一路上的风景非常不错。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/10/12/16654113750336.jpg" alt></p><p>遇到了山间的一条小溪。水质超级棒，还有一条休息的小娃娃鱼(太无知了，我以为天太热蜥蜴下水游泳了)</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/10/12/16654114422541.jpg" alt></p><p>一个多小时的艰难路程，终于到达梅沙尖。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/10/12/imgv2bbeb64a32e5d4200a18db2ee6702015g.jpg" alt="img_v2_bbeb64a3-2e5d-4200-a18d-b2ee6702015g"></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/10/12/imgv27c433633d9bd443fa37736a6f7f91a3g.jpg" alt="img_v2_7c433633-d9bd-443f-a377-36a6f7f91a3g"></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/10/12/imgv2b88982fe77b44554b4bfce2f777a24eg.jpg" alt="img_v2_b88982fe-77b4-4554-b4bf-ce2f777a24eg"></p><p>嘀，打卡。这地标，有点寒碜。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/10/12/imgv2cd5fdbc2b87c4a0cb2d4d4fd0a38e1bg.jpg" alt="img_v2_cd5fdbc2-b87c-4a0c-b2d4-d4fd0a38e1bg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记2022.10.9梅沙尘徒步。&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://www.sunmoonblog.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ClickHosue 入门(一)</title>
    <link href="http://www.sunmoonblog.com/2022/06/29/clickhosue-1/"/>
    <id>http://www.sunmoonblog.com/2022/06/29/clickhosue-1/</id>
    <published>2022-06-29T02:46:46.000Z</published>
    <updated>2022-07-02T09:39:07.613Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><p>翻译 <a href="https://clickhouse.com/docs/en/quick-start" target="_blank" rel="noopener">Quick Start | ClickHouse Docs</a></p><h1 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h1><p>第一步，本地下载 ClickHouse 最简单的方式是运行 <code>curl https://clickhouse.com/ | sh</code> 命令。如果系统支持 ClickHouse，会自动下载 ClickHouse 二进制包并且添加可执行权限。</p><p>第二步，运行 <code>sudo ./clickhouse install</code> 命令，会为 ClickHouse 创建相应的软链接。</p><p>第三步，脚本运行结束后会提示用户输入密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Creating log directory /var/log/clickhouse-server.</span><br><span class="line">Creating data directory /var/lib/clickhouse.</span><br><span class="line">Creating pid directory /var/run/clickhouse-server.</span><br><span class="line"> chown -R clickhouse:clickhouse &apos;/var/log/clickhouse-server&apos;</span><br><span class="line"> chown -R clickhouse:clickhouse &apos;/var/run/clickhouse-server&apos;</span><br><span class="line"> chown  clickhouse:clickhouse &apos;/var/lib/clickhouse&apos;</span><br><span class="line">Enter password for default user:</span><br></pre></td></tr></table></figure><p>ClickHouse 安装成功后输出以下日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Start clickhouse-server with:</span><br><span class="line"> sudo clickhouse start</span><br><span class="line"></span><br><span class="line">Start clickhouse-client with:</span><br><span class="line"> clickhouse-client</span><br></pre></td></tr></table></figure><p>第四步，运行以下命令来启动服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo clickhouse start</span><br></pre></td></tr></table></figure><h1 id="连接-ClickHouse"><a href="#连接-ClickHouse" class="headerlink" title="连接 ClickHouse"></a>连接 ClickHouse</h1><p>缺省时 ClickHouse 在 8123 端口启动 Http 服务。<a href="http://127.0.0.1:8123/play" target="_blank" rel="noopener">http://127.0.0.1:8123/play</a> 提供内置的SQL查询器(根据实际情况修改hostname)</p><p><img src="/images/16564715665938.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW databases</span><br></pre></td></tr></table></figure><p>点击 RUN 按钮后结果展示如下：</p><p><img src="/images/16564716127327.jpg" alt></p><h1 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h1><p>跟大部分数据库管理系统类似，ClickHouse 从逻辑上将以数据库(databases)的形式对数据表(tables)分组。</p><p>ClickHouse 中即使最简单的表也必须指定表引擎(<code>table engine</code>)。表引擎决定以下细节：</p><ul><li>数据如何存放，数据存放到哪里</li><li>支持哪些查询</li><li>数据是否可复制</li></ul><p>有许多种引擎可供使用，但对单节点的 ClickHouse 服务器来说<a href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree" target="_blank" rel="noopener">MergeTree</a>是常见的选择。以下命令在数据库 <code>helloworld</code> 中创建名为 <code>my_first_table</code> 的数据表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE helloworld.my_first_table</span><br><span class="line">(</span><br><span class="line">    user_id UInt32,</span><br><span class="line">    message String,</span><br><span class="line">    timestamp DateTime,</span><br><span class="line">    metric Float32</span><br><span class="line">)</span><br><span class="line">ENGINE = MergeTree()</span><br><span class="line">PRIMARY KEY (user_id, timestamp)</span><br></pre></td></tr></table></figure><h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><p>使用 <code>INSERT INTO TABLE</code> 在 ClickHouse 中插入数据。不过要注意的是每次向 MergeTree 表中插入数据时都会导致数据存储中生成一个 <strong>part</strong>。</p><p>使用 ClickHouse 的最佳实践是一次性批量插入大量数据，比如说上万行甚至百万行。(别担心，ClickHouse 可以处理这种量级的数据)。</p><ul><li>即使对于简单的例子，我们也是一次插入多条数据：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO helloworld.my_first_table (user_id, message, timestamp, metric) VALUES</span><br><span class="line">    (101, &apos;Hello, ClickHouse!&apos;,                                 now(),       -1.0    ),</span><br><span class="line">    (102, &apos;Insert a lot of rows per batch&apos;,                     yesterday(), 1.41421 ),</span><br><span class="line">    (102, &apos;Sort your data based on your commonly-used queries&apos;, today(),     2.718   ),</span><br><span class="line">    (101, &apos;Granules are the smallest chunks of data read&apos;,      now() + 5,   3.14159 )</span><br></pre></td></tr></table></figure><ul><li>确认是否正常工作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM helloworld.my_first_table</span><br></pre></td></tr></table></figure><p>可以看到已经插入了四行数据：</p><p><img src="/images/16567536616501.jpg" alt></p><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>可以使用 clickhouse-client 命令行工具连接 ClickHouse server。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client</span><br></pre></td></tr></table></figure><p>如果看到笑脸提示符，说明已经成功连接到 ClickHouse server。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:)</span><br></pre></td></tr></table></figure><p>连接成功后可以尝试查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM helloworld.my_first_table</span><br><span class="line">ORDER BY timestamp</span><br></pre></td></tr></table></figure><p>注意返回结果以表格形式展示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM helloworld.my_first_table</span><br><span class="line">ORDER BY timestamp ASC</span><br><span class="line"></span><br><span class="line">Query id: f7a33012-bc8c-4f0f-9641-260ee1ffe4b8</span><br><span class="line"></span><br><span class="line">┌─user_id─┬─message────────────────────────────────────────────┬───────────timestamp─┬──metric─┐</span><br><span class="line">│     102 │ Insert a lot of rows per batch                     │ 2022-03-21 00:00:00 │ 1.41421 │</span><br><span class="line">│     102 │ Sort your data based on your commonly-used queries │ 2022-03-22 00:00:00 │   2.718 │</span><br><span class="line">│     101 │ Hello, ClickHouse!                                 │ 2022-03-22 14:04:09 │      -1 │</span><br><span class="line">│     101 │ Granules are the smallest chunks of data read      │ 2022-03-22 14:04:14 │ 3.14159 │</span><br><span class="line">└─────────┴────────────────────────────────────────────────────┴─────────────────────┴─────────┘</span><br><span class="line"></span><br><span class="line">4 rows in set. Elapsed: 0.008 sec.</span><br></pre></td></tr></table></figure><p>可以添加 <strong>FORMAT</strong> 子句来指定<a href="https://clickhouse.com/docs/en/interfaces/formats/" target="_blank" rel="noopener">输出格式</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM helloworld.my_first_table</span><br><span class="line">ORDER BY timestamp</span><br><span class="line">FORMAT TabSeparated</span><br></pre></td></tr></table></figure><p>上述查询中，输出结果以 tab 分隔符返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Query id: 3604df1c-acfd-4117-9c56-f86c69721121</span><br><span class="line"></span><br><span class="line">102 Insert a lot of rows per batch  2022-03-21 00:00:00 1.41421</span><br><span class="line">102 Sort your data based on your commonly-used queries  2022-03-22 00:00:00 2.718</span><br><span class="line">101 Hello, ClickHouse!  2022-03-22 14:04:09 -1</span><br><span class="line">101 Granules are the smallest chunks of data read   2022-03-22 14:04:14 3.14159</span><br><span class="line"></span><br><span class="line">4 rows in set. Elapsed: 0.005 sec.</span><br></pre></td></tr></table></figure><p>使用 <strong>exit</strong> 命令退出 clickhouse-client</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:) exit</span><br><span class="line">Bye.</span><br></pre></td></tr></table></figure><h1 id="导入CSV"><a href="#导入CSV" class="headerlink" title="导入CSV"></a>导入CSV</h1><p>A common task when getting started with a database is to insert some data that you already have in files. We have some sample data online that you can insert that represents clickstream data - it includes a user ID, a URL that was visited, and the timestamp of the event.</p><p>一个常见任务是将文件中的数据导入到数据库。我们有一些在线的点击流示例数据，包括用户ID、访问的URL以及事件戳。</p><p>假设一个名为 <code>data.csv</code> 的文件中有以下数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">102,This is data in a file,2022-02-22 10:43:28,123.45</span><br><span class="line">101,It is comma-separated,2022-02-23 00:00:00,456.78</span><br><span class="line">103,Use FORMAT to specify the format,2022-02-21 10:43:30,678.90</span><br></pre></td></tr></table></figure><p>以下命令将数据插入 <strong>my_first_table</strong> 表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client --query=&apos;INSERT INTO helloworld.my_first_table FORMAT CSV&apos; &lt; data.csv</span><br></pre></td></tr></table></figure><p>可以看到新的数据入库了。</p><p><img src="/images/16567543203933.jpg" alt></p><h1 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h1><ul><li>这份<a href="https://clickhouse.com/docs/en/tutorial" target="_blank" rel="noopener">教程</a>教你如何将两百万条数据插入ClickHouse并且写一些分析查询</li><li>这里有一些<a href="https://clickhouse.com/docs/en/getting-started/example-datasets/" target="_blank" rel="noopener">示例数据集</a></li><li>这是一个25分钟的视频<a href="https://clickhouse.com/company/events/getting-started-with-clickhouse/" target="_blank" rel="noopener">Getting Started with ClickHouse</a></li><li>如果你的数据来自外部，可以通过<a href="https://clickhouse.com/docs/en/integrations/" target="_blank" rel="noopener">集成指南集合</a>来了解如何连接到消息队列、数据库、流水线</li><li>如果你使用UI/BI可视化分析工具，可以通过<a href="https://clickhouse.com/docs/en/connect-a-ui/" target="_blank" rel="noopener">user guides for connecting a UI to ClickHouse</a>了解更多技巧</li><li>通过<a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-intro" target="_blank" rel="noopener">primary keys</a>一文来了解如何在ClickHouse中定义主键</li></ul><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>问题一：启动时提示监控端口失败，无法访问 ClickHouse</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2022.06.29 11:44:33.144576 [ 23415 ] &#123;&#125; &lt;Warning&gt; Application: Listen [::1]:8123 failed: Poco::Exception. Code: 1000, e.code() = 99, Net Exception: Cannot assign requested address: [::1]:8123 (version 22.7.1.823 (official build)). If it is an IPv6 or IPv4 address and your host has disabled IPv6 or IPv4, then consider to specify not disabled IPv4 or IPv6 address to listen in &lt;listen_host&gt; element of configuration file. Example for disabled IPv6: &lt;listen_host&gt;0.0.0.0&lt;/listen_host&gt; . Example for disabled IPv4: &lt;listen_host&gt;::&lt;/listen_host&gt;</span><br><span class="line">2022.06.29 11:44:33.144986 [ 23415 ] &#123;&#125; &lt;Warning&gt; Application: Listen [::1]:9000 failed: Poco::Exception. Code: 1000, e.code() = 99, Net Exception: Cannot assign requested address: [::1]:9000 (version 22.7.1.823 (official build)). If it is an IPv6 or IPv4 address and your host has disabled IPv6 or IPv4, then consider to specify not disabled IPv4 or IPv6 address to listen in &lt;listen_host&gt; element of configuration file. Example for disabled IPv6: &lt;listen_host&gt;0.0.0.0&lt;/listen_host&gt; . Example for disabled IPv4: &lt;listen_host&gt;::&lt;/listen_host&gt;</span><br><span class="line">2022.06.29 11:44:33.145252 [ 23415 ] &#123;&#125; &lt;Warning&gt; Application: Listen [::1]:9004 failed: Poco::Exception. Code: 1000, e.code() = 99, Net Exception: Cannot assign requested address: [::1]:9004 (version 22.7.1.823 (official build)). If it is an IPv6 or IPv4 address and your host has disabled IPv6 or IPv4, then consider to specify not disabled IPv4 or IPv6 address to listen in &lt;listen_host&gt; element of configuration file. Example for disabled IPv6: &lt;listen_host&gt;0.0.0.0&lt;/listen_host&gt; . Example for disabled IPv4: &lt;listen_host&gt;::&lt;/listen_host&gt;</span><br></pre></td></tr></table></figure><p>解决办法：<code>clickhouse-server -- --listen_host=0.0.0.0</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Space Commander 介绍</title>
    <link href="http://www.sunmoonblog.com/2022/06/04/space-commander/"/>
    <id>http://www.sunmoonblog.com/2022/06/04/space-commander/</id>
    <published>2022-06-04T08:57:05.000Z</published>
    <updated>2022-06-04T13:33:59.318Z</updated>
    
    <content type="html"><![CDATA[<p>Space Commander 是 Square 开源的一款 Objective C 代码格式化工具，这个工具可以为 iOS 开发者向 Git 仓库提交代码时提供统一的格式化能力。<br><a id="more"></a></p><p>以下一节翻译自 <a href="https://github.com/square/spacecommander/blob/master/README.md" target="_blank" rel="noopener">Space Commander README.md</a></p><p>Space Commander 让一组 iOS 开发人员可以向 git 仓库提交统一格式的代码，无需任何人工修复。</p><p>你可以使用它完成以下工作：</p><ul><li>在代码提交前强制使用统一的格式</li><li>一键格式化代码(单个文件或整个仓库)</li><li>未格式化的代码提交时编译失败</li></ul><p>在 Square，Space Commander 有一个针对 pull request 的工作流水线。应用格式化标准时无需人工干预，时间可以花在更有意义的地方。</p><p>你可以 for Space Commander，然后使用自己的格式化规则，或者直接使用 Square 的 Objective-C 格式化规则。</p><ul><li>本地安装</li></ul><p>从 git 仓库根目录，运行 <code>path/to/spacecommander/setup-repo.sh</code> 即可为当前仓库添加 <code>pre-commit</code>。</p><ul><li>用法</li></ul><p>运行 <code>setup-repo.sh</code> 之后每次提交代码时会自动进行格式化检查。</p><p>运行 <code>format-objc-file.sh &lt;file&gt;</code> 可以对单个文件进行格式化。运行 <code>format-objc-file-dry-run.sh &lt;file&gt;</code> 可以对单个文件进行格式化，但不修改文件本身。</p><p>运行 <code>format-objc-files-in-repo.sh</code> 格式化仓库中所有的的 OC 文件。</p><ul><li>详情</li></ul><p>项目中的每个开发者运行 setup script 后就会安装 pre-commit 钩子。这个钩子会在 commit 成功前检查代码是否有格式化。</p><p>commit 时如果有格式错误，会自动运行一个修复代码的脚本。</p><p>在 Square，这个提供格式化脚本的仓库是更大规模的 iOS 项目中的一个子模块，所以格式化规则及脚本会锁定到父仓库的某个版本。我们以这种方式检出格式化的代码，作为构建过程中的一部分。如果格式不正确，构建会中止。</p><ul><li>配置</li></ul><p>为了只格式化特定目录中的 OC 文件，需要在 <code>.formatting-directory</code> 指定每个目录的名字。否则，将检查仓库中所有的 OC 文件。</p><p>为了忽略特定目录中的 OC 文件，需要在 <code>.formatting-directory-ignore</code> 指定每个目录的名字。</p><p>编辑以下文件来修改格式化输出：</p><ul><li>编辑 <code>.clang-format</code> 修改内置的 <code>clang-format</code> 选项</li><li><code>format-objc-file-dry-run.sh</code>和 <code>format-objc-file.sh</code> 来修改 <code>custom/</code> 中的规则</li><li><code>Testing Support/</code> 用于验证修改</li></ul><p>如果期望 formatter 忽略某些文件，可以在文件的第一行添加 <code>#pragma Formatter Exempt</code> 或 <code>// MARK: Formatter Exempt</code>。</p><ul><li>自定义规则</li></ul><p><code>clang-format</code> 非常赞，我们喜欢它。但它仍然有许多限制。我们在 <code>custom/</code> 中添加了自己的格式化规则。你也可以在 <code>custom/</code> 中添加自己的规则，然后调用 <code>format-objc-file.sh</code> 和 <code>format-objc-file-dry-run.sh</code> 来应用新的规则。输入输出示例添加到 <code>Testing Support/</code> 目录下。</p><ul><li>预期外的输出</li></ul><p>formatter 并不能完成所有的事情。偶尔会产生预期外的结果，此时的处理办法如下：</p><ul><li>重构代码，以便 formatter 更容易识别代码</li><li>使用 <code>// clang-format off</code> 或 <code>// clang-format on</code> 来选择性地为文件中的指定行开启或关闭 <code>clang-format</code></li><li>在文件首行添加 <code>#pragma Formatter Exempt</code> 或 <code>// MARK: Formatter Exempt</code>，当前文件不会被格式化</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/1b402a68c325" target="_blank" rel="noopener">Xcode代码格式化 .clang-format配置与使用 - 简书</a></li><li><a href="https://www.jianshu.com/p/561739ae03e1" target="_blank" rel="noopener">使用spacecommander 格式化iOS项目代码 - 简书</a></li><li><a href="https://github.com/travisjeffery/ClangFormat-Xcode" target="_blank" rel="noopener">travisjeffery/ClangFormat-Xcode: Xcode plug-in to to use clang-format from in Xcode and consistently format your code with Clang</a></li><li><a href="https://stackoverflow.com/questions/17476859/xcode-and-checking-for-code-convention" target="_blank" rel="noopener">objective c - Xcode and checking for code convention - Stack Overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Space Commander 是 Square 开源的一款 Objective C 代码格式化工具，这个工具可以为 iOS 开发者向 Git 仓库提交代码时提供统一的格式化能力。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git Hooks 小记</title>
    <link href="http://www.sunmoonblog.com/2022/06/03/git-hooks/"/>
    <id>http://www.sunmoonblog.com/2022/06/03/git-hooks/</id>
    <published>2022-06-03T08:19:00.000Z</published>
    <updated>2022-06-04T08:53:12.467Z</updated>
    
    <content type="html"><![CDATA[<p>了解 Git hook 的用法。<br><a id="more"></a></p><h1 id="Git-hook"><a href="#Git-hook" class="headerlink" title="Git hook"></a>Git hook</h1><p>Git hook 是 Git 提供的功能。Git hook 分为客户端 hook 和服务器端 hook。</p><blockquote><p>客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作</p></blockquote><blockquote><p>钩子都被存储在 Git 目录下的 hooks 子目录中。 也即绝大部分项目中的 .git/hooks 。 当你用 git init 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。 这些脚本除了本身可以被调用外，它们还透露了被触发时所传入的参数。 所有的示例都是 shell 脚本，其中一些还混杂了 Perl 代码，不过，任何正确命名的可执行脚本都可以正常使用 —— 你可以用 Ruby 或 Python，或任何你熟悉的语言编写它们。 这些示例的名字都是以 .sample 结尾，如果你想启用它们，得先移除这个后缀。</p></blockquote><p>常用钩子如下：</p><ul><li><code>pre-commit</code> - 在键入提交信息前运行。 它用于检查即将提交的快照，例如，检查是否有所遗漏，确保测试运行，以及核查代码。 如果该钩子以非零值退出，Git 将放弃此次提交，不过你可以用 git commit –no-verify 来绕过这个环节。</li><li><code>pre-receive</code> - 处理来自客户端的推送操作时，最先被调用的脚本是 pre-receive。 它从标准输入获取一系列被推送的引用。如果它以非零值退出，所有的推送内容都不会被接受。 你可以用这个钩子阻止对引用进行非快进（non-fast-forward）的更新，或者对该推送所修改的所有引用和文件进行访问控制</li></ul><p>客户端钩子的使用非常简单。在工程的 <code>.git/hooks</code> 目录中可以找到许多内置的钩子。</p><p><img src="/images/16543134395089.jpg" alt="-w766"></p><p>这是一个 <code>commit-msg</code> 钩子。内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">MSG=`awk <span class="string">'&#123;printf("%s",$0)&#125;'</span> <span class="variable">$1</span>`</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$MSG</span> =~ ^Merge|(feat|fix|perf|refactor|version|<span class="built_in">test</span>|docs|style|build|ci|lint|demo|chore):[[:space:]].*$ ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[32m commit success! \033[0m"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"\033[31m 错误: 不规范的提交信息！ \033[m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31m 提示: 可选的提交类型 [feat|fix|perf|lint|refactor|version|test|docs|style|build|ci|chore|demo] \033[m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\n"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31m  feat: 新功能 \033[m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31m  fix: 问题修复 \033[m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31m  build: 依赖项更新，比如升级第三方库版本 \033[m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31m  ci: CI 配置或脚本更新 \033[m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31m  lint: 代码警告清理(基本不影响功能) \033[m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31m  perf: 性能优化(不影响功能) \033[m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31m  refactor: 代码重构(不影响功能) \033[m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31m  version: SDK版本号更新(不影响功能) \033[m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31m  test: 测试代码更新(不影响功能) \033[m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31m  demo: demo代码更新(不影响功能) \033[m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31m  docs: 文档更新(不影响功能) \033[m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31m  style: 代码格式化(不影响功能) \033[m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[31m  chore: 代码或文档以外的更新，比如更新CHANGELOG(不影响功能) \033[m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\n"</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"\033[31m 示例: feat: 订单模块增加倒计时功能 \033[m"</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>默认的客户端 hook 是放在 .git/hooks/ 目录下，所以不受版本控制。</p><p>我们可以将客户端 hook 纳入到版本控制中。在根目录中新建 <code>.githooks</code> 目录，目录中放 hook 脚本，然后执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.hooksPath .githooks</span><br></pre></td></tr></table></figure><p>服务器端的钩子也是类似方法来配置。Gitlab 支持 <a href="https://docs.gitlab.com/ee/administration/server_hooks.html" target="_blank" rel="noopener">Server hooks</a></p><p><img src="/images/16543319076458.jpg" alt="-w1363"></p><blockquote><p>GitLab administrators configure server hooks on the file system of the GitLab server. If you don’t have file system access, alternatives to server hooks include:</p><ul><li><a href="https://docs.gitlab.com/ee/user/project/integrations/webhooks.html" target="_blank" rel="noopener">Webhooks</a></li><li><a href="https://docs.gitlab.com/ee/ci/index.html" target="_blank" rel="noopener">GitLab CI/CD</a></li><li><a href="https://docs.gitlab.com/ee/user/project/repository/push_rules.html" target="_blank" rel="noopener">Push rules</a>, for a user-configurable Git hook interface.</li></ul></blockquote><p>不过，公司的git服务器由专人管理，我们通常无权限随意修改服务端的钩子。Gitlab 提供的其他可替代方案包括：Webhooks、GitLab CI/CD、Push rules</p><p><a href="https://docs.gitlab.com/ee/user/project/repository/push_rules.html" target="_blank" rel="noopener">Push rules</a> 机制，允许用户为自己的项目设备 <code>pre-receive</code> 钩子。</p><blockquote><p>Push rules are pre-receive Git hooks you can enable in a user-friendly interface. Push rules give you more control over what can and can’t be pushed to your repository. </p></blockquote><p><img src="/images/16543140681504.jpg" alt="-w1433"></p><p>不过，这个功能只在 Gitlab Premium 版本中提供，Gitlab CE 版本中不支持。很不幸，我们公司使用的是 Gitlab CE 版本。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>钩子(hook)是 Git 提供的功能，它跟 Github、Gitlab 或 Gogs 无关</li><li>钩子分客户端钩子和服务器端钩子</li><li>Gitlab 支持 Server hooks。不过 Serve hooks 一般只有系统管理员才有权限操作</li><li>Gitlab Premium 版本支持 Push Rules (即 <code>pre-receive</code>)</li><li>Gitlab CE 版本不支持 Push Rules</li><li>Gitlab CE 版本中 Push Rules 的最佳替代方案是 GitLab CI/CD</li><li>可以通过 <code>git config core.hooksPath &lt;path&gt;</code> 调整钩子目录来将钩子纳入到版本管理中来</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks" target="_blank" rel="noopener">Git - Git Hooks</a></li><li><a href="http://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">Git - Git 钩子</a></li><li><a href="https://blog.csdn.net/Muscleheng/article/details/122060783" target="_blank" rel="noopener">gitLab hooks简介和简单使用_Muscleheng的博客-CSDN博客_gitlab hooks使用</a></li><li><a href="https://docs.gitlab.com/ee/user/project/repository/push_rules.html" target="_blank" rel="noopener">Push rules | GitLab</a></li><li><a href="https://docs.gitlab.com/ee/administration/server_hooks.html" target="_blank" rel="noopener">Server hooks | GitLab</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解 Git hook 的用法。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Puppeteer 问题小记</title>
    <link href="http://www.sunmoonblog.com/2022/05/23/puppeteer-in-practice/"/>
    <id>http://www.sunmoonblog.com/2022/05/23/puppeteer-in-practice/</id>
    <published>2022-05-23T01:33:24.000Z</published>
    <updated>2022-06-06T06:45:10.169Z</updated>
    
    <content type="html"><![CDATA[<p>记录使用 Puppeteer 时遇到的两个小问题，以备忘。<br><a id="more"></a></p><h1 id="安装-puppeteer-失败"><a href="#安装-puppeteer-失败" class="headerlink" title="安装 puppeteer 失败"></a>安装 puppeteer 失败</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ npm i puppeteer</span><br><span class="line">&gt; puppeteer@14.1.1 install /home/gitlab-runner/builds/deaaa930/0/project-abc/node_modules/puppeteer</span><br><span class="line">&gt; node install.js</span><br><span class="line">ERROR: Failed to set up Chromium r991974! Set &quot;PUPPETEER_SKIP_DOWNLOAD&quot; env variable to skip download.</span><br><span class="line">Error: connect ETIMEDOUT 172.217.31.16:443</span><br><span class="line">    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1144:16) &#123;</span><br><span class="line">  errno: &apos;ETIMEDOUT&apos;,</span><br><span class="line">  code: &apos;ETIMEDOUT&apos;,</span><br><span class="line">  syscall: &apos;connect&apos;,</span><br><span class="line">  address: &apos;172.217.31.16&apos;,</span><br><span class="line">  port: 443</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">npm WARN notsup Unsupported engine for puppeteer@14.1.1: wanted: &#123;&quot;node&quot;:&quot;&gt;=14.1.0&quot;&#125; (current: &#123;&quot;node&quot;:&quot;12.22.7&quot;,&quot;npm&quot;:&quot;6.14.15&quot;&#125;)</span><br><span class="line">npm WARN notsup Not compatible with your version of node/npm: puppeteer@14.1.1</span><br><span class="line">npm WARN enoent ENOENT: no such file or directory, open &apos;/home/gitlab-runner/builds/deaaa930/0/project-abc/package.json&apos;</span><br><span class="line">npm WARN project-abc No description</span><br><span class="line">npm WARN project-abc No repository field.</span><br><span class="line">npm WARN project-abc No README data</span><br><span class="line">npm WARN project-abc No license field.</span><br><span class="line">npm ERR! code ELIFECYCLE</span><br><span class="line">npm ERR! errno 1</span><br><span class="line">npm ERR! puppeteer@14.1.1 install: `node install.js`</span><br><span class="line">npm ERR! Exit status 1</span><br><span class="line">npm ERR! </span><br><span class="line">npm ERR! Failed at the puppeteer@14.1.1 install script.</span><br></pre></td></tr></table></figure><p>看错误日志是在执行 <code>npm i puppeteer</code> 时出现失败，猜测是当时出现网络故障。</p><p>解决办法：实际上已经在 gitlab runner 所在的机器上全局安装过 <a href="mailto:puppeteer@14.1.1" target="_blank" rel="noopener">puppeteer@14.1.1</a>，且设置了 gitlab CI 缓存，所以没必要每次构建时都重新安装。<code>.gitlab-ci.yml</code> 优化如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">stages:</span><br><span class="line">  - build</span><br><span class="line">  - test</span><br><span class="line">  - deploy</span><br><span class="line"></span><br><span class="line">before_script:</span><br><span class="line">  #- whoami</span><br><span class="line">  - npm list puppeteer</span><br><span class="line">  - npm list puppeteer || npm install puppeteer@14.1.1  </span><br><span class="line"></span><br><span class="line">bugly:</span><br><span class="line">  stage: build</span><br><span class="line">  cache:</span><br><span class="line">    key: $&#123;CI_BUILD_REF_NAME&#125;</span><br><span class="line">    paths:</span><br><span class="line">      - node_modules/</span><br><span class="line">  script:</span><br><span class="line">    ./bugly.sh &quot;$&#123;IS_PRD&#125;&quot;</span><br><span class="line">  tags:</span><br><span class="line">    - android</span><br><span class="line">  only:</span><br><span class="line">    - bugly-trigger</span><br><span class="line">  allow_failure: true</span><br></pre></td></tr></table></figure><p>优化后的另一个意想不到的好处是 gitlab CI速度加快了 (省去了安装 重新安装 puppeteer 的过程)</p><p><img src="/images/16532726175570.jpg" alt></p><h1 id="puppeteer-脚本执行失败"><a href="#puppeteer-脚本执行失败" class="headerlink" title="puppeteer 脚本执行失败"></a>puppeteer 脚本执行失败</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./bugly.sh &quot;$&#123;IS_PRD&#125;&quot;</span><br><span class="line">(node:4711) UnhandledPromiseRejectionWarning: TypeError: Cannot read property &apos;waitForSelector&apos; of undefined</span><br><span class="line">    at /home/gitlab-runner/builds/deaaa930/0/project-abc/pp.js:33:17</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:97:5)</span><br><span class="line">(node:4711) UnhandledPromiseRejectionWarning: Unhandled promise rejection. </span><br><span class="line">  This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 1)</span><br><span class="line">(node:4711) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</span><br><span class="line">Session terminated, killing shell... ...killed.</span><br><span class="line">ERROR: Job failed: execution took longer than 1h0m0s seconds</span><br></pre></td></tr></table></figure><p>错误原因：脚本中找不到指定元素后出错了，但是没有进行异常处理。正常情况下会执行 <code>await browser.close()</code> 及时关闭浏览器，异常时不会关闭浏览器而是无限等待，直到到达 gitlab CI的超时时间(60分钟)后才被外部杀死。</p><p>解决办法：增加异常处理和重试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无异常处理</span></span><br><span class="line"><span class="comment">//(async () =&gt; &#123;</span></span><br><span class="line"><span class="comment">//    const browser = await puppeteer.launch(&#123;&#125;);</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    // page: 用于模拟登录流程</span></span><br><span class="line"><span class="comment">//    const page = (await browser.pages())[0];</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//      // 原脚本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    console.log(c);</span></span><br><span class="line"><span class="comment">//    await browser.close();</span></span><br><span class="line"><span class="comment">//&#125;)();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有异常处理</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// page: 用于模拟登录流程</span></span><br><span class="line">        <span class="keyword">const</span> page = (<span class="keyword">await</span> browser.pages())[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 原脚本</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">console</span>.log(c);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> browser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>此外，还在增加异常处理的基础上补充了重试机制。重试代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">retry</span>(<span class="params">promiseFactory, retryCount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> promiseFactory();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (retryCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> retry(promiseFactory, retryCount - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考自<a href="https://stackoverflow.com/questions/56884276/best-practice-for-retrying-page-goto-page-waitfornavigation-etc-in-puppeteer-j" target="_blank" rel="noopener">这里</a>。</p><h2 id="自动登录"><a href="#自动登录" class="headerlink" title="自动登录"></a>自动登录</h2><p>两个办法。一是直接使用 <strong>用户数据</strong>。注意这里的 <code>userDataDir</code> 参数，它指定了当前浏览器的数据目录。<a href="https://chromium.googlesource.com/chromium/src/+/master/docs/user_data_dir.md#Command-Line" target="_blank" rel="noopener">User Data Directory</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">    headless: <span class="literal">true</span>,</span><br><span class="line">    userDataDir: <span class="string">'./puppeteer_data'</span>,</span><br><span class="line">    ignoreHTTPSErrors: <span class="literal">true</span>,</span><br><span class="line">    defaultViewport: <span class="literal">false</span>,</span><br><span class="line">    devtools: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// args: ['--disable-features=site-per-process', '--no-sandbox', '--disable-setuid-sandbox', '--disable-infobars']</span></span><br><span class="line">    args: [<span class="string">'--disable-features=site-per-process'</span>, <span class="string">'--no-sandbox'</span>],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>另一个思路是复用cookie。步骤如下：</p><ul><li>第一步，导出chrome登录态</li><li>第二步，导入登录态至puppeteer</li><li>第三步，访问页面</li></ul><p><a href="https://chrome.google.com/webstore/detail/editthiscookie/fngmhnnpilhplaeedifhccceomclgfbg/related?hl=en" target="_blank" rel="noopener">EditThisCookie</a>是一款Chrome插件，支持从Chrome中导出cookie。</p><p><img src="/images/16544952632684.jpg" alt></p><p>导出的cookie是一个json字符串。可以直接使用 <code>await page.setCookie(...cookies)</code> 将该json串设置给 puppeteer。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    <span class="attr">"domain"</span>: <span class="string">".feishu.cn"</span>,</span><br><span class="line">    <span class="attr">"expirationDate"</span>: <span class="number">1662259808.850663</span>,</span><br><span class="line">    <span class="attr">"hostOnly"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"httpOnly"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"__tea__ug__uid"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"/"</span>,</span><br><span class="line">    <span class="attr">"sameSite"</span>: <span class="string">"unspecified"</span>,</span><br><span class="line">    <span class="attr">"secure"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"session"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"storeId"</span>: <span class="string">"0"</span>,</span><br><span class="line">    <span class="attr">"value"</span>: <span class="string">"7105953789148546601"</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">    headless: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// userDataDir: './puppeteer_data',</span></span><br><span class="line">    ignoreHTTPSErrors: <span class="literal">true</span>,</span><br><span class="line">    defaultViewport: <span class="literal">false</span>,</span><br><span class="line">    devtools: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// args: ['--disable-features=site-per-process', '--no-sandbox', '--disable-setuid-sandbox', '--disable-infobars']</span></span><br><span class="line">    args: [<span class="string">'--disable-features=site-per-process'</span>, <span class="string">'--no-sandbox'</span>],</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// page: 用于模拟登录流程</span></span><br><span class="line"><span class="keyword">const</span> page = (<span class="keyword">await</span> browser.pages())[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line"><span class="keyword">await</span> page.goto(<span class="string">'http://femap-ci.huolala.work/#/monitor/index'</span>, &#123; <span class="attr">waitUntil</span>: <span class="string">"networkidle2"</span> &#125;);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> cookies = fs.readFileSync(<span class="string">'crash_toke.json'</span>, <span class="string">'utf8'</span>)</span><br><span class="line"><span class="keyword">const</span> deserializedCookies = <span class="built_in">JSON</span>.parse(cookies)</span><br><span class="line"><span class="keyword">await</span> page.setCookie(...deserializedCookies)</span><br></pre></td></tr></table></figure><p><a href="https://kth.instructure.com/courses/11/pages/running-a-second-puppeteer-script-using-the-same-session-cookies" target="_blank" rel="noopener">Running a second Puppeteer script using the same session cookies: Chip sandbox</a> 提到了 <code>userDataDir</code> 和 <code>page.setCookie</code> 的区别：</p><blockquote><p>前者使用了相同的用户数据来启动下一次测试。但实际上并不需要完全相同的用户数据，通常只需要使用相同的 cookie 来启动下一次测试即可。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/30667239/is-it-possible-to-install-npm-package-only-if-it-has-not-been-already-installed" target="_blank" rel="noopener">node.js - Is it possible to install npm package only if it has not been already installed? - Stack Overflow</a></li><li><a href="https://stackoverflow.com/questions/63187371/puppeteer-not-able-to-install-error-failed-to-set-up-chromium-r782078-set-pu" target="_blank" rel="noopener">node.js - puppeteer not able to install: ERROR: Failed to set up Chromium r782078! Set “PUPPETEER_SKIP_DOWNLOAD” env variable to skip download - Stack Overflow</a></li><li><a href="https://blog.csdn.net/Maybe_Lee/article/details/78604927" target="_blank" rel="noopener">shell脚本中判断上一个命令是否执行成功</a></li><li><a href="https://stackoverflow.com/questions/50418994/pass-signed-cookie-to-puppeteer" target="_blank" rel="noopener">node.js - Pass signed cookie to puppeteer - Stack Overflow</a></li><li><a href="https://stackoverflow.com/questions/56514877/how-to-save-cookies-and-load-it-in-another-puppeteer-session" target="_blank" rel="noopener">How to save cookies and load it in another puppeteer session? - Stack Overflow</a></li><li><a href="https://www.checklyhq.com/learn/headless/managing-cookies/" target="_blank" rel="noopener">Setting state using cookies | Checkly</a></li><li><a href="https://zhaoqize.github.io/puppeteer-api-zh_CN/#/" target="_blank" rel="noopener">Puppeteer v14.2.1</a> 中文文档，优质</li><li><a href="https://devdocs.io/puppeteer/" target="_blank" rel="noopener">Puppeteer documentation — DevDocs</a> 英文文档，官方</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录使用 Puppeteer 时遇到的两个小问题，以备忘。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>移动端网络监控小结</title>
    <link href="http://www.sunmoonblog.com/2022/03/19/network-monitor-roadmap/"/>
    <id>http://www.sunmoonblog.com/2022/03/19/network-monitor-roadmap/</id>
    <published>2022-03-19T12:31:20.000Z</published>
    <updated>2022-03-19T13:41:51.193Z</updated>
    
    <content type="html"><![CDATA[<p>最近做了一些关于Android移动端网络监控的调研，记录以备忘。<br><a id="more"></a></p><ol><li>Gradle 相关<ol><li>了解 buildSrc</li><li>了解 Transform </li><li>了解 Gradle 插件 <a href="https://zhuanlan.zhihu.com/p/262865457" target="_blank" rel="noopener">Android 编译插桩（二）： Gradle Transform</a></li></ol></li><li>ASM 相关<ol><li>ASM 用法</li><li>Hunter 源码学习 <a href="https://cloud.tencent.com/developer/article/1378925" target="_blank" rel="noopener">一起玩转Android项目中的字节码（Transform篇）</a></li><li>辅助工具</li></ol></li><li>高德 SDK Hook 点分析</li><li>HttpUrlConnection Demo</li><li>Network Profiler 实现原理<ol><li><a href="https://developer.android.com/studio/profile/network-profiler" target="_blank" rel="noopener">利用网络性能剖析器检查网络流量  |  Android 开发者  |  Android Developers</a></li><li><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/profiler/app/perfa-okhttp/src/main/java/com/android/tools/profiler/agent/okhttp/OkHttp2Interceptor.java" target="_blank" rel="noopener">profiler/app/perfa-okhttp/src/main/java/com/android/tools/profiler/agent/okhttp/OkHttp2Interceptor.java - platform/tools/base - Git at Google</a></li><li><a href="https://jishuin.proginn.com/p/763bfbd601fb" target="_blank" rel="noopener">okhttp文件上传失败，居然是AS背锅？太难了～-技术圈</a></li><li><a href="https://android-doc.github.io/tools/building/plugin-for-gradle.html" target="_blank" rel="noopener">Android Plug-in for Gradle | Android Developers</a></li></ol></li><li>竞品 <a href="https://github.com/ChuckerTeam/chucker" target="_blank" rel="noopener">ChuckerTeam/chucker: 🔎 An HTTP inspector for Android &amp; OkHTTP (like Charles but on device)</a></li><li>正解 <a href="https://cloud.tencent.com/developer/article/1399805?from=article.detail.1378925" target="_blank" rel="noopener">【Android】函数插桩（Gradle + ASM） - 云+社区 - 腾讯云</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做了一些关于Android移动端网络监控的调研，记录以备忘。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Gradle Transform 简介</title>
    <link href="http://www.sunmoonblog.com/2022/03/19/android-gradle-transform/"/>
    <id>http://www.sunmoonblog.com/2022/03/19/android-gradle-transform/</id>
    <published>2022-03-19T03:58:23.000Z</published>
    <updated>2022-03-19T12:39:24.616Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>回顾一下 Transform 相关的知识。<br><a id="more"></a></p><h1 id="什么是-Transform"><a href="#什么是-Transform" class="headerlink" title="什么是 Transform"></a>什么是 Transform</h1><h2 id="Android-App构建流程"><a href="#Android-App构建流程" class="headerlink" title="Android App构建流程"></a>Android App构建流程</h2><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/03/19/16476630335052.jpg" alt></p><p>上图来自 <a href="https://developer.android.google.cn/studio/build/" target="_blank" rel="noopener">Android Developers</a>。不过上图缺失一些细节，我们稍作展开。</p><p>我们知道，Android应用是Java或Kotlin语言写的。简单起见，我们只考虑Java。以Java语言编写的 <strong>Source Code</strong>，经Java编译器编译成 Java字节码(<code>.class</code>文件)。Java编译器的编译产物是<code>.class</code>，那么上图的中dex文件是怎么来的呢？</p><p>Dex之于Android，类似于jar之于Java。dex中保存的也是字节码，不过需要说明的是这里的字节码并非标准的Java字节码，而是专门<strong>为Android平台设计的字节码</strong>。</p><p>所以完整的编译流程是这样的：multiple .java files –&gt; multiple .classes files –&gt; a single .dex file</p><p>更多细节可以参考以下资料：</p><ul><li><a href="https://stackoverflow.com/questions/14230573/role-of-classes-dex-file-in-an-apk-file" target="_blank" rel="noopener">Role of classes.dex file in an apk file</a></li><li><a href="https://stackoverflow.com/questions/8210173/what-is-the-difference-between-class-and-dex-files" target="_blank" rel="noopener">java - What is the difference between .class and .dex files?</a></li><li><a href="https://source.android.com/devices/tech/dalvik/dex-format" target="_blank" rel="noopener">Dex File Format</a> v.s. <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html" target="_blank" rel="noopener">Class File Format specification</a></li></ul><h2 id="Transform-的作用"><a href="#Transform-的作用" class="headerlink" title="Transform 的作用"></a>Transform 的作用</h2><p>从Android App构建流程可以看到，构建过程中需要对代码、资源文件和AIDL做各种处理。于是，Android Gradle插件提供了 Transform 以及相应的API。</p><p>以下内容翻译自 <a href="https://google.github.io/android-gradle-dsl/javadoc/2.1/com/android/build/api/transform/Transform.html" target="_blank" rel="noopener">Transform (Android Gradle API)</a>。</p><blockquote><p>Transform 类代表构建过程中的一个转换操作，用于处理中间构建产物。对于每个新增的 transform，都会创建一个新的 task。添加新的 transform 时需要处理好task之间的依赖。transfrom 的输出由其他 transform 消费，而相关的 task 则自动关联到一起。</p><p>Transform 需要明确它作用于哪个 (content,scope)，以及它会生成什么 (content)</p><p>Transform 接收一个 <a href="https://google.github.io/android-gradle-dsl/javadoc/2.1/com/android/build/api/transform/TransformInput.html" target="_blank" rel="noopener">TransformInput</a> 集合作为输入，它由 <a href="https://google.github.io/android-gradle-dsl/javadoc/2.1/com/android/build/api/transform/JarInput.html" target="_blank" rel="noopener">JarInput</a> 和 <a href="https://google.github.io/android-gradle-dsl/javadoc/2.1/com/android/build/api/transform/DirectoryInput.html" target="_blank" rel="noopener">DirectoryInput</a> 组成。两者都需要提供关于特定内容的 <a href="https://google.github.io/android-gradle-dsl/javadoc/2.1/com/android/build/api/transform/QualifiedContent.Scope.html" target="_blank" rel="noopener">QualifiedContent.Scope</a> 和 <a href="https://google.github.io/android-gradle-dsl/javadoc/2.1/com/android/build/api/transform/QualifiedContent.ContentType.html" target="_blank" rel="noopener">QualifiedContent.ContentType</a> 信息。</p><p>Transform 的输出由 <a href="https://google.github.io/android-gradle-dsl/javadoc/2.1/com/android/build/api/transform/TransformOutputProvider.html" target="_blank" rel="noopener">TransformOutputProvider</a> 处理，它可以创建新的自包含的内容，这些内容有自己的 Scopes 和 Content Types。TransformInput/Output 处理的内容由 transform 系统管理，其路径不可配置。</p><p>It is best practice to write into as many outputs as Jar/Folder Inputs have been received by the transform. 将所有输入处理后放到同一个输出，会让下游的 transform 无法处理指定的 scopes。(Combining all the inputs into a single output prevents downstream transform from processing limited scopes.)</p><p>虽然可以通过文件名后缀来区分不同的 Content Types，但无法通过文件名后缀来区分 Scopes。因此如果一个 transform 要求某种 Scope，但 Output 中包含的 Scope 种类多于要求的，构建会失败。(While it’s possible to differentiate different Content Types by file extension, it’s not possible to do so for Scopes. Therefore if a transform request a Scope but the only available Output contains more than the requested Scope, the build will fail.)<br>If a transform request a single content type but the only available content includes more than the requested type, the input file/folder will contain all the files of all the types, but the transform should only read, process and output the type(s) it requested.</p><p>另外，transform 还可指定辅助的输入输出目录(secondary inputs/outputs)。上下游的 transform 不处理这个目录，目录中的内容也不局限为 transform 能处理的文件类型，它们可以是任意内容。由每个 transform 来管理这些文件，并且保证在 transform 被调用前生成文件内容. This is done through additional parameters when register the transform.<br>These secondary inputs/outputs allow a transform to read but not process any content. This can be achieved by having getScopes() return an empty list and use getReferencedScopes() to indicate what to read instead.</p></blockquote><p>(太难翻译了!)</p><p>简单来说，</p><ul><li>Transform API 是由 Android Gradle Plugin 插件提供的，而非 Gradle 官方提供的，</li><li>Transform API 是一套用来修改构建产物的标准API</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/03/19/16476732191547.jpg" alt></p><p>Android App 打包过程中的代码混淆、desugar等过程，其实都是一个个的 Transform。</p><h1 id="使用-Transform-的场景"><a href="#使用-Transform-的场景" class="headerlink" title="使用 Transform 的场景"></a>使用 Transform 的场景</h1><ul><li>对编译产生的class文件做自定义的处理。</li><li>读取编译产生的class文件，并不修改</li></ul><h2 id="示例一-Instant-run"><a href="#示例一-Instant-run" class="headerlink" title="示例一 - Instant run"></a>示例一 - Instant run</h2><ul><li><a href="https://www.sunmoonblog.com/2018/10/28/instant-run-instrumentation/">(译)Instant Run Instrumentation | Sunmoon的博客</a></li><li><a href="https://www.sunmoonblog.com/2018/10/30/instant-run-1/">Instant Run浅析(二) | Sunmoon的博客</a></li></ul><h2 id="示例二-Network-Profiler"><a href="#示例二-Network-Profiler" class="headerlink" title="示例二 - Network Profiler"></a>示例二 - Network Profiler</h2><p>TODO</p><h1 id="Transform-API-介绍"><a href="#Transform-API-介绍" class="headerlink" title="Transform API 介绍"></a>Transform API 介绍</h1><p>自定义的 transform 要继承自 <code>Transform</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Transform</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>; <span class="comment">// 自定义 Transform的名字</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Set&lt;ContentType&gt; <span class="title">getInputTypes</span><span class="params">()</span></span>; <span class="comment">// 自定义 Transform 的输入类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Set&lt;? <span class="keyword">super</span> Scope&gt; getScopes();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isIncremental</span><span class="params">()</span></span>; <span class="comment">// 是否支持增量编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入类型"><a href="#输入类型" class="headerlink" title="输入类型"></a>输入类型</h2><p><code>getInputTypes()</code> 指定 transform 的输入类型。</p><ul><li><code>DefaultContentType</code> 包括 <code>CLASSES</code> 和 <code>RESOURCES</code> 两种类型</li><li><code>ExtendedContentType</code> 包括 <code>DEX</code>、<code>NATIVE_LIBS</code>、<code>CLASSES_ENHANCED</code>、<code>DATA_BINDING</code> 等几种类型。</li></ul><h2 id="输入范围"><a href="#输入范围" class="headerlink" title="输入范围"></a>输入范围</h2><p><code>getScopes()</code> 指定 transform 的输入范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Scope implements ScopeType &#123;</span><br><span class="line">    <span class="comment">/** Only the project (module) content */</span></span><br><span class="line">    PROJECT(<span class="number">0x01</span>),</span><br><span class="line">    <span class="comment">/** Only the sub-projects (other modules) */</span></span><br><span class="line">    SUB_PROJECTS(<span class="number">0x04</span>),</span><br><span class="line">    <span class="comment">/** Only the external libraries */</span></span><br><span class="line">    EXTERNAL_LIBRARIES(<span class="number">0x10</span>),</span><br><span class="line">    <span class="comment">/** Code that is being tested by the current variant, including dependencies */</span></span><br><span class="line">    TESTED_CODE(<span class="number">0x20</span>),</span><br><span class="line">    <span class="comment">/** Local or remote dependencies that are provided-only */</span></span><br><span class="line">    PROVIDED_ONLY(<span class="number">0x40</span>),</span><br></pre></td></tr></table></figure><p>注意 <code>getScopes()</code> 和 <code>getReferencedScopes()</code> 的区别。前者用于表示将要消费的范围，后者表示引用的范围(可查看内容、但并不消费)。所以，如果一个Transform不想处理任何输入，只是想查看输入的内容,那么只需在getScopes()返回一个空集合，在getReferencedScopes()返回想要接收的范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the scope(s) of the Transform. This indicates which scopes the transform consumes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Set&lt;? <span class="keyword">super</span> Scope&gt; getScopes();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the referenced scope(s) for the Transform. These scopes are not consumed by</span></span><br><span class="line"><span class="comment"> * the Transform. They are provided as inputs, but are still available as inputs for</span></span><br><span class="line"><span class="comment"> * other Transforms to consume.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation returns an empty Set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;? <span class="keyword">super</span> Scope&gt; getReferencedScopes() &#123;</span><br><span class="line">    <span class="keyword">return</span> ImmutableSet.of();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何自定义-Transform"><a href="#如何自定义-Transform" class="headerlink" title="如何自定义 Transform"></a>如何自定义 Transform</h1><p>时序图如下：<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/03/19/16476911150553.jpg" alt="-w809"></p><p>类图如下：<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/03/19/16476917603072.jpg" alt="-w824"></p><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><ul><li>Q: 有了ASM等字节码框架，为什么还需要 Transform？</li><li>A: ASM并不能直接运行于Android系统。ASM主要用于Android应用构建流程中修改Java字节码(Transform)</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/031b62d02607" target="_blank" rel="noopener">Gradle Transform API 的基本使用 - 简书</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;回顾一下 Transform 相关的知识。&lt;br&gt;
    
    </summary>
    
    
      <category term="Gradle" scheme="http://www.sunmoonblog.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>(译) Organizing Gradle Projects</title>
    <link href="http://www.sunmoonblog.com/2022/03/18/gradle-best-practices/"/>
    <id>http://www.sunmoonblog.com/2022/03/18/gradle-best-practices/</id>
    <published>2022-03-18T02:22:33.000Z</published>
    <updated>2022-03-19T12:14:46.251Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自《Organizing Gradle Projects》，介绍了Gradle的若干最佳实践。<br><a id="more"></a></p><p>每个软件工程的源代码和构建逻辑应该以有意义的方式来组织。本文介绍了若干最佳实践来实现可读性好、易维护的项目结构。同时也介绍了若干常见问题以及解决方法。</p><h1 id="单独存放不同语言的源码"><a href="#单独存放不同语言的源码" class="headerlink" title="单独存放不同语言的源码"></a>单独存放不同语言的源码</h1><!--Separate language-specific source files--><p>Gradle的编程语言插件建立了发现和编译源码的约定。比如，使用了Java插件的工程会自动编译<code>src/main/java</code>目录下的代码。其他语言的插件也遵循类似的模式。目录路径的最后一部分通常表明了对应的语言。</p><p>某些编译器支持编译同一个源码目录中的不同语言写的代码。Groovy编译器可以处理混放在<code>src/main/groovy</code>目录下的Java和Groovy源码。Gradle建议按不同的语言来存放代码，以达到更好的构建性能。此外，the user and build can make stronger assumptions。</p><p>The following source tree contains Java and Kotlin source files. Java source files live in src/main/java, whereas Kotlin source files live in src/main/kotlin.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build.gradle</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── HelloWorld.java</span><br><span class="line">        └── kotlin</span><br><span class="line">            └── Utils.kt</span><br></pre></td></tr></table></figure><h1 id="不同类型的测试代码分开存放"><a href="#不同类型的测试代码分开存放" class="headerlink" title="不同类型的测试代码分开存放"></a>不同类型的测试代码分开存放</h1><p>Have a look at the sample  <a href="https://docs.gradle.org/current/samples/sample_jvm_multi_project_with_additional_test_types.html" target="_blank" rel="noopener">sample</a> that demonstrates how a separate integration tests configuration can be added to a Java-based project.</p><p>一个项目中有不同类型的测试代码，这个很常见。比如单元测试，集成测试，功能测试或冒烟测试。每种类型的测试代码应当放在专门的源码目录中(可选的)。分开存放对可维护性有好处，也能让你更关注特定类型的测试。</p><p>这个<a href="https://docs.gradle.org/current/samples/sample_jvm_multi_project_with_additional_test_types.html" target="_blank" rel="noopener">sample</a>展示了如何在一个Java项目中添加不同的测试配置。</p><h1 id="尽可能使用标准约定"><a href="#尽可能使用标准约定" class="headerlink" title="尽可能使用标准约定"></a>尽可能使用标准约定</h1><p>Gradle核心插件遵守软件工程范例<a href="https://en.wikipedia.org/wiki/Convention_over_configuration" target="_blank" rel="noopener">convention over configuration</a>。插件逻辑在特定上下文中为用户提供有意义的缺省值以及约定。以<a href="https://docs.gradle.org/current/userguide/java_plugin.html#java_plugin" target="_blank" rel="noopener">Java plugin</a>插件为例：</p><ul><li><code>src/main/java</code>作为缺省的源码位置</li><li>编译后的产物放在<code>build</code>目录</li></ul><p>严格遵守缺省约定的话，加入项目的新开发者能马上知道如何开始工作。当然，约定也支持重新配置，只不过构建脚本的用户和作者更难维护构建逻辑和构建输出。应当尽可能尝试严格遵守缺省约定，除非你需要适配遗留项目结构。参考各相关插件的手册来学习其缺省约定。</p><h1 id="定义settings文件"><a href="#定义settings文件" class="headerlink" title="定义settings文件"></a>定义settings文件</h1><p>每次构建时，Gradle会尝试找到<code>settings.gradle</code>(Groovy DSL)或者<code>settings.gradle.kts</code>(Kotlin DSL)文件。基于这个目的，运行时会沿着目录树结构往上一直搜索到根目录。一旦找到settings文件后立即停止查找。</p><p>一定要在根目录中添加一个<code>settings.gradle</code>以避免性能问题。这个建议对单工程构建和多工程构建都有效。该文件可以为空，也可以定义工程名。</p><p>一个典型的带settings文件的Gradle工程结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── settings.gradle</span><br><span class="line">├── subproject-one</span><br><span class="line">│   └── build.gradle</span><br><span class="line">└── subproject-two</span><br><span class="line">    └── build.gradle</span><br></pre></td></tr></table></figure><h1 id="使用-buildSrc-抽象逻辑"><a href="#使用-buildSrc-抽象逻辑" class="headerlink" title="使用 buildSrc 抽象逻辑"></a>使用 buildSrc 抽象逻辑</h1><p>复杂的构建逻辑通常适合封装成自定义任务或者二进制插件。自定义任务和二进制插件不应放到项目的构建脚本中。如果这些逻辑不需要在多个独立的项目中共享，那么可以使用<code>buildSrc</code>。</p><p><code>buildSrc</code>目录视为一个<a href="https://docs.gradle.org/current/userguide/composite_builds.html#composite_build_intro" target="_blank" rel="noopener">included build</a>。一旦 Gradle 发现这个目录，它会自动编译和测试其中的代码并将其添加到构建脚本的classpath。对于多项目构建(multi-project builds)，只能有一个<code>buildSrc</code>目录，这个目录位于项目根目录。应优先使用<code>buildSrc</code>而不是插件(<a href="https://docs.gradle.org/current/userguide/plugins.html#sec:script_plugins" target="_blank" rel="noopener">script plugins</a>)，因为前者代码更容易维护、重构和测试。</p><p><code>buildSrc</code>使用跟Java和Groovy项目相同的代码结构(<a href="https://docs.gradle.org/current/userguide/java_plugin.html#javalayout" target="_blank" rel="noopener">source code conventions</a>)。它可以直接访问Gradle API。<code>buildSrc</code>目录下的<code>build.gradle</code>脚本中可以添加其他依赖。</p><p><em>Example 1. Custom buildSrc build script</em></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.13'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个包含<code>buildSrc</code>的工程，其项目结构如下。<code>buildSrc</code>下的代码使用跟应用代码类似的包。如果有额外的配置需要，<code>buildSrc</code>目录可以放一个可选的构建脚本(比如，使用插件或声明依赖)。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── buildSrc</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── main</span><br><span class="line">│       │   └── java</span><br><span class="line">│       │       └── com</span><br><span class="line">│       │           └── enterprise</span><br><span class="line">│       │               ├── Deploy.java</span><br><span class="line">│       │               └── DeploymentPlugin.java</span><br><span class="line">│       └── test</span><br><span class="line">│           └── java</span><br><span class="line">│               └── com</span><br><span class="line">│                   └── enterprise</span><br><span class="line">│                       └── DeploymentPluginTest.java</span><br><span class="line">├── settings.gradle</span><br><span class="line">├── subprojecto-one</span><br><span class="line">│   └── build.gradle.kts</span><br><span class="line">└── subproject-two</span><br><span class="line">    └── build.gradle.kts</span><br></pre></td></tr></table></figure><p>注意<code>buildSrc</code>中的变更会引起整个项目变成out-of-date状态。因此，当进行小的增量变更时，<a href="https://docs.gradle.org/current/userguide/command_line_interface.html#sec:command_line_execution_options" target="_blank" rel="noopener">–no-rebuild command-line option</a>可加快编译速度。记住<code>buildSrc</code>修改完成后要定期进行全量构建。</p><h1 id="在-gradle-properties-文件中定义属性"><a href="#在-gradle-properties-文件中定义属性" class="headerlink" title="在 gradle.properties 文件中定义属性"></a>在 gradle.properties 文件中定义属性</h1><p>Gradle中可以在构建脚本中定义属性，也可以在<code>gradle.properties</code>定义属性，或者在命令行参数中定义属性。</p><p>命令行参数中定义属性在ad-hoc场景下很常见。比如，你想传特定的属性值来控制某次构建的运行时行为。构建脚本中的属性很容易带来维护性问题。<code>gradle.properties</code>用于将属性跟构建脚本分离。它适用于保存控制构建环境的属性。</p><p>典型的工程中将<code>gradle.properties</code>文件放在根目录。另外，如果你想将其应用于所有构建任务的话，也可将该文件放在<code>GRADLE_USER_HOME</code>目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── gradle.properties</span><br><span class="line">└── settings.gradle</span><br><span class="line">├── subproject-a</span><br><span class="line">│   └── build.gradle</span><br><span class="line">└── subproject-b</span><br><span class="line">    └── build.gradle</span><br></pre></td></tr></table></figure><h1 id="避免覆盖任务输出"><a href="#避免覆盖任务输出" class="headerlink" title="避免覆盖任务输出"></a>避免覆盖任务输出</h1><p>Task 应当定义输入和输出以利用 <a href="https://docs.gradle.org/current/userguide/more_about_tasks.html#sec:up_to_date_checks" target="_blank" rel="noopener">incremental build functionality</a> 提升性能。当声明 task 的输出时，应当确认输出目录是独有的。</p><p>混合或覆盖不同task的输出，会导致 up-to-date 检查过程复杂化，从而拖慢构建过程。另一方面，文件系统的变化可能让Gradle的构建缓存(<a href="https://docs.gradle.org/current/userguide/build_cache.html#build_cache" target="_blank" rel="noopener">build cache</a>)难以识别和缓存应当缓存的task。</p><h1 id="发布自定义的Gradle"><a href="#发布自定义的Gradle" class="headerlink" title="发布自定义的Gradle"></a>发布自定义的Gradle</h1><p>企业常常想通过定义通用约定或规则来为所有的项目做标准化构建。你可以借助初始化脚本来实现这个功能。<a href="https://docs.gradle.org/current/userguide/init_scripts.html#init_scripts" target="_blank" rel="noopener">Initialization scripts</a>可以非常容易地为同一台机器上的各个项目应同一构建逻辑。比如，使用一个私有的repo以及其凭证。</p><p>这种方式有期缺点。首先，你必须跟公司的所有开发人员沟通标准化设置过程。另外，统一升级初始化脚本逻辑也是个挑战。</p><p>发布自定义Gradle是个可行的解决方案。自定义的Gradle包含标准的Gradle发布版本，以及一个或多个自定义 initialization script。初始化脚本跟发布版本打包在一起，并且可应用到每次的构建上。开发者只需要将他们的 wraper 文件指向自定义Gradle的url。</p><p>创建自定义Gradle发布版本的典型步骤如下：</p><ol><li>实现下载和重新打包Gradle发布版本的逻辑</li><li>定义一个或多个初始化脚本</li><li>将初始化脚本跟Gradle发布包打包到一起</li><li>将Gradle发布包上传到HTTP服务器</li><li>将所有项目的wrapper文件指向自定义Gradle发布版本的url</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources" target="_blank" rel="noopener">Organizing Gradle Projects</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自《Organizing Gradle Projects》，介绍了Gradle的若干最佳实践。&lt;br&gt;
    
    </summary>
    
    
      <category term="Gradle" scheme="http://www.sunmoonblog.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>聊聊 Gradle buildSrc</title>
    <link href="http://www.sunmoonblog.com/2022/03/18/gradle-buildsrc/"/>
    <id>http://www.sunmoonblog.com/2022/03/18/gradle-buildsrc/</id>
    <published>2022-03-18T00:43:23.000Z</published>
    <updated>2022-03-19T12:15:47.967Z</updated>
    
    <content type="html"><![CDATA[<p>简单了解一下 Gradle 项目中 buildSrc 的用法。<br><a id="more"></a></p><h1 id="buildSrc-介绍"><a href="#buildSrc-介绍" class="headerlink" title="buildSrc 介绍"></a>buildSrc 介绍</h1><p>本节内容翻译自<a href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources" target="_blank" rel="noopener">Organizing Gradle Projects</a>。</p><p>复杂的构建逻辑通常适合封装成自定义任务或者二进制插件。自定义任务和二进制插件不应放到项目的构建脚本中。如果这些逻辑不需要在多个独立的项目中共享，那么可以使用<code>buildSrc</code>。</p><p><code>buildSrc</code>目录视为一个<a href="https://docs.gradle.org/current/userguide/composite_builds.html#composite_build_intro" target="_blank" rel="noopener">included build</a>。一旦 Gradle 发现这个目录，它会自动编译和测试其中的代码并将其添加到构建脚本的classpath。对于多项目构建(multi-project builds)，只能有一个<code>buildSrc</code>目录，这个目录位于项目根目录。应优先使用<code>buildSrc</code>而不是插件(<a href="https://docs.gradle.org/current/userguide/plugins.html#sec:script_plugins" target="_blank" rel="noopener">script plugins</a>)，因为前者代码更容易维护、重构和测试。</p><p><code>buildSrc</code>使用跟Java和Groovy项目相同的代码结构(<a href="https://docs.gradle.org/current/userguide/java_plugin.html#javalayout" target="_blank" rel="noopener">source code conventions</a>)。它可以直接访问Gradle API。<code>buildSrc</code>目录下的<code>build.gradle</code>脚本中可以添加其他依赖。</p><p><em>Example 1. Custom buildSrc build script</em></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.13'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个包含<code>buildSrc</code>的工程，其项目结构如下。<code>buildSrc</code>下的代码使用跟应用代码类似的包。如果有额外的配置需要，<code>buildSrc</code>目录可以放一个可选的构建脚本(比如，使用插件或声明依赖)。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── buildSrc</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── main</span><br><span class="line">│       │   └── java</span><br><span class="line">│       │       └── com</span><br><span class="line">│       │           └── enterprise</span><br><span class="line">│       │               ├── Deploy.java</span><br><span class="line">│       │               └── DeploymentPlugin.java</span><br><span class="line">│       └── test</span><br><span class="line">│           └── java</span><br><span class="line">│               └── com</span><br><span class="line">│                   └── enterprise</span><br><span class="line">│                       └── DeploymentPluginTest.java</span><br><span class="line">├── settings.gradle</span><br><span class="line">├── subprojecto-one</span><br><span class="line">│   └── build.gradle.kts</span><br><span class="line">└── subproject-two</span><br><span class="line">    └── build.gradle.kts</span><br></pre></td></tr></table></figure><p>注意<code>buildSrc</code>中的变更会引起整个项目变成out-of-date状态。因此，当进行小的增量变更时，<a href="https://docs.gradle.org/current/userguide/command_line_interface.html#sec:command_line_execution_options" target="_blank" rel="noopener">–no-rebuild command-line option</a>可加快编译速度。记住<code>buildSrc</code>修改完成后要定期进行全量构建。</p><p>总结一下：</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/145082015" target="_blank" rel="noopener">参考</a> 摘自 Gradle 文档：当运行 Gradle 时会检查项目中是否存在一个名为 buildSrc 的目录。然后 Gradle 会自动编译并测试这段代码，并将其放入构建脚本的类路径中, 对于多项目构建，只能有一个 buildSrc 目录，该目录必须位于根项目目录中, buildSrc 是 Gradle 项目根目录下的一个目录，它可以包含我们的构建逻辑，与脚本插件相比，buildSrc 应该是首选，因为它更易于维护、重构和测试代码</p></blockquote><h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><ul><li>IDEA 新建 gradle 项目</li><li>在项目下新建 <code>buildSrc</code> 目录 (注意是目录而不是 <code>module</code>)</li><li>在 <code>buildSrc</code> 目录下新建或修改 <code>build.gradle</code> 文件。内容如下:</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'groovy'</span></span><br><span class="line">    id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group <span class="string">'com.gradle'</span></span><br><span class="line">version <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'org.codehaus.groovy:groovy-all:3.0.7'</span></span><br><span class="line">    testImplementation <span class="string">group:</span> <span class="string">'junit'</span>, <span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>buildSrc</code> 目录中创建源码目录，<code>src/main/groovy</code><br><img src="/images/16475645072640.jpg" alt="-w716"></li><li>在源码目录下新建一个类 <code>MyTask</code></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span>&#123;</span></span><br><span class="line">    MyTask() &#123;</span><br><span class="line">        <span class="keyword">this</span>.description = <span class="string">"test buildSrc"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="keyword">void</span> start() &#123;</span><br><span class="line">        println <span class="string">'hi, cm, bi bo bi bo... ...'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在项目根目录的 <code>build.gradle</code> 中使用新建的 <code>MyTask</code><br><img src="/images/16475646953948.jpg" alt="-w1391"></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/ca795325d582" target="_blank" rel="noopener">Gradle 创建 buildSrc 文件夹 - 简书</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单了解一下 Gradle 项目中 buildSrc 的用法。&lt;br&gt;
    
    </summary>
    
    
      <category term="Gradle" scheme="http://www.sunmoonblog.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>iTerm2快速ssh登录</title>
    <link href="http://www.sunmoonblog.com/2022/03/06/ssh-with-iterm2/"/>
    <id>http://www.sunmoonblog.com/2022/03/06/ssh-with-iterm2/</id>
    <published>2022-03-06T08:24:54.000Z</published>
    <updated>2022-03-06T08:53:30.261Z</updated>
    
    <content type="html"><![CDATA[<p>我有几台服务器。虽然均配置了ssh登录，但日常工作和学习中仍感觉登录服务器不免有些麻烦。如何配置iTerm2快速ssh登录呢？<br><a id="more"></a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>第一步，在 <code>~/.ssh</code> 目录下创建一个脚本，不妨脚本名为 <code>qcloud</code>。脚本文件内容如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect -f</span></span><br><span class="line"><span class="built_in">set</span> user root</span><br><span class="line"><span class="built_in">set</span> host 124.221.147.234</span><br><span class="line"><span class="built_in">set</span> timeout -5</span><br><span class="line">spawn ssh <span class="variable">$user</span>@<span class="variable">$host</span></span><br><span class="line">interact</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure><p>第二步，<code>command + ,</code> 打开 iTerm2 设置:</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/03/06/16465557145174.jpg" alt="-w986"></p><p>第三步，开始使用吧！</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/03/06/16465557915219.jpg" alt="-w920"></p><p>有没有感觉ssh登录效率小小地提高了。</p><p>如果你需要经常在命令行下切换到某个目录工作，也可以使用类似配置。比如，我的博客放在 <code>PublicCode/blog</code> 这个目录下，所以添加以下配置之后我可以直接从 <code>Profiles</code> &gt; <code>博客</code> 进入到指定目录。是不是方便多了?</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/03/06/16465561302286.jpg" alt="-w986"></p><p>此外，iTerm2还支持将Profiles导入导出，方便我们偷懒到底。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/03/06/16465563272988.jpg" alt="-w921"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/zhaoyawei/p/9285588.html" target="_blank" rel="noopener">Mac下使用iTerm2自动ssh登录服务器 - 轻叹花开花落的流年 - 博客园</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我有几台服务器。虽然均配置了ssh登录，但日常工作和学习中仍感觉登录服务器不免有些麻烦。如何配置iTerm2快速ssh登录呢？&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Puppeteer 使用小记</title>
    <link href="http://www.sunmoonblog.com/2021/11/07/use-puppeteer/"/>
    <id>http://www.sunmoonblog.com/2021/11/07/use-puppeteer/</id>
    <published>2021-11-07T14:05:42.000Z</published>
    <updated>2021-11-09T14:26:05.838Z</updated>
    
    <content type="html"><![CDATA[<p>Puppeteer 实战小记——教你如何使用 Puppeteer 来完成模拟登录+抓取数据。<br><a id="more"></a></p><h1 id="Puppeteer-简介"><a href="#Puppeteer-简介" class="headerlink" title="Puppeteer 简介"></a>Puppeteer 简介</h1><p>网上关于 <a href="https://github.com/puppeteer/puppeteer" target="_blank" rel="noopener">Puppeteer</a> 介绍资料很多，所以这里就不过多展开了。只说两点。</p><p>第一，与 Puppeteer 类似的技术很多，早期主要是 Phantom.js。不过随着Google 在 Chrome 59版本开始支持 headless 模式，Ariya Hidayat 决定放弃对 Phantom.js 的维护</p><p>我原本尝试使用 PhantomJS 完成模块登录和抓取数据工作，但遇到了一点问题(问题原因未深究)，随后果断换到 Puppeteer。</p><p>第二，Puppeteer 是一个提供高级别API的 Node 库，简化 headless Chrome 的使用。</p><blockquote><p>Puppeteer（Puppeteer is a Node library which provides a high-level API to control headless Chrome over the DevTools Protocol. It can also be configured to use full (non-headless) Chrome.）</p></blockquote><p>这张图展示了 Puppeteer 的全貌。</p><p><img src="/images/16362948442778.jpg" alt="-w783"></p><ul><li>Puppeteer 使用 DevTools 协议与浏览器通信</li><li>Browser 实例可以拥有多个浏览器上下文</li><li>BrowserContext 实例定义了一个浏览会话，并且可以拥有多个 Page</li><li>Page至少有一个框架：主框架。iframe 可能还会创建其他框架</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用 npm 安装 puppeteer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i puppeteer</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://www.baidu.com'</span>); <span class="comment">//打开百度</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h1 id="Puppeteer-实战"><a href="#Puppeteer-实战" class="headerlink" title="Puppeteer 实战"></a>Puppeteer 实战</h1><p>以下是获取某网站登录态的 Puppeteer 脚本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uname = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">const</span> pwd = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        headless: <span class="literal">false</span>,</span><br><span class="line">        ignoreHTTPSErrors: <span class="literal">true</span>,</span><br><span class="line">        defaultViewport: <span class="literal">false</span>,</span><br><span class="line">        devtools: <span class="literal">false</span>,</span><br><span class="line">        args: [<span class="string">'--disable-features=site-per-process'</span>]</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// page: 用于模拟登录流程</span></span><br><span class="line">    <span class="keyword">const</span> page = (<span class="keyword">await</span> browser.pages())[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开页面并跳转登录页</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://abc.xyz.com/v2/workbench/apps'</span>, &#123; <span class="attr">waitUntil</span>: <span class="string">"networkidle2"</span> &#125;); <span class="comment">// &lt;----- 问题1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到登录页中的frame</span></span><br><span class="line">    <span class="keyword">const</span> frame = page.frames().find(<span class="function"><span class="params">f</span> =&gt;</span> f.name() === <span class="string">'login_iframe'</span>); <span class="comment">// &lt;----- 问题2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到账号登录</span></span><br><span class="line">    <span class="keyword">const</span> ploginSelector = <span class="string">'a#switcher_login.link'</span>;</span><br><span class="line">    <span class="keyword">await</span> frame.waitForSelector(ploginSelector);</span><br><span class="line">    <span class="keyword">await</span> frame.click(ploginSelector);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始账号登录</span></span><br><span class="line">    <span class="keyword">await</span> frame.type(<span class="string">'#u'</span>, uname);</span><br><span class="line">    <span class="keyword">await</span> frame.type(<span class="string">'#p'</span>, pwd);</span><br><span class="line">    <span class="keyword">await</span> frame.click(<span class="string">'#login_button'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.waitForNavigation(&#123; <span class="attr">waitUntil</span>: <span class="string">'networkidle2'</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// page2页面中尝试获取登录token  &lt;----- 问题3</span></span><br><span class="line">    <span class="comment">//await page2.goto('https://abc.xyz.com/v2/workbench/apps');</span></span><br><span class="line">    <span class="comment">// page2.evaluate(function () &#123;</span></span><br><span class="line">    <span class="comment">//     debugger;  &lt;----- 问题4</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cookies = <span class="keyword">await</span> page.cookies(); <span class="comment">// &lt;----- 问题5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> c = <span class="string">''</span>;</span><br><span class="line">    cookies.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        c = c + v.name + <span class="string">'='</span> + v.value + <span class="string">'; '</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>脚本看起来还是简单易懂的。但实际开发过程中还是遇到了不少小坑：</p><h2 id="问题1：网页跳转"><a href="#问题1：网页跳转" class="headerlink" title="问题1：网页跳转"></a>问题1：网页跳转</h2><p>这个案例中要登录的网站是 OAuth 方式，所以登录过程中是有一次页面跳转的，从我们要访问的网页跳转到 OAuth 提供方的网页。</p><p>解决办法：<code>page.goto</code> 方法的 <code>waitUntil</code> 参数传 <code>networkidle2</code>。即，等待足够长的时间保证页面跳转完成</p><h2 id="问题2：无法找到页面元素"><a href="#问题2：无法找到页面元素" class="headerlink" title="问题2：无法找到页面元素"></a>问题2：无法找到页面元素</h2><p>这个其实不是问题，但对 iframe 不了解的话往往会踩到这个坑。实际的网页结构比较复杂，可能有多个 iframe。如果 Puppeteer 脚本中找到指定的 html 元素，不妨看看你要访问的元素是否在 iframe 中！</p><p>解决办法：<code>page.frames()</code> 返回当前页面中的所有 frame。</p><h2 id="问题3：Execution-context-was-destroyed"><a href="#问题3：Execution-context-was-destroyed" class="headerlink" title="问题3：Execution context was destroyed"></a>问题3：Execution context was destroyed</h2><p>如果你遇到以下报错，可以考虑使用另外一个 page 来规避问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Execution context was destroyed, most likely because of a navigation.</span><br></pre></td></tr></table></figure><p>出错这种报错的原因很可能是因为导航，具体解决方法可以参考 <a href="https://www.it1352.com/1107753.html" target="_blank" rel="noopener">Puppeteer执行上下文被破坏</a></p><h2 id="问题4：调试技巧"><a href="#问题4：调试技巧" class="headerlink" title="问题4：调试技巧"></a>问题4：调试技巧</h2><p>技巧一：插入 <code>debugger</code> 启动调试器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">page2.evaluate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>技巧二：<code>devtools</code> 传 <code>true</code> 时打开 DevTools</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const browser = await puppeteer.launch(&#123;</span><br><span class="line">    ...,</span><br><span class="line">    headless: false</span><br><span class="line">    devtools: true,</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="问题5：获取-cookie"><a href="#问题5：获取-cookie" class="headerlink" title="问题5：获取 cookie"></a>问题5：获取 cookie</h2><p>Puppeteer 模拟登录成功后可以获取网页登录态。登录态一般放在 cookie 中，使用 <code>page.cookies()</code> 获取页面 cookie (注意不是 <code>document.cookie</code>，这个无法返回 http only 的 cookie)</p><p>总结一下使用 Puppeteer 的大致步骤：</p><ul><li><a href="https://www.jianshu.com/p/e9db0baf781b" target="_blank" rel="noopener">CentOS 上安装 nodejs</a><ul><li><code>curl --silent --location https://rpm.nodesource.com/setup_12.x | sudo bash</code></li><li><code>yum -y install nodejs</code></li></ul></li></ul><ol><li>使用 npm 安装 Puppeteer。如果遇到安装错误可以参考<a href="https://www.cnblogs.com/ilizhu/p/14504049.html" target="_blank" rel="noopener">这里</a><ul><li><code>npm i puppeteer</code></li></ul></li><li>写 Puppeteer 脚本模拟登录，获取网站登录态。可以参考上面提供的脚本</li><li>写脚本访问网站的数据。这个因不同网站而异，这里不具体展开</li><li>crontab 定时抓取数据。使用 crontab 时我经常把脚本路径弄错，注意 <a href="https://blog.csdn.net/qq_36743482/article/details/83616436" target="_blank" rel="noopener">crontab 路径问题</a><ul><li><code>crontab -e</code> 设置定时任务</li></ul></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/cangqinglang/p/14588014.html" target="_blank" rel="noopener">谈谈 Puppeteer - 苍青浪 - 博客园</a></li><li><a href="https://zhuanlan.zhihu.com/p/33015883" target="_blank" rel="noopener">phantomJs之殇，chrome-headless之生 - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/137922030" target="_blank" rel="noopener">Phantomjs、Selenium之后浪Puppeteer - 知乎</a></li><li><a href="https://github.com/puppeteer/puppeteer/tree/main/examples" target="_blank" rel="noopener">puppeteer/examples at main · puppeteer/puppeteer · GitHub</a></li><li><a href="http://www.puppeteerjs.com/" target="_blank" rel="noopener">Puppeteer v10.4.0</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Puppeteer 实战小记——教你如何使用 Puppeteer 来完成模拟登录+抓取数据。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记一次 _objc_retain 崩溃分析</title>
    <link href="http://www.sunmoonblog.com/2021/08/08/objc-retain-crash/"/>
    <id>http://www.sunmoonblog.com/2021/08/08/objc-retain-crash/</id>
    <published>2021-08-08T02:13:17.000Z</published>
    <updated>2021-08-08T09:05:48.469Z</updated>
    
    <content type="html"><![CDATA[<p>最近收到 iOS 上一个偶现的 <code>SIGSEGV SEGV_ACCERR</code> 崩溃。错误信息显示该崩溃发生在 <code>_objc_retain</code> 方法，让我困惑了很久。经过分析，发现看似内存问题，实则线程问题。<br><a id="more"></a></p><h1 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h1><p>一条典型的错误如下：</p><!-- https://bugly.qq.com/v2/crash-reporting/crashes/9067e7d4ff/2334154/report?pid=2&crashDataType=unSystemExit&start=40 --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 libobjc.A.dylib       _objc_retain + 16</span><br><span class="line">1 AbcDriver_Example     -[AbcRecorder startRecordWithType:] (AbcLocationRecorder.m:151)</span><br><span class="line">2 AbcDriver_Example     __40-[AbcLocationReporter onCollectTimer:]_block_invoke (AbcLocationReporter.m:0)</span><br><span class="line">3 Foundation            ___NSBLOCKOPERATION_IS_CALLING_OUT_TO_A_BLOCK__ + 16</span><br><span class="line">4 Foundation            -[NSBlockOperation main] + 100</span><br><span class="line">5 Foundation            ___NSOPERATION_IS_INVOKING_MAIN__ + 20</span><br><span class="line">6 Foundation            -[NSOperation start] + 784</span><br><span class="line">7 Foundation            ___NSOPERATIONQUEUE_IS_STARTING_AN_OPERATION__ + 20</span><br><span class="line">8 Foundation            ___NSOQSchedule_f + 180</span><br></pre></td></tr></table></figure><p>显示错误发生在 <code>AbcLocationRecorder.m</code> 第151行。第151行代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbcLocationSample *locationSample = [self prepareDataFromAbcLocation:self.latestLocation regeocode:nil];</span><br></pre></td></tr></table></figure><p>代码看起来没有任何问题，也很难将其跟 <code>_objc_retain</code> 方法联系起来。</p><h1 id="类似案例"><a href="#类似案例" class="headerlink" title="类似案例"></a>类似案例</h1><p>处理 iOS 崩溃的经验不多，所以先在网上找了一圈看是否有人遇到类似问题，还果真找到了。</p><h2 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h2><p><a href="https://www.cnblogs.com/song-jw/p/11691715.html" target="_blank" rel="noopener">iOS崩溃分析 - Lightning_S - 博客园</a> 提到了两个崩溃。</p><p>一个是 <code>objc_release</code>，错误如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0  libobjc.A.dylib                0x1b394f150 objc_release + 16</span><br><span class="line">1  _appstore                      0x10184b694 -[YNP_VRHomeCoreViewModel voiceRoomDidChangeSpeakingUser:] + 373 (YNP_VRHomeCoreViewModel.m:373)</span><br><span class="line">2  Aipai_appstore                 0x1015a6144 __63-[YNP_VoiceRoomManager makeDelegatesPerformSelector:obj:async:]_block_invoke + 1633 (YNP_VoiceRoomManager.m:1633)</span><br></pre></td></tr></table></figure><p>另一个是 <code>objc_retain</code>，错误如下：</p><p><img src="/images/16283922797911.jpg" alt></p><p>文章的结论是：</p><ul><li>以上崩溃都是对象引用计数变化时没有正确加锁(线程不安全)导致</li><li>编译器在代码中插入 <code>objc_retainAutoreleasedReturnValue</code>，所以错误日志中会看到 <code>_objc_retain</code></li></ul><h2 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h2><p><a href="https://www.jianshu.com/p/298c69ce33b2" target="_blank" rel="noopener">从一个crash分析到苹果的代码问题 - 简书</a> 提到属性被声明为 <code>nonatomic</code> 时，当对象在一个线程中释放了，另一个线程访问时就可能出问题。</p><p>至于 <code>nonatomic</code> 的线程安全问题，原因如下：</p><blockquote><p>nonatomic取到函数地址后，直接返回指针指向的值，如果这时 *slot 正好被释放，那么返回的就是一个错误的值<br>而atomic会先retain，然后放到自动释放池，这样就能保证返回的对象一定不会被释放</p></blockquote><p>这里直接贴上相关的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) &#123;</span><br><span class="line">    if (offset == 0) &#123;</span><br><span class="line">        return object_getClass(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Retain release world</span><br><span class="line">    id *slot = (id*) ((char*)self + offset);</span><br><span class="line">    if (!atomic) return *slot;</span><br><span class="line">        </span><br><span class="line">    // Atomic retain release world</span><br><span class="line">    spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();</span><br><span class="line">    id value = objc_retain(*slot);</span><br><span class="line">    slotlock.unlock();</span><br><span class="line">    </span><br><span class="line">    // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span><br><span class="line">    return objc_autoreleaseReturnValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h1><p>看过两个类似案例，再来分析自己的问题就有头绪了。出错的第151行代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 主线程中读 self.latestLocation</span><br><span class="line">AbcLocationSample *locationSample = [self prepareDataFromAbcLocation:self.latestLocation regeocode:nil];</span><br></pre></td></tr></table></figure><p>我们很自然地把怀疑目标锁定在 <code>self.latestLocation</code> 这里。<code>latestLocation</code> 属性定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface AbcLocationRecorder () &lt;AbcLocationManagerDelegate&gt;</span><br><span class="line">// latestLocation 访问修饰符为 nonatomic</span><br><span class="line">@property (nonatomic, strong) AbcLocation *latestLocation;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>位置更新时通过如下回调来更新 <code>self.latestLocation</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)mapLocationManager:(AbcLocationManager *)manager didUpdateLocations:(NSArray&lt;AbcLocation *&gt; *)locations &#123;</span><br><span class="line">    if (locations.count &gt; 0) &#123;</span><br><span class="line">        AbcLocation* location = [locations firstObject];</span><br><span class="line">        AbcLog_C(@&quot;定位坐标: %f, %f&quot;, location.location.coordinate.latitude, location.location.coordinate.longitude);</span><br><span class="line">        // 子线程中写 self.latestLocation</span><br><span class="line">        self.latestLocation = location;</span><br><span class="line">        AbcLOCATION_UNLOCK(self.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下：</p><ul><li>latestLocation 访问修饰符为 <code>nonatomic</code></li><li>主线程中读 <code>self.latestLocation</code></li><li>子线程中写 <code>self.latestLocation</code></li><li><font color="red">读写 <code>self.latestLocation</code> 没有加锁！</font></li></ul><p>前面提到这个 <code>SIGSEGV SEGV_ACCERR</code> 崩溃在我们 App 中是偶现的，Bugly 上有不少上报，但实际中跟进问题时却一次也没复现。怎么办？</p><p>我们写个 demo 吧。demo 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong) AbcLocation *latestLocation;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)testFun2</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;queue1&quot;, 0);</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;queue2&quot;, 0);</span><br><span class="line">    dispatch_queue_t queue3 = dispatch_queue_create(&quot;queue3&quot;, 0);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue1, ^&#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2f];</span><br><span class="line">            //@synchronized (self) &#123;</span><br><span class="line">                NSLog(@&quot;last location %@&quot;, self.latestLocation);</span><br><span class="line">            //&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue3, ^&#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2f];</span><br><span class="line">            //@synchronized (self) &#123;</span><br><span class="line">                NSLog(@&quot;last location %@&quot;, self.latestLocation);</span><br><span class="line">            //&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue2, ^&#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //@synchronized (self) &#123;</span><br><span class="line">                self.latestLocation = [[AbcLocation alloc] init];</span><br><span class="line">            //&#125;</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2f];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>运行几次很快就会产生崩溃。找到复现方法后，解决问题就很简单了。多线程读写 <code>self.latestLocation</code> 属性中正确地加锁，保证线程安全就能避免崩溃。</p><h1 id="更多知识"><a href="#更多知识" class="headerlink" title="更多知识"></a>更多知识</h1><p>网上寻找相似案例，是为了快速弄清问题原因。写demo是为了快速找到问题复现方法和解决办法。但我们不能就此止步，因为很多问题还可以更深入。</p><h2 id="objc-autoreleaseReturnValue-和-objc-retainAutoreleasedReturnValue"><a href="#objc-autoreleaseReturnValue-和-objc-retainAutoreleasedReturnValue" class="headerlink" title="objc_autoreleaseReturnValue 和 objc_retainAutoreleasedReturnValue"></a>objc_autoreleaseReturnValue 和 objc_retainAutoreleasedReturnValue</h2><blockquote><p>编译器在代码中插入 <code>objc_retainAutoreleasedReturnValue</code>，所以错误日志中会看到 <code>_objc_retain</code></p></blockquote><p>那什么是 <code>objc_autoreleaseReturnValue</code> 呢？</p><p>在 MRC 的环境里有以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// MRC</span><br><span class="line">+ (id) array &#123;</span><br><span class="line">    return [[NSMutableArray alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道内存分配的原则是”谁分配，谁释放”。这个原则让上述代码很为难，</p><ul><li>不能在 return 之前释放，因为分配出来的对象还没交给调用方法使用</li><li>也不可能在 return 之后释放，因为 return 之后作为分配方没法负责释放了(没有对象指针)</li></ul><p>所以需要将分配出来的对象注册到自动释放池，也延迟释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// MRC</span><br><span class="line">+ (id) array &#123;</span><br><span class="line">    return [[[NSMutableArray alloc] init] autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ARC 为我们自动调用了 <code>autorelease</code> 和 <code>retain</code> 两个方法 (自动释放)。考虑到兼容 MRC 时，ARC 自动调用 <code>autorelease</code> 和 <code>retain</code> 两个方法会带来不必要的开销，所以 ARC 使用 <code>objc_autoreleaseReturnValue</code> 和<br><code>objc_retainAutoreleasedReturnValue</code> 对多余操作优化，以提升性能优化。</p><hr><p><a href="https://www.galloway.me.uk/2012/02/how-does-objc_retainautoreleasedreturnvalue-work/" target="_blank" rel="noopener">How does objc_retainAutoreleasedReturnValue work? - Matt Galloway</a> 中对 <code>objc_retainAutoreleasedReturnValue</code> 有更多解释。这里挑关键点翻译出来。</p><p><code>objc_retainAutoreleasedReturnValue</code> 背后的思路是这样的：如果一个函数返回的对象是 autoreleased 的，并且接下来的对这个对象执行的操作是 <code>retain</code>，那么这里的 <code>autorelease</code> 和 <code>retain</code> 完全是无意义的，不过是在浪费 CPU 时间。如果某些情况下我们可以检测出这种情况，就能节省CPU时间。在App整个运行期间，节省的CPU时间累计下来就是个不小的优化。</p><p><a href="http://www.opensource.apple.com/source/objc4/objc4-493.9/runtime/objc-arr.mm" target="_blank" rel="noopener">Apple’s code</a>提到：</p><blockquote><p>objc_autoreleaseReturnValue() 检查 return 之后调用方的指令。如果调用方是立即调用 objc_retainAutoreleasedReturnValue，则被调用方不会做 autorelease 操作，而是将结果以 thread-local 方式保存。如果调用方并没有调用 objc_retainAutoreleasedReturnValue，则被调用方会做 autorelease 操作。<br>objc_retainAutoreleasedReturnValue 会检查返回值是否跟 thread-local 变量中保存的值一致。如果一致，则直接返回结果。如果不一致，则会执行一次 autorelease 和 retain。无论哪种方式，调用方都能拿到一个 retained reference</p></blockquote><p>考虑你有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (SomeClass*)createMeAnObject &#123;</span><br><span class="line">   SomeClass *obj = [[SomeClass alloc] init];</span><br><span class="line">   obj.string = @&quot;Badger&quot;;</span><br><span class="line">   obj.number = 10;</span><br><span class="line">   return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        self.myObject = [self createMeAnObject];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以重写以上代码，重写后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (SomeClass*)createMeAnObject &#123;</span><br><span class="line">   SomeClass *obj = [[SomeClass alloc] init];</span><br><span class="line">   obj.string = @&quot;Badger&quot;;</span><br><span class="line">   obj.number = 10;</span><br><span class="line">   return [obj autorelease];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        [myObject release];</span><br><span class="line">        SomeClass *temp = [self createMeAnObject];</span><br><span class="line">        myObject = [temp retain];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将 <code>createMeAnObject</code> 内联到 <code>init</code>，则代码变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        [myObject release];</span><br><span class="line">        SomeClass *temp = [[SomeClass alloc] init];</span><br><span class="line">        obj.string = @&quot;Badger&quot;;</span><br><span class="line">        obj.number = 10;</span><br><span class="line">        [temp autorelease];</span><br><span class="line">        myObject = [temp retain];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意以上代码中 <code>[temp autorelease]</code> 后紧接着一个 <code>[temp retain]</code>。这正是新的 Objective-C 运行时可以优化的一个点。</p><p>(译者注：有很多细节的分析，这里略过) 编译一个调用 <code>objc_autoreleaseReturnValue()</code> 和 <code>objc_retainAutoreleasedReturnValue()</code> 的方法时，编译器会添加如下指令作为标记。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thumb mode:</span><br><span class="line">f7ffef56   blx  _objc_msgSend</span><br><span class="line">    463f  mov  r7, r7</span><br><span class="line">f7ffef54   blx  _objc_retainAutoreleasedReturnValue</span><br><span class="line"></span><br><span class="line">ARM mode:</span><br><span class="line">ebffffa0   bl   _objc_msgSend</span><br><span class="line">e1a07007   mov  r7, r7</span><br><span class="line">ebffff9e   bl   _objc_retainAutoreleasedReturnValue</span><br></pre></td></tr></table></figure><p>无论哪种模式，编译器均会添加 <code>mov r7, r7</code>这条看似无任何意义的指令(它将 r7 寄存器的值 move 到 r7寄存器)。不过这条指令是有意义的，编译器将它作为标识，用于告知 <code>objc_autoreleaseReturnValue</code> 方法：调用方接下来会调用 <code>objc_retainAutoreleasedReturnValue</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">id objc_autoreleaseReturnValue(id object) &#123;</span><br><span class="line">    if (thumb_mode &amp;&amp; next_instruction_after_return == 0x463f ||</span><br><span class="line">        arm_mode   &amp;&amp; next_instruction_after_return == 0xe1a07007)</span><br><span class="line">    &#123;</span><br><span class="line">        set_flag(object);</span><br><span class="line">        return object;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return objc_autorelease(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id objc_retainAutoreleasedReturnValue(id object) &#123;</span><br><span class="line">    if (get_flag(object)) &#123;</span><br><span class="line">        clear_flag();</span><br><span class="line">        return object;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return objc_retain(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：以上是伪代码，x86 版本的代码见<a href="https://opensource.apple.com/source/objc4/objc4-493.9/runtime/objc-arr.mm" target="_blank" rel="noopener">这里</a>。</p><p>总结一下：ARC 出现之前，我们不得不在代码中写 autorelease 和 retain。ARC 出现之后，虽然不用再写 autorelease 和 retain，但是遗留代码中的 autorelease 和 retain 会导致很多冗余操作，<code>objc_autoreleaseReturnValue</code> 和 <code>objc_retainAutoreleasedReturnValue</code> 正是为了应对这些冗余操作的优化。</p><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/2f05060fa377?spm=a2c4e.11153940.blogcont690541.7.575f3c89jeD8IS" target="_blank" rel="noopener">objc_autoreleaseReturnValue和objc_retainAutoreleasedReturnValue函数对ARC的优化 - 简书</a></li><li><a href="https://www.galloway.me.uk/2012/02/how-does-objc_retainautoreleasedreturnvalue-work/" target="_blank" rel="noopener">How does objc_retainAutoreleasedReturnValue work? - Matt Galloway</a></li><li><a href="https://opensource.apple.com/source/objc4/objc4-493.9/runtime/objc-arr.mm" target="_blank" rel="noopener">https://opensource.apple.com/source/objc4/objc4-493.9/runtime/objc-arr.mm</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近收到 iOS 上一个偶现的 &lt;code&gt;SIGSEGV SEGV_ACCERR&lt;/code&gt; 崩溃。错误信息显示该崩溃发生在 &lt;code&gt;_objc_retain&lt;/code&gt; 方法，让我困惑了很久。经过分析，发现看似内存问题，实则线程问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.sunmoonblog.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>关于 OC 中的 @weakify</title>
    <link href="http://www.sunmoonblog.com/2021/07/20/oc-weakify/"/>
    <id>http://www.sunmoonblog.com/2021/07/20/oc-weakify/</id>
    <published>2021-07-20T05:59:40.000Z</published>
    <updated>2021-07-20T08:56:21.864Z</updated>
    
    <content type="html"><![CDATA[<p>关于 <code>@weakify</code> 和 <code>@strongify</code> 的一些小知识。<br><a id="more"></a> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">block = ^() &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">block = ^()&#123;</span><br><span class="line">    __strong typeof(weakSelf) self = weakSelf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://halfrost.com/ios_block_retain_circle/#toc-12" target="_blank" rel="noopener">https://halfrost.com/ios_block_retain_circle/#toc-12</a></p><p><a href="https://www.jianshu.com/p/bc794fa07167" target="_blank" rel="noopener">https://www.jianshu.com/p/bc794fa07167</a></p><p><a href="https://stackoverflow.com/questions/28305356/ios-proper-use-of-weakifyself-and-strongifyself" target="_blank" rel="noopener">https://stackoverflow.com/questions/28305356/ios-proper-use-of-weakifyself-and-strongifyself</a></p><p>How @strongify works<br>After @strongify is called, self will have a different pointer address inside the block than it will outside the block. That’s because @strongify declares a new local variable called self each time. (This is why it suppresses the -Wshadow warning, which will “warn whenever a local variable shadows another local variable.”) It’s worth reading and understanding the implementation of these functions. So even though the names are the same, treat them as separate strong references.</p><p>Using @strongify in your code</p><ul><li>(void)someMethod {<br>  if (self.someBOOL) {<pre><code>@weakify(self);_someObjectInstanceVar = [Object objectWithCompletionHandler:^{    @strongify(self);    // self reference #1    if (self.someProperty) {        @weakify(self);        // self reference #2        [[Async HTTPRequest] sendAWithID:self.property.id completionHandler:^(void (^)(NewObject *newObject) {            @strongify(self);            // self reference #3            @weakify(self);            [self showViewWithObject:newObject handler:^{                // self reference #4                @strongify(self);                [self reloadData];            }];        }];    }}];</code></pre>  // etc…<br>}</li></ul><p>However, remember that after your first use of @strongify, self will refer to local, stack variables. These will typically get destroyed when the scope in which they’re defined ends (as long as you aren’t storing them to properties or using them in a nested block). So based on the code you showed, you only need it after // self reference #1.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 &lt;code&gt;@weakify&lt;/code&gt; 和 &lt;code&gt;@strongify&lt;/code&gt; 的一些小知识。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>提升 AppCode 性能的几个小技巧</title>
    <link href="http://www.sunmoonblog.com/2021/05/01/enhance-appcode-performane/"/>
    <id>http://www.sunmoonblog.com/2021/05/01/enhance-appcode-performane/</id>
    <published>2021-05-01T09:18:18.000Z</published>
    <updated>2021-11-07T13:17:58.166Z</updated>
    
    <content type="html"><![CDATA[<p>AppCode 好用是好用，但这性能比起 Xcode 让人很无语。不过，AppCode 的性能是可以优化的。<br><a id="more"></a></p><p>最近的开发过程中发现 AppCode 占了 5GB 内存却仍然卡得干不了活，忍无可忍之下了解了一下如何优化 AppCode 性能。主要的参考资料来自 AppCode 官网。</p><ul><li><a href="https://www.jetbrains.com/help/objc/performance-tuning-tips.html" target="_blank" rel="noopener">Enhance performance | AppCode</a></li></ul><p>资料中提到几个点总结下来就是：</p><ul><li>加大 AppCode 内存</li><li>提升 AppCode code analysis﻿ 速度</li><li>提升 AppCode indexing﻿ 速度</li><li>关闭不必要的 Plugin</li></ul><h1 id="加大内存"><a href="#加大内存" class="headerlink" title="加大内存"></a>加大内存</h1><h2 id="打开内存指示器"><a href="#打开内存指示器" class="headerlink" title="打开内存指示器"></a>打开内存指示器</h2><p>AppCode 卡顿的一个主要原因是堆内存过低。所以我们很<em>有必要打开 AppCode 内存指示器</em>。</p><p>在 AppCode 底部状态上右键点击后出现如下菜单，勾选 “Memory Indicator” 即可打开内存指示器。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198615366659.jpg" alt="-w267"></p><p>我的内存指示器已打开，显示 “264 of 6131M”。内存状态良好。</p><p>注意：当可用的堆内存大小低于最大堆内存的5%时，会有低内存告警。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198618640390.jpg" alt></p><h2 id="加大堆内存"><a href="#加大堆内存" class="headerlink" title="加大堆内存"></a>加大堆内存</h2><p>从 AppCode 顶部菜单中 <strong>Help | Change Memory Settings</strong> 调整堆内存大小。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198617067248.jpg" alt="-w875"></p><p>我的 MacBook 内存大小 16G，已经给 AppCode 分了 6144 MB。已经相当奢侈，不能再加了。(即便 6G 内存，AppCode 还是卡，所以就我遇到的问题而言，瓶颈并不在内存)</p><h1 id="提升代码分析速度"><a href="#提升代码分析速度" class="headerlink" title="提升代码分析速度"></a>提升代码分析速度</h1><blockquote><p>On-the-fly code analysis is one of the most performance-consuming processes in AppCode.</p></blockquote><p>AppCode 的实时代码检查过程是最吃电脑性能的一个过程。针对这个问题，我们可以对实时代码检查进行配置，减少检查过程的性能消耗。</p><p>简单来说，就是减少实时代码检查甚至干脆不要实时检查(等要要检查时再启动)。</p><h2 id="调整代码检查项"><a href="#调整代码检查项" class="headerlink" title="调整代码检查项"></a>调整代码检查项</h2><p>AppCode 默认状态下会打开全部的检查类型(作者：不卡才怪？)，我们可以根据自己的需要进行调整。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198622243684.jpg" alt="-w992"></p><p>其实我们可以放心大胆地全关，因为完全可以在需要时通过 <strong>Code | Inspect Code</strong> 命令来检查。</p><h2 id="调整检查级别"><a href="#调整检查级别" class="headerlink" title="调整检查级别"></a>调整检查级别</h2><p>此外，还可以使用 <strong>Code | Configure Current File Analysis</strong> 命令调整当前已打开文件的检查级别。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198625862232.jpg" alt></p><p>分三种级别：</p><ul><li>None - 不检查</li><li>Syntax - 语法检查</li><li>Inspections - 检查</li></ul><p>不过个人感觉这个功能不太实用。</p><h1 id="提升索引速度"><a href="#提升索引速度" class="headerlink" title="提升索引速度"></a>提升索引速度</h1><p>AppCode 对文件进行索引(代码检查、代码自动补全、代码生成、自动导入功能依赖索引)。不过，不索引那些包含二进制文件、日志以及构建产物的目录并不会影响 AppCode 的代码检查等功能，所以进行索引时我们完全可以将这些目录排除。</p><p>另外，某些文件因过太大或是位于远程机器，索引的代价非常大。所以也应将这些文件排除在外。</p><p>排除文件或目录的方法很简单，在 <strong>Project</strong> 窗口将工程切换到 <strong>Files</strong> 视图，右击想要排除的文件，然后选择 <strong>Mark Directory as | Excluded</strong> </p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198705760997.jpg" alt="-w321"></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198713192648.jpg" alt></p><hr><p>回到前面我提到分配6G内存的情况下 AppCode 仍然卡顿的问题，发现卡顿时 AppCode 一直在索引。检查后发现 <font color="red">AppCode 打开该工程后，索引范围是当前用户的所有文件</font>(即整个 <code>/Users/username/</code> 目录。发现 AppCode 打开其他工程时只会索引当前工程目录中的文件，所以这是 AppCode 的 bug？)。对数量巨大的文件进行索引，几个小时也完成不了吧？</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198709164361.jpg" alt="-w318"></p><p>解决办法：果断排除掉不相关的目录，减少索引时间。</p><h1 id="其他优化技巧"><a href="#其他优化技巧" class="headerlink" title="其他优化技巧"></a>其他优化技巧</h1><p>另外一些优化手段包括：</p><ul><li>关闭 AppCode 中不必要的插件。AppCode 默认加载了很多插件，我们可以关闭不需要的插件以减少内存占用、提升速度</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198717657700.jpg" alt></p><ul><li>保证 AppCode 和 Xcode 版本兼容。如下图，这是我自己遇到的一个情况：AppCode 提示当前 Xcode 版本为 12.4，版本过高。</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198716155390.jpg" alt="-w967"></p><p>不清楚到底有什么影响，不过还是升级到跟 Xcode 12.4 兼容的 AppCode。如下图，AppCode 和 Xcode 兼容时，没有上述的警告。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198719580894.jpg" alt="-w898"></p><ul><li>Download Xcode caches﻿。如下图，勾选这里的 Download Xcode cacheds automatically，某些情况下能提升索引性能。(作者：按官方解释，这里的”某些情况”其实并不多，主要是指升级 Xcode 的情况)</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198720197701.jpg" alt="-w898"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一番折腾之后，AppCode 速度果然上来了。虽然 AppCode 响应速度相对 Xcode 还是有些差距，不过考虑到 AppCode 强大的重构功能还是非常值得使用的！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AppCode 好用是好用，但这性能比起 Xcode 让人很无语。不过，AppCode 的性能是可以优化的。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.sunmoonblog.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>20210306 问题小记</title>
    <link href="http://www.sunmoonblog.com/2021/03/06/variables-debug-info/"/>
    <id>http://www.sunmoonblog.com/2021/03/06/variables-debug-info/</id>
    <published>2021-03-06T01:52:30.000Z</published>
    <updated>2021-05-01T08:59:04.746Z</updated>
    
    <content type="html"><![CDATA[<p>最近对某些第三方Android库做简单的逆向分析。遇到两个问题，记录之。  </p><a id="more"></a><h1 id="Variables-debug-info-not-available"><a href="#Variables-debug-info-not-available" class="headerlink" title="Variables debug info not available"></a>Variables debug info not available</h1><p>Android Studio 中断点调试某些第三方 Android 库提示 Variables debug info not available，无法查看局部变量信息。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16149956735267.jpg" alt></p><p>找到以下资料 <a href="https://stackoverflow.com/questions/1313922/step-through-jdk-source-code-in-intellij-idea" target="_blank" rel="noopener">来源</a></p><blockquote><p>Java classes which are part of the JDK are compiled without debug info for the size and performance reasons.</p></blockquote><p>简单来说是提到出于大小和性能因素考虑，JDK 中的类是不带 debug 信息的。</p><p>类似地，很多第三方 Android 库使用 proguard 等工具混淆和优化后也去掉了 debug 信息，所以调试时无法查看局部变量信息(不过可以查看成员变量信息)。</p><h1 id="无法创建-ScanResult-实例"><a href="#无法创建-ScanResult-实例" class="headerlink" title="无法创建 ScanResult 实例"></a>无法创建 ScanResult 实例</h1><p>通常来说，我们会使用 Android 系统 API 获取 <a href="https://android.googlesource.com/platform/frameworks/base/+/5bab9da/wifi/java/android/net/wifi/ScanResult.java" target="_blank" rel="noopener">android.net.wifi.ScanResult</a> 的实例。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ScanResult&gt; list = wifiManager.getScanResults();</span><br></pre></td></tr></table></figure><p>有时出于某些原因，需要创建 <code>android.net.wifi.ScanResult</code> 实例。一开始，我以为这很简单。</p><p>思路一，直接调用构造方法创建实例不就可以了吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScanResult sr = <span class="keyword">new</span> ScanResult();</span><br><span class="line"></span><br><span class="line">ScanResult sr2 = <span class="keyword">new</span> ScanResult(sr);</span><br></pre></td></tr></table></figure><p>但实际上在 Android SDK 30 (Android 11) 之前，没有这两个构造方法。</p><ul><li><a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/android10-dev/wifi/java/android/net/wifi/ScanResult.java" target="_blank" rel="noopener">ScanResult android 10</a></li><li><a href="https://android.googlesource.com/platform/frameworks/base/+/android-6.0.1_r25/wifi/java/android/net/wifi/ScanResult.java" target="_blank" rel="noopener">ScanResult android 6</a></li></ul><p>在低版本 Android 设备上直接调用 <code>ScanResult</code> 构造方法会报 <code>java.lang.NoSuchMethodError</code> 错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2021-03-06 11:15:48.458 22161-22161/? E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">    Process: com.example.amaploc.demo, PID: 22161</span><br><span class="line">    java.lang.NoSuchMethodError: No direct method &lt;init&gt;()V in class Landroid/net/wifi/ScanResult; or its super classes </span><br><span class="line">    (declaration of &apos;android.net.wifi.ScanResult&apos; appears in /system/framework/framework.jar!classes2.dex)</span><br></pre></td></tr></table></figure><p>思路二，直接调用 <code>ScanResult</code> 构造方法行不通(低版本兼容问题)，那使用反射方式调用呢？但同样遇到兼容性问题：</p><ol><li>不同版本的 SDK 上非公开的构造方法参数不同</li><li>某些厂商可能修改了 <code>ScanResult</code> 构造方法</li></ol><p>思路三，考虑到 <code>ScanResult</code> 实现了 <code>Parcelable</code> 接口，所以可以借助 <code>Parcel</code> 来序列化/反序列化已有的 <code>ScanResult</code> 来生成新的 <code>ScanResult</code> 实例。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198583514111.jpg" alt="-w709"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ScanResult <span class="title">scanResultInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ScanResult parent = sCopyInstance;</span><br><span class="line"></span><br><span class="line">    Parcel p = Parcel.obtain();</span><br><span class="line">    parent.writeToParcel(p, <span class="number">0</span>);</span><br><span class="line">    p.setDataPosition(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ScanResult.CREATOR.createFromParcel(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单又完美地创建 ScanResult 实例</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/1313922/step-through-jdk-source-code-in-intellij-idea" target="_blank" rel="noopener">debugging - Step through JDK source code in IntelliJ IDEA - Stack Overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近对某些第三方Android库做简单的逆向分析。遇到两个问题，记录之。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.sunmoonblog.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>HTTP抓包小记</title>
    <link href="http://www.sunmoonblog.com/2021/02/18/http-cap/"/>
    <id>http://www.sunmoonblog.com/2021/02/18/http-cap/</id>
    <published>2021-02-18T02:01:02.000Z</published>
    <updated>2021-02-19T04:22:40.077Z</updated>
    
    <content type="html"><![CDATA[<p>最近处理一些对第三方应用中HTTPS请求抓包工作。杂七杂八挺烦琐，又容易遗忘。记录之，备不时之需。<br><a id="more"></a></p><h1 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h1><p>抓包工具有很多，选一个顺手的就行。我用的是 whistle。启动方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">whistle run</span><br><span class="line">[i] whistle@2.6.3 started</span><br><span class="line">[i] 1. use your device to visit the following URL list, gets the IP of the URL you can access:</span><br><span class="line">       http://127.0.0.1:8899/</span><br><span class="line">       http://172.30.209.45:8899/</span><br><span class="line">       http://172.20.209.88:8899/</span><br><span class="line">       Note: If all the above URLs are unable to access, check the firewall settings</span><br><span class="line">             For help see https://github.com/avwo/whistle</span><br><span class="line">[i] 2. configure your device to use whistle as its HTTP and HTTPS proxy on IP:8899</span><br><span class="line">[i] 3. use Chrome to visit http://local.whistlejs.com/ to get started</span><br><span class="line">Press [Ctrl+C] to stop whistle...</span><br></pre></td></tr></table></figure><p>启动后直接在浏览器中打开对应地址开始抓包。</p><h1 id="HTTPS-抓包"><a href="#HTTPS-抓包" class="headerlink" title="HTTPS 抓包"></a>HTTPS 抓包</h1><p>抓 HTTP 一般不会遇到什么问题，这里要说的主要是 HTTPS 抓包时遇到的问题。</p><h2 id="问题一：Android-iOS安装和信任证书"><a href="#问题一：Android-iOS安装和信任证书" class="headerlink" title="问题一：Android/iOS安装和信任证书"></a>问题一：Android/iOS安装和信任证书</h2><ul><li>Android 直接下载后从 SD 卡安装即可。安装成功后在<code>设置 &gt; 受信任的凭据 &gt; 用户</code>中查看</li><li>iOS 使用 Safari 浏览器打开证书链接来安装。安装成功后在<code>设置 &gt; 通用 &gt; 描述文件与设备管理</code>中查看。注意iOS上需要手动设置信任第三方证书</li></ul><p><img src="/images/16136148646757.jpg" alt="-w336"></p><p><img src="/images/16136152558859.jpg" alt="-w396"></p><p><img src="/images/16136153959387.jpg" alt="-w426"></p><p>经过如上设置后，可以抓到部分应用中的 HTTPS 请求了。但另一些应用的 HTTPS 请求，仍然无法抓取。大致可以归纳为两种原因(<a href="https://www.cnblogs.com/lulianqi/p/11380794.html#_label2" target="_blank" rel="noopener">部分APP无法代理抓包的原因及解决方法（flutter 抓包）</a>一文总结得不错)：</p><ul><li>HTTP 客户端没有走系统代理。这种情况比较少见，一个典型的例子是 Flutter</li><li>HTTP 客户端不信任第三方证书。这种情况比较多见，例如 Android 平台上滴滴出行、微信(7.0版本之后)</li></ul><p>接下来看Android系统中如何避免应用不信任第三方证书。</p><h2 id="问题二：应用不信任第三方证书"><a href="#问题二：应用不信任第三方证书" class="headerlink" title="问题二：应用不信任第三方证书"></a>问题二：应用不信任第三方证书</h2><p>两个解决办法：</p><ul><li>模拟器(开启root) + 安装系统证书</li><li>真机(无root) +  <a href="https://vxposed.com/" target="_blank" rel="noopener">VirtualXposed</a> + JustTrustMe</li></ul><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>有多种模拟器可供选择。这里推荐两个自带root功能，并且可成功运行大部分主流应用的模拟器。</p><ul><li>Windows 上可以使用夜神模拟器</li><li>Mac 上可以使用 <a href="http://mumu.163.com/help/func/20190129/30131_797867.html" target="_blank" rel="noopener">MuMu模拟器</a></li></ul><p>第一步，将whistle 证书下载到电脑上，名字是 <code>root.crt</code>。执行如下命令得到类似 <code>b4a43da9</code> 这样的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -subject_hash_old -in getssl.crt</span><br></pre></td></tr></table></figure><p>第二步，将 <code>root.crt</code> 重命名成 <code>b4a43da9.0</code>，安装到模拟器上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push b4a43da9.0 /system/etc/security/cacerts/</span><br></pre></td></tr></table></figure><p>第三步，<code>设置 &gt; 受信任的凭据 &gt; 系统</code>中检查证书是否安装成功。</p><p>将 whistle 证书安装成系统证书后，就可以正常抓取部分应用中的 HTTPS 请求。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ul><li>安装 VirtualXposed.apk 和 JustTrustme.apk</li><li>给 VirtualXposed 足够的权限</li><li>在 VirtualXposed 中安装 JustTrustme 和需要抓包测试的应用</li><li>重启 VirtualXposed</li><li>在 VirtualXposed 中打开待抓包的应用</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.cnblogs.com/lulianqi/p/11380794.html#_label2" target="_blank" rel="noopener">部分APP无法代理抓包的原因及解决方法（flutter 抓包） - lulianqi15 - 博客园</a></li><li><a href="https://www.jianshu.com/p/3d981ae674c5" target="_blank" rel="noopener">安卓高版本安装系统证书 HTTPS 抓包 - 简书</a></li><li><a href="https://gaojiajun.cn/2018/08/charles-notTrust-in-android7.0/" target="_blank" rel="noopener">Android7.0及以上charles抓包提示证书无效的解决方法 | 高嘉君的个人博客</a></li><li><a href="https://www.jianshu.com/p/a818a0d0aa9f" target="_blank" rel="noopener">Android 7.0+ 抓包https的一种方案(支持微信7.0) - 简书</a></li><li><a href="https://github.com/asLody/VirtualApp" target="_blank" rel="noopener">asLody/VirtualApp: Virtual Engine for Android(Support 11.0 in business version)</a></li><li><a href="https://www.cnblogs.com/h2zZhou/p/7759889.html" target="_blank" rel="noopener">VirtualApp技术黑产利用研究报告 - h2z - 博客园</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近处理一些对第三方应用中HTTPS请求抓包工作。杂七杂八挺烦琐，又容易遗忘。记录之，备不时之需。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ios-pod-package</title>
    <link href="http://www.sunmoonblog.com/2020/11/27/ios-pod-package/"/>
    <id>http://www.sunmoonblog.com/2020/11/27/ios-pod-package/</id>
    <published>2020-11-27T01:32:56.000Z</published>
    <updated>2021-02-10T01:43:25.928Z</updated>
    
    <content type="html"><![CDATA[<p>了解 pod lib 命令的用法。<br><a id="more"></a></p><h1 id="创建Pod库"><a href="#创建Pod库" class="headerlink" title="创建Pod库"></a>创建Pod库</h1><p>第一步，创建Pod工程。使用 <code>pod lib create</code> 命令创建Pod工程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create &lt;PodName&gt;</span><br></pre></td></tr></table></figure><p>按提示配置选项，完成后自动打开 pod install 并打开 xcworkspace 文件</p><p>第二步，生成 Framework。Xcode中运行Example工程后，会生成对应的Framework文件</p><p><img src="/images/16064419140316.jpg" alt></p><p>不过这种方式生成Framework文件有几个问题：</p><ul><li>兼容性问题 - 生成的Framework只支持模拟器或真机，不能同时二者同时兼容</li><li>自动化问题 - 手动在Xcode操作，不便于自动构建</li></ul><h1 id="生成Framework"><a href="#生成Framework" class="headerlink" title="生成Framework"></a>生成Framework</h1><h2 id="使用-cocoapods-packager-生成"><a href="#使用-cocoapods-packager-生成" class="headerlink" title="使用 cocoapods-packager 生成"></a>使用 cocoapods-packager 生成</h2><p><a href="https://github.com/CocoaPods/cocoapods-packager" target="_blank" rel="noopener">CocoaPods Packager</a> 是一个 CocoaPods 插件，用于从 podspec 生成静态库。</p><blockquote><p>CocoaPods plugin which allows you to generate a static library from a podspec.</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>一种方式是使用 gem install 安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install cocoapods-packager</span><br></pre></td></tr></table></figure><p>不过从 Gem 官方源安装的 cocoapods-packager 版本比较老。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gem list | grep packager</span><br><span class="line">cocoapods-packager (1.5.0)</span><br></pre></td></tr></table></figure><p>另一种方式是从源码安装。</p><ul><li>下载源码</li><li>修改版本号</li><li>安装依赖库</li><li>构建gem安装包</li><li>安装gem包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/CocoaPods/cocoapods-packager.git</span><br><span class="line"></span><br><span class="line"># 修改 lib/cocoapods_packager.rb 文件中的版本号</span><br><span class="line"></span><br><span class="line">bundler install</span><br><span class="line"></span><br><span class="line">sudo gem build cocoapods-packager.gemspec</span><br><span class="line"></span><br><span class="line">sudo gem install cocoapods-packager-1.6.0.gem  -l</span><br></pre></td></tr></table></figure><p>构建安装包。构建成功后生成一个 gem 安装包</p><p><img src="/images/16064526409155.jpg" alt></p><p>安装gem包。使用 <code>sudo gem install &lt;gem包名&gt;</code> 安装。</p><p>检查版本号。安装完成后，使用 <code>gem list | grep packager</code> 检查 cocoapods-packager 版本是否正确</p><p><img src="/images/16064529541769.jpg" alt></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用cocoapods-packager时遇到几个问题，记录如下。</p><h3 id="问题一：没有使用-CDN"><a href="#问题一：没有使用-CDN" class="headerlink" title="问题一：没有使用 CDN"></a>问题一：没有使用 CDN</h3><p><code>pod package</code> 命令默认的 spec-sources 是 <a href="https://github.com/CocoaPods/Specs.git，所以会长时间卡在" target="_blank" rel="noopener">https://github.com/CocoaPods/Specs.git，所以会长时间卡在</a> Cloning spec repo 这一步。</p><p><img src="/images/16064435750825.jpg" alt></p><p>解决办法是指定 spec-sources。<a href="https://github.com/CocoaPods/cocoapods-packager/issues/250" target="_blank" rel="noopener">参考</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod package PodDemo.podspec  --spec-sources=&apos;https://cdn.cocoapods.org/&apos;</span><br></pre></td></tr></table></figure><h3 id="问题二：XCode-12-生成失败"><a href="#问题二：XCode-12-生成失败" class="headerlink" title="问题二：XCode 12 生成失败"></a>问题二：XCode 12 生成失败</h3><p>错误日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">have the same architectures (arm64) and can&apos;t be in the same fat output file</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/CocoaPods/cocoapods-packager/issues/259" target="_blank" rel="noopener">issues/259</a> - have the same architectures (arm64) and can’t be in the same fat output file</li><li><a href="https://github.com/CocoaPods/cocoapods-packager/issues/260" target="_blank" rel="noopener">issues/260</a> - Xcode12.0.1 build failed, can’t generate framework #260</li></ul><p>解决办法是排除特定的架构，避免打包失败。这个办法由<a href="https://github.com/CocoaPods/cocoapods-packager/issues/259" target="_blank" rel="noopener">issues/259</a>提供，我尝试发现在我的机器上可用。</p><p>首先，找到 <code>/Library/Ruby/Gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/cocoapods-packager/pod_utils.rb</code> 文件。</p><p>然后，在该文件第32行后面添加一行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.build_settings[&apos;EXCLUDED_ARCHS[sdk=iphonesimulator*]&apos;] = &apos;arm64&apos;</span><br></pre></td></tr></table></figure><p><img src="/images/16064430755729.jpg" alt></p><p>不过这个解决方案并没有提到问题的原因。推测这里的问题跟 <a href="https://github.com/Carthage/Carthage/blob/master/Documentation/Xcode12Workaround.md" target="_blank" rel="noopener">Carthage</a> Xcode 12 上的打包问题比较类似。Carthage 对此的解释是： </p><blockquote><p>Well, shortly, Carthage builds fat frameworks, which means that the framework contains binaries for all supported architectures. Until Apple Silicon was introduced it all worked just fine, but now there is a conflict as there are duplicate architectures (arm64 for devices and arm64 for simulator). This means that Carthage cannot link architecture specific frameworks to a single fat framework.</p><p>You can find more info in <a href="https://github.com/Carthage/Carthage/issues/3019" target="_blank" rel="noopener">respective issue #3019</a>.</p></blockquote><h3 id="问题三：找不到头文件"><a href="#问题三：找不到头文件" class="headerlink" title="问题三：找不到头文件"></a>问题三：找不到头文件</h3><p>遇到一个很诡异的问题：生成的 Framework 中没有公开的头文件。</p><p>排查了很久，发现是一个非常低级的错误。</p><p>原因是这样的：我使用本地Git仓库中的代码来生成 Framework，所以指定了目录但没有指定tag。在没有指定tag时，cocoapods-packager 使用 HEAD 指向的代码来打包。但是，<font color="red">我的代码写好了(包括头文件和源文件)，但并没有提交到Git仓库！</font>cocoapods-packager 当然无法复制公开的文件到生成的 Framework 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#s.source           = &#123; :git =&gt; &apos;https://github.com/abc/CmLib2.git&apos;, :tag =&gt; s.version.to_s &#125;</span><br><span class="line">s.source           = &#123; :git =&gt; &apos;/Users/abc/PublicCode/CmLib2&apos;&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-Carthage-生成"><a href="#使用-Carthage-生成" class="headerlink" title="使用 Carthage 生成"></a>使用 Carthage 生成</h2><p><a href="https://github.com/Carthage/Carthage" target="_blank" rel="noopener">Carthage</a>用于生成二进制的Framework。对比CocoaPods，Carthage无入侵性。</p><blockquote><p>Carthage is intended to be the simplest way to add frameworks to your Cocoa application.</p><p>Carthage builds your dependencies and provides you with binary frameworks, but you retain full control over your project structure and setup. Carthage does not automatically modify your project files or your build settings.</p></blockquote><p>需要注意的是 Carthage只支持</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/a253017eecce" target="_blank" rel="noopener">cocoapods-packager源码安装 - 简书</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解 pod lib 命令的用法。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NSClassFromString 用法简介</title>
    <link href="http://www.sunmoonblog.com/2020/11/14/ios-class-from-string/"/>
    <id>http://www.sunmoonblog.com/2020/11/14/ios-class-from-string/</id>
    <published>2020-11-14T08:09:17.000Z</published>
    <updated>2021-08-08T02:16:27.027Z</updated>
    
    <content type="html"><![CDATA[<p>简单了解如何使用 <code>NSClassFromString()</code> 函数动态加载类。</p><a id="more"></a><h1 id="NSClassFromString-及相关函数"><a href="#NSClassFromString-及相关函数" class="headerlink" title="NSClassFromString 及相关函数"></a>NSClassFromString 及相关函数</h1><table><thead><tr><th></th><th>OC</th><th>Java</th><th>备注</th></tr></thead><tbody><tr><td>通过名字获取类</td><td>NSClassFromString()</td><td>Class.forName()</td><td></td></tr><tr><td>通过名字获取方法</td><td>NSSelectorFromString()</td><td>Class.getDeclaredMethod()</td><td></td></tr><tr><td>判断方法能否调用</td><td>[NSObject respondsToSelector]</td><td></td><td></td></tr><tr><td>动态调用方法</td><td>[NSInvocation invoke]</td><td>Method.invoke()</td></tr></tbody></table><h2 id="NSClassFromString-介绍"><a href="#NSClassFromString-介绍" class="headerlink" title="NSClassFromString 介绍"></a>NSClassFromString 介绍</h2><p><code>NSClassFromString()</code> 函数的作用是通过名字来获取类 (原文：Obtains a class by name.)。</p><p>这个函数接受类的名字(一个字符串)作为参数，返回值是对应的类对象(如果这个名字对应的类未加载，则返回 <code>nil</code>)。如果参数为 <code>nil</code>，则直接返回 <code>nil</code>。</p><p>OC 的 <code>NSClassFromString()</code> 跟 Java 的 <code>Class.forName()</code> 类似。</p><p>OC 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSObject *target = [[NSClassFromString(className) alloc] init];</span><br></pre></td></tr></table></figure><p>对应的 Java 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单起见这里忽略异常处理</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">Object target = clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 9</span></span><br><span class="line"><span class="comment">// Object target = clazz.getDeclaredConstructor().newInstance()</span></span><br></pre></td></tr></table></figure><h2 id="NSSelectorFromString-介绍"><a href="#NSSelectorFromString-介绍" class="headerlink" title="NSSelectorFromString 介绍"></a>NSSelectorFromString 介绍</h2><p><code>NSSelectorFromString()</code> 函数的作用是通过名字来获取 selector (原文：Returns the selector with a given name)。</p><p>这个函数接受 selector 的名字(一个字符串)作为参数，返回值是对应的 selector。如果参数为 <code>nil</code> 或者无法转换成 UTF-8 字符串，则直接返回 <code>(SEL)0</code>。</p><p>OC 的 <code>NSSelectorFromString()</code> 跟 Java 的 <code>Class.getDeclaredMethod()</code> 方法类似。</p><p>OC 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SEL action = NSSelectorFromString(methodName);</span><br></pre></td></tr></table></figure><p>对应的 Java 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method catMethod = SomeClass<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredMethod</span>(<span class="title">methodName</span>)</span>;</span><br></pre></td></tr></table></figure><p>注意：</p><p><code>SEL</code> 的定义是 <code>typedef struct objc_selector *SEL;</code>。它的用于定义代表 method selector 的类型 (原文：Defines an opaque type that represents a method selector)。</p><h2 id="判断方法是否能调用"><a href="#判断方法是否能调用" class="headerlink" title="判断方法是否能调用"></a>判断方法是否能调用</h2><p><code>[NSObject] - (BOOL)respondsToSelector:(SEL)aSelector;</code> - Returns a Boolean value that indicates whether the receiver implements or inherits a method that can respond to a specified message. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (![target respondsToSelector:action])&#123;</span><br><span class="line">   // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Java中没有对应的用法。</p><h2 id="动态调用方法"><a href="#动态调用方法" class="headerlink" title="动态调用方法"></a>动态调用方法</h2><p><code>[NSInvocation invoke]</code> - Sends the receiver’s message (with arguments) to its target and sets the return value.</p><p>OC代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMethodSignature* methodSig = [target methodSignatureForSelector:action];</span><br><span class="line">NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSig];</span><br><span class="line">[invocation invoke];</span><br></pre></td></tr></table></figure><p>对应的Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method action = ...</span><br><span class="line">action.invoke(target);</span><br></pre></td></tr></table></figure><h1 id="NSStringClass-使用案例"><a href="#NSStringClass-使用案例" class="headerlink" title="NSStringClass 使用案例"></a>NSStringClass 使用案例</h1><p>可以使用 <code>NSStringClass()</code> 动态加载类。如果返回 <code>nil</code>，表示不能加载此类。</p><p>如下面代码所示，有不同的方式创建对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 方式一</span><br><span class="line">id myObj = [[NSClassFromString(@&quot;MyClass&quot;) alloc] init];</span><br><span class="line"></span><br><span class="line">// 方式二</span><br><span class="line">id myObj2 = [[MyClass alloc] init];</span><br></pre></td></tr></table></figure><p>通常来说这两种方式没有太多区别。但是，如果并不存在 <code>MyClass</code> 这个类，那么方式二编译报错。所以如果不确定是否存在 <code>MyClass</code> 这个类的情况下，应当使用方式一来创建对象。</p><p>方式一有这样两个好处：</p><ul><li>“弱”链接</li><li>不需要使用 <code>import</code>。即使没有头文件，只要类存在，就可以创建其对象</li></ul><p>再来看一个实例。某项目需要兼容 v4.3 和 v6.0 版本的百度地图SDK(有点怪，是吧)</p><ul><li>百度地图SDK v4.3 - 没有 <code>BMKCustomMapStyleOption</code>，不支持自定义地图功能</li><li>百度地图SDK v6.0 - 有 <code>BMKCustomMapStyleOption</code>，支持自定义地图功能</li></ul><p>原先的代码是这样写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BMKCustomMapStyleOption *options = [[BMKCustomMapStyleOption alloc] init];</span><br></pre></td></tr></table></figure><p>当使用百度地图SDK v6.0时，这行代码工作正常；当使用百度地图SDK v4.3时，这行代码<font color="red">无法编译</font>，提示 <code>BMKCustomMapStyleOption</code> 引起 “Undefined symbols”。</p><p>我们可以使用 <code>NSClassFromString</code> 避免这里的编译错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id options = [[NSClassFromString(@&quot;BMKCustomMapStyleOption&quot;) alloc] init];</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// MyBMapSettingsAdapter.m</span><br><span class="line"></span><br><span class="line">- (void)setCustomMapStyleOptions:(MyCustomStyleOptions *)styleOptions &#123;</span><br><span class="line">    if (styleOptions) &#123;</span><br><span class="line">        // BMKCustomMapStyleOption *options = [[BMKCustomMapStyleOption alloc] init];</span><br><span class="line">        // options.customMapStyleID = styleOptions.styleId;</span><br><span class="line">        // options.customMapStyleFilePath = styleOptions.stylePath;</span><br><span class="line">        // self.bMapView setCustomMapStyleWithOption...</span><br><span class="line">        </span><br><span class="line">        id options = [[NSClassFromString(@&quot;BMKCustomMapStyleOption&quot;) alloc] init];</span><br><span class="line">        </span><br><span class="line">        if (options) &#123;</span><br><span class="line">            SEL idMethod = NSSelectorFromString(@&quot;setCustomMapStyleID:&quot;);</span><br><span class="line">            [MyBMapSettingsAdapter invokeMethod:options selector:idMethod arg1:styleOptions.styleId];</span><br><span class="line">        </span><br><span class="line">            SEL pathMethod = NSSelectorFromString(@&quot;setCustomMapStyleFilePath:&quot;);</span><br><span class="line">            [MyBMapSettingsAdapter invokeMethod:options selector:pathMethod arg1:styleOptions.stylePath];</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用于解决 &quot;performSelector may cause a leak because its selector is unknown&quot;.</span><br><span class="line">+ (void)invokeMethod:(id)obj selector:(SEL)selector arg1:(id)arg1 &#123;</span><br><span class="line">    if (!obj) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if ([obj respondsToSelector:selector]) &#123;</span><br><span class="line">        IMP imp = [obj methodForSelector:selector];</span><br><span class="line">        void (*func)(id, SEL, id) = (void*)imp;</span><br><span class="line">        func(obj, selector, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--问题现象：+ 反序列化时不成功+ 提交加载相关类后，反序列化成功代码：原因：--><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/3ed2c7bc6653" target="_blank" rel="noopener">OC的反射机制 - 简书</a></li><li><a href="https://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown" target="_blank" rel="noopener">ios - performSelector may cause a leak because its selector is unknown - Stack Overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单了解如何使用 &lt;code&gt;NSClassFromString()&lt;/code&gt; 函数动态加载类。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ios-bundle</title>
    <link href="http://www.sunmoonblog.com/2020/11/13/ios-bundle/"/>
    <id>http://www.sunmoonblog.com/2020/11/13/ios-bundle/</id>
    <published>2020-11-13T08:11:34.000Z</published>
    <updated>2020-11-14T08:08:25.766Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 中如何加载资源。</p><a id="more"></a><h1 id="读取第三方Framework中的资源文件"><a href="#读取第三方Framework中的资源文件" class="headerlink" title="读取第三方Framework中的资源文件"></a>读取第三方Framework中的资源文件</h1><p>先看看IPA文件目录结构。右键选中文件然后”显示包内容”：</p><p><img src="/images/16052551712936.jpg" alt></p><p>图中可以看到百度地图SDK的 mapapi.bundle 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *bundlePath = [[NSBundle mainBundle] pathForResource:@&quot;mapapi&quot; ofType:@&quot;bundle&quot;];</span><br><span class="line">NSLog(@&quot;bundle path  is %@&quot;, bundlePath);</span><br></pre></td></tr></table></figure><p>输出如下日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-11-13 16:10:44.289957+0800 map-sdk-ios-framework[19583:1397775] bundle path  is /private/var/containers/Bundle/Application/57181523-430B-42C0-AFD3-450AC94D14AF/map-sdk-ios-framework.app/mapapi.bundle</span><br></pre></td></tr></table></figure><p>百度地图SDK的 mapapi.bundle 文件包含一张名为 baidumap_logo.png 的图片。</p><p><img src="/images/16052555701661.jpg" alt></p><p>我们可以进一步读取这张图片。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *bundlePath = [[NSBundle mainBundle] pathForResource:@&quot;mapapi&quot; ofType:@&quot;bundle&quot;];</span><br><span class="line">NSData *localData = [NSData dataWithContentsOfFile:[bundlePath stringByAppendingPathComponent:@&quot;images/baidumap_logo.png&quot; ]];</span><br><span class="line">NSLog(@&quot;bundle data is %@&quot;, localData);</span><br></pre></td></tr></table></figure><h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="无法读取依赖工程中的资源"><a href="#无法读取依赖工程中的资源" class="headerlink" title="无法读取依赖工程中的资源"></a>无法读取依赖工程中的资源</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 中如何加载资源。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
