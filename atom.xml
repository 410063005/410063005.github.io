<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sunmoon的博客</title>
  
  <subtitle>点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sunmoonblog.com/"/>
  <updated>2021-03-06T03:31:37.047Z</updated>
  <id>http://www.sunmoonblog.com/</id>
  
  <author>
    <name>Sunmoon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>20210306 问题小记</title>
    <link href="http://www.sunmoonblog.com/2021/03/06/variables-debug-info/"/>
    <id>http://www.sunmoonblog.com/2021/03/06/variables-debug-info/</id>
    <published>2021-03-06T01:52:30.000Z</published>
    <updated>2021-03-06T03:31:37.047Z</updated>
    
    <content type="html"><![CDATA[<p>最近对某些第三方Android库做简单的逆向分析。遇到两个问题，记录之。  </p><a id="more"></a><h1 id="Variables-debug-info-not-available"><a href="#Variables-debug-info-not-available" class="headerlink" title="Variables debug info not available"></a>Variables debug info not available</h1><p>Android Studio 中断点调试某些第三方 Android 库提示 Variables debug info not available，无法查看局部变量信息。</p><p><img src="/images/16149956735267.jpg" alt></p><p>找到以下资料 <a href="https://stackoverflow.com/questions/1313922/step-through-jdk-source-code-in-intellij-idea" target="_blank" rel="noopener">来源</a></p><blockquote><p>Java classes which are part of the JDK are compiled without debug info for the size and performance reasons.</p></blockquote><p>简单来说是提到出于大小和性能因素考虑，JDK 中的类是不带 debug 信息的。</p><p>类似地，很多第三方 Android 库使用 proguard 等工具混淆和优化后去掉了 debug 信息，所以调试时无法查看局部变量信息(成员变量信息可查看)</p><h1 id="无法生成-ScanResult-实例"><a href="#无法生成-ScanResult-实例" class="headerlink" title="无法生成 ScanResult 实例"></a>无法生成 ScanResult 实例</h1><p>通常来说，我们会使用 Android 系统 API 获取 <code>android.net.wifi.ScanResult</code> 的实例。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ScanResult&gt; list = wifiManager.getScanResults();</span><br></pre></td></tr></table></figure><p>但出于某些原因，我想自己创建 <code>android.net.wifi.ScanResult</code> 的实例。一开始，我以为这很简单。</p><p>第一个思路，直接调用构造方法创建不就可以了吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScanResult sr = <span class="keyword">new</span> ScanResult();</span><br><span class="line"></span><br><span class="line">ScanResult sr2 = <span class="keyword">new</span> ScanResult(sr);</span><br></pre></td></tr></table></figure><p>但实际上在 Android SDK 30 之前，没有这两个构造方法。所以低版本 Android 设备上有兼容问题，会报 java.lang.NoSuchMethodError 错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2021-03-06 11:15:48.458 22161-22161/? E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">    Process: com.example.amaploc.demo, PID: 22161</span><br><span class="line">    java.lang.NoSuchMethodError: No direct method &lt;init&gt;()V in class Landroid/net/wifi/ScanResult; or its super classes (declaration of &apos;android.net.wifi.ScanResult&apos; appears in /system/framework/framework.jar!classes2.dex)</span><br></pre></td></tr></table></figure><p>第二个思路，反射调用 <code>ScanResult</code> 的构造方法 (非公开方法，@hidden)。但同样存在兼容性问题：</p><ol><li>不同版本的 SDK 上非公开的构造方法参数不同</li><li>某些厂商可能修改了 <code>ScanResult</code> 构造方法</li></ol><p>这里提供一个简单的解决办法。考虑到 <code>ScanResult</code> 实现了 <code>Parcelable</code> 接口，所以可以借助 <code>Parcel</code> 来序列化/反序列化生成新的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ScanResult <span class="title">scanResultInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ScanResult parent = sCopyInstance;</span><br><span class="line"></span><br><span class="line">    Parcel p = Parcel.obtain();</span><br><span class="line">    parent.writeToParcel(p, <span class="number">0</span>);</span><br><span class="line">    p.setDataPosition(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ScanResult.CREATOR.createFromParcel(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/1313922/step-through-jdk-source-code-in-intellij-idea" target="_blank" rel="noopener">debugging - Step through JDK source code in IntelliJ IDEA - Stack Overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近对某些第三方Android库做简单的逆向分析。遇到两个问题，记录之。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.sunmoonblog.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>HTTP抓包小记</title>
    <link href="http://www.sunmoonblog.com/2021/02/18/http-cap/"/>
    <id>http://www.sunmoonblog.com/2021/02/18/http-cap/</id>
    <published>2021-02-18T02:01:02.000Z</published>
    <updated>2021-02-19T04:22:40.077Z</updated>
    
    <content type="html"><![CDATA[<p>最近处理一些对第三方应用中HTTPS请求抓包工作。杂七杂八挺烦琐，又容易遗忘。记录之，备不时之需。<br><a id="more"></a></p><h1 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h1><p>抓包工具有很多，选一个顺手的就行。我用的是 whistle。启动方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">whistle run</span><br><span class="line">[i] whistle@2.6.3 started</span><br><span class="line">[i] 1. use your device to visit the following URL list, gets the IP of the URL you can access:</span><br><span class="line">       http://127.0.0.1:8899/</span><br><span class="line">       http://172.30.209.45:8899/</span><br><span class="line">       http://172.20.209.88:8899/</span><br><span class="line">       Note: If all the above URLs are unable to access, check the firewall settings</span><br><span class="line">             For help see https://github.com/avwo/whistle</span><br><span class="line">[i] 2. configure your device to use whistle as its HTTP and HTTPS proxy on IP:8899</span><br><span class="line">[i] 3. use Chrome to visit http://local.whistlejs.com/ to get started</span><br><span class="line">Press [Ctrl+C] to stop whistle...</span><br></pre></td></tr></table></figure><p>启动后直接在浏览器中打开对应地址开始抓包。</p><h1 id="HTTPS-抓包"><a href="#HTTPS-抓包" class="headerlink" title="HTTPS 抓包"></a>HTTPS 抓包</h1><p>抓 HTTP 一般不会遇到什么问题，这里要说的主要是 HTTPS 抓包时遇到的问题。</p><h2 id="问题一：Android-iOS安装和信任证书"><a href="#问题一：Android-iOS安装和信任证书" class="headerlink" title="问题一：Android/iOS安装和信任证书"></a>问题一：Android/iOS安装和信任证书</h2><ul><li>Android 直接下载后从 SD 卡安装即可。安装成功后在<code>设置 &gt; 受信任的凭据 &gt; 用户</code>中查看</li><li>iOS 使用 Safari 浏览器打开证书链接来安装。安装成功后在<code>设置 &gt; 通用 &gt; 描述文件与设备管理</code>中查看。注意iOS上需要手动设置信任第三方证书</li></ul><p><img src="/images/16136148646757.jpg" alt="-w336"></p><p><img src="/images/16136152558859.jpg" alt="-w396"></p><p><img src="/images/16136153959387.jpg" alt="-w426"></p><p>经过如上设置后，可以抓到部分应用中的 HTTPS 请求了。但另一些应用的 HTTPS 请求，仍然无法抓取。大致可以归纳为两种原因(<a href="https://www.cnblogs.com/lulianqi/p/11380794.html#_label2" target="_blank" rel="noopener">部分APP无法代理抓包的原因及解决方法（flutter 抓包）</a>一文总结得不错)：</p><ul><li>HTTP 客户端没有走系统代理。这种情况比较少见，一个典型的例子是 Flutter</li><li>HTTP 客户端不信任第三方证书。这种情况比较多见，例如 Android 平台上滴滴出行、微信(7.0版本之后)</li></ul><p>接下来看Android系统中如何避免应用不信任第三方证书。</p><h2 id="问题二：应用不信任第三方证书"><a href="#问题二：应用不信任第三方证书" class="headerlink" title="问题二：应用不信任第三方证书"></a>问题二：应用不信任第三方证书</h2><p>两个解决办法：</p><ul><li>模拟器(开启root) + 安装系统证书</li><li>真机(无root) +  <a href="https://vxposed.com/" target="_blank" rel="noopener">VirtualXposed</a> + JustTrustMe</li></ul><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>有多种模拟器可供选择。这里推荐两个自带root功能，并且可成功运行大部分主流应用的模拟器。</p><ul><li>Windows 上可以使用夜神模拟器</li><li>Mac 上可以使用 <a href="http://mumu.163.com/help/func/20190129/30131_797867.html" target="_blank" rel="noopener">MuMu模拟器</a></li></ul><p>第一步，将whistle 证书下载到电脑上，名字是 <code>root.crt</code>。执行如下命令得到类似 <code>b4a43da9</code> 这样的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -subject_hash_old -in getssl.crt</span><br></pre></td></tr></table></figure><p>第二步，将 <code>root.crt</code> 重命名成 <code>b4a43da9.0</code>，安装到模拟器上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push b4a43da9.0 /system/etc/security/cacerts/</span><br></pre></td></tr></table></figure><p>第三步，<code>设置 &gt; 受信任的凭据 &gt; 系统</code>中检查证书是否安装成功。</p><p>将 whistle 证书安装成系统证书后，就可以正常抓取部分应用中的 HTTPS 请求。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ul><li>安装 VirtualXposed.apk 和 JustTrustme.apk</li><li>给 VirtualXposed 足够的权限</li><li>在 VirtualXposed 中安装 JustTrustme 和需要抓包测试的应用</li><li>重启 VirtualXposed</li><li>在 VirtualXposed 中打开待抓包的应用</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.cnblogs.com/lulianqi/p/11380794.html#_label2" target="_blank" rel="noopener">部分APP无法代理抓包的原因及解决方法（flutter 抓包） - lulianqi15 - 博客园</a></li><li><a href="https://www.jianshu.com/p/3d981ae674c5" target="_blank" rel="noopener">安卓高版本安装系统证书 HTTPS 抓包 - 简书</a></li><li><a href="https://gaojiajun.cn/2018/08/charles-notTrust-in-android7.0/" target="_blank" rel="noopener">Android7.0及以上charles抓包提示证书无效的解决方法 | 高嘉君的个人博客</a></li><li><a href="https://www.jianshu.com/p/a818a0d0aa9f" target="_blank" rel="noopener">Android 7.0+ 抓包https的一种方案(支持微信7.0) - 简书</a></li><li><a href="https://github.com/asLody/VirtualApp" target="_blank" rel="noopener">asLody/VirtualApp: Virtual Engine for Android(Support 11.0 in business version)</a></li><li><a href="https://www.cnblogs.com/h2zZhou/p/7759889.html" target="_blank" rel="noopener">VirtualApp技术黑产利用研究报告 - h2z - 博客园</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近处理一些对第三方应用中HTTPS请求抓包工作。杂七杂八挺烦琐，又容易遗忘。记录之，备不时之需。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ios-pod-package</title>
    <link href="http://www.sunmoonblog.com/2020/11/27/ios-pod-package/"/>
    <id>http://www.sunmoonblog.com/2020/11/27/ios-pod-package/</id>
    <published>2020-11-27T01:32:56.000Z</published>
    <updated>2021-02-10T01:43:25.928Z</updated>
    
    <content type="html"><![CDATA[<p>了解 pod lib 命令的用法。<br><a id="more"></a></p><h1 id="创建Pod库"><a href="#创建Pod库" class="headerlink" title="创建Pod库"></a>创建Pod库</h1><p>第一步，创建Pod工程。使用 <code>pod lib create</code> 命令创建Pod工程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create &lt;PodName&gt;</span><br></pre></td></tr></table></figure><p>按提示配置选项，完成后自动打开 pod install 并打开 xcworkspace 文件</p><p>第二步，生成 Framework。Xcode中运行Example工程后，会生成对应的Framework文件</p><p><img src="/images/16064419140316.jpg" alt></p><p>不过这种方式生成Framework文件有几个问题：</p><ul><li>兼容性问题 - 生成的Framework只支持模拟器或真机，不能同时二者同时兼容</li><li>自动化问题 - 手动在Xcode操作，不便于自动构建</li></ul><h1 id="生成Framework"><a href="#生成Framework" class="headerlink" title="生成Framework"></a>生成Framework</h1><h2 id="使用-cocoapods-packager-生成"><a href="#使用-cocoapods-packager-生成" class="headerlink" title="使用 cocoapods-packager 生成"></a>使用 cocoapods-packager 生成</h2><p><a href="https://github.com/CocoaPods/cocoapods-packager" target="_blank" rel="noopener">CocoaPods Packager</a> 是一个 CocoaPods 插件，用于从 podspec 生成静态库。</p><blockquote><p>CocoaPods plugin which allows you to generate a static library from a podspec.</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>一种方式是使用 gem install 安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install cocoapods-packager</span><br></pre></td></tr></table></figure><p>不过从 Gem 官方源安装的 cocoapods-packager 版本比较老。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gem list | grep packager</span><br><span class="line">cocoapods-packager (1.5.0)</span><br></pre></td></tr></table></figure><p>另一种方式是从源码安装。</p><ul><li>下载源码</li><li>修改版本号</li><li>安装依赖库</li><li>构建gem安装包</li><li>安装gem包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/CocoaPods/cocoapods-packager.git</span><br><span class="line"></span><br><span class="line"># 修改 lib/cocoapods_packager.rb 文件中的版本号</span><br><span class="line"></span><br><span class="line">bundler install</span><br><span class="line"></span><br><span class="line">sudo gem build cocoapods-packager.gemspec</span><br><span class="line"></span><br><span class="line">sudo gem install cocoapods-packager-1.6.0.gem  -l</span><br></pre></td></tr></table></figure><p>构建安装包。构建成功后生成一个 gem 安装包</p><p><img src="/images/16064526409155.jpg" alt></p><p>安装gem包。使用 <code>sudo gem install &lt;gem包名&gt;</code> 安装。</p><p>检查版本号。安装完成后，使用 <code>gem list | grep packager</code> 检查 cocoapods-packager 版本是否正确</p><p><img src="/images/16064529541769.jpg" alt></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用cocoapods-packager时遇到几个问题，记录如下。</p><h3 id="问题一：没有使用-CDN"><a href="#问题一：没有使用-CDN" class="headerlink" title="问题一：没有使用 CDN"></a>问题一：没有使用 CDN</h3><p><code>pod package</code> 命令默认的 spec-sources 是 <a href="https://github.com/CocoaPods/Specs.git，所以会长时间卡在" target="_blank" rel="noopener">https://github.com/CocoaPods/Specs.git，所以会长时间卡在</a> Cloning spec repo 这一步。</p><p><img src="/images/16064435750825.jpg" alt></p><p>解决办法是指定 spec-sources。<a href="https://github.com/CocoaPods/cocoapods-packager/issues/250" target="_blank" rel="noopener">参考</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod package PodDemo.podspec  --spec-sources=&apos;https://cdn.cocoapods.org/&apos;</span><br></pre></td></tr></table></figure><h3 id="问题二：XCode-12-生成失败"><a href="#问题二：XCode-12-生成失败" class="headerlink" title="问题二：XCode 12 生成失败"></a>问题二：XCode 12 生成失败</h3><p>错误日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">have the same architectures (arm64) and can&apos;t be in the same fat output file</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/CocoaPods/cocoapods-packager/issues/259" target="_blank" rel="noopener">issues/259</a> - have the same architectures (arm64) and can’t be in the same fat output file</li><li><a href="https://github.com/CocoaPods/cocoapods-packager/issues/260" target="_blank" rel="noopener">issues/260</a> - Xcode12.0.1 build failed, can’t generate framework #260</li></ul><p>解决办法是排除特定的架构，避免打包失败。这个办法由<a href="https://github.com/CocoaPods/cocoapods-packager/issues/259" target="_blank" rel="noopener">issues/259</a>提供，我尝试发现在我的机器上可用。</p><p>首先，找到 <code>/Library/Ruby/Gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/cocoapods-packager/pod_utils.rb</code> 文件。</p><p>然后，在该文件第32行后面添加一行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.build_settings[&apos;EXCLUDED_ARCHS[sdk=iphonesimulator*]&apos;] = &apos;arm64&apos;</span><br></pre></td></tr></table></figure><p><img src="/images/16064430755729.jpg" alt></p><p>不过这个解决方案并没有提到问题的原因。推测这里的问题跟 <a href="https://github.com/Carthage/Carthage/blob/master/Documentation/Xcode12Workaround.md" target="_blank" rel="noopener">Carthage</a> Xcode 12 上的打包问题比较类似。Carthage 对此的解释是： </p><blockquote><p>Well, shortly, Carthage builds fat frameworks, which means that the framework contains binaries for all supported architectures. Until Apple Silicon was introduced it all worked just fine, but now there is a conflict as there are duplicate architectures (arm64 for devices and arm64 for simulator). This means that Carthage cannot link architecture specific frameworks to a single fat framework.</p><p>You can find more info in <a href="https://github.com/Carthage/Carthage/issues/3019" target="_blank" rel="noopener">respective issue #3019</a>.</p></blockquote><h3 id="问题三：找不到头文件"><a href="#问题三：找不到头文件" class="headerlink" title="问题三：找不到头文件"></a>问题三：找不到头文件</h3><p>遇到一个很诡异的问题：生成的 Framework 中没有公开的头文件。</p><p>排查了很久，发现是一个非常低级的错误。</p><p>原因是这样的：我使用本地Git仓库中的代码来生成 Framework，所以指定了目录但没有指定tag。在没有指定tag时，cocoapods-packager 使用 HEAD 指向的代码来打包。但是，<font color="red">我的代码写好了(包括头文件和源文件)，但并没有提交到Git仓库！</font>cocoapods-packager 当然无法复制公开的文件到生成的 Framework 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#s.source           = &#123; :git =&gt; &apos;https://github.com/abc/CmLib2.git&apos;, :tag =&gt; s.version.to_s &#125;</span><br><span class="line">s.source           = &#123; :git =&gt; &apos;/Users/abc/PublicCode/CmLib2&apos;&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-Carthage-生成"><a href="#使用-Carthage-生成" class="headerlink" title="使用 Carthage 生成"></a>使用 Carthage 生成</h2><p><a href="https://github.com/Carthage/Carthage" target="_blank" rel="noopener">Carthage</a>用于生成二进制的Framework。对比CocoaPods，Carthage无入侵性。</p><blockquote><p>Carthage is intended to be the simplest way to add frameworks to your Cocoa application.</p><p>Carthage builds your dependencies and provides you with binary frameworks, but you retain full control over your project structure and setup. Carthage does not automatically modify your project files or your build settings.</p></blockquote><p>需要注意的是 Carthage只支持</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/a253017eecce" target="_blank" rel="noopener">cocoapods-packager源码安装 - 简书</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解 pod lib 命令的用法。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ios-class-from-string</title>
    <link href="http://www.sunmoonblog.com/2020/11/14/ios-class-from-string/"/>
    <id>http://www.sunmoonblog.com/2020/11/14/ios-class-from-string/</id>
    <published>2020-11-14T08:09:17.000Z</published>
    <updated>2020-11-14T08:35:14.740Z</updated>
    
    <content type="html"><![CDATA[<p>OC的<code>NSClassFromString</code>跟Java的<code>Class.forName</code>非常类似。快速了解一下。<br><a id="more"></a></p><h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><h2 id="通过名字获取类"><a href="#通过名字获取类" class="headerlink" title="通过名字获取类"></a>通过名字获取类</h2><p><code>NSClassFromString</code> - Obtains a class by name.</p><p>备注：对应于Java的<code>Class.forName()</code></p><p>OC代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSObject *target = [[NSClassFromString(className) alloc] init];</span><br></pre></td></tr></table></figure><p>对应的Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单起见这里忽略异常处理</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">Object target = clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 9</span></span><br><span class="line"><span class="comment">// Object target = clazz.getDeclaredConstructor().newInstance()</span></span><br></pre></td></tr></table></figure><h2 id="通过名字获取方法"><a href="#通过名字获取方法" class="headerlink" title="通过名字获取方法"></a>通过名字获取方法</h2><p><code>NSSelectorFromString</code> - Returns the selector with a given name.</p><p>OC代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SEL action = NSSelectorFromString(methodName);</span><br></pre></td></tr></table></figure><p>对应的Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method catMethod = SomeClass<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredMethod</span>(<span class="title">methodName</span>)</span>;</span><br></pre></td></tr></table></figure><p>上面代码中需要说明一下的是<code>SEL</code>。它的定义是：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure><p>它的作用是 Defines an opaque type that represents a method selector.</p><p>另一个要注意的OC中通过可以直接通过名字获取到对应的selector，并不需要借助Object或Class；而Java中不能直接通过名字获取到对应的Method，而需要借助Class。</p><h2 id="判断方法是否能调用"><a href="#判断方法是否能调用" class="headerlink" title="判断方法是否能调用"></a>判断方法是否能调用</h2><p><code>[NSObject] - (BOOL)respondsToSelector:(SEL)aSelector;</code> - Returns a Boolean value that indicates whether the receiver implements or inherits a method that can respond to a specified message. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (![target respondsToSelector:action])&#123;</span><br><span class="line">   // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Java中没有对应的用法</p><h2 id="动态调用方法"><a href="#动态调用方法" class="headerlink" title="动态调用方法"></a>动态调用方法</h2><p><code>[NSInvocation invoke]</code> - Sends the receiver’s message (with arguments) to its target and sets the return value.</p><p>OC代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMethodSignature* methodSig = [target methodSignatureForSelector:action];</span><br><span class="line">NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSig];</span><br><span class="line">[invocation invoke];</span><br></pre></td></tr></table></figure><p>对应的Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method action = ...</span><br><span class="line">action.invoke(target);</span><br></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>问题现象：</p><ul><li>反序列化时不成功</li><li>提交加载相关类后，反序列化成功</li></ul><p>代码：</p><p>原因：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OC的&lt;code&gt;NSClassFromString&lt;/code&gt;跟Java的&lt;code&gt;Class.forName&lt;/code&gt;非常类似。快速了解一下。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ios-bundle</title>
    <link href="http://www.sunmoonblog.com/2020/11/13/ios-bundle/"/>
    <id>http://www.sunmoonblog.com/2020/11/13/ios-bundle/</id>
    <published>2020-11-13T08:11:34.000Z</published>
    <updated>2020-11-14T08:08:25.766Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 中如何加载资源。</p><a id="more"></a><h1 id="读取第三方Framework中的资源文件"><a href="#读取第三方Framework中的资源文件" class="headerlink" title="读取第三方Framework中的资源文件"></a>读取第三方Framework中的资源文件</h1><p>先看看IPA文件目录结构。右键选中文件然后”显示包内容”：</p><p><img src="/images/16052551712936.jpg" alt></p><p>图中可以看到百度地图SDK的 mapapi.bundle 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *bundlePath = [[NSBundle mainBundle] pathForResource:@&quot;mapapi&quot; ofType:@&quot;bundle&quot;];</span><br><span class="line">NSLog(@&quot;bundle path  is %@&quot;, bundlePath);</span><br></pre></td></tr></table></figure><p>输出如下日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-11-13 16:10:44.289957+0800 map-sdk-ios-framework[19583:1397775] bundle path  is /private/var/containers/Bundle/Application/57181523-430B-42C0-AFD3-450AC94D14AF/map-sdk-ios-framework.app/mapapi.bundle</span><br></pre></td></tr></table></figure><p>百度地图SDK的 mapapi.bundle 文件包含一张名为 baidumap_logo.png 的图片。</p><p><img src="/images/16052555701661.jpg" alt></p><p>我们可以进一步读取这张图片。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *bundlePath = [[NSBundle mainBundle] pathForResource:@&quot;mapapi&quot; ofType:@&quot;bundle&quot;];</span><br><span class="line">NSData *localData = [NSData dataWithContentsOfFile:[bundlePath stringByAppendingPathComponent:@&quot;images/baidumap_logo.png&quot; ]];</span><br><span class="line">NSLog(@&quot;bundle data is %@&quot;, localData);</span><br></pre></td></tr></table></figure><h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="无法读取依赖工程中的资源"><a href="#无法读取依赖工程中的资源" class="headerlink" title="无法读取依赖工程中的资源"></a>无法读取依赖工程中的资源</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 中如何加载资源。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>H5开发小记</title>
    <link href="http://www.sunmoonblog.com/2020/09/24/h5-dev/"/>
    <id>http://www.sunmoonblog.com/2020/09/24/h5-dev/</id>
    <published>2020-09-24T11:29:29.000Z</published>
    <updated>2020-11-13T04:03:36.121Z</updated>
    
    <content type="html"><![CDATA[<p>离职中。离职前最后一个项目是前端项目，用到了一些之前不了解的工具，也遇到不少的问题。预计接下来几年都不会再接触前端开发工作，但记录一下以备忘、拓展知识广度总是好的。</p><a id="more"></a><p>具体分成三类话题。</p><ul><li>工具</li><li>问题</li><li>技巧</li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>首先谈谈<strong>开发工具</strong>。Chrome Devtools 真是个神器。<a href="(https://juejin.im/post/5f1542e16fb9a07e6f7b80fe">这里</a>)有篇介绍 Devtools 的文章。只挑几个我觉得特别有用的功能说说。</p><p><img src="/images/16009472822261.jpg" alt="-w451"></p><p>一是选择机型，便于在不同分辨率下调试。二是选中元素开关(点击一下后变成蓝色)，打开后选择 html 页面中的元素非常方便</p><p><img src="/images/16009474285734.jpg" alt="-w444"></p><p>第三个是 Replay XHR 功能。只会刷新页面来重新发送 XHR 请求，太 low 了。其实 Replay 一下就足够了！</p><p>另一个好用的开发工具是 Vue.js devtools。怎么好用呢？看图。直接在 Vue.js devtools 中修改数据，UI 也随之变化。调试界面非常方便！</p><p><img src="/images/vuejs-devtools.gif" alt="vuejs-devtools"></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>再来说说遇到的问题(或者说是坑)。</p><h2 id="DOM-与-Vue-js"><a href="#DOM-与-Vue-js" class="headerlink" title="DOM 与 Vue.js"></a>DOM 与 Vue.js</h2><p>首先要说的一个坑就是在 Vue.js 中使用 zepto 操作真实DOM节点引起的一个看似诡异其实很好理解的愚蠢问题。你肯定会质疑为什么 Vue.js 会使用 zepto。实际情况是前端输出的重构文件中用到的 zepto，一是我懒二是确实也不知如何准确地将 zepto 代码翻译成 Vue.js，所以就出现 Vue.js 与 zepto 混用的情况。</p><p>大部分场景下这种做并不会有问题，直接这个点击用户名后编辑的功能：</p><p><img src="/images/edit-name.gif" alt="edit-name"></p><p>伪代码类似这样，其关键在于 <code>vm.inputTeamName = newtxt</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;inputTeamName&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更改名称</span></span><br><span class="line">$(<span class="string">".btn-change"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> td = $(<span class="keyword">this</span>).siblings(<span class="string">'span'</span>);</span><br><span class="line"><span class="keyword">var</span> txt = td.text();</span><br><span class="line"><span class="keyword">var</span> input = $(<span class="string">"&lt;input type='text'value='"</span> + txt + <span class="string">"'/&gt;"</span>);</span><br><span class="line">td.html(input);</span><br><span class="line">input.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line">input.trigger(<span class="string">"focus"</span>);</span><br><span class="line">input.blur(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> newtxt = $(<span class="keyword">this</span>).val();</span><br><span class="line"><span class="keyword">if</span>(newtxt != txt) &#123;</span><br><span class="line">  <span class="comment">// 更新 inputTeamName</span></span><br><span class="line">  vm.inputTeamName = newtxt</span><br><span class="line">td.html(newtxt);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">td.html(newtxt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不过这段代码时灵时不灵。我疑惑了好久。但仔细一想又很简单：操作 span 这个<font color="red">真实DOM节点后</font>，就不能指望 <code></code> 是可靠的了 (毕竟它跟 Vue.js 的<font color="red">虚拟DOM节点</font>相关)</p><p>类似的情况还有操作过真实DOM节点后，<code>v-model</code>指令失效。原因也类似。</p><h2 id="重名组件"><a href="#重名组件" class="headerlink" title="重名组件"></a>重名组件</h2><p>封装了一个 <code>RegisterDialog</code> 组件，组件中指定了 id。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pop-wrap pop-bg02 pop-box01"</span> <span class="attr">id</span>=<span class="string">"pop-box01"</span> <span class="attr">style</span>=<span class="string">"display: none"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"p-title"</span>&gt;</span>绑定手机<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"phone-input"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>RegisterDialog</code> 组件被多处使用。如下图：</p><p><img src="/images/16010202840140.jpg" alt="-w502"></p><p>发现有时操作不能按预期方式操作 <code>RegisterDialog</code>。比如，头像和昵称无法正常显示。推测问题原因是 <code>RegisterDialog</code> 导致 html 页面内元素 ID 冲突。</p><p>一种解决方式是使用更合理的页面结构，保证只有一个 <code>RegisterDialog</code>。如下图：</p><p><img src="/images/16010202885727.jpg" alt="-w503"></p><p>另一种解决方式是避免 <code>RegisterDialog</code> 组件中 div 元素的 ID 写死为 <code>pop-box01</code>，而是使用动态ID。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pop-wrap pop-bg02 pop-box01"</span> <span class="attr">:id</span>=<span class="string">"myID"</span> <span class="attr">style</span>=<span class="string">"display: none"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"p-title"</span>&gt;</span>绑定手机<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"phone-input"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="分享图白边"><a href="#分享图白边" class="headerlink" title="分享图白边"></a>分享图白边</h2><p>我们的H5在某些机型上生成的分享图会出现一条白边。如下图：</p><p><img src="/images/16010220630144.jpg" alt="-w383"></p><p>白边问题的原因是rem和px转化存在小数点。提前将rem转换成px即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fixDimen(domId) &#123;</span><br><span class="line">  <span class="keyword">const</span> ele = <span class="built_in">document</span>.getElementById(domId);</span><br><span class="line">  <span class="keyword">if</span> (ele) &#123;</span><br><span class="line">    <span class="comment">// 解决rem和px转化存在小数点，导致的白边问题</span></span><br><span class="line">    ele.style.width = <span class="string">`<span class="subst">$&#123;ele.offsetWidth&#125;</span>px`</span>;</span><br><span class="line">    ele.style.height = <span class="string">`<span class="subst">$&#123;ele.offsetHeight&#125;</span>px`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="图片跨域"><a href="#图片跨域" class="headerlink" title="图片跨域"></a>图片跨域</h2><p>dom2img 库用于将 DOM 节点转换成图片。使用 dom2img 时要注意图片跨域问题。一种简单的解决办法是将托管在图片服务器上的图片保存到本地，同时修改部分css代码。</p><p>修改前：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://image-1251917893.cos.ap-guangzhou.myqcloud.com/gp-match/css/match.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://image-1251917893.cos.ap-guangzhou.myqcloud.com/gp-match/css/match.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"match.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后本地新增一个 <code>match.css</code> 文件。这个css会重写几个样式(主要是将背景图片指向本地图片，而非图片服务器)以覆盖前一个css中某些规则，以避免图片跨域问题。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.xspr1</span> &#123; <span class="attribute">background-image</span>: <span class="built_in">url</span>(img/xspr1.png); <span class="attribute">background-repeat</span>: no-repeat; <span class="attribute">background-size</span>: <span class="number">9.94rem</span> <span class="number">5.18rem</span>; &#125;</span><br><span class="line"><span class="selector-class">.xspr</span> &#123; <span class="attribute">background-image</span>: <span class="built_in">url</span>(img/xspr.png); <span class="attribute">background-repeat</span>: no-repeat; <span class="attribute">background-size</span>: <span class="number">9.92rem</span> <span class="number">11.21rem</span>; &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="内联CSS"><a href="#内联CSS" class="headerlink" title="内联CSS"></a>内联CSS</h2><p>有时需要在 Vue.js 中内联 css 文件。</p><p>比如我遇到这样一个问题。一些图片和css文件在测试环境中可以正常访问，但发布到正式环境就不行。</p><ul><li>测试环境中能正常访问<ul><li><a href="https://test.igame.qq.com/newcss/admin/hp-match/match.css" target="_blank" rel="noopener">https://test.igame.qq.com/newcss/admin/hp-match/match.css</a></li><li><a href="https://test.igame.qq.com/newcss/admin/hp-match/img/share1.jpg" target="_blank" rel="noopener">https://test.igame.qq.com/newcss/admin/hp-match/img/share1.jpg</a></li></ul></li><li>正式环境中不能正常访问<ul><li><a href="https://igame.qq.com/newcss/admin/hp-match/match.css" target="_blank" rel="noopener">https://igame.qq.com/newcss/admin/hp-match/match.css</a></li><li><a href="https://igame.qq.com/newcss/admin/hp-match/img/share1.jpg" target="_blank" rel="noopener">https://igame.qq.com/newcss/admin/hp-match/img/share1.jpg</a></li></ul></li></ul><p>看 Chrome 提示推测是正式服务器 <code>content-type</code> 配置有问题，它将css文件的作为html返回了，所以无法正常加载css。随之引起图片跨域问题(该css是专门用来解决跨域问题的)</p><p><img src="/images/16010240487770.jpg" alt="-w936"></p><p>无奈我没权限修改正式服务器配置。于是换另一种思路，将 css 内存到 Vue.js。</p><p>修改前：在 <code>index.html</code> 引入 <code>match.css</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"match.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后：在 <code>App.vue</code> 引入 <code>match.css</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./../../../public/match.css'</span>;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><p>修改后成功绕过正式服务器的 <code>content-type</code> 配置问题，可正常加载 <code>match.css</code>，避免了随之而来的图片跨域问题！</p><h2 id="使用图片"><a href="#使用图片" class="headerlink" title="使用图片"></a>使用图片</h2><p>vue 文件中也可以直接使用图片。方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register-dialog.vue</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;img <span class="class"><span class="keyword">class</span></span>=<span class="string">"info-txt-1"</span> :src=<span class="string">"imgs.share_text"</span> alt /&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import head_name from 'src/m</span>odule/xxx/img/head-name.png<span class="string">'</span></span><br><span class="line"><span class="string">import headbox from '</span>src/<span class="built_in">module</span>/xxx/img/headbox.png<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  data() &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      imgs: &#123;</span></span><br><span class="line"><span class="string">        head_name: head_name,</span></span><br><span class="line"><span class="string">        headbox: headbox</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="保存分享图"><a href="#保存分享图" class="headerlink" title="保存分享图"></a>保存分享图</h2><p>一个需求是这样的：用户长按h5保存图片时，实际保存的图片上要求有一个二维码和提示。</p><p><a href="https://blog.csdn.net/w20101310/article/details/60580241/" target="_blank" rel="noopener">微信中如何长按图片保存的是另一张图片_小朱的专栏-CSDN博客</a>中介绍了一种解决方案。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><img src="/images/16009498051466.jpg" alt="-w102"></p><ul><li>chrome devtools 中快速qq登录 (一直觉得H5中QQ登录很麻烦，实际上是没有掌握技巧。使用 Toggle device toolbar 将浏览器切换成PC模式而不是Mobile模式，可以拉起PC端的QQ登录页，然后手机QQ扫一扫登录，非常方便)</li><li>部署不同的 url 的环境 (修改 <code>publish.js</code> 脚本)</li><li>beforeDestroy 响应back 键回退时，以关闭 layer</li><li>同名组件问题 (同ref或同ID)</li><li>无法获取角色信息问题确认</li><li>卡在ssl.ptlogin2.qq.com的问题 (短时间同一测试QQ号在多个Android机器上登录时容易出现这个问题)</li><li>分环境部署 (修改 <code>publish.js</code> 中的 <code>desc</code> 即可)</li><li>css 作用域问题 (dialog 样式)</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/5f1542e16fb9a07e6f7b80fe" target="_blank" rel="noopener">脱离996，Chrome DevTools 面板全攻略！！！ - 掘金</a></li><li><a href="https://blog.csdn.net/w20101310/article/details/60580241/" target="_blank" rel="noopener">微信中如何长按图片保存的是另一张图片_小朱的专栏-CSDN博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;离职中。离职前最后一个项目是前端项目，用到了一些之前不了解的工具，也遇到不少的问题。预计接下来几年都不会再接触前端开发工作，但记录一下以备忘、拓展知识广度总是好的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 内存优化之优化 so 文件</title>
    <link href="http://www.sunmoonblog.com/2020/07/22/flutter-mmamp-memory/"/>
    <id>http://www.sunmoonblog.com/2020/07/22/flutter-mmamp-memory/</id>
    <published>2020-07-22T05:29:59.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>优化 so 大小能否减少 Android 应用的内存？从原理上讲是可以的，实际效果如何？一起来看看吧。</p><a id="more"></a><p>(本文待完善)</p><p>相关文章：</p><ul><li><a href="https://www.sunmoonblog.com/2020/07/16/flutter-split-debug-info/">Flutter split-debug-info 用法介绍</a> - 使用 split-debug-info 可以优化 Flutter libapp.so 大小</li><li><a href="https://www.sunmoonblog.com/2020/07/15/flutter-app-memory-test/">Flutter App 内存测试</a> - 在若干简单场景下测试 Flutter 应用内存，为内存优化提供指导</li></ul><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们知道，Android 应用占用的内存有一类是 <code>Code</code>。<code>dumpsys meminfo</code> 命令的输出中可以看到 Code 类别的内存：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949713220131.jpg" alt></p><p>关于 Code 内存，官网是这样解释的：</p><blockquote><p>Memory that your app uses for code and resources, such as dex bytecode, optimized or compiled dex code, .so libraries, and fonts <a href="https://developer.android.com/studio/profile/memory-profiler#how-counted" target="_blank" rel="noopener">来源</a></p></blockquote><p>简单计算一下，发现 Code 内存大致包括 <code>.so mmap</code> 和 <code>.apk mmap</code>。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949717854679.jpg" alt></p><p>我们可以观察 so 优化前后 <code>.so mmap</code> 的变化来判断优化是否有效果。</p><p>不过还有另外一个问题：Android 应用中通常有很多 so，所以没法通过 <code>.so mmap</code> 来判断单个 so 的优化效果。该怎么办？</p><h1 id="maps-文件"><a href="#maps-文件" class="headerlink" title="maps 文件"></a>maps 文件</h1><p>判断单个 so 的优化效果的方法是查看和分析进程对应的 <code>proc/&lt;pid&gt;/maps</code> 文件。</p><p><a href="https://stackoverflow.com/questions/1401359/understanding-linux-proc-id-maps" target="_blank" rel="noopener">Understanding-linux-proc-id-maps</a> 对 <code>maps</code> 文件有介绍。</p><blockquote><p>Each row in /proc/$PID/maps describes a region of contiguous virtual memory in a process or thread. Each row has the following fields:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">address           perms offset  dev   inode   pathname</span><br><span class="line">08048000-08056000 r-xp 00000000 03:0c 64593   /usr/sbin/gpm</span><br></pre></td></tr></table></figure><ul><li>address - 进程地址空间的起始地址</li><li>permissions - 访问权限</li><li>pathname - 如果该区域是从文件映射来的，pathname 为文件名</li></ul><p>注意，直接在 adb shell 用 cat 查看 maps 文件可能会遇到 permission denied 问题。可以 <code>run-as</code> 命令来避免该问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ ✗ adb shell</span><br><span class="line">HWANE:/ $ run-as</span><br><span class="line">run-as: usage: run-as &lt;package-name&gt; [--user &lt;uid&gt;] &lt;command&gt; [&lt;args&gt;]</span><br><span class="line">run-as com.example.flutter.image.flutter_image_demo  cat /proc/7331/maps \ </span><br><span class="line">  | grep libapp.so</span><br></pre></td></tr></table></figure><p>以下示例查看 <code>com.example.flutter.image.flutter_image_demo</code> 的 maps 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HWANE:/ $ run-as com.example.flutter.image.flutter_image_demo  cat /proc/7331/maps | grep libandroid</span><br><span class="line">7016edb000-7016ef6000 r-xp 00000000 fd:00 7502                           /system/lib64/libandroid.so</span><br><span class="line">7016ef7000-7016efb000 r--p 0001b000 fd:00 7502                           /system/lib64/libandroid.so</span><br></pre></td></tr></table></figure><p>方便起见，可以写个脚本来解析 maps 文件以快速统计每个 so 文件占用内存的总大小。源码见 <a href="https://gist.github.com/410063005/eb8d405d1605e9990620c9f4135762b2" target="_blank" rel="noopener">gist</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">data_list = []</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">    raw_data = input(<span class="string">'paste maps string here: '</span> <span class="keyword">if</span> len(data_list) == <span class="number">0</span> <span class="keyword">else</span> <span class="string">''</span>)</span><br><span class="line">    <span class="keyword">if</span> (raw_data.strip() == <span class="string">''</span>): </span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    data_list.append(raw_data)</span><br><span class="line"></span><br><span class="line">mem_map = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> data_list:</span><br><span class="line">    tmp = item.split(<span class="string">' '</span>)</span><br><span class="line">    addr = tmp[<span class="number">0</span>].split(<span class="string">'-'</span>)</span><br><span class="line">    <span class="keyword">if</span> len(addr) == <span class="number">2</span>:</span><br><span class="line">        mem = (int(addr[<span class="number">1</span>], <span class="number">16</span>) - int(addr[<span class="number">0</span>], <span class="number">16</span>)) / <span class="number">1024.0</span> / <span class="number">1024.0</span></span><br><span class="line"></span><br><span class="line">        key = tmp[<span class="number">-1</span>][<span class="number">-30</span>:]</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> mem_map:</span><br><span class="line">            mem_map[key].append(mem)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            li = []</span><br><span class="line">            li.append(mem)</span><br><span class="line">            mem_map[key] = li</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">for</span> (k, v) <span class="keyword">in</span> mem_map.items():</span><br><span class="line">    print(k, <span class="string">' '</span>, sum(v), <span class="string">'MB'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949755118549.jpg" alt="-w785"></p><h1 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h1><ul><li>测试目标：FlutterImageDemo、Flutter 项目优化前、Flutter 项目优化后</li><li>测试工具：<code>dumpsys meminfo</code> 和 <code>run-as</code></li><li>测试指标：<ul><li><code>libflutter.so</code> 和 <code>libapp.so</code> 文件大小</li><li><code>.so mmap</code></li><li>maps 文件中 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小</li></ul></li></ul><p>数据如下。</p><h2 id="FlutterImageDemo"><a href="#FlutterImageDemo" class="headerlink" title="FlutterImageDemo"></a>FlutterImageDemo</h2><p>FlutterImageDemo 是一个简单的 Flutter 应用。</p><ul><li>包名 <code>com.example.flutter.image.flutter_image_demo</code></li><li>进程号 7331</li><li>APK 包解压出来的 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小分别是 13.9MB 和 6.1MB</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949758838686.jpg" alt></p><p>不得不吐槽下 Mac 上文件大小的计算方式对开发人员实现不友好。我重新算了一下，准确的大小分别是 13.2MB 和 5.8MB。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949759493938.jpg" alt="-w778"></p><p><code>.so mmap</code> 数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys meminfo com.example.flutter.image.flutter_image_demo</span><br><span class="line"></span><br><span class="line">** MEMINFO in pid 7331 [com.example.flutter.image.flutter_image_demo] **</span><br><span class="line">                   Pss  Private  Private  SwapPss     Heap     Heap     Heap</span><br><span class="line">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free</span><br><span class="line">                ------   ------   ------   ------   ------   ------   ------</span><br><span class="line">     .so mmap    14010      584    12600       47</span><br></pre></td></tr></table></figure><p>maps 数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HWANE:/ $ run-as com.example.flutter.image.flutter_image_demo  cat /proc/7331/maps | grep libflutter.so</span><br><span class="line">6fffee6000-70005d9000 r--p 00000000 103:08 39455                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libflutter.so</span><br><span class="line">70005e6000-7000ae9000 r-xp 00700000 103:08 39455                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libflutter.so</span><br><span class="line">7000af6000-7000bd6000 rw-p 00c10000 103:08 39455                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libflutter.so</span><br><span class="line">7000bd6000-7000c25000 r--p 00cf0000 103:08 39455                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libflutter.so</span><br><span class="line">HWANE:/ $ run-as com.example.flutter.image.flutter_image_demo  cat /proc/7331/maps | grep libapp.so</span><br><span class="line">6fff5c3000-6fff5c5000 rw-p 00000000 103:08 45222                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libapp.so</span><br><span class="line">6fff5c5000-6fff85d000 r-xp 00002000 103:08 45222                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libapp.so</span><br><span class="line">6fff85d000-6fffb94000 r--p 0029a000 103:08 45222                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libapp.so</span><br><span class="line">6fffb94000-6fffb95000 rw-p 005d1000 103:08 45222                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libapp.so</span><br></pre></td></tr></table></figure><p>maps 解析后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/lib/arm64/libflutter.so   13.14453125 MB</span><br><span class="line">/lib/arm64/libapp.so   5.8203125 MB</span><br></pre></td></tr></table></figure><h2 id="Flutter-项目优化前"><a href="#Flutter-项目优化前" class="headerlink" title="Flutter 项目优化前"></a>Flutter 项目优化前</h2><p>从优化前的 APK 包解压出来的 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小分别是 5.9MB 和 9.6MB</p><p><code>.so mmap</code> 数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys meminfo com.t.t.i.host</span><br><span class="line">** MEMINFO in pid 15191 [com.t.t.i.host] **</span><br><span class="line">                   Pss  Private  Private  SwapPss     Heap     Heap     Heap</span><br><span class="line">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free</span><br><span class="line">                ------   ------   ------   ------   ------   ------   ------</span><br><span class="line">     .so mmap    16194      452    13896      127</span><br></pre></td></tr></table></figure><p>maps 数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HWANE:/ $ run-as com.t.t.i.host cat /proc/15191/maps  | grep libflutter.so</span><br><span class="line">c16c1000-c17ef000 r--p 00000000 103:08 132483                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libflutter.so</span><br><span class="line">c17ef000-c1baa000 r-xp 0012e000 103:08 132483                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libflutter.so</span><br><span class="line">c1baa000-c1c87000 rw-p 004e9000 103:08 132483                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libflutter.so</span><br><span class="line">c1c87000-c1caf000 r--p 005c6000 103:08 132483                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libflutter.so</span><br><span class="line">HWANE:/ $ run-as com.t.t.i.host cat /proc/15191/maps  | grep libapp.so</span><br><span class="line">c0a0f000-c0a11000 rw-p 00000000 103:08 129024                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libapp.so</span><br><span class="line">c0a11000-c0f55000 r-xp 00002000 103:08 129024                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libapp.so</span><br><span class="line">c0f55000-c13a6000 r--p 00546000 103:08 129024                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libapp.so</span><br><span class="line">c13a6000-c13a7000 rw-p 00997000 103:08 129024                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libapp.so</span><br></pre></td></tr></table></figure><p>maps 解析后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ccpa7w==/lib/arm/libflutter.so   5.9296875 MB</span><br><span class="line">FaZeCcpa7w==/lib/arm/libapp.so   9.59375 MB</span><br></pre></td></tr></table></figure><h2 id="Flutter-项目优化后"><a href="#Flutter-项目优化后" class="headerlink" title="Flutter 项目优化后"></a>Flutter 项目优化后</h2><p>从优化后的 APK 包解压出来的 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小分别是 5.9MB 和 8.6MB</p><p><code>.so mmap</code> 数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys meminfo com.t.t.i.host</span><br><span class="line"></span><br><span class="line">** MEMINFO in pid 14331 [com.t.t.i.host] **</span><br><span class="line">                   Pss  Private  Private  SwapPss     Heap     Heap     Heap</span><br><span class="line">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free</span><br><span class="line">                ------   ------   ------   ------   ------   ------   ------</span><br><span class="line">     .so mmap    16053      452    13572      117</span><br></pre></td></tr></table></figure><p>maps 数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127|HWANE:/ $ run-as com.t.t.i.host cat /proc/14331/maps | grep libflutter.so</span><br><span class="line">c154b000-c1679000 r--p 00000000 103:08 136617                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libflutter.so</span><br><span class="line">c1679000-c1a34000 r-xp 0012e000 103:08 136617                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libflutter.so</span><br><span class="line">c1a34000-c1b11000 rw-p 004e9000 103:08 136617                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libflutter.so</span><br><span class="line">c1b11000-c1b39000 r--p 005c6000 103:08 136617                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libflutter.so</span><br><span class="line">HWANE:/ $ run-as com.t.t.i.host cat /proc/14331/maps | grep libapp.so</span><br><span class="line">c0a8d000-c0a8f000 rw-p 00000000 103:08 131577                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libapp.so</span><br><span class="line">c0a8f000-c0fd2000 r-xp 00002000 103:08 131577                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libapp.so</span><br><span class="line">c0fd2000-c1328000 r--p 00545000 103:08 131577                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libapp.so</span><br><span class="line">c1328000-c1329000 rw-p 0089b000 103:08 131577                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libapp.so</span><br></pre></td></tr></table></figure><p>maps 解析后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V1HTdA==/lib/arm/libflutter.so   5.9296875 MB</span><br><span class="line">0xhjV1HTdA==/lib/arm/libapp.so   8.609375 MB</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>对比 <code>libflutter.so</code> 和 <code>libapp.so</code> 文件大小及 maps 的解析结果，发现数值几乎一致</li><li>对比 <code>.so mmap</code> 内存，看起来跟 so 文件大小相关性不明显 (<font color="red">??? 哪里出错了？</font>)</li></ul><table><thead><tr><th></th><th>libflutter.so文件</th><th>libapp.so文件</th><th><code>.so mmap</code></th><th>maps文件解析</th></tr></thead><tbody><tr><td>FlutterImageDemo</td><td>13.2MB</td><td>5.8MB</td><td>13.7MB</td><td>13.1MB和5.8MB</td></tr><tr><td>优化前</td><td>5.9MB</td><td>9.6MB</td><td>15.8MB</td><td>5.9MB和9.6MB</td></tr><tr><td>优化后</td><td>5.9MB</td><td>8.6MB</td><td>15.7MB</td><td>5.9MB和8.6MB</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;优化 so 大小能否减少 Android 应用的内存？从原理上讲是可以的，实际效果如何？一起来看看吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.sunmoonblog.com/tags/android/"/>
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>(译) Flutter State 生命周期</title>
    <link href="http://www.sunmoonblog.com/2020/07/21/flutter-state-lifecycle/"/>
    <id>http://www.sunmoonblog.com/2020/07/21/flutter-state-lifecycle/</id>
    <published>2020-07-21T09:48:26.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自 <a href="https://medium.com/flutter-community/flutter-lifecycle-for-android-and-ios-developers-8f532307e0c7" target="_blank" rel="noopener">Flutter Lifecycle for Android and iOS Developers | Medium</a>。类比 Android 和 iOS，了解 Flutter State 的生命周期。</p><a id="more"></a><!--One of the most confusing ideas transitioning from Android and/or iOS is to understand how Flutter handles its lifecycle.--><p>从 Android 或 iOS 转到 Flutter 开发，最让人疑惑的是 Flutter 如何处理生命周期。</p><p><strong>onCreate()</strong> 在哪里？<strong>viewDidLoad()</strong> 呢？我应该将业务逻辑放在哪里？为什么只有一个 <code>build</code> 方法？</p><p>本文将解答这些疑惑。</p><h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><p><strong>Activity</strong> 生命周期是 Android 开发必须记住的：</p><ul><li>onCreate</li><li>onStart</li><li>onResume</li></ul><hr><ul><li>onPause</li><li>onStop</li><li>onRestart</li><li>onDestroy</li></ul><p>大部分业务逻辑放在 <strong>onCreate</strong> 方法：初始化 view、数据库、监听器等等。<strong>onResume</strong> 和 <strong>onPause</strong> 是判断用户离开或进入当前页面的好时机。</p><h1 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h1><p>UIViewController 的生命周期如下：</p><ul><li>viewDidLoad</li><li>viewWillAppear</li><li>viewDidAppear</li></ul><hr><ul><li>viewWillDisappear</li><li>viewDidDisappear</li><li>viewDidUnload</li></ul><p>如你所见，两个平台均使用几乎一致的步骤来创建或销毁页面。大部分业务逻辑放在 <strong>viewDidLoad()</strong>，而 <strong>Will/Did Appear/Disappear</strong> 用于保存信息，判断用户何时离开页面等等。</p><h1 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h1><p>在 Flutter 中呢？Widget 也遵循类似规则吗？</p><p>Flutter 中主要有两种 Widget：<strong>StatelessWidget</strong> 和 <strong>StatefulWidget</strong>。本文重点放在 <strong>StatefulWidget</strong>，因为它有点像 <strong>Android</strong> 和 <strong>iOS</strong> 中的某些概念。</p><h2 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2><p>StatefulWidget 是最重要的 Widget，因为它持有 <strong>State</strong>，它知道何时发生变化并进行必要的重绘。它的生命周期如下：</p><ul><li>createState</li><li>initState</li><li>didChangeDependencies</li><li>build</li><li>(didUpdateWidget)</li></ul><p>— — — — — — — — — — —</p><ul><li>deactivate</li><li>dispose</li></ul><p>你可能会注意到创建阶段的 state 比销毁阶段的多，这是因为创建/重建 Widget 及其 State 更复杂。</p><h3 id="createState"><a href="#createState" class="headerlink" title="createState():"></a>createState():</h3><p>构建新的 StatefulWidget 时将调用 createState()，StatefulWidget 的子类必须覆盖这个方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyScreen</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyScreenState createState() =&gt; _MyScreenState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initState"><a href="#initState" class="headerlink" title="initState()"></a>initState()</h3><p>通常需要重写这个方法。它是 Widget 创建后调用的第一个方法，可以理解成 <strong>onCreate()</strong> 或 <strong>viewDidLoad()</strong> 的等价物。在这个方法中可以检查 Widget 某些相关属性：是否有被渲染？当前是否处理 mounted 状态？</p><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>每个 Widget 都有这个属性。当为 Widget.buildContext 赋值后 mounted 的值变成 <strong>true</strong>，Widget 在树中。直到 <strong>dispose</strong> 方法被调用前，mounted 一直为 true。</p><h3 id="addPostFrameCallback"><a href="#addPostFrameCallback" class="headerlink" title="addPostFrameCallback"></a>addPostFrameCallback</h3><p>可以在 <strong>initState</strong> 方法中按如下方式调用 <code>addPostFrameCallback</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/scheduler.dart'</span>;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">  <span class="keyword">super</span>.initState();</span><br><span class="line">  SchedulerBinding.instance.addPostFrameCallback((_) =&gt; &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法为一帧结束时添加回调，回调方法只会调用一次，通知 Widget 构建已完成。</p><h3 id="didChangeDependencies"><a href="#didChangeDependencies" class="headerlink" title="didChangeDependencies"></a>didChangeDependencies</h3><p>widget 构建时第一次调用 initState() 后立即会调用 didChangeDependencies()。如果 <strong>StatefulWidgets</strong> 依赖某个 <strong>InheritedWidget</strong>，后者发生变化时会导致 didChangeDependencies() 再次被调用。</p><h3 id="build"><a href="#build" class="headerlink" title="build()"></a>build()</h3><p>可以肯定地说这是最重要的方法。这个方法依赖整个待渲染的 Widget 树，在 <strong>didChangeDependencies()</strong> 立即被调用。所有的 GUI 渲染发生在这个方法，每次 UI 需要重新渲染时都会调用这个方法。(重新渲染是很廉价的操作)</p><h3 id="didUpdateWidget"><a href="#didUpdateWidget" class="headerlink" title="didUpdateWidget()"></a>didUpdateWidget()</h3><p>这是一个不太常见的生命周期方法。一旦 parent widget 有变化需要重绘 UI 时会调用 didUpdateWidget()。这个方法有一个 <strong>oldWidget</strong> 参数，可以将它跟当前 <strong>widget</strong> 进行比较以执行某些额外的业务逻辑。</p><h3 id="deactivate"><a href="#deactivate" class="headerlink" title="deactivate()"></a>deactivate()</h3><p>这个生命周期方法也不太常见。这个方法被调用时，意味着 Widget 开始进入”死亡”阶段。</p><p>当 framework 从树中移除 State 时会调用本方法。某些情况下，framework 会重新将 State 对象加入到树中。</p><h3 id="dispose"><a href="#dispose" class="headerlink" title="dispose()"></a>dispose()</h3><p>这个方法也非常重要。当 Widget 及其 State 从树中永久移除时会调用这个方法。此后 Widget 不会再被构建。</p><p>你需要在这个方法中做取消对 stream 的监听、销毁动画等操作。它是 <strong>initState</strong> 的反操作。</p><h1 id="WidgetsBindingObserver"><a href="#WidgetsBindingObserver" class="headerlink" title="WidgetsBindingObserver"></a>WidgetsBindingObserver</h1><p>如果我们想监听应用何时进入后台该怎么办？</p><p>可以这样做。对 <strong>StatefulWidget</strong> 做些小改动：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyScreen</span>&gt; <span class="title">with</span> <span class="title">WidgetsBindingObserver</span></span></span><br></pre></td></tr></table></figure><p>我们让 <code>_MyScreenState</code> 实现了抽象类 <strong>WidgetsBindingObserver</strong>，之后就可以观察应用的生命周期状态。在 <strong>initState</strong> 方法中开始观察：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WidgetsBinding.instance.addObserver(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>在 <strong>dispose</strong> 方法中停止观察：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WidgetsBinding.instance.removeObserver(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>接下来在 <strong>didChangeAppLifecycleState</strong> 接收生命周期的变化即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> didChangeAppLifecycleState(AppLifecycleState state) &#123;</span><br><span class="line">  <span class="keyword">super</span>.didChangeAppLifecycleState(state);</span><br><span class="line">  <span class="keyword">if</span> (state == AppLifecycleState.paused) &#123;</span><br><span class="line">    <span class="comment">// went to Background</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (state == AppLifecycleState.resumed) &#123;</span><br><span class="line">    <span class="comment">// came back to Foreground</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个技巧很有用。如果你想在应用进入后台时弹出 notification，或者保存数据，又或者在用户点 back 回退时弹出 popup，都可以使用这个技巧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自 &lt;a href=&quot;https://medium.com/flutter-community/flutter-lifecycle-for-android-and-ios-developers-8f532307e0c7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flutter Lifecycle for Android and iOS Developers | Medium&lt;/a&gt;。类比 Android 和 iOS，了解 Flutter State 的生命周期。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
      <category term="翻译" scheme="http://www.sunmoonblog.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Flutter split-debug-info 用法介绍</title>
    <link href="http://www.sunmoonblog.com/2020/07/16/flutter-split-debug-info/"/>
    <id>http://www.sunmoonblog.com/2020/07/16/flutter-split-debug-info/</id>
    <published>2020-07-16T09:34:18.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>介绍如何使用 Flutter 1.7 提供的 <code>split-debug-info</code> 编译选项来减小包大小。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>先介绍下什么是 <a href="https://en.wikipedia.org/wiki/Obfuscation_(software" target="_blank" rel="noopener">Code obfuscation</a>)。Code obfuscation 翻译过来就是代码混淆。代码混淆是修改应用二进制文件以增加理解难度的过程。混淆会隐藏编译后的 Dart 代码中的函数名和类名，让攻击者难以对应用进行逆向工程。</p><p>目前 Flutter (v1.7.14) stable 分支仅在 <a href="https://flutter.dev/docs/testing/build-modes" target="_blank" rel="noopener">release build</a> 中支持代码混淆。<a href="https://github.com/flutter/flutter/pull/49650" target="_blank" rel="noopener">Pull Request #49650 · flutter/flutter</a> 添加了这个功能。</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>同时使用 <code>--obfuscate</code> 和 <code>--split-debug-info</code> 标志来在 release 版本的应用中开启混淆。<code>--split-debug-info</code> 用于指定一个目录来存放 debug 文件，即 symbol map。目前 Flutter (v1.7.14) stable 分支支持 <code>apk</code>、<code>appbundle</code>、<code>ios</code> 和 <code>ios-framework</code>，master 和 dev 分支上还支持 <code>macos</code> 和 <code>aar</code>。</p><p>示例：编译并混淆一个 APK，在 <code>tmp</code> 目录下保存 symbol map。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter build apk --release --target-platform android-arm64 \</span><br><span class="line"> --obfuscate \</span><br><span class="line"> --split-debug-info=tmp/</span><br></pre></td></tr></table></figure><p>对于 Android 项目，也可以通过在 <code>&lt;project&gt;/app/gradle.properties</code> 中添加如下配置来<a href="https://github.com/flutter/flutter/wiki/Obfuscating-Dart-Code" target="_blank" rel="noopener">开启代码混淆</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extra-gen-snapshot-options=--obfuscate</span><br></pre></td></tr></table></figure><p>编译完成后 <code>tmp</code> 目录将生成一个后缀名为 <code>.symbols</code> 的文件。</p><p>注意：也可以单独使用 <code>--split-debug-info</code>。实际上这个参数是用来减小代码大小的 (即 <code>libapp.so</code> 的大小)</p><p>分别使用如下命令编译 APK。第一条命令生成优化前的 APK，第二条命令生成优化后的 APK。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter build apk --release --target-platform android-arm64</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter build apk --release --target-platform android-arm64 \</span><br><span class="line"> --obfuscate \</span><br><span class="line"> --split-debug-info=tmp/</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/16/15948669243081.jpg" alt></p><p>使用 <code>--split-debug-info</code> 优化后，APK 大小较之前减少 435KB。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/16/15948672793669.jpg" alt="-w727"></p><ul><li>优化前未压缩状态下 <code>libapp.so</code> 大小是 9.7MB</li><li>优化后未压缩状态下 <code>libapp.so</code> 大小是 8.6MB</li></ul><p>真正的减少来自 <code>libapp.so</code>，约 1.1MB。正如文档所言，<code>--split-debug-info</code> 可以减少代码大小。不过考虑到 APK 是压缩包，所以 <code>libapp.so</code> 的减小反映在 APK 包大小变化上并不明显。</p><h1 id="优化效果"><a href="#优化效果" class="headerlink" title="优化效果"></a>优化效果</h1><p>我们项目以 AAR 产物方式集成 Flutter。我从我们最新发布的 APK 中解压出 <code>libapp.so</code>，不作称为 <code>libapp-当前发布包.so</code>。</p><p><code>flutter build aot --release --target-platform android-arm</code> 编译结果为 <code>libapp-优化前.so</code></p><p><code>flutter build aot --release --target-platform android-arm</code> 加上 <code>--obfuscate</code> 和 <code>--split-debug-info</code> 的编译结果为 <code>libapp-优化后.so</code>。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/16/15948868220974.jpg" alt></p><p>可以看到前两个 so 文件大小接近，后一个 so 文件小了将近 0.9MB。(注意：这里的 so 是32位，不同于上一节中的64位，所以文件大小变化不同)。这里的 0.9MB(减小约11%) 并不太起眼，不过考虑到最小的 <code>libapp.so</code> 也有将近 3.7MB，所以其实还是很可观的。</p><table><thead><tr><th>文件</th><th>大小</th><th>备注</th></tr></thead><tbody><tr><td>最小的 <code>libapp.so</code></td><td>3.7MB</td><td>从 <code>flutter create</code> 创建的工程编译而来</td></tr><tr><td><code>libapp-当前发布包.so</code></td><td>8.3MB</td><td>从最新发布的APK解压而来</td></tr><tr><td><code>libapp-优化后.so</code></td><td>7.4MB</td><td>使用 <code>split-debug-info</code> 编译编译</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>官方 <a href="https://flutter.dev/docs/perf/app-size#reducing-app-size" target="_blank" rel="noopener">Measuring your app’s size - Flutter</a> 中提供了几种减小 Flutter 包大小的方法，可以作为参考</p><ul><li>Remove unused resources</li><li>Minimize resource imported from libraries</li><li>Support a limited number of screen densities</li><li>Compress PNG and JPEG files</li></ul><p>其他资料：</p><ul><li><a href="https://github.com/flutter/flutter/wiki/Obfuscating-Dart-Code" target="_blank" rel="noopener">Obfuscating-Dart-Code</a></li><li><a href="https://flutter.dev/docs/deployment/obfuscate" target="_blank" rel="noopener">Obfuscating Dart code - Flutter</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍如何使用 Flutter 1.7 提供的 &lt;code&gt;split-debug-info&lt;/code&gt; 编译选项来减小包大小。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flutter Overlay 用法简介</title>
    <link href="http://www.sunmoonblog.com/2020/07/15/flutter-overlay-usage/"/>
    <id>http://www.sunmoonblog.com/2020/07/15/flutter-overlay-usage/</id>
    <published>2020-07-15T10:20:29.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter Overlay 用法简介。</p><a id="more"></a><h1 id="Overlay-基本用法"><a href="#Overlay-基本用法" class="headerlink" title="Overlay 基本用法"></a>Overlay 基本用法</h1><p><code>Overlay</code> 实际上是一个 <code>Stack</code>，所以 <code>OverlayEntry</code> 的内容可以是 <code>Positioned</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> overlayEntry = OverlayEntry(builder: (context) =&gt; Positioned(...););</span><br><span class="line">Overlay.of(context).insert(overlayEntry);</span><br></pre></td></tr></table></figure><ul><li>显示 Overlay - 使用 <code>Overlay.of(context).insert()</code> 方法</li><li>隐藏 Overlay - 使用 <code>overlayEntry.remove()</code> 方法</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/overlaybasic.gif" alt="overlay-basic"></p><h1 id="Overlay-高级用法"><a href="#Overlay-高级用法" class="headerlink" title="Overlay 高级用法"></a>Overlay 高级用法</h1><h2 id="指定位置"><a href="#指定位置" class="headerlink" title="指定位置"></a>指定位置</h2><p>有时我们想指定 Overlay 的显示位置，实现方式如下：</p><ul><li>先使用 <code>BuildContext.findRenderObject()</code> 来找到当前 Widget 对应的 RenderObject</li><li>再使用 <code>RenderBox.localToGlobal()</code> 找到 Widget 在屏幕上的位置</li></ul><p>具体见 <code>_calcPos()</code> 方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyButton</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> PosCallback callback;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> _MyButton(&#123;Key key, <span class="keyword">this</span>.callback&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  __MyButtonState createState() =&gt; __MyButtonState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">__MyButtonState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">_MyButton</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; _calcPos() &#123;</span><br><span class="line">    RenderBox renderBox = context.findRenderObject();</span><br><span class="line">    <span class="keyword">var</span> size = renderBox.size;</span><br><span class="line">    <span class="keyword">var</span> offset = renderBox.localToGlobal(Offset.zero);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [offset.dx, offset.dy + size.height];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RaisedButton(</span><br><span class="line">      onPressed: () &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; list = _calcPos();</span><br><span class="line">        widget.callback(list[<span class="number">0</span>], list[<span class="number">1</span>]);</span><br><span class="line">      &#125;,</span><br><span class="line">      child: Text(<span class="string">'show overlay'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/overlaypos.gif" alt="overlay-pos"></p><h2 id="跟随滚动"><a href="#跟随滚动" class="headerlink" title="跟随滚动"></a>跟随滚动</h2><p>使用 <a href="https://api.flutter.dev/flutter/rendering/LayerLink-class.html" target="_blank" rel="noopener">LayerLink</a> 来让 Overlay 跟随指定的 Widget 来滚动。</p><ul><li>LayerLink 用于联系 <a href="https://api.flutter.dev/flutter/rendering/LeaderLayer-class.html" target="_blank" rel="noopener">LeaderLayer</a> 和 <a href="https://api.flutter.dev/flutter/rendering/FollowerLayer-class.html" target="_blank" rel="noopener">FollowerLayer</a></li><li>使用 <a href="https://api.flutter.dev/flutter/widgets/CompositedTransformTarget-class.html" target="_blank" rel="noopener">CompositedTransformTarget</a> 来创建 LeaderLayer</li><li>使用 <a href="https://api.flutter.dev/flutter/widgets/CompositedTransformFollower-class.html" target="_blank" rel="noopener">CompositedTransformFollower</a> 来创建 FollowLayer</li></ul><p>代码篇幅较长，这里就不贴上来了。完整代码见 <a href="https://gist.github.com/410063005/4034c395f3305feeb262482a96d4278e" target="_blank" rel="noopener">gist</a>。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/overlayscroll.gif" alt="overlay-scroll"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://medium.com/saugo360/https-medium-com-saugo360-flutter-using-overlay-to-display-floating-widgets-2e6d0e8decb9" target="_blank" rel="noopener">Flutter: Using Overlay to display floating widgets | by AbdulRahman AlHamali | SAUGO 360 | Medium</a></li><li><a href="https://api.flutter.dev/flutter/rendering/LayerLink-class.html" target="_blank" rel="noopener">LayerLink class - rendering library - Dart API</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter Overlay 用法简介。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter App 内存测试</title>
    <link href="http://www.sunmoonblog.com/2020/07/15/flutter-app-memory-test/"/>
    <id>http://www.sunmoonblog.com/2020/07/15/flutter-app-memory-test/</id>
    <published>2020-07-15T06:12:49.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter 应用内存测试数据。</p><a id="more"></a><h1 id="内存测试一-简单-UI"><a href="#内存测试一-简单-UI" class="headerlink" title="内存测试一 - 简单 UI"></a>内存测试一 - 简单 UI</h1><p>分别<strong>使用 Android 和 Flutter 实现最简单的界面</strong>。</p><ul><li>显示一个文本</li><li>显示一个图片</li></ul><p>使用 TextView 显示 “Hello World!” 的 Android Demo，布局如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Hello World!"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 Text Widget 显示 “Hello World!” 的 Flutter Demo，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Center(child: Text(<span class="string">'Hello World!'</span>)),</span><br></pre></td></tr></table></figure><p>显示图片的 Demo 非常类似，这里略过。</p><p>测试数据显示：<strong>Flutter 应用比原生应用占用更多内存，多出来的部分主要包括 Other、Code、Native、Graphics</strong>。(注意：Android Studio 中无法正常显示 Other 部分变化，<code>adb shell dumpsys meminfo</code> 及 Flutter DevTools 中可正常观察到)</p><p>以下是具体测试数据。</p><h2 id="数据一"><a href="#数据一" class="headerlink" title="数据一"></a>数据一</h2><p>机型及配置：华为 Nova 2，Android 8.0，分辨率480dp(3x)。</p><p>Android Text Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944369530168.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944406815956.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944408053563.jpg" alt></p><p>Android Image Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944370128933.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944407225565.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944408363481.jpg" alt></p><p>Flutter Text Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944384753825.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944408943099.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944440141932.jpg" alt></p><p>Flutter Image Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944385231943.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944409251967.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944440514423.jpg" alt></p><h2 id="数据二"><a href="#数据二" class="headerlink" title="数据二"></a>数据二</h2><p>机型及配置：小米 8，分辨率440dp(2.8x)</p><p>Android Text Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944403017361.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944441459158.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944443093212.jpg" alt></p><p>Android Image Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944404063442.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944441807084.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944443368308.jpg" alt></p><p>Flutter Text Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944399044259.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944442195175.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944443788400.jpg" alt></p><p>Flutter Image Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944399984819.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944442627978.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944444195039.jpg" alt></p><h1 id="内存测试二-分配大对象"><a href="#内存测试二-分配大对象" class="headerlink" title="内存测试二 - 分配大对象"></a>内存测试二 - 分配大对象</h1><p>持续在 Dart 代码中分配对象。观察内存变化。</p><p>测试数据显示：<strong>从 Android 角度看，Dart Heap 中分配的对象归类为 “Private Other” 内存</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Uint8List&gt; _memList = <span class="built_in">List</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _addToMemList() &#123;</span><br><span class="line">    <span class="comment">// 点击一次, 分配 10MB 内存</span></span><br><span class="line">    _memList.add(_createData(<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15945451536123.jpg" alt="-w1428"></p><p>随着分配的 Dart 对象，Dart 内存和 Android 内存都在增加</p><ul><li>左图是 Dart 内存<ul><li>Dart Heap Capacity (绿线区域)一直在增长</li><li><font color="red">Dart Heap Used (浅蓝色区域)一直在增长</font></li><li>Dart External (蓝色区域)几乎不变</li></ul></li><li>右图是 Android 内存<ul><li>Total (绿线)一直在增长</li><li><font color="red">Other (紫线)一直在增长</font></li><li>其他几乎不变</li></ul></li></ul><h1 id="内存测试三-显示图片"><a href="#内存测试三-显示图片" class="headerlink" title="内存测试三 - 显示图片"></a>内存测试三 - 显示图片</h1><p>持续在 Dart 代码中<strong>加载并显示</strong>本地图片(1024x1024)。观察内存变化。</p><p>测试数据显示：<strong>Flutter 应用中图片在 Graphics 内存中分配</strong></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947280277523.jpg" alt="-w1666"></p><p>随着加载和显示的图片增多，Dart 内存和 Android 内存都在增加</p><ul><li>左图是 Dart 内存<ul><li>Dart Heap Capacity (绿线区域)一直在增长</li><li>Dart Heap Used (浅蓝色区域)几乎不变</li><li><font color="red">Dart External (蓝色区域)一直在增长</font></li></ul></li><li>右图是 Android 内存<ul><li>Total (绿线)一直在增长</li><li><font color="red">Graphics (橙色区域)波浪形增长</font></li><li>其他几乎不变</li></ul></li></ul><h1 id="内存测试四-预加载图片"><a href="#内存测试四-预加载图片" class="headerlink" title="内存测试四 - 预加载图片"></a>内存测试四 - 预加载图片</h1><p>持续在 Dart 代码中<strong>预加载但不显示</strong>本地图片(1024x1024)。观察内存变化。</p><p>测试数据显示：<strong>Flutter 应用中图片在 Graphics 内存中分配</strong></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947294740934.jpg" alt="-w1294"></p><p>随着预加载的图片增多，Dart 内存和 Android 内存都在增加</p><ul><li>左图是 Dart 内存<ul><li>Dart Heap Capacity (绿线区域)一直在增长</li><li>Dart Heap Used (浅蓝色区域)几乎不变</li><li><font color="red">Dart External (蓝色区域)一直在增长</font></li></ul></li><li>右图是 Android 内存<ul><li>Total (绿线)一直在增长</li><li><font color="red">Graphics (橙色区域)波浪形增长</font></li><li>其他几乎不变</li></ul></li></ul><h1 id="内存测试五-启动多个-Flutter-引擎"><a href="#内存测试五-启动多个-Flutter-引擎" class="headerlink" title="内存测试五 - 启动多个 Flutter 引擎"></a>内存测试五 - 启动多个 Flutter 引擎</h1><p>持续启动 Flutter 引擎，每次增加一个。观察内存变化。</p><p>测试数据显示：<strong>每开启一个 Flutter 引擎，Native 内存大约有5-6MB增长，Private Other 有10MB左右增长</strong></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947866240369.jpg" alt="-w1302"></p><p>随着 Flutter 引擎数量增多，Dart 内存和 Android 内存都在增加</p><ul><li>左图是 Dart 内存<ul><li><font color="red">Dart Heap Used (浅蓝色区域)几乎不变</font></li><li>Dart External (蓝色区域)一直在增长</li></ul></li><li>右图是 Android 内存<ul><li>Total (绿线)一直在增长</li><li><font color="red">Other (紫色区域)一直在快速增长</font></li><li><font color="red">Native (蓝色区域)一直在较快增长</font></li><li>Graphics (橙色区域)无增长</li></ul></li></ul><p>在 Android Studio 中测试结果如下：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947848408890.jpg" alt></p><p>随着 Flutter 引擎数量增多，</p><ul><li>Private Other 一直在增长 (注：注意：Android Studio 中无法正常显示 Other 部分变化，<code>adb shell dumpsys meminfo</code> 及 Flutter DevTools 中可正常观察到)</li><li>Native 内存(蓝色区域)一直在增长</li></ul><h1 id="测试结论"><a href="#测试结论" class="headerlink" title="测试结论"></a>测试结论</h1><ul><li>Flutter 应用比原生应用占用更多内存，多出来的部分主要包括 Other、Code、Native、Graphics <a href="https://developer.android.com/studio/profile/memory-profiler#how-counted" target="_blank" rel="noopener">内存分类</a> <a href="https://developer.android.com/studio/command-line/dumpsys#meminfo" target="_blank" rel="noopener">meminfo</a></li><li>从 Android 角度看，Dart Heap 属性 “Private Other” 内存。Dart 中创建对象会导致 Private Other 内存增长</li><li>Flutter 应用中图片在 Graphics 内存中分配 <a href="https://www.yuque.com/xytech/flutter/avmyht" target="_blank" rel="noopener">闲鱼技术 Android Flutter实践内存初探</a></li><li>每开启一个 Flutter 引擎，Native 内存大约有5-6MB增长，Private Other 有10MB左右增长</li></ul><p>为什么 Flutter 应用会比原生应用占用更多内存？官网给出的一些数据也许能解释部分原因。以下翻译自 <a href="https://flutter.dev/docs/development/add-to-app/performance#memory-and-latency" target="_blank" rel="noopener">Load sequence, performance, and memory - Flutter</a></p><blockquote><p>展示 Flutter UI 会有一定不可忽视的延迟。可以提前启动 Flutter 引擎来减少这个延迟。</p><p>集成 Flutter 到已有应用时要评估预加载 Flutter 引擎(即，加载 Flutter 库、启动 Dart VM、运行 isolate 入口程序)带来的内存开销及延迟。</p><p>在 2015 年的一款低端手机上，Flutter v1.10.3 release-AOT 模式下预热 <code>FlutterEngine</code> 开销如下：</p><ul><li><strong>Android</strong> 42 MB 和 1530 ms。其中有 330 ms 会阻塞主线程</li><li><strong>iOS</strong>  22 MB 和 860 ms。其中有 260 ms 会阻塞主线程</li></ul><p>内存方面，一个测试样本数据如下(根据使用场景会有所变化)</p><ul><li>~4 MB OS’s memory usage for creating pthreads.</li><li>~10 MB GPU driver memory.</li><li>~1 MB for Dart runtime-managed memory.</li><li>~5 MB for Dart-loaded font maps.</li></ul><p>延迟方面，一个测试样本数据如下(根据使用场景会有所变化)</p><ul><li>~20 ms to collect the Flutter assets from the application package.</li><li>~15 ms to dlopen the Flutter engine library.</li><li>~200 ms to create the Dart VM and load the AOT snapshot.</li><li>~200 ms to load Flutter-dependent fonts and assets.</li><li>~400 ms to run the entrypoint, create the first widget tree, and compile the needed GPU shader programs.</li></ul><p>预热 Flutter 引擎的时机应该足够晚，以减小内存占用；同时还要足够早，以避免 Flutter 引擎启动时间跟首帧延迟叠加在一起(否则会感觉启动慢，体验非常糟糕)</p><p>具体预热时机要根据应用的实际结构来决定。通常经验是在将显示 Flutter 页面的前一个页面中预热</p><p>假设引擎已经预热，关联 UI 时的首帧开销如下：</p><ul><li><strong>Android</strong> 320 ms 以及额外的 12 MB (跟屏幕的物理像素尺寸非常相关，physical pixel size)</li><li><strong>iOS</strong> 200 ms 以及额外的 16 MB (跟屏幕的物理像素尺寸非常相关，physical pixel size)</li></ul><p>内存方面，开销主要来自用于渲染的 graphical memory buffer (跟屏幕尺寸相关)</p><p>延迟方面，开销主要是等原生系统回调(提供 surface)以及编译 shader 程序(原文: compiling the remaining shader programs that are not pre-emptively predictable)的时间。这里的延迟仅在第一帧</p><p>Flutter UI 释放后，相关内存也会释放。这里的内存释放跟 <code>FlutterEngine</code> 中的 Flutter State 无关，除非 <code>FlutterEngine</code> 也释放了</p></blockquote><h1 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h1><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947301347638.jpg" alt></p><p>Flutter 应用内存可优化的点分别是：</p><ul><li>Private Others，Dart 代码分配的对象属于这一类。优化点是减少 Dart 代码中不必要的对象分配，尤其是大对象</li><li>Code - 用于处理代码和资源，如 dex 字节码，so 库和字体。优化点是减少 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小</li><li>Graphics - 图形缓冲区队列向屏幕显示像素（包括 GL 表面、GL 纹理等等）所使用的内存。比较好入手的一个优化是减少 Dart 代码中图片占用的内存。另外可以考虑优化 Flutter UI 这一块(同样使用 skia，为什么 Android 原生 UI 占用的内存比 Flutter UI 少？)</li><li>Native - C 或 C++ 代码分配的对象的内存。优化点是减少 Flutter 引擎占用的内存，比如单引擎比多引擎使用更少的内存</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947874114688.jpg" alt="-w1261"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter 应用内存测试数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>(译) Flutter 原理</title>
    <link href="http://www.sunmoonblog.com/2020/07/11/how-flutter-works/"/>
    <id>http://www.sunmoonblog.com/2020/07/11/how-flutter-works/</id>
    <published>2020-07-11T06:29:22.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter 是如何工作的？<br><a id="more"></a></p><p>要点如下：</p><ul><li>Flutter 框架更像一个游戏引擎，而不是传统的应用框架</li><li>Flutter 应用由 Widget 构成，Widget 被渲染到 Skia canvas，最后发送到平台</li><li>Flutter 引擎在对应的平台 shell 中运行</li><li>Flutter UI 发生变化时会被构建和渲染到 Skia Canvas</li><li>Flutter 以 60fps 来更新 UI，并且使用 GPU 完成大部分工作</li></ul><p>原文翻译如下。</p><p>跟其他框架相比，Flutter 以一种全新的方式构建，它更像一个游戏引擎而不是传统应用框架。我想讲讲在大层面上 Flutter 是如何工作的，以及它如何实现高性能。从大的层面来讲，<strong>应用由 Widget 构成，Widget 被渲染到 Skia canvas，最后发送到平台。平台显示 canvas，并且按要求返回事件</strong>。</p><p><img src="/images/15944494180838.jpg" alt></p><p>应用在平台上以 AOT 直接运行 (Your app runs on the platform in natively, Ahead of Time complied.)</p><h1 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h1><p>Flutter 在平台上提供 <code>Shell</code>，用作 Dart VM 和宿主。Shell 是平台相关的，提供对平台原生 API 的访问支持并且建立平台相关的 canvas。</p><p><img src="/images/15944503631949.jpg" alt></p><p>Shell 还用于和 IMEs 和系统应用生命周期事件通信。</p><h1 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h1><p>引擎是平台之上的层，提供 Dart 运行时、Skia、Platform Channel 及其他内容。Flutter Wiki 中的<a href="https://github.com/flutter/engine/wiki#architecture-diagram" target="_blank" rel="noopener">架构图</a>中有更多细节。</p><p><img src="/images/15944505039484.jpg" alt></p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>Flutter 引擎跟应用开发者最相关。它包含你开发应用时需要交互的所有内容。</p><p><img src="/images/15944513053707.jpg" alt></p><p>Flutter 只需简单使用对应的风格就能保持跟 iOS 或 Android 原生一致风格。iOS 使用 Cupertino 风格，Android 使用 Material 风格。</p><p>Flutter 不使用原生组件，而是 Widget。Widget 是 Flutter 应用的组件。Flutter 将 UI 绘制到 Skia Canvas。</p><p>一旦 UI 完成渲染，就进入引擎环境。</p><h1 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h1><p>Flutter 更像游戏引擎，而不是应用框架。Flutter UI 发生变化时会被构建和渲染到 Skia Canvas。Flutter 以 60fps 来更新 UI，并且使用 GPU 完成大部分工作。(所以 Flutter UI 这么流畅)</p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>这里只是大体上讲了一下 Flutter 是如何工作的，实际上 Flutter 底层有许多细节。可以参考这些资料</p><p>代码库：</p><ul><li><a href="https://github.com/flutter/flutter" target="_blank" rel="noopener">Flutter Framework</a></li><li><a href="https://github.com/flutter/engine" target="_blank" rel="noopener">Flutter Engine</a></li></ul><p>技术文档：</p><ul><li><a href="https://docs.google.com/presentation/d/1cw7A4HbvM_Abv320rVgPVGiUP2msVs7tfGbkgdrTy0I/edit#slide=id.p" target="_blank" rel="noopener">Flutter System Architecture Diagrams</a></li><li><a href="https://flutter.io/technical-overview/" target="_blank" rel="noopener">Technical Overview</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter 是如何工作的？&lt;br&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
      <category term="翻译" scheme="http://www.sunmoonblog.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Dart VM Service 简介</title>
    <link href="http://www.sunmoonblog.com/2020/07/07/dart-vm-service/"/>
    <id>http://www.sunmoonblog.com/2020/07/07/dart-vm-service/</id>
    <published>2020-07-07T07:28:13.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter 开发工具 DevTools 是不是有些神奇？移动端开发中用到的性能工具通常是原生应用，而 DevTools 却是基于浏览器的。为什么要基于浏览器开发，Dart VM Service Protocol 又是什么？简单了解一下。</p><a id="more"></a><p>Dart DevTools 提供 hot reload、UI 调试和内存分析等各种功能。</p><p><img src="/images/15941055868454.jpg" alt></p><h1 id="Dart-VM-Service-Protocol"><a href="#Dart-VM-Service-Protocol" class="headerlink" title="Dart VM Service Protocol"></a>Dart VM Service Protocol</h1><p>先来看看 Dart VM Service Protocol 是什么。</p><p><a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#rpcs-requests-and-responses" target="_blank" rel="noopener">Dart VM Service Protocol 3.36</a> 介绍如下：</p><blockquote><p>Service Protocol 协议用于跟运行中的 Dart VM 通信</p><p>使用 <code>--observe</code> 启动 Dart VM 后就能使用 Service Protocol。VM 会启动一个 webserver 并通过 WebSocket 为 protocol request 提供服务。也可发送 HTTP (非WebSocket)请求，但这种情况下无法访问 VM <em>event</em></p><p>Service Protocol 使用 <a href="http://www.jsonrpc.org/specification" target="_blank" rel="noopener">JSON-RPC 2.0</a> 来通信</p></blockquote><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>通过 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#getversion" target="_blank" rel="noopener">getVersion</a> 这个例子来看看 RPC 请求和响应。</p><p>RPC request 是一个发送到 server 的 JSON 对象。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>, <span class="comment">// jsonprc 属性可选</span></span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"getVersion"</span>, <span class="comment">//</span></span><br><span class="line">  <span class="attr">"params"</span>: &#123;&#125;, <span class="comment">// params 属性在 Dart 代码中以 named parameters 形式提供</span></span><br><span class="line">  <span class="attr">"id"</span>: <span class="string">"1"</span> <span class="comment">// id 属性可以是 string, number, null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RPC response 也是一个 JSON 对象。</p><p>这是一个成功的 RPC response：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"result"</span>: &#123; <span class="comment">// 请求成功时返回 result 属性</span></span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"Version"</span>, <span class="comment">// type 参数可用于判断准确的返回类型，它是 Response 类的子类</span></span><br><span class="line">    <span class="attr">"major"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"minor"</span>: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">"id"</span>: <span class="string">"1"</span> <span class="comment">// id 属性跟对应请求中的 id 匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个失败的 RPC response：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"error"</span>: &#123; <span class="comment">// 请求失败时返回 error 属性，它包括 code, message 和 data</span></span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">103</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"Stream already subscribed"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">      <span class="attr">"details"</span>: <span class="string">"The stream 'GC' is already subscribed"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">"id"</span>: <span class="string">"2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="error codes">JSON-RPC 规范</a>的基础上，Service Protocol 定义了一些额外的错误码。具体错误见 Service Protocol 文档，这里不展开。</p><h2 id="Event-和-Binary-Event"><a href="#Event-和-Binary-Event" class="headerlink" title="Event 和 Binary Event"></a>Event 和 Binary Event</h2><ul><li>通过使用 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#streamlisten" target="_blank" rel="noopener">streamListen</a> 和 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#streamcancel" target="_blank" rel="noopener">streamCancel</a> RPC，客户端可以收到 VM 中特定 stream 上的事件通通知</li><li>每个 stream 跟一个 <em>stream id</em> 关联</li><li>每个 stream 跟某种类型的事件关联。比如 <em>Isolate</em> stream 提供 isolate 相关的创建和销毁等事件</li><li>客户端通过 WebSocket 异步接收 stream event</li><li>某些事件跟二进制数据关联，通过 WebSocket binary frame 而不是 text frame 发送这些事件</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"json-rpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"streamNotify"</span>,</span><br><span class="line">  <span class="attr">"params"</span>: &#123; <span class="comment">// 参数中包括 streamId 和 event 属性</span></span><br><span class="line">    <span class="attr">"streamId"</span>: <span class="string">"Isolate"</span>,</span><br><span class="line">    <span class="attr">"event"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Event"</span>,</span><br><span class="line">      <span class="attr">"kind"</span>: <span class="string">"IsolateExit"</span>,</span><br><span class="line">      <span class="attr">"isolate"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"@Isolate"</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"isolates/33"</span>,</span><br><span class="line">        <span class="attr">"number"</span>: <span class="string">"51048743613"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"worker-isolate"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>Service Protocol 中的每个响应或事件均有 <code>type</code> 属性，它是 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#response" target="_blank" rel="noopener">Response</a> 子类。客户端可以通过 <code>type</code> 属性判断每种响应或事件的准确类型。</p><ul><li>以 <code>@</code> 开头的 type 表示当前响应是一个 <code>reference</code></li><li>不以 <code>@</code> 开头的 type 表示当前响应是一个 <code>object</code></li></ul><p><code>reference</code> 可提供的信息是 <code>object</code> 的子集</p><h1 id="Dart-VM-Service-Protocol-Extension"><a href="#Dart-VM-Service-Protocol-Extension" class="headerlink" title="Dart VM Service Protocol Extension"></a>Dart VM Service Protocol Extension</h1><p><a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service_extension.md" target="_blank" rel="noopener">Dart VM Service Protocol Extension</a> 与 VM 通信的方式跟 Service Protocol 类似跟类似，但它们并不是核心 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md" target="_blank" rel="noopener">Dart VM Service Protocol</a> 的一部分，仅允许通过某些核心库访问。</p><p>通过添加前缀名来调用对应的 RPC 接口，类似 “ext.dart.libraryName”。比如，调用 <code>ext.dart.io.getSocketProfile</code> 来执行 dart:io 暴露的 <code>getSocketProfile</code> RPC 接口。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单了解 Dart VM Service Protocol 和 Dart VM Service Protocol Extension 后，我们有以下认识：</p><ul><li>Service Protocol 和 Service Protocol Extension 是一套 RPC-JSON 协议</li><li>Service Protocol 兼容性好，可以很容易地集成到现有 IDE</li><li>VM 会启动一个 webserver 并通过 WebSocket 为客户端提供服务</li></ul><p>为什么要基于浏览器来开发 DevTools？有以下几个原因</p><ul><li>浏览器天生支持 WebSocket，所以基于浏览器开发 DevTools 是水到渠成</li><li>基于浏览器开发 DevTools，可兼容多平台</li><li>当前的 DevTools 是使用 Flutter 框架开发的 (没错，Flutter。以前是纯 Dart 开发)，部署成 Web 应用很方便</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#rpcs-requests-and-responses" target="_blank" rel="noopener">sdk/service.md at master · dart-lang/sdk</a></li><li><a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service_extension.md" target="_blank" rel="noopener">sdk/service_extension.md at master · dart-lang/sdk</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652058622&amp;idx=1&amp;sn=3551e237325a72a99ac71ec8c8747a43&amp;chksm=808c93bbb7fb1aad62acae899e59e36596d719c1194a912b26cccf565641c5a2683e675b691e&amp;mpshare=1&amp;scene=1&amp;srcid=0707V7mgrCqByikjM5WbdfpD&amp;sharer_sharetime=1594105478505&amp;sharer_shareid=b5535657e3516bd6d7252ce5f5ed09f4#rd" target="_blank" rel="noopener">​我们用 Flutter 写了一套全新的 Flutter 开发者工具</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter 开发工具 DevTools 是不是有些神奇？移动端开发中用到的性能工具通常是原生应用，而 DevTools 却是基于浏览器的。为什么要基于浏览器开发，Dart VM Service Protocol 又是什么？简单了解一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
      <category term="Dart" scheme="http://www.sunmoonblog.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 引擎崩溃分析方法简介</title>
    <link href="http://www.sunmoonblog.com/2020/07/04/flutter-engine-crash-track/"/>
    <id>http://www.sunmoonblog.com/2020/07/04/flutter-engine-crash-track/</id>
    <published>2020-07-04T02:48:41.000Z</published>
    <updated>2020-11-13T02:18:59.049Z</updated>
    
    <content type="html"><![CDATA[<p>Android 项目信息 Flutter 后上线，偶尔会遇到一些 Flutter 引擎的崩溃。简单记录下如何还原引擎崩溃日志，方便在源码中定位问题。</p><a id="more"></a><h1 id="Flutter-Engine-Crash-堆栈还原"><a href="#Flutter-Engine-Crash-堆栈还原" class="headerlink" title="Flutter Engine Crash 堆栈还原"></a>Flutter Engine Crash 堆栈还原</h1><p>首先，在 <code>bin/internal/engine.version</code> 找到 flutter engine revision</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b851c718295a896918dc93cb1ff14f2f895a1b90</span><br></pre></td></tr></table></figure><p>第二步，下载带符号表的 <code>libflutter.so</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://console.cloud.google.com/storage/browser/flutter_infra/flutter/b851c718295a896918dc93cb1ff14f2f895a1b90</span><br></pre></td></tr></table></figure><p>第三步，利用 <code>ndk-stack</code> 还原堆栈信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/path/to/android-ndk-r16b/ndk-stack -sym /path/to/symbols/armeabi-v7a -dump /path/to/stacktrace.txt</span><br></pre></td></tr></table></figure><p>如果是将 crash 上报到 bugly 平台，则不必使用 <code>ndk-stack</code>，直接在 bugly 上配置符号表即可。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/04/15938295883428.jpg" alt></p><p>配置成功后就能在 bugly 平台上看到 native crash 堆栈信息。</p><p>原始堆栈信息<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/04/15938297243231.jpg" alt></p><p>还原后的堆栈信息<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/04/15938297398367.jpg" alt></p><p>拿到还原后的堆栈信息，就可以对着源码分析问题了。</p><h1 id="一个疑问"><a href="#一个疑问" class="headerlink" title="一个疑问"></a>一个疑问</h1><p>官方提到每个 <code>libflutter.so</code> 文件中有一个 build id，native crash 堆栈中见到的 <code>BuildId</code> 要跟 <code>libflutter.so</code> 的匹配，否则没法还原 native crash 堆栈信息。原文如下：</p><blockquote><p>The build system sets a build id for each libflutter.so file. In the tombstones, you would see the ID like so:</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; #00 pc 000000000062d6e0  /data/app/com.app-tARy3eLH2Y-QN8J0d0WFog==/lib/arm64/libflutter.so!libflutter.so (offset 0x270000) (BuildId: 34ad5bdf0830d77a)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>This equals to a build id of 34ad5bdf0830d77a. The libflutter.so debug files downloaded as shown above could be verified using the file command:</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; % file ~/Downloads/libflutter.so</span><br><span class="line">&gt; /Users/user/Downloads/libflutter.so: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, BuildID[xxHash]=34ad5bdf0830d77a, with debug_info, not stripped</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Ensure the build IDs match, else you will not be able to symbolicate.</p></blockquote><p>不过我往 bugly 上传了一个非严格匹配的符号表(上报 crash 的 app 使用的是自己编译的 <code>libflutter.so</code>，符号表是官方提供的 <code>libflutter.so</code>)，也能还原出来。让人很是疑惑。</p><p>观察了下，bugly 上看到的 native crash 日志中并没有找到类似 <code>(BuildId: 34ad5bdf0830d77a)</code> 这样的信息。<em>推测</em>由此导致匹配变得不严格，所以也能还原出来。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>某个 native crash 还原后得到如下堆栈信息。</p><p><img src="/images/15938315565456.jpg" alt></p><p>首先看到的是 <code>message_loop_impl.cc</code> 中的 <code>MessageLoopImpl::RunExpiredTasksNow</code>。这个方法会立即执行任务队列中的已过期任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageLoopImpl::FlushTasks</span><span class="params">(FlushType type)</span> </span>&#123;</span><br><span class="line">  TRACE_EVENT0(<span class="string">"fml"</span>, <span class="string">"MessageLoop::FlushTasks"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;fml::closure&gt; invocations;</span><br><span class="line"></span><br><span class="line">  task_queue_-&gt;GetTasksToRunNow(queue_id_, type, invocations);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; invocation : invocations) &#123;</span><br><span class="line">    invocation();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;fml::closure&gt; observers =</span><br><span class="line">        task_queue_-&gt;GetObserversToNotify(queue_id_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; observer : observers) &#123;</span><br><span class="line">      observer();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageLoopImpl::RunExpiredTasksNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FlushTasks(FlushType::kAll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看到的是 <code>platform_view_android_jni.cc</code> 中的 <code>FlutterViewUpdateSemantics</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FlutterViewUpdateSemantics</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">                                jobject buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                jobjectArray strings)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用 g_update_semantics_method (Java 层方法)</span></span><br><span class="line">  env-&gt;CallVoidMethod(obj, g_update_semantics_method, buffer, strings);</span><br><span class="line">  <span class="comment">// 检查 Java 代码是否发生异常，有异常则写入 fml 日志中</span></span><br><span class="line">  FML_CHECK(CheckException(env));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RegisterApi</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// g_update_semantics_method 对应的是 </span></span><br><span class="line">  <span class="comment">// Java 层中的 FlutterJNI.updateSemantics() 方法</span></span><br><span class="line">  g_update_semantics_method =</span><br><span class="line">      env-&gt;GetMethodID(g_flutter_jni_class-&gt;obj(), <span class="string">"updateSemantics"</span>,</span><br><span class="line">                       <span class="string">"(Ljava/nio/ByteBuffer;[Ljava/lang/String;)V"</span>);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 Java 代码是否发生异常</span></span><br><span class="line"><span class="comment">// 发生异常时返回 false，否则返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckException</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (env-&gt;ExceptionCheck() == JNI_FALSE)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  jthrowable exception = env-&gt;ExceptionOccurred();</span><br><span class="line">  env-&gt;ExceptionClear();</span><br><span class="line">  FML_LOG(ERROR) &lt;&lt; fml::jni::GetJavaExceptionInfo(env, exception);</span><br><span class="line">  env-&gt;DeleteLocalRef(exception);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后看到的是 <code>logging.cc</code> 第92行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">LogMessage::~LogMessage() &#123;</span><br><span class="line">  stream_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_ANDROID)</span></span><br><span class="line">  android_LogPriority priority =</span><br><span class="line">      (severity_ &lt; <span class="number">0</span>) ? ANDROID_LOG_VERBOSE : ANDROID_LOG_UNKNOWN;</span><br><span class="line">  <span class="keyword">switch</span> (severity_) &#123;</span><br><span class="line">    <span class="keyword">case</span> LOG_INFO:</span><br><span class="line">      priority = ANDROID_LOG_INFO;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LOG_WARNING:</span><br><span class="line">      priority = ANDROID_LOG_WARN;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LOG_ERROR:</span><br><span class="line">      priority = ANDROID_LOG_ERROR;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LOG_FATAL:</span><br><span class="line">      priority = ANDROID_LOG_FATAL;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  __android_log_write(priority, <span class="string">"flutter"</span>, stream_.str().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(OS_IOS)</span></span><br><span class="line">  syslog(LOG_ALERT, <span class="string">"%s"</span>, stream_.str().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; stream_.str();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span>.flush();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (severity_ &gt;= LOG_FATAL) &#123;</span><br><span class="line">    <span class="comment">// 最终的 crash 由这里产生</span></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初看起来可能会有点不明白 crash 如何产生，梳理一下就渐渐明了：</p><ul><li>调用 <code>RunExpiredTasksNow</code> 立即执行队伍中的过期任务</li><li>过期任务中的某一个任务调用了 <code>FlutterViewUpdateSemantics()</code> (C++层)</li><li><code>FlutterViewUpdateSemantics()</code> 调用 <code>FlutterJNI.updateSemantics()</code> (Java层)</li><li><code>FlutterViewUpdateSemantics()</code> 调用 <code>CheckException()</code> 检查 Java 代码执行后是否产生异常</li><li><code>FlutterViewUpdateSemantics()</code> 调用 <code>FML_CHECK()</code> 记录错误日志 (如有 Java 异常)</li></ul><p>所以我们可以把怀疑目标锁定到 <code>FlutterJNI.updateSemantics()</code> 方法。剩下的工作就是进入 Java 层分析该方法的出错原因了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Keep</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterJNI</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Invoked by native to send semantics tree updates from Flutter to Android.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The &#123;<span class="doctag">@code</span> buffer&#125; and &#123;<span class="doctag">@code</span> strings&#125; form a communication protocol that is implemented here:</span></span><br><span class="line"><span class="comment">   * https://github.com/flutter/engine/blob/master/shell/platform/android/platform_view_android.cc#L207</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateSemantics</span><span class="params">(@NonNull ByteBuffer buffer, @NonNull String[] strings)</span> </span>&#123;</span><br><span class="line">    ensureRunningOnMainThread();</span><br><span class="line">    <span class="keyword">if</span> (accessibilityDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">      accessibilityDelegate.updateSemantics(buffer, strings);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO(mattcarroll): log dropped messages when in debug mode (https://github.com/flutter/flutter/issues/25391)</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://fucknmb.com/2019/10/20/%E8%8E%B7%E5%8F%96%E5%B9%B6%E8%BF%98%E5%8E%9FFlutter-Engine-Crash%E5%A0%86%E6%A0%88/" target="_blank" rel="noopener">获取并还原 Flutter Engine Crash 堆栈 | 区长</a></li><li><a href="https://github.com/flutter/flutter/wiki/Crashes" target="_blank" rel="noopener">Crashes · flutter/flutter Wiki</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 项目信息 Flutter 后上线，偶尔会遇到一些 Flutter 引擎的崩溃。简单记录下如何还原引擎崩溃日志，方便在源码中定位问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>mockjs 入门</title>
    <link href="http://www.sunmoonblog.com/2020/07/02/mockjs-basic/"/>
    <id>http://www.sunmoonblog.com/2020/07/02/mockjs-basic/</id>
    <published>2020-07-02T08:17:46.000Z</published>
    <updated>2020-11-13T02:18:59.049Z</updated>
    
    <content type="html"><![CDATA[<p>感觉 mockjs 真是个好东西。简单了解下用法。<br><a id="more"></a></p><h1 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h1><p>先直接上文档 <a href="http://mockjs.com/examples.html#Image" target="_blank" rel="noopener">Mock.js</a>。文档中列出了 mockjs 可以模拟的数据类型，包括：</p><ul><li>string</li><li>number</li><li>bool</li><li>array</li><li>object</li><li>guid</li><li>id</li><li>title</li><li>paragraph</li><li>image</li><li>address</li><li>date</li><li>time</li><li>url</li><li>email</li><li>ip</li><li>regexp</li></ul><p>不要小看这个文档，<strong>你可以打开控制台，随意地试验这些方法。</strong></p><p><img src="/images/15936783153589.jpg" alt="-w795"></p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>这里列举几个我用到的模拟数据。</p><p>模拟 title：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Mock.mock(&#123;<span class="string">'title'</span>: <span class="string">'@title(1)'</span>&#125;)</span><br><span class="line"><span class="comment">// &#123;title: "Qoqhdl"&#125;</span></span><br><span class="line">&gt; Mock.mock(&#123;<span class="string">'title'</span>: <span class="string">'@csentence(6)'</span>&#125;)</span><br><span class="line"><span class="comment">// &#123;title: "容约声量局有。"&#125;</span></span><br></pre></td></tr></table></figure><p>模拟图片：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Mock.mock(&#123;<span class="string">'head'</span>: <span class="string">'@image()'</span>&#125;)</span><br><span class="line"><span class="comment">// &#123;head: "http://dummyimage.com/234x60"&#125;</span></span><br></pre></td></tr></table></figure><p>模拟图片打开之后的效果如下：</p><p><img src="/images/15936788801014.jpg" alt="-w938"></p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>mockjs 的语法还是比较简单易懂的，感觉不必花时间专门研究。不过不妨找一批较全的示例，实在不记得怎么写时可以照着示例来写。这里直接贴上一个示例，它来自<a href="https://github.com/ToNiQian/mockjs" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Mock</span></span><br><span class="line"><span class="keyword">let</span> Mock = <span class="built_in">require</span>(<span class="string">'mockjs'</span>);</span><br><span class="line">Mock.mock(<span class="string">'http://1.json'</span>,<span class="string">'get'</span>,&#123;</span><br><span class="line">    <span class="comment">// 属性 list 的值是一个数组，其中含有 1 到 3 个元素</span></span><br><span class="line">    <span class="string">'list|1-3'</span>: [&#123;</span><br><span class="line">        <span class="comment">// 属性 sid 是一个自增数，起始值为 1，每次增 1</span></span><br><span class="line">        <span class="string">'sid|+1'</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="comment">// 属性 userId 是一个5位的随机码</span></span><br><span class="line">        <span class="string">'userId|5'</span>: <span class="string">''</span>,</span><br><span class="line">        <span class="comment">// 属性 sex 是一个bool值</span></span><br><span class="line">        <span class="string">"sex|1-2"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 属性 city对象 是对象值中2-4个的值</span></span><br><span class="line">        <span class="string">"city|2-4"</span>: &#123;</span><br><span class="line">            <span class="string">"110000"</span>: <span class="string">"北京市"</span>,</span><br><span class="line">            <span class="string">"120000"</span>: <span class="string">"天津市"</span>,</span><br><span class="line">            <span class="string">"130000"</span>: <span class="string">"河北省"</span>,</span><br><span class="line">            <span class="string">"140000"</span>: <span class="string">"山西省"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//属性 grade 是数组当中的一个值</span></span><br><span class="line">        <span class="string">"grade|1"</span>: [</span><br><span class="line">            <span class="string">"1年级"</span>,</span><br><span class="line">            <span class="string">"2年级"</span>,</span><br><span class="line">            <span class="string">"3年级"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">//属性 guid 是唯一机器码</span></span><br><span class="line">        <span class="string">'guid'</span>: <span class="string">'@guid'</span>,</span><br><span class="line">        <span class="comment">//属性 id 是随机id</span></span><br><span class="line">        <span class="string">'id'</span>: <span class="string">'@id'</span>,</span><br><span class="line">        <span class="comment">//属性 title 是一个随机长度的标题</span></span><br><span class="line">        <span class="string">'title'</span>: <span class="string">'@title()'</span>,</span><br><span class="line">        <span class="comment">//属性 paragraph 是一个随机长度的段落</span></span><br><span class="line">        <span class="string">'paragraph'</span>: <span class="string">'@cparagraph'</span>,</span><br><span class="line">        <span class="comment">//属性 image 是一个随机图片 参数分别为size, background, text</span></span><br><span class="line">        <span class="string">'image'</span>: <span class="string">"@image('200x100', '#4A7BF7', 'Hello')"</span>,</span><br><span class="line">        <span class="comment">//属性 address 是一个随机地址</span></span><br><span class="line">        <span class="string">'address'</span>: <span class="string">'@county(true)'</span>,</span><br><span class="line">        <span class="comment">//属性 date 是一个yyyy-MM-dd 的随机日期</span></span><br><span class="line">        <span class="string">'date'</span>: <span class="string">'@date("yyyy-MM-dd")'</span>,</span><br><span class="line">        <span class="comment">//属性 time 是一个 size, background, text 的随机时间</span></span><br><span class="line">        <span class="string">'time'</span>: <span class="string">'@time("HH:mm:ss")'</span>,</span><br><span class="line">        <span class="comment">//属性 url 是一个随机的url</span></span><br><span class="line">        <span class="string">'url'</span>: <span class="string">'@url'</span>,</span><br><span class="line">        <span class="comment">//属性 email 是一个随机email</span></span><br><span class="line">        <span class="string">'email'</span>: <span class="string">'@email'</span>,</span><br><span class="line">        <span class="comment">//属性 ip 是一个随机ip</span></span><br><span class="line">        <span class="string">'ip'</span>: <span class="string">'@ip'</span>,</span><br><span class="line">        <span class="comment">//属性 regexp 是一个正则表达式匹配到的值 如aA1</span></span><br><span class="line">        <span class="string">'regexp'</span>: <span class="regexp">/[a-z][A-Z][0-9]/</span>,</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="其他模拟方式"><a href="#其他模拟方式" class="headerlink" title="其他模拟方式"></a>其他模拟方式</h1><p>以下是另外两个 mock 库，看起来更为强大。</p><ul><li><a href="https://github.com/APIJSON/APIJSON" target="_blank" rel="noopener">APIJSON/APIJSON: 🏆码云最有价值开源项目 🚀后端接口和文档自动化，前端(客户端) 定制返回 JSON 的数据和结构！🏆Gitee Most Valuable Project 🚀A JSON Transmission Protocol and an ORM Library for automatically providing APIs and Docs.</a></li><li><a href="https://github.com/chinesedfan/parrot-mocker-web/blob/master/README-zh.md" target="_blank" rel="noopener">parrot-mocker-web/README-zh.md at master · chinesedfan/parrot-mocker-web</a></li></ul><p><a href="https://segmentfault.com/a/1190000011230904" target="_blank" rel="noopener">AntDesign结合mockjs随机生成图片</a> 提供了另外一种思路：上传一批图片到云端(保证名字有规律)，再使用 mockjs 来拿到图片地址，从而实现在模拟自定义图片。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>mockjs 本身并不是特别有用，不过它结合 vue-admin-template 中的 mock-server，可以直接模拟线上接口，方便在后台尚未提供接口的情况下开始前端页面开发。这一点在某些情况下特别有用，如果事先后台能提供接口协议，保证模拟接口跟实际接口基本一致，生产力应该能大大提高。</p><p>vue-admin-template 中 mock-server 的用法见<a href="https://www.sunmoonblog.com/2020/07/01/vue-mockserver-watch-not-working/">前一篇</a>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">nuysoft/Mock: A simulation data generator</a></li><li><a href="http://mockjs.com/examples.html#Image" target="_blank" rel="noopener">Mock.js</a></li><li><a href="https://github.com/ToNiQian/mockjs" target="_blank" rel="noopener">ToNiQian/mockjs: 一个webpack 搭建的 mock 案例演示</a></li><li><a href="https://juejin.im/post/599c1bfaf265da248d0cc6b6" target="_blank" rel="noopener">Mockjs,再也不用追着后端小伙伴要接口了 - 掘金</a></li><li><a href="https://juejin.im/post/5ce2a960e51d455a2f2201c3" target="_blank" rel="noopener">vue-vue项目中mock.js的使用 - 掘金</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉 mockjs 真是个好东西。简单了解下用法。&lt;br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://www.sunmoonblog.com/tags/javascript/"/>
    
      <category term="Vue" scheme="http://www.sunmoonblog.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-admin-template 中 mock-server 的用法</title>
    <link href="http://www.sunmoonblog.com/2020/07/01/vue-mockserver-watch-not-working/"/>
    <id>http://www.sunmoonblog.com/2020/07/01/vue-mockserver-watch-not-working/</id>
    <published>2020-07-01T12:03:07.000Z</published>
    <updated>2020-11-13T02:18:59.049Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一下 vue-admin-template 中 mock-server 的用法。<br><a id="more"></a></p><p>最近刚接触一个 vue 项目。发现该项目是基于 vue-admin-template 的，但并没有很好地利用 vue-admin-template 的 <a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/mock-api.html" target="_blank" rel="noopener">Mock Data</a> 功能。这个功能正好能解决我目前的痛点：后台接口预计很久之后才能给到，而缺少接口的情况下前端页面中很多边边角角的工作并不好处理。</p><p>所以我了解了下如何使用在 vue-admin-template 中模拟数据。</p><p>vue-admin-template 提供两种模拟方式：</p><ul><li>本地模拟 - 这是使用 <a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">mockjs</a> 进行纯前端模拟。其原理是拦截了所有的请求并代理到本地，然后进行数据模拟。大部分情况下够用，但有几个问题：一是调试工具中看不到网络数据；二是s可能影响依赖 <code>XMLHttpRequest</code> 的库</li><li>线上模拟 - 本地启动一个 mock-server 来模拟数据，其模拟数据仍然来自 <a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">mockjs</a></li></ul><p>我们重点看线上模拟这种方式。</p><h1 id="配置和用法"><a href="#配置和用法" class="headerlink" title="配置和用法"></a>配置和用法</h1><p>先安装 <code>mockjs</code> 和 <code>chokidar</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install mockjs</span><br><span class="line">npm install chokidar</span><br></pre></td></tr></table></figure><p><a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/mock-api.html#%E7%A7%BB%E9%99%A4" target="_blank" rel="noopener">官方 Wiki</a> 提到的配置方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">  // change xxx-api/login =&gt; mock/login</span><br><span class="line">  // detail: https://cli.vuejs.org/config/#devserver-proxy</span><br><span class="line">  [process.env.VUE_APP_BASE_API]: &#123;</span><br><span class="line">    target: `http://localhost:$&#123;port&#125;/mock`,</span><br><span class="line">    changeOrigin: true,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      [&apos;^&apos; + process.env.VUE_APP_BASE_API]: &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">after: require(&apos;./mock/mock-server.js&apos;)</span><br></pre></td></tr></table></figure><p>但这个文档较旧，跟当前<a href="https://github.com/PanJiaChen/vue-admin-template/blob/permission-control/vue.config.js" target="_blank" rel="noopener">最新源码</a> 中的配置有较大差异。源码的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  port: port,</span><br><span class="line">  open: true,</span><br><span class="line">  overlay: &#123;</span><br><span class="line">    warnings: false,</span><br><span class="line">    errors: true</span><br><span class="line">  &#125;,</span><br><span class="line">  before: require(&apos;./mock/mock-server.js&apos;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>注意<strong>之前的 <code>after</code> 变成了 <code>before</code>，并且不再需要为 devServer 配置 proxy 了</strong>。 </p><p><img src="/images/15936059512268.jpg" alt></p><p>之后就可以在 <code>mock</code> 目录下写模拟数据了。 </p><p><img src="/images/15936061733008.jpg" alt></p><p><code>mock</code> 目录下各个文件的作用如下：</p><ul><li><code>mock-server.js</code> - mock-server 的源码</li><li><code>index.js</code> - 引入用到的模拟数据文件</li><li>其他 js 文件 - 模拟数据文件</li></ul><p><code>mock</code> 目录下各个文件的依赖关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mock-server.js</span><br><span class="line"> -&gt; index.js</span><br><span class="line">  -&gt; 其他 js 文件</span><br></pre></td></tr></table></figure><p>来看一个实例。</p><p>第一步，在 <code>register.js</code> 文件中定义一条模拟数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  &#123;</span><br><span class="line">    url: <span class="string">'/cm/reg/sendcode'</span>,</span><br><span class="line">    type: <span class="string">'post'</span>,</span><br><span class="line">    response: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> items = data.items</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        r: <span class="number">0</span>,</span><br><span class="line">        msg: <span class="string">'hello22'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>第二步，在 <code>index.js</code> 文件引入 <code>register.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> register <span class="keyword">from</span> <span class="string">'./register'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mocks = [</span><br><span class="line">  ...user,</span><br><span class="line">  ...table,</span><br><span class="line">  ...register</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>第三步，在 vue 文件中请求上面定义的模拟数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">post(&#123;</span><br><span class="line">  url: &apos;/cm/reg/sendcode&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意这里的 <code>post()</code> 方法用到一个 <code>axios</code> 实例，该 <code>axios</code> 实例的 baseUrl 为 <code>https://localhost/dev-api</code>。所以模拟请求的目标地址为 <code>https://localhost/dev-api/cm/reg/sendcode</code>。如下图，</p><p><img src="/images/15936068577258.jpg" alt="-w434"></p><p><img src="/images/15936068933224.jpg" alt="-w428"></p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>mock-server 有一个很赞的功能，每次修改 <code>mock</code> 目录下文件后，mock-server 会执行 hot reload，重新加载最新的数据。如下图，注意可以看到 “Mock Server hot reload success!”</p><p><img src="/images/15936071064085.jpg" alt></p><p>但我遇到一个小坑，无论如何修改 <code>mock</code> 目录下的文件都不会出现 hot reload。</p><p>反复检查后发现，我目前开发的这个 vue 项目虽然是基于 vue-admin-template 的，但是将原始工程中的部分源文件路径调整了。其中一个调整是将 <code>mock</code> 调整成 <code>src/mock</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockDir = path.join(process.cwd(), <span class="string">'mock'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// watch files, hot reload mock server</span></span><br><span class="line">  chokidar.watch(mockDir, &#123;</span><br><span class="line">    ignored: <span class="regexp">/mock-server/</span>,</span><br><span class="line">    ignoreInitial: <span class="literal">true</span></span><br><span class="line">  &#125;).on(<span class="string">'all'</span>, (event, path) =&gt; &#123; ... &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但 mock-server 监听的是 cwd 中的 <code>mock</code> 目录，所以修改 <code>mock</code> 目录中的模拟数据文件后，无法 hot reload。解决办法很简单，调整一下路径，改成监听 cwd 中的 <code>src/mock</code> 目录即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockDir = path.join(process.cwd(), <span class="string">'src/mock'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// watch files, hot reload mock server</span></span><br><span class="line">  chokidar.watch(mockDir, &#123;</span><br><span class="line">    ignored: <span class="regexp">/mock-server/</span>,</span><br><span class="line">    ignoreInitial: <span class="literal">true</span></span><br><span class="line">  &#125;).on(<span class="string">'all'</span>, (event, path) =&gt; &#123; ... &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他可能遇到的问题见 <a href="https://github.com/PanJiaChen/vue-element-admin/issues?page=2&amp;q=mock+server" target="_blank" rel="noopener">issues</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/mock-api.html" target="_blank" rel="noopener">Mock Data</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单记录一下 vue-admin-template 中 mock-server 的用法。&lt;br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://www.sunmoonblog.com/tags/javascript/"/>
    
      <category term="Vue" scheme="http://www.sunmoonblog.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vant Toast 无法显示的问题</title>
    <link href="http://www.sunmoonblog.com/2020/07/01/vue-toast-not-show/"/>
    <id>http://www.sunmoonblog.com/2020/07/01/vue-toast-not-show/</id>
    <published>2020-07-01T02:17:34.000Z</published>
    <updated>2020-11-13T02:18:59.049Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Vant Toast 时发现有些场景下无法显示。简单记录一下问题原因和解决方法。</p><a id="more"></a><h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>问题是这样的：界面上有一个注册对话框，当检查到用户输入有误使用 Vant Toast 弹出错误提示信息。比如，当用户没有输入手机号时，提示手机号为不能为空。</p><p><img src="/images/15935700432089.jpg" alt="-w371"></p><p>弹出错误提示 Toast 的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toast.fail(<span class="string">'手机号不能为空'</span>)</span><br></pre></td></tr></table></figure><p>但发现 Toast 始终无法显示。</p><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>检查样式后发现对话框的 <code>z-index</code> 过大。这里看到的是 9999</p><p><img src="/images/15935702844010.jpg" alt="-w1049"></p><p>Toast 实际已经弹出，但是它的 <code>z-index</code> 小于对话框的 <code>z-index</code>，导致 Toast 被对话框挡住，所以无法显示。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>解决办法很简单。</p><p>首先，在 vue 文件里写一个简单的 <code>toast</code> 样式，指定其 <code>z-index</code> 为 10000 (确保比对话框的大就行)。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- app.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.toast &#123;</span><br><span class="line">z-index: 10000 !important;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，弹出 Toast 时指定相应的样式即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toast.fail(&#123;<span class="attr">message</span>: <span class="string">'手机号不能为空'</span>, <span class="attr">className</span>: <span class="string">'toast'</span>&#125;)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.w3schools.com/cssref/pr_pos_z-index.asp" target="_blank" rel="noopener">CSS z-index property</a></li><li><a href="https://github.com/youzan/vant/issues/3145" target="_blank" rel="noopener">如果Toast先弹出过，因为z-indx计算，会被后使用的popup组件遮住，如果在popup里面需要使用Toast的话，就会被遮住了，这该如何解决？ · Issue #3145 · youzan/vant</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Vant Toast 时发现有些场景下无法显示。简单记录一下问题原因和解决方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://www.sunmoonblog.com/tags/javascript/"/>
    
      <category term="Vue" scheme="http://www.sunmoonblog.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Dart VM</title>
    <link href="http://www.sunmoonblog.com/2020/06/30/dartvm/"/>
    <id>http://www.sunmoonblog.com/2020/06/30/dartvm/</id>
    <published>2020-06-30T01:20:30.000Z</published>
    <updated>2020-11-13T02:18:59.049Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自 <a href="https://mrale.ph/dartvm/" target="_blank" rel="noopener">Dart VM</a>，非常详细地介绍了 Dart 代码运行机制。<br><a id="more"></a><br>Dart VM 是一个用于原生地执行 Dart 代码的组件集合。它主要包含如下部分：</p><ul><li>运行时系统<ul><li>对象模型</li><li>GC</li><li>Snapshot</li></ul></li><li>核心库</li><li>通过 <em>service protocol</em> 访问的 Development Experience 组件<ul><li>调试</li><li>分析</li><li>热加载</li></ul></li><li>Just-in-Time (JIT) 和 Ahead-of-Time (AOT) 编译流水线</li><li>解释器</li><li>ARM 模拟器</li></ul><p>Dart VM 这个名字是历史遗留的。在某种意义上 Dart VM 能为上层编程语言提供执行环境，但这个名字并不意味着 Dart VM 中 Dart 代码总是解释执行或 JTI 编译的。比如，可以使用 Dart VM AOT 流水线将 Dart 代码编译成机器码，然后在精简版本的 Dart VM 中执行，称之为 <em>precompiled runtime</em>，它既不包含任何编译器组件，也不能动态加载 Dart 源码。</p><h1 id="Dart-VM-是如何运行代码的？"><a href="#Dart-VM-是如何运行代码的？" class="headerlink" title="Dart VM 是如何运行代码的？"></a>Dart VM 是如何运行代码的？</h1><p>Dart VM 有多种方式执行代码，比如：</p><ul><li>使用 JIT 从源码或 Kernel binary</li><li>从 snapshot<ul><li>AOT snapshot</li><li>AppJIT snapshot</li></ul></li></ul><p>这些方式之间的主要不同在于 VM 将 Dart 源码转换成可执行代码的时机和方式。执行代码的运行时环境是相同的。</p><p>VM 中的 Dart 代码运行在 <em>isolate</em>，对 isolate 的最好描述是这样的：一个隔离的 Dart 世界，有其自己的内存(<em>heap</em>)，通常有自己的线程(<em>mutator thread</em>)。可以有多个 isolate 并发执行 Dart 代码，但 isolate 不能直接共享任何状态，只能通过 <em>port</em> 发送消息来通信(不要将这里的 port 跟 network port 混淆)。</p><p><img src="https://mrale.ph/dartvm/images/isolates.png" alt></p><p>OS 线程跟 isolate 之间的关系比较模糊，具体依赖于 VM 是如何 embed 到应用中的。只能保证如下几个规则：</p><ul><li>OS 线程同一时刻只能进入一个 isolate。如果线程想进入另一个 isolate，它必须离开当前 isolate</li><li>同一时刻一个 isolate 只能有一个 <em>mutator</em> 线程。mutator 线程是指执行 Dart 代码并能访问 VM 公开 C API 的线程</li></ul><p>当然，同一个 OS 线程可以先进入一个 isolate，执行 Dart 代码，然后离开这个 isolate 并进入另一个 isolate。类似的，多个不同的线程可以进入同一个 isolate 并执行代码，只要不是同时发生。</p><p>除了单个 mutator 线程外，一个 isolate 还能跟多个辅助线程关联，比如：</p><ul><li>一个后台运行的 JIT 编译器线程</li><li>多个 GC sweeper 线程</li><li>多个并发 GC maker 线程</li></ul><p>VM 内部使用线程池(<a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/thread_pool.h#L14" target="_blank" rel="noopener">ThreadPool</a>)管理 OS 线程，代码围绕 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/thread_pool.h#L17" target="_blank" rel="noopener">ThreadPool::Task</a> 而非 OS 线程来组织。比如，GC VM 向全局 VM 线程池提交 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/heap/sweeper.cc#L100" target="_blank" rel="noopener">SweeperTask</a> 后并不是生成一个专门的线程来执行后台清理工作，线程池可能会选择一个空闲的线程，或者在没有线程可用时生成一个新线程。类似的，用于 isolate 消息处理的 event loop 的缺省实现也并不是真的生成专门的 event loop 线程，而是在新消息到达时向线程池提交 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/message_handler.cc#L19" target="_blank" rel="noopener">MessageHandlerTask</a>。</p><p>源码清单：</p><ul><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/isolate.h#L151" target="_blank" rel="noopener">Isolate</a> 类代表 isolate</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/heap/heap.h#L28" target="_blank" rel="noopener">Heap</a> 类代表 isolate 的 heap</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/thread.h#L204" target="_blank" rel="noopener">Thread</a> 类描述与 isolate 关联的线程的状态。注意这里的名字 Thread 容易让人混淆，因为实际上所有作为 mutator 关联到同一个 isolate 的所有的操作系统线程会重用同一个 Thread 实例。</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/dart_api_impl.cc#L1586" target="_blank" rel="noopener">Dart_RunLoop</a> 和 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/message_handler.h#L17" target="_blank" rel="noopener">MessageHandler</a> 是 isolate 消息处理的缺省实现</li></ul><h2 id="JIT-模式源码运行"><a href="#JIT-模式源码运行" class="headerlink" title="JIT 模式源码运行"></a>JIT 模式源码运行</h2><p>这一节是关于在命令行下执行 Dart 时的过程。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// hello.dart</span><br><span class="line">main() =&gt; <span class="built_in">print</span>(<span class="string">'Hello, World!'</span>);</span><br><span class="line">$ dart hello.dart</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><p>Dart 2 开始 VM 不再支持直接从原始代码执行 Dart，而是执行指定的 <em>Kernel binaries</em> (也称之为 <em>dill files</em>)，其中包含系列化后的 <a href="https://github.com/dart-lang/sdk/blob/master/pkg/kernel/README.md" target="_blank" rel="noopener">Kernel ASTs</a>。Dart 源码转换成 Kernel AST 的任务由 <a href="https://github.com/dart-lang/sdk/tree/master/pkg/front_end" target="_blank" rel="noopener">common front-end (CFE)</a> 完成，CFE 由 Dart 写成，在不同的 Dart 工具共享(比如 VM，dart2js，Dart Dev Compiler)。</p><p><img src="/images/15934867158439.jpg" alt></p><p>为了保留直接执行 Dart 代码的便捷性，标准的 <code>dart</code> 执行命令带有一个叫 <em>kernel service</em> 的 isolate，它负责将 Dart 源码编译成 Kernel binary。之后 VM 后运行生成的 Kernel binary。</p><p><img src="/images/15934867009562.jpg" alt></p><p>不过这并非 CFE 和 VM 运行 Dart 代码唯一的组合方式。比如，Flutter 完全将 <em>compilation to Kernel</em> 和      <em>execution from Kernel</em> 两个过程分离到不同的设备上：编译发生在开发机(<em>host</em>)，而执行发生在移动设备(<em>device</em>)，它接收通过 <code>flutter</code> tool 发送来的 Kernel binary。</p><p><img src="/images/15934866911219.jpg" alt><br><img src="https://mrale.ph/dartvm/images/flutter-cfe.png" alt></p><p>注意 <code>flutter</code> tool 自己并不解析 Dart，它启动另一个进程 <code>frontend_server</code>。<code>frontend_server</code> 是对 CFE 的包装，并且进行某些 Flutter 特定的 Kernel-to-Kernel 转换。<code>frontend_server</code> 将 Dart 代码转换成 Kernel binary 文件，<code>flutter</code> tool 将这些文件发送到设备。当开发者想使用 <em>hot reload</em> 特性时，就需要 <code>frontend_server</code> 是常驻进程了：<code>frontend_server</code> 可以根据前一次编译来重用 CFE 状态，只编译发生实际变动的代码。</p><p>Kernel binary 加载到 VM 后会被解析成代码不同程序实体的对象。不过解析是延迟进行的：最初只加载库和类的基本信息。每个来自 Kernel binary 的实体都有一个指向 Kernel binary 的指针，以便之后需要时能加载更多信息。</p><blockquote><p>使用 <code>Raw...</code> 前缀来指代 VM 内部分配的特定对象。这是 VM 的命名习惯：VM 内部对象布局由一个位于 <code>raw_object.h</code> 头文件中以 Raw 开头的 C++ 类来定义。比如 <code>RawClass</code> 是一个描述 Dart 类的 VM 对象，而 <code>RawField</code> 是一个描述 Dart 类中 Dart 字段的对象。在后台讨论运行时系统和对象模型那节中我们还会回到这个话题。</p></blockquote><p><img src="/images/15934878531318.jpg" alt></p><p>类的信息只在之后运行时需要时才完全反序列化(比如，查找类成员，分配对象等等)。这一阶段，类成员读取自 Kernel binary。不过，此时只有成员签名，完整的函数方法此时并没有完全反序列化。</p><p><img src="/images/15934880714981.jpg" alt></p><p>这时运行时已经从 Kernel binary 加载了足够信息，可以成功解析和调用方法。比如，它可以从一个库中解析和调用 <code>main</code> 函数。</p><p>源码清单：</p><ul><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/kernel/lib/ast.dart" target="_blank" rel="noopener">package:kernel/ast.dart</a> 定义了描述 Kernel AST 的类</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/front_end" target="_blank" rel="noopener">package:front_end</a> 用于解析 Dart 源码并从源码构建 AST</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/kernel_loader.cc#L211" target="_blank" rel="noopener">kernel::KernelLoader::LoadEntireProgram</a> 是将 Kernel AST 反序列化成对应 VM 对象的入口</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/vm/bin/kernel_service.dart" target="_blank" rel="noopener">pkg/vm/bin/kernel_service.dart</a> 实现了 Kernel Service isolate</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/kernel_isolate.cc" target="_blank" rel="noopener">runtime/vm/kernel_isolate.cc</a> 将 Dart 实现跟 VM 的其他部分粘合起来</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/vm" target="_blank" rel="noopener">package:vm</a> 包含基于 Kernel 的 VM 的大部分功能，比如不同的 Kernel-to-Kernel 转换，由于一些历史原因一些 VM 特定的转换仍然放在 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/kernel" target="_blank" rel="noopener">package:kernel</a> 中</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/kernel/lib/transformations/continuation.dart" target="_blank" rel="noopener">package:kernel/transformations/continuation.dart</a> 是一个复杂转换的好例子，它对 <code>async</code>、<code>async*</code> 以及 <code>sync*</code> 函数进行脱糖处理 </li></ul><p>动手尝试！如果你对 Kernel binary 格式以及 VM 用法感兴趣，可以使用 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/vm/bin/gen_kernel.dart" target="_blank" rel="noopener">pkg/vm/bin/gen_kernel.dart</a> 来从 Dart 源码生成一个 Kernel binary 文件。生成的 binary 文件可以使用 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/vm/bin/dump_kernel.dart" target="_blank" rel="noopener">pkg/vm/bin/dump_kernel.dart</a> 进行 dump 操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Take hello.dart and compile it to hello.dill Kernel binary using CFE.</span></span><br><span class="line">$ dart pkg/vm/bin/gen_kernel.dart                        \</span><br><span class="line">       --platform out/ReleaseX64/vm_platform_strong.dill \</span><br><span class="line">       -o hello.dill                                     \</span><br><span class="line">       hello.dart</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dump textual representation of Kernel AST.</span></span><br><span class="line">$ dart pkg/vm/bin/dump_kernel.dart hello.dill hello.kernel.txt</span><br></pre></td></tr></table></figure><p>当你尝试使用 <code>gen_kernel.dart</code> 时你你发现它需要一个名为 <em>platform</em> 的东西，这个参数用于指定一个包含所有核心库(例如 <code>dart:core</code>，<code>dart:async</code>)的 AST 的文件。如果你本地编译过 Dart SDK，可以使用 out 目录下的 platform 文件，比如 <code>out/ReleaseX64/vm_platform_strong.dill</code>。(译者注：如果你本地编译过 Flutter 引擎，也可以使用 <code>engine/src/out/host_debug_unopt/vm_platform_strong.dill</code>)。另外，你也可以使用 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/front_end/tool/_fasta/compile_platform.dart" target="_blank" rel="noopener">pkg/front_end/tool/_fasta/compile_platform.dart</a> 生成 platform。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Produce outline and platform files using the given libraries list.</span></span><br><span class="line">$ dart pkg/front_end/tool/_fasta/compile_platform.dart \</span><br><span class="line">       dart:core                                       \</span><br><span class="line">       sdk/lib/libraries.json                          \</span><br><span class="line">       vm_outline.dill vm_platform.dill vm_outline.dill</span><br></pre></td></tr></table></figure><p>译者注：我在本地操作了一把，成功！</p><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 dill</span></span><br><span class="line">$ dart /Users/cm/wd/engine/src/third_party/dart/pkg/vm/bin/gen_kernel.dart \</span><br><span class="line">--platform /Users/cm/wd/engine/src/out/host_debug_unopt/vm_platform_strong.dill \</span><br><span class="line">-o hello.dill \</span><br><span class="line">   hello.dart</span><br><span class="line"><span class="comment"># dump dill</span></span><br><span class="line">$ dart /Users/cm/wd/engine/src/third_party/dart/pkg/vm/bin/dump_kernel.dart \</span><br><span class="line">hello.dill hello.kernel.txt</span><br></pre></td></tr></table></figure><p><img src="/images/15934899027428.jpg" alt></p><p><img src="/images/15934899450735.jpg" alt></p><p>所有函数体初始时只有占位符而不是实际的可执行代码：占位符指向 <code>LazyCompileStub</code>，它只是请求运行时系统为当前函数生成可执行代码并且对新生成的代码进行尾调用(tail-calls this newly generated code)。</p><p><img src="/images/15934979827846.jpg" alt></p><p>函数第一次编译时以上过程由 <em>unoptimizing compiler</em> 完成。</p><p><img src="/images/15934980438450.jpg" alt></p><p><em>Unoptimizing compiler</em> 按以下两个步骤生成机器码：</p><ol><li>遍历函数体的序列化后的 AST，为函数体生成 <em>control flow graph</em> (CFG)。CFG 由 <em>intermediate language</em> (IL) 指令块组成。这个阶段使用的 IL 指令类似基于栈的 VM 中的指令：从栈中取出操作数，执行操作后将结果放回同一个栈 (注意：实际上并不是所有的函数都有实际的 Dart/Kernel AST 函数体，比如 C++ 中定义的 native 方法或 artificial tear-off functions generated by Dart VM，这些场景中 IL 是从从头构造的而不是从 Kernel AST 生成的)</li><li>生成的 CFG 直接编译成机器码：每个 IL 指令扩展成多个机器语言指令</li></ol><p>这个阶段中没有进行优化，unoptimizing compiler 的主要目标是快速生成可执行代码。</p><p>This also means that unoptimizing compiler does not attempt to statically resolve any calls that were not resolved in Kernel binary, so calls (MethodInvocation or PropertyGet AST nodes) are compiled as if they were completely dynamic. VM 目前不使用任何形式的基于的 <em>virtual table</em> 或 <em>interface table</em> 的分发方法，而是使用 <a href="https://en.wikipedia.org/wiki/Inline_caching" target="_blank" rel="noopener">inline caching</a> 实现动态调用。</p><p>inline caching 背后的主要思想是在 call site specific cache 中保存方法解析的结果(The core idea behind inline caching is to cache results of method resolution in a call site specific cache.)。注意：原始的 inline caching 实现实际上是用来对函数的 native 代码打补丁。VM 使用的 inline caching 有如下组成：</p><ul><li>call site specific cache (RawICData 对象)，将接收方的类映射成方法，如果接收方的类匹配上就调用这个方法。这个 cache 还保存一些辅助信息，比如调用计数，用于记录指定类在这个 call site 中出现的次数</li><li>shared lookup stub，实现方法调用的快捷路径。该 stub 在指定 cache 中检查是否包含能跟接收方的类匹配的 entry，如果有，则 stub 将增调用频率计数。否则，stub 将请求运行时系统进行方法解析。解析方法后会更新 cache，之后的方法调用不必再经过运行时系统。</li></ul><p>下图展示了跟 <code>animal.toFace()</code> call site 关联的 inline cache 的结构和方法，这个方法在一个 <code>Dog</code> 实例上执行两次，在另一个 <code>Cat</code> 实例上执行一次。</p><p><img src="/images/15934995543159.jpg" alt></p><p>Unoptimizing compiler 本身足够执行任意 Dart 代码。但它生成的代码非常慢，这也是为什么 VM 还实现了 <em>adaptive optimizing</em> 编译流水线。adaptive optimizing 背后的思想是对一个运行中的程序的执行分析结果来驱动优化决策：</p><p>unoptimized code (未经优化的代码) 运行时会收集以下信息：</p><ul><li>dynamic call site 对应的 inline cache 收集接收者的类型信息</li><li>每个函数和块的执行计数器记录代码热点</li></ul><p>当一个函数的执行计数数达到某个阈值时，该函数被提交给 <em>background optimizing compiler</em> 进行优化。</p><p>优化编译以跟未优化编译相同的方式开始：遍历序列化后的 Kernel AST 来为待优化的函数构建未优化的 IL。不过，现在跟直接将 unoptimized IL 转成机器码不同的是，optimizing compiler 将 unoptimized IL 转换成 static single assignment (SSA) 格式的 optimized IL。SSA 格式的 IL 接下来会基于收集到的类型反馈来进行一系列常规的以及 Dart 特有的优化：比如  e.g. inlining, range analysis, type propagation, representation selection, store-to-load and load-to-load forwarding, global value numbering, allocation sinking, etc. 最后，使用 linear scan register allocator 将 optimized IL 转换成机器码。</p><p>优化编译完成后 background compiler 要求 mutator thread 进入一个安全点，并且将优化后的代码关联到待优化的函数。下次函数执行时，它将使用优化后的代码。</p><p>注意：有些函数包含长时间执行的循环，所以在函数运行期间从 unoptimized code 切换到 optimized code 也是有意义的。这个过程称为 <em>on stack replacement</em> (OSR)，它的名字来自于这样一个事实：栈帧从函数的某个版本被透明地替换成同一函数的另一个版本。</p><p><img src="/images/15935012109939.jpg" alt></p><p>源码清单：</p><ul><li>编译器源码见 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler" target="_blank" rel="noopener">runtime/vm/compiler</a> 目录</li><li>编译流水线入口见 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/jit/compiler.cc#L701" target="_blank" rel="noopener">CompileParsedFunctionHelper::Compile</a></li><li>IL 由 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/backend/il.h" target="_blank" rel="noopener">runtime/vm/compiler/backend/il.h</a> 定义</li><li>Kernel-to-IL 的转换从 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/frontend/kernel_binary_flowgraph.cc#L1929" target="_blank" rel="noopener">kernel::StreamingFlowGraphBuilder::BuildGraph</a> 开始</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/stub_code_x64.cc#L1795" target="_blank" rel="noopener">StubCode::GenerateNArgsCheckInlineCacheStub</a> 为 inline-cache stub 生成机器码，<a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/runtime_entry.cc#L1073" target="_blank" rel="noopener">InlineCacheMissHandler</a> 处理 IC 缺失</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/compiler_pass.cc" target="_blank" rel="noopener">runtime/vm/compiler/compiler_pass.cc</a> 定义 optimizing compiler pass 和 order</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/jit/jit_call_specializer.h#L12" target="_blank" rel="noopener">JitCallSpecializer</a> 完成大部分 type-feedback based specialization</li></ul><p>动手尝试！VM 提供一些选项用于控制 JIT，并能 dump 由 JIT 编译的函数的 IL 和机器码.</p><p>Flag    Description<br>–print-flow-graph[-optimized]    Print IL for all (or only optimized) compilations<br>–disassemble[-optimized]    Disassemble all (or only optimized) compiled functions<br>–print-flow-graph-filter=xyz,abc,…    Restrict output triggered by previous flags only to the functions which contain one of the comma separated substrings in their names<br>–compiler-passes=…    Fine control over compiler passes: force IL to be printed before/after a certain pass. Disable passes by name. Pass help for more information<br>–no-background-compilation    Disable background compilation, and compile all hot functions on the main thread. Useful for experimentation, otherwise short running programs might finish before background compiler compiles hot function</p><p>例如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Run test.dart and dump optimized IL and machine code for</span><br><span class="line"># function(s) that contain(s) &quot;myFunction&quot; in its name.</span><br><span class="line"># Disable background compilation for determinism.</span><br><span class="line">$ dart --print-flow-graph-optimized         \</span><br><span class="line">       --disassemble-optimized              \</span><br><span class="line">       --print-flow-graph-filter=myFunction \</span><br><span class="line">       --no-background-compilation          \</span><br><span class="line">       test.dart</span><br></pre></td></tr></table></figure><p>另外需要强调的是 optimizing compiler 是基于对应用执行结果分析而得出的假设来生成优化后的代码的。比如，观察到动态调用只将 <code>C</code> 类作为接收者，会将这个动态调用转换成直接调用，并验证接收者的类型为 <code>C</code>。但是，后续的调用可能打破这种假设：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> printAnimal(obj) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Animal &#123;'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'  <span class="subst">$&#123;obj.toString()&#125;</span>'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'&#125;'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call printAnimal(...) a lot of times with an intance of Cat.</span></span><br><span class="line"><span class="comment">// As a result printAnimal(...) will be optimized under the</span></span><br><span class="line"><span class="comment">// assumption that obj is always a Cat.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++)</span><br><span class="line">  printAnimal(Cat());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now call printAnimal(...) with a Dog - optimized version</span></span><br><span class="line"><span class="comment">// can not handle such an object, because it was</span></span><br><span class="line"><span class="comment">// compiled under assumption that obj is always a Cat.</span></span><br><span class="line"><span class="comment">// This leads to deoptimization.</span></span><br><span class="line">printAnimal(Dog());</span><br></pre></td></tr></table></figure><p>任何时候如果 optimized code 做了某种假设，但这些假设并不来自静态不可变信息，则应该防范假设被打破，并且能在打破假设的场景中恢复。</p><p>这种恢复过程称为 <em>deoptimization</em> (反优化)：无论何时当 optimized code 不能处理某种 case 时，简单地切换成 unoptimized code 对应的匹配点并继续执行。unoptimized code 没有做任何假设，所以能处理任何可能的输入。</p><blockquote><p>注意：进入 unoptimized 函数正确的执行点非常重要，因为方法有副作用。比如上面的例子中，deoptimization 发生在调用第一个 <code>print</code> 调用后。Matching instructions that deoptimize to positions in the unoptimized code in VM is done using deopt ids</p></blockquote><p>VM 通常会在 deoptimization 发生时抛弃函数的 optimized 版本，并且在之后使用更新后的 type feedback 重新进行优化。</p><p>VM 有两种方式来防范编译做出的假设被破坏：</p><ul><li>inline check (比如，<code>CheckSmi</code> 和 <code>CheckClass</code> IL 指令) 用于在编译器做出假设的 use site 中验证假设仍然成立。比如，将动态调用转换成直接调用时编译器会在直接调用前增加检查。检查失败时发生的 deoptimization 被称为 <em>eager deoptimization</em>，因为检查后它马上发生</li><li>全局守卫，用于提示运行时在 optimized code 依赖的东西被修改后抛弃这些 optimized code。比如，optimizing compiler 可能发现 <code>C</code> 类没有被其他类继承，并且在类型传递时使用了这个信息。但是接下来动态加载的代码可能引入了一个继承自 <code>C</code> 类的类，所以之前假设不成立。这时运行时需要抛弃所有基于 <code>C</code> 类没有子类这个假设优化得到的 optimized code。运行时可能发现某些失效的 optimized code 在执行栈中，这种情况下受影响的栈帧需要被标记以反优化。这种 deoptimization 称为 <em>lazy deoptimization</em>：因为它会延迟到控制流回到 optimized code 时才发生</li></ul><p>代码清单：</p><ul><li>Deoptimizer 机制见 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/deopt_instructions.cc" target="_blank" rel="noopener">runtime/vm/deopt_instructions.cc</a>。它实际上是一个用于 <em>deoptimization instructions</em> 的迷你解释器，用于描述从 optimized code 状态重建必要的 unoptimized code 状态</li><li><p>Deoptimization 指令由 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/backend/flow_graph_compiler_x64.cc#L68" target="_blank" rel="noopener">CompilerDeoptInfo::CreateDeoptInfo</a> 为 optimized code 中每个潜在的 deoptimization location 生成 deoptimization 指令</p></li><li><p><code>--trace-deoptimization</code> 用于 VM 输出每个 deoptimization 的原因和位置</p></li><li><code>--trace-deoptimization-verbose</code> 用于 VM 为每个 deoptimization instruction 输出一行日志</li></ul><h2 id="从-snapshot-运行"><a href="#从-snapshot-运行" class="headerlink" title="从 snapshot 运行"></a>从 snapshot 运行</h2><p>VM 具备对 isolate 堆(更准确地说是堆中的对象图)序列化成二进制 <em>snapshot</em> 的能力。snapshot 可用于启动 VM isolate 时重建相同状态。</p><p><img src="/images/15935061109366.jpg" alt></p><p>snapshot 使用低级格式，便于快速启动。它实际上是待创建对象的列表，以及如何联系这些对象的指令。snapshot 背后的初始思想是：相比解析 Dart 源码来逐步创建 VM 内部数据结构，VM 可以快速从 snapshot 得到所有必要的数据结构来启动 isolate。</p><p>最初，snapshot 中并不包含机器码。后来随着 AOT compiler 的开发，snapshot 中也可包含机器码。开发 AOT compiler 以及 snapshots-with-code 的目的是允许 VM 用于 JITing 不可用(平台本身限制)的那些平台。</p><p>snapshots-with-code 跟普通 snapshot 几乎相同，一个小的区别在于：前者包含一个 code section，这个区域跟其他区域不同，并不需要反序列化。code section 允许映射到内存时直接作为 heap 的一部分。</p><p><img src="/images/15935067498616.jpg" alt></p><p>代码清单：</p><ul><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/clustered_snapshot.cc" target="_blank" rel="noopener">runtime/vm/clustered_snapshot.cc</a> 处理 snapshot 的序列化与反序列化。有一系列 Dart_CreateXyzSnapshot[AsAssembly] 方法用于将 heap 导出成 snapshot，例如 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/dart_api_impl.cc#L6238" target="_blank" rel="noopener">Dart_CreateAppJITSnapshotAsBlobs</a> 和 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/dart_api_impl.cc#L5986" target="_blank" rel="noopener">Dart_CreateAppAOTSnapshotAsAssembly</a></li></ul><h2 id="从-AppJIT-snapshot-运行"><a href="#从-AppJIT-snapshot-运行" class="headerlink" title="从 AppJIT snapshot 运行"></a>从 AppJIT snapshot 运行</h2><p>引入 AppJIT snapshot 是为解决大型 Dart 应用的启动时间，例如 <code>dartanalyzer</code> 或 <code>dart2js</code>。这些工具用于小工程时完成实际工作的时间跟 VM 花在 JIT 上的时间一样多(译者注：言下之意是，VM 花了太多时间对大型 Dart 应用进行 JIT 处理，而这些应用用于处理小工程时实际工作本身并不会耗时太多？)</p><p>AppJIT snapshot 可用于处理这种问题：一个应用可以在 VM 使用一些模拟的训练数据运行，之后将生成的代码和 VM 内部数据结构序列化成 AppJIT snapshot。不同于以源码和 Kernel binary 形式来分发应用，而是分发 AppJIT snapshot。当在实际数据上执行时的 execution profile 无法匹配到训练阶段时观察到的 execution profile，从这种 snapshot 启动的 VM 仍然可以 JIT—</p><p><img src="/images/15935079364904.jpg" alt></p><p>动手尝试！给 <code>dart</code> 命令传 <code>--snapshot-kind=app-jit --snapshot=path-to-snapshot</code> 参数会生成 AppJIT snapshot。如下的例子为 <code>dart2js</code> 生成和使用 AppJIT snapshot。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run from source in JIT mode.</span></span><br><span class="line">$ dart pkg/compiler/lib/src/dart2js.dart -o hello.js hello.dart</span><br><span class="line">Compiled 7,359,592 characters Dart to 10,620 characters JavaScript <span class="keyword">in</span> 2.07 seconds</span><br><span class="line">Dart file (hello.dart) compiled to JavaScript: hello.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># Training run to generate app-jit snapshot</span></span><br><span class="line">$ dart --snapshot-kind=app-jit --snapshot=dart2js.snapshot \</span><br><span class="line">       pkg/compiler/lib/src/dart2js.dart -o hello.js hello.dart</span><br><span class="line">Compiled 7,359,592 characters Dart to 10,620 characters JavaScript <span class="keyword">in</span> 2.05 seconds</span><br><span class="line">Dart file (hello.dart) compiled to JavaScript: hello.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run from app-jit snapshot.</span></span><br><span class="line">$ dart dart2js.snapshot -o hello.js hello.dart</span><br><span class="line">Compiled 7,359,592 characters Dart to 10,620 characters JavaScript <span class="keyword">in</span> 0.73 seconds</span><br><span class="line">Dart file (hello.dart) compiled to JavaScript: hello.js</span><br></pre></td></tr></table></figure><h2 id="从-AppAOT-snapshot-运行"><a href="#从-AppAOT-snapshot-运行" class="headerlink" title="从 AppAOT snapshot 运行"></a>从 AppAOT snapshot 运行</h2><p>AOT snapshot 初始是为无法开启 JIT 编译的平台引入的，但它们也可用于快速启动以及性能强一致性(可接受潜在性能损失)的场景。</p><blockquote><p>关于 JIT 和 AOT 性能特性之间的比较常常有很多混淆。JIT 能访问到准确的本地类型信息，以及应用运行期间的 execution profile，但它付出的代价是较慢的预热过程。AOT 可以推断和验证全局属性(代价是较长的编译时间)，但没有应用如何实际执行的信息。换句话说，AOT 编译的代码实际没有预热过程，启动后几乎就能达到性能峰值。当前 Dart VM JIT 有最好的性能峰值，而 Dart VM AOT 有最短的启动时间。</p></blockquote><p>无法 JIT 意味着：</p><ol><li>AOT snapshot 必须包含应用执行期间每个可能被调用的函数的可执行代码</li><li>这些可执行代码不能依赖任何在执行期间可能被违反的假设</li></ol><p>为了满足这些需求，AOT 编译时会进行全局静态分析(<em>type flow analysis</em>，TFA)以确定从一些已知的入口出发，应用的哪些部分是可达的；会分配哪些类的实例；以及程序的 type flow 是怎样的。所有这些分析都是保守的：即它们更看重正确性。这与 JIT 更看重高性能是截然不同的。JIT 总是可以在必要时”反优化”到 unoptimized code 来实现正确的行为。</p><p>所有潜在可达的函数被编译成 native code，不做任何推测优化(All potentially reachable functions are then compiled to native code without any speculative optimizations)。当然，仍然会使用 type flow 信息对代码进行处理(比如，取消虚调用 devirtualize calls)。</p><p>所以函数编译完成后生成 snapshot。生成的 snapshot 可以在 <em>precompiled runtime</em>，这是一个特别的 Dart VM，没有 JIT 组件及动态加载代码的能力。</p><p><img src="/images/15935100043901.jpg" alt></p><p>源码清单：</p><ul><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/vm/lib/transformations/type_flow/transformer.dart" target="_blank" rel="noopener">package:vm/transformations/type_flow/transformer.dart</a> 是 type flow 分析及基于 TFA 转换的入口</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/aot/precompiler.cc#L190" target="_blank" rel="noopener">Precompiler::DoCompileAll</a> 是   VM 中 AOT 编译循环(the AOT compilation loop in the VM)的入口</li></ul><p>动手尝试！目前 Dart SDK 并不包含 AOT 编译流水线，那些依赖这个特性的项目(比如 Flutter)必须自行从 SDK 构建这个功能。<a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/vm/tool/precompiler2" target="_blank" rel="noopener">pkg/vm/tool/precompiler2</a> 脚本是个不错的参考，它演示了流水线是如何组织的，哪些二进制产物必须被构建。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Need to build normal dart executable and runtime for running AOT code.</span></span><br><span class="line">$ tool/build.py -m release -a x64 runtime dart_precompiled_runtime</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now compile an application using AOT compiler</span></span><br><span class="line">$ pkg/vm/tool/precompiler2 hello.dart hello.aot</span><br><span class="line"></span><br><span class="line"><span class="comment"># Execute AOT snapshot using runtime for AOT code</span></span><br><span class="line">$ out/ReleaseX64/dart_precompiled_runtime hello.aot</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><p>注意：如果想检查生成的 AOT 代码，类似 <code>--print-flow-graph-optimized</code> 或 <code>--disassemble-optimized</code> 这些参数也可以传给 <code>precompiler2</code> 脚本。</p><h1 id="Runtime-System"><a href="#Runtime-System" class="headerlink" title="Runtime System"></a>Runtime System</h1><p>敬请期待 (译者注：原文还在完善中)</p><h1 id="Object-Model"><a href="#Object-Model" class="headerlink" title="Object Model"></a>Object Model</h1><p>敬请期待 (译者注：原文还在完善中)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自 &lt;a href=&quot;https://mrale.ph/dartvm/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dart VM&lt;/a&gt;，非常详细地介绍了 Dart 代码运行机制。&lt;br&gt;
    
    </summary>
    
    
      <category term="Dart" scheme="http://www.sunmoonblog.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>(译) 使用 DevTools 分析 Flutter 内存</title>
    <link href="http://www.sunmoonblog.com/2020/06/29/flutter-memory/"/>
    <id>http://www.sunmoonblog.com/2020/06/29/flutter-memory/</id>
    <published>2020-06-29T12:34:41.000Z</published>
    <updated>2020-11-13T02:18:59.049Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自 <a href="https://raw.githubusercontent.com/flutter/website/master/src/docs/development/tools/devtools/memory.md" target="_blank" rel="noopener">Using the Memory view</a>，学习如何使用 DevTools 中的来分析 Flutter 应用的内存。</p><a id="more"></a><p>个人感觉目前 DevTools (0.8.0)还不太稳定，我的 Mac 机器上查看内存一段时间后经常无响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; flutter pub global list</span><br><span class="line">devtools 0.8.0+2</span><br></pre></td></tr></table></figure><h2 id="它是什么"><a href="#它是什么" class="headerlink" title="它是什么?"></a>它是什么?</h2><p>使用类构建方法(比如，<code>new MyClass()</code> 或 <code>MyClass()</code>)分配的 Dart 对象存活于称为堆的内存中。</p><!--DevTools Memory pane lets you peek at how an isolate is usingmemory at a given moment. This pane, using Snapshot andReset, can display accumulator counts. The accumulatorscan be used to study the rate of memory allocations,if you suspect your application is leaking memory or hasother bugs relating to memory allocation.--><p>DevTools 的内存面板用于查看指定时刻时的 isolate 内存。这个面板使用 Snapshot 和 Reset 来展示 accumulator 计数。如果你怀疑应用中存在内存泄漏或其他内存相关的 bug，可以使用 accumulator 分析内存分配情况。</p><!--Memory profiling consists of four parts, each increasingin granularity:--><p>内存分析由四部分组成，精细度从低到高分别是:</p><ul><li>Memory overview chart</li><li>Event timeline</li><li>Snapshot classes</li><li>Class instances</li></ul><!--<p>  <strong>Use [profile mode][] when running your app to analyze performance.</strong><br>  Memory usage is not indicative of release performance unless your<br>  application is run in profile mode. In general, memory usage is<br>  fairly accurate, in relative terms, between debug, release, or<br>  profile modes. Profile mode might show higher absolute memory usage<br>  because a service isolate is created to profile your application.<br>  This isolate won’t exist in release mode. Absolute memory used might<br>  also be higher in debug versus release mode. In release mode,<br>  work can be computed and optimized ahead of time, while in debug<br>  mode that same work might have to be computed at runtime,<br>  requiring more information.<br>–&gt;</p><blockquote><p><strong>分析性能时请以 [profile mode][<a href="https://flutter.dev/docs/testing/build-modes#profile]">https://flutter.dev/docs/testing/build-modes#profile]</a> 启动应用。</strong> 除非以 profile mode 运行，否则看到的内存使用量并不代表实际发布模式的内存使用量。无论是 debug, release 还是 profile 模式，测出来的内存值都是相当准确的。不过由于要启动一个 service isolate 用于分析应用，所以 profile mode 可能会显示更高的绝对内存使用量。这个 isolate 在发布模式下并不存在。相比发布模式，debug 模式的绝对内存使用量也会更高。在发布模式中，可以提前进行计算或优化处理，而在 debug 模式中相同工作只能在运行时进行，所以需要更多信息(译者注: 也意味占用更多内存)。</p></blockquote><!--## Memory anatomy--><h2 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h2><!--Use a timeseries graph to visualize the state of the Flutter memoryat successive intervals of time. Each data point on the chartcorresponds to the timestamp (x-axis) of measured quantities (y-axis)of the heap, for example, usage, capacity, external, garbagecollection, and resident set size.--><p>使用时间序列图形来可视化一段连续时间内的 Flutter 内存状态。图表中的每个数据点分别对应堆(heap)的时间戳(x轴)和测量值(y轴)。测量值有多种，比如 usage, capacity, external, garbage<br>collection, 和 resident set size</p><p><img src="/images/15952331308847.jpg" alt></p><!--<dl markdown="1"><dt markdown="1">**Legend**</dt><dd>All collected measurements regarding the memory.    Clicking a legend name hides or shows that data.</dd><dt markdown="1">**Range selector**</dt><dd>All memory data collected (timeseries).    The left-most or first time/data (memory information),    in the selector is when the application was launched.    The right-most or last time/data is the continual memory    information being received (live) until the application is    stopped.</dd><dt markdown="1">**Range selector view**</dt><dd>Detailed view of the data collected    for this timeseries range (non-gray area).</dd><dt markdown="1">**X-axis timestamp**</dt><dd>Time of the collected memory information    (capacity, used, external, RSS (resident set size),    and GC (garbage collection).</dd><dt markdown="1">**Hover information of collected data**</dt><dd>At a particular time (x-axis) the detailed collected    memory data.</dd><dt markdown="1">**Garbage collection occurred**</dt><dd>Compaction of the heap occurred.</dd><dt markdown="1">**Event timeline**</dt><dd>When a user action occurred (such as the    Snapshot or Reset button being clicked).</dd><dt markdown="1">**Snapshot**</dt><dd markdown="1">Display a table of current active    memory objects (see    [Snapshot classes](#snapshot-classes)).<dt markdown="1">**Reset accumulator**</dt><dd markdown="1">Reset values, to zero, under the    Accumulator column in the Snapshot classes table.<dt markdown="1">**Filtering classes**</dt><dd>PENDING</dd><dt markdown="1">**Snapshot classes**</dt><dd>Clicking the Snapshot button (top right area)    displays a table of current memory objects.    The memory objects can be sorted by class name,    size, allocated instances, and so on.</dd><dt markdown="1">**Accumulator counts since reset**</dt><dd>Clicking the Reset button (top right area) resets    the accumulated instances count. Clicking Snapshot    after a reset displays the number of new instances    allocated since last reset.    This is useful for finding memory leaks.</dd><dt markdown="1">**Class instances**</dt><dd>Clicking a class in the Snapshot class table    displays the number of active instances for that class.</dd><dt markdown="1">**Inspecting contents of an instance**</dt><dd>PENDING</dd><dt markdown="1">**Total active objects and classes in the heap**</dt><dd>Total classes allocated in the heap and total objects    (instances) in the heap.</dd>--><p><strong>图例</strong></p><p>所有收集到的内存相关的测量值。点击图例名会隐藏或显示对应数据。</p><p><strong>Range selector</strong></p><p>所有收集到的内存数据(时间线)。selector 中最左边/第一个 time/data(或 memory information)对应于应用启动时，最右边/最后一个 time/data 对应于应用结束时收到内存信息。</p><p><strong>Range selector view</strong></p><p>timeserie range 中收集到的的数据的详细视图。</p><p><strong>X轴 时间戳</strong></p><p>收集到内存信息时对应的时间(capacity, used, external, RSS (resident set size),<br>   和 GC (garbage collection)。</p><p><strong>Hover information of collected data</strong></p><p>特定时间(x-axis)详细的内存数据。</p><p><strong>Garbage collection occurred</strong></p><p>Compaction of the heap occurred.</p><p><strong>Event timeline</strong></p><p>用户操作发生的时间 (such as the Snapshot or Reset button being clicked)</p><p><strong>Snapshot</strong></p><p>以表格形式显示内存中存活的对象</p><p><strong>Reset accumulator</strong></p><p>将 Snapshot class 表中 Accumulator 那一列下的值重置为 0</p><p><strong>Filtering classes</strong></p><p>PENDING</p><p><strong>Snapshot classes</strong></p><p>点击右上角的 Snapshot 按钮将显示以表格形式显示内存中的对象。这些对象可以按类名、大小、实例等条件排序。</p><p><strong>Accumulator counts since reset</strong></p><p>点击右上角的 Reset 按钮将重置 accumulated instances count。点击重置之后再点击 Snapshot 将展示上次重置之后新分配的实例。这在查找内存泄漏时非常有用。</p><p><strong>Class instances</strong></p><p>点击 Snapshot class 表中的 class 将展示该类对应的存活实例。</p><p><strong>Inspecting contents of an instance</strong></p><p>PENDING</p><p><strong>Total active objects and classes in the heap</strong></p><p>堆中分配的全部类以及全部对象</p><h2 id="Memory-overview-chart"><a href="#Memory-overview-chart" class="headerlink" title="Memory overview chart"></a>Memory overview chart</h2><p><img src="/images/15952347134525.jpg" alt></p><p>这是一个用于帮助可视化展示不同时间 heap 内存情况的时间序列图。</p><p>图中的 x-axis 是时间线。它在应用运行时每 500ms 读取一次内存值。y-axis 上(从上到下)的分别是：</p><p><strong>Capacity</strong></p><p>当前堆大小</p><p><strong>GC</strong></p><p>是事发生 GC。更多关于 Dart 如何处理 GC 请参考 <a href="https://medium.com/flutter/flutter-dont-fear-the-garbage-collector-d69b3ff1ca30" target="_blank" rel="noopener">Don’t Fear the Garbage Collector</a></p><p><strong>Used</strong></p><p>堆中的 Dart 对象</p><p><strong>External</strong></p><p>不在 Dart 堆中但仍然是总内存的一部分的那部分内存。在 external 内存中的对象是 native object(比如，已解码的图片)。原生系统使用 Dart embedder 向 Dart VM 暴露这些对象。Dart embedder 创建 Dart wrapper 用于 Dart 代码跟这些原生资源通信。</p><!--<dd markdown="1">Memory that is not in the Dart heap but is still part  of the total memory footprint. Objects in external memory would be  native objects (for example, from a memory read from a file,  or a decoded image). The native objects are exposed to the Dart  VM from the native OS (such as Android, Linux, Windows, iOS)  using a Dart embedder. The embedder creates a Dart wrapper with  a finalizer, allowing Dart code to communicate with these native  resources. Flutter has an embedder for Android and iOS.  For more information, see [Dart on the Server][server] or  [Custom Flutter Engine Embedders][embedder].--><p><img src="/images/15952351903784.jpg" alt></p><p>想查看 RSS (resident set size)，在图例中点击 RSS 的名字即可。</p><!--To view RSS (resident set size), click the name of the RSS locatedin the legend.--><ul><li>RSS 显示了进程使用的全部内存。它不包含被 swap out 的内存，但包含已加载的 shared library 内存，以及全部的栈内存和堆内存。</li></ul><!--* The resident set size displays the amount of memory to a process.  It doesn't include memory that is swapped out. It includes memory  from shared libraries that are loaded, as well as all stack and  heap memory.--><!--For more information, see [Dart VM internals][vm].--><p>更多信息请参考 <a href="https://mrale.ph/dartvm/" target="_blank" rel="noopener">Dart VM internals</a>。</p><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p><img src="/images/15952353620278.jpg" alt></p><p>这个图表展示了 DevTools 事件与跟内存时间线的关系。停在时间线的标记上将展示事件发生的时机。这个功能有助于发现可能的内存泄漏。</p><!--This chart displays DevTools events (such as Snapshot and Reset buttonclicks) in relation to the memory chart timeline. Hovering over themarkers in the Event timeline displays the time when the event occurred.This helps identify when a memory leak might have occurred in thetimeline (x-axis).--><!--Clicking the **Snapshot** button shows the current state of the heap withregard to all active classes and their instances. When the **Reset** buttonis pressed, the accumulator for all classes resets to zero.The reset is temporally tied, using a faint blue horizontal bar,to the previous snapshot. Clicking the **Reset** button again resets theaccumulators since the last reset and temporally ties the latestreset to the previous reset.--><p><strong>Snapshot</strong> 按钮将显示当前堆中所有存活的 class 及其实例。点击 <strong>Reset</strong> 按钮时，所有 accumulator 重置成 0。使用浅蓝色水平条将 Reset 跟之前的 Snapshot 连接。再次点击 <strong>Reset</strong> 按钮时重置 accumulator 并且暂时将最新的 reset 跟上次 reset 连接。</p><h2 id="Snapshot-classes"><a href="#Snapshot-classes" class="headerlink" title="Snapshot classes"></a>Snapshot classes</h2><p><img src="/images/15952357576151.jpg" alt></p><p>这个面板显示堆中分配的 class 及其所有实例，已分配内存大小，以及 accumulator (从上次 reset 开始计起)</p><!--This pane shows classes allocated in the heap, total instances,total bytes allocated, and an accumulator of allocations sincethe last reset.--><p><strong>Size</strong></p><p>堆中当前对象占用的全部内存</p><p><strong>Count</strong></p><p>堆中当前对象数量</p><p><strong>Accumulator</strong></p><p>上次 reset 后堆中的对象数量</p><p><strong>Class</strong></p><p>当前 class 的对象数量。点击类名会显示该类的实例列表</p><h2 id="Class-instances"><a href="#Class-instances" class="headerlink" title="Class instances"></a>Class instances</h2><!--Displays a list of class instances by their handle name.[PENDING: add a link to inspecting data values.]--><p>展示类实例列表。</p><h2 id="Memory-actions"><a href="#Memory-actions" class="headerlink" title="Memory actions"></a>Memory actions</h2><p><img src="/images/15952458407426.jpg" alt></p><h3 id="Liveness-of-the-memory-overview-chart"><a href="#Liveness-of-the-memory-overview-chart" class="headerlink" title="Liveness of the memory overview chart"></a>Liveness of the memory overview chart</h3><p><strong>Pause</strong></p><p>暂停 memory overview 以查看当前数据。注意：此时仍然会接收数据；Range selector 继续往右更新。</p><p><strong>Resume</strong></p><p>memory overview 正在运行中，展示最新时间以及最新的内存数据。</p><h3 id="Managing-the-objects-and-statistics-in-the-heap"><a href="#Managing-the-objects-and-statistics-in-the-heap" class="headerlink" title="Managing the objects and statistics in the heap"></a>Managing the objects and statistics in the heap</h3><p><strong>Snapshot</strong></p><p>返回堆中的存活对象列表。Accumulator 那一列展示了上次 reset 后分配对象的数量</p><p><strong>Reset</strong></p><p>重置 Snapshot classes table 中的 Accumulator 列，并刷新数据</p><p><strong>Filter</strong></p><p>Snapshot classes table 只展示选中的 package 下的 class</p><p><strong>GC</strong></p><p>发起 GC</p><!--## Glossary of VM terms--><h2 id="VM-术语汇总"><a href="#VM-术语汇总" class="headerlink" title="VM 术语汇总"></a>VM 术语汇总</h2><!--Here are some computer science concepts that will help you betterunderstand how your application uses memory.--><p>这里是一些有助于你更好理解应用是如何使用内存的计算机科学基础概念。</p><!--<dd>GC is the process of searching the    heap to locate, and reclaim, regions of "dead" memory&mdash;memory    that is no longer being used by an application. This process    allows the memory to be re-used and minimizes the risk of an    application running out of memory, causing it to crash. Garbage    collection is performed automatically by the Dart VM. In DevTools,    you can perform garbage collection on demand by clicking the    GC button.</dd>--><p><dl markdown="1"></dl></p><p><dt markdown="1"><strong>Garbage collection (GC)</strong></dt></p><dd>GC 是指在堆中定位和回收已”死亡”的内存的过程&mdash;即不再被应用使用的内存。这个过程允许内存被重新使用，将应用内存不足导致崩溃的风险最小化。Dart VM 自动回收垃圾。在 DevTools 中可以点击 GC 按钮主动回收垃圾。</dd><br><dt markdown="1"><strong>Heap</strong></dt><br><dd>Dart 对象在内存上动态分配，这块内存称之为堆。堆上分配的对象不再被引用时(由 GC 完成)或应用结束时将会释放。一个对象不被引用时，认为它已死亡。一个对象被引用时，它则是存活的。</dd><br><dt markdown="1"><strong>Isolates</strong></dt><br><dd markdown="1">Dart 通过 isolate 来支持并发。可以将 isolate 理解成无开销的进程。每个 isolate 有自己的内存和代码，它们不会被其他 isolate 影响。详情请参考 [The Event Loop and Dart][event-loop].<br><dt markdown="1"><strong>Memory leak</strong></dt><br><dd>当对象仍然存活(意味着另一个对象引用它)，却不再被使用(即其他对象不应引用它)时认为发生了内存泄漏。这种对象无法被 GC，所以会仍然占用堆空间，导致内存碎片。内存泄漏给 VM 带来不必要的压力，难以调试。</dd><br><dt markdown="1"><strong>Virtual machine (VM)</strong></dt><br><dd>Dart 虚拟机是直接执行 Dart 代码的软件。</dd><p>[embedder]: /flutter/flutter/wiki/Custom-Flutter-Engine-Embedders<br>[vm]: <a href="https://mrale.ph/dartvm/" target="_blank" rel="noopener">https://mrale.ph/dartvm/</a><br>[event-loop]: NaN/articles/archive/event-loop<br>[profile mode]: /docs/testing/build-modes#profile<br>[release mode]: /docs/testing/build-modes#release<br>[debug mode]: /docs/testing/build-modes#debug<br>[Don’t Fear the Garbage Collector]: NaN/flutter-dont-fear-the-garbage-collector-d69b3ff1ca30</p></dd>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自 &lt;a href=&quot;https://raw.githubusercontent.com/flutter/website/master/src/docs/development/tools/devtools/memory.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Using the Memory view&lt;/a&gt;，学习如何使用 DevTools 中的来分析 Flutter 应用的内存。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
      <category term="翻译" scheme="http://www.sunmoonblog.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Dart Protobuf 用法简介</title>
    <link href="http://www.sunmoonblog.com/2020/06/24/dart-protobuf/"/>
    <id>http://www.sunmoonblog.com/2020/06/24/dart-protobuf/</id>
    <published>2020-06-24T02:25:14.000Z</published>
    <updated>2020-11-13T02:18:59.048Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录下如何在 Dart 中使用 Protobuf。</p><a id="more"></a><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developers.google.com/protocol-buffers/docs/reference/dart-generated" target="_blank" rel="noopener">Dart Generated Code</a></li><li><a href="https://github.com/dart-lang/protobuf/tree/master/protoc_plugin" target="_blank" rel="noopener">dart-lang/protobuf</a></li></ul><p>注意点：</p><ul><li>Protobuf 编译器依赖独立安装的<a href="https://github.com/dart-lang/dart-protoc-plugin" target="_blank" rel="noopener">Dart 插件</a>来生成 Dart 代码 <a href="https://developers.google.com/protocol-buffers/docs/reference/dart-generated" target="_blank" rel="noopener">参考来源</a></li><li>Dart 要求 Protobuf 编译器版本为 3.0.0 及以上 <a href="https://github.com/dart-lang/protobuf/tree/master/protoc_plugin" target="_blank" rel="noopener">参考来源</a></li><li>Dart 只支持 <a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">proto3</a> scheme <a href="https://github.com/dart-lang/protobuf/tree/master/protoc_plugin" target="_blank" rel="noopener">参考来源</a> <del>Dart 只支持 <a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">proto2</a> scheme <a href="https://github.com/dart-lang/protobuf/tree/master/protoc_plugin" target="_blank" rel="noopener">参考来源</a></del></li></ul><h1 id="安装和编译"><a href="#安装和编译" class="headerlink" title="安装和编译"></a>安装和编译</h1><p>第一步，安装 Protobuf 编译器。可以从 <a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">Protobuf release</a> 页面下载和安装，也可以 <code>brew install protobuf</code> 安装。</p><p>第二步，安装 Protobuf Dart 插件。</p><ul><li>下载<a href="https://github.com/dart-lang/protobuf.git" target="_blank" rel="noopener">代码</a>。<code>git clone https://github.com/dart-lang/protobuf.git</code></li><li><strong>编译插件</strong>。调用 <code>pub install</code> 编译插件，编译后源码 <code>bin</code> 目录下可以找到 <code>proto-gen-dart</code> 文件。如果出错，可以使用 <code>pub --trace install</code> 查看详细错误日志</li><li>使用插件。将插件配置到 PATH 路径中，或者调用 <code>protoc</code> 时使用 <code>--plugin</code> 参数指定插件路径</li></ul><p>第三步，运行 protoc 编译生成 <code>.proto.dart</code> 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  aproj_pub_proj git:(cm) ✗ protoc --proto_path=proto --dart_out=build/gen --plugin=/Users/xxx/Documents/GitHub/protobuf/protoc_plugin/bin proto/aproj/comm_conn.proto</span><br><span class="line">protoc-gen-dart: program not found or is not executable</span><br><span class="line">--dart_out: protoc-gen-dart: Plugin failed with status code 1.</span><br><span class="line">➜  aproj_pub_proj git:(cm) ✗ protoc --proto_path=proto --dart_out=build/gen --plugin=/Users/xxx/Documents/GitHub/protobuf/protoc_plugin/bin/protoc-gen-dart proto/aproj/comm_conn.proto</span><br><span class="line">/Users/kingcmchen/Documents/GitHub/protobuf/protoc_plugin/bin/protoc-gen-dart: line 3: dart: command not found</span><br><span class="line">--dart_out: protoc-gen-dart: Plugin failed with status code 127.</span><br></pre></td></tr></table></figure><ul><li>第一次出错是因为 <code>--plugin</code> 指定的 Dart 插件路径不正确，应当指定具体文件而不是文件所在的目录</li><li>第二次出错是因为 Dart 插件依赖 <code>dart</code> 命令，要确保 PATH 中有配置 <code>dart</code>。 </li></ul><p>PATH 中配置 <code>dart</code> 命令方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DART_PATH=&quot;$HOME/flutter/bin/cache/dart-sdk/bin&quot;</span><br></pre></td></tr></table></figure><p>编译成功！</p><p><img src="media/15635014696032/15635045817933.jpg" alt="-w770"></p><h1 id="发送字符串"><a href="#发送字符串" class="headerlink" title="发送字符串"></a>发送字符串</h1><p>先使用 Dart 实现简单的服务器端 <code>SimpleServer</code> 和客户端 <code>SimpleClient</code>，代码分别如下。</p><p><code>SimpleServer</code> 收到客户端发送的数据，转换成大写的 UTF-8 后发回客户端，并关闭 Socket。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  ServerSocket serverSocket =</span><br><span class="line">      <span class="keyword">await</span> ServerSocket.bind(InternetAddress.anyIPv4, <span class="number">6760</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Started'</span>);</span><br><span class="line"></span><br><span class="line">  serverSocket.listen((Socket socket) &#123;</span><br><span class="line">    socket.listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; event) <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> msg = utf8.decode(event);</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Received <span class="subst">$msg</span>'</span>);</span><br><span class="line">      socket.write(msg.toUpperCase());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">await</span> socket.close();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SimpleClient</code> 向服务器端发送 ‘hello’，并且接收和输出服务器端的响应。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  Socket socket = <span class="keyword">await</span> Socket.connect(<span class="string">'127.0.0.1'</span>, <span class="number">6760</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Connected'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// listen to the received data event stream</span></span><br><span class="line">  socket.listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; event) &#123;</span><br><span class="line">    <span class="built_in">print</span>(utf8.decode(event));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send hello</span></span><br><span class="line">  socket.add(utf8.encode(<span class="string">'hello'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait 5 seconds</span></span><br><span class="line">  <span class="keyword">await</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .. and close the socket</span></span><br><span class="line">  socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="发送-Protobuf-数据"><a href="#发送-Protobuf-数据" class="headerlink" title="发送 Protobuf 数据"></a>发送 Protobuf 数据</h1><p>如何在使用 Protobuf 数据在 <code>SimpleServer</code> 和 <code>SimpleClient</code> 之间通信？</p><p>注意，生成的 <code>.pb.dart</code> 文件中有如下 <code>import</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:fixnum/fixnum.dart&apos;;</span><br><span class="line">import &apos;package:protobuf/protobuf.dart&apos; as $pb;</span><br></pre></td></tr></table></figure><p>所以相应地需要在 <code>pubspec.yaml</code> 中添加对应的依赖。</p><p>第一步，为工程添加 <code>fixnum</code> 和 <a href="https://pub.dev/packages/protobuf" target="_blank" rel="noopener">protobuf</a> 依赖。添加后记得运行 <code>flutter pb get</code> 同步一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  http: 0.12.0+2</span><br><span class="line">  fixnum: 0.10.9</span><br><span class="line">  protobuf: 0.13.15</span><br></pre></td></tr></table></figure><p>第二步，将生成的 <code>.pb.dart</code> 文件拷贝到工程，供 <code>SimpleServer</code> 和 <code>SimpleClient</code> 引用。</p><p>第三步，修改服务器端 <code>SimpleServer</code> 和客户端 <code>SimpleClient</code> 代码，使用 Protobuf 通信。修改后的代码分别如下：</p><p><code>SimpleServer</code> 收到客户端发送的 Protobuf 数据并以 JSON 格式打印出来，然后向客户端发送 Protobuf 数据 <code>CommRsp</code>，最后关闭 Socket。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'comm_conn.pb.dart'</span>;</span><br><span class="line"></span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  ServerSocket serverSocket =</span><br><span class="line">      <span class="keyword">await</span> ServerSocket.bind(InternetAddress.anyIPv4, <span class="number">6760</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Started'</span>);</span><br><span class="line"></span><br><span class="line">  serverSocket.listen((Socket socket) &#123;</span><br><span class="line">    socket.listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; event) <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> msg = CommReq.fromBuffer(event).writeToJson();</span><br><span class="line"></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Received <span class="subst">$msg</span>'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> rsp = CommRsp.create();</span><br><span class="line">      rsp.cmd = <span class="number">0</span>;</span><br><span class="line">      rsp.result = <span class="number">0</span>;</span><br><span class="line">      rsp.uid = <span class="string">'41006'</span>;</span><br><span class="line">      <span class="comment">// socket.write(writeToBuffer);</span></span><br><span class="line">      socket.add(rsp.writeToBuffer());</span><br><span class="line">      socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SimpleClient</code> 向服务器端发送 Protobuf 数据 <code>CommReq</code>，并且接收和打印服务器端的响应。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'comm_conn.pb.dart'</span>;</span><br><span class="line"></span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  Socket socket = <span class="keyword">await</span> Socket.connect(<span class="string">'127.0.0.1'</span>, <span class="number">6760</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Connected'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// listen to the received data event stream</span></span><br><span class="line">  socket.listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; event) &#123;</span><br><span class="line">    <span class="built_in">print</span>(CommRsp.fromBuffer(event));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send hello</span></span><br><span class="line">  <span class="keyword">var</span> req = CommReq.create();</span><br><span class="line">  req.cmd = <span class="number">0</span>;</span><br><span class="line">  req.uid = <span class="string">'cm'</span>;</span><br><span class="line">  req.ext1 = <span class="string">'hello'</span>;</span><br><span class="line">  socket.add(req.writeToBuffer());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .. and close the socket</span></span><br><span class="line">  <span class="keyword">await</span> socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意以下两点：</p><ul><li>注意 Protobuf 数据字段分为 required 字段和 optional 字段</li><li>使用 <code>socket.add()</code> 发送数据而不是 <code>socket.write()</code>。注意 <code>socket.write()</code> 先对要发送的数据编码后再调用 <code>socket.add()</code>，实际发送的是编码后的数据</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> write(<span class="built_in">Object</span> obj) &#123;</span><br><span class="line">  <span class="built_in">String</span> string = <span class="string">'<span class="subst">$obj</span>'</span>;</span><br><span class="line">  <span class="keyword">if</span> (string.isEmpty) <span class="keyword">return</span>;</span><br><span class="line">  add(_encoding.encode(string));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何在 Dart 中创建和解析 Protobuf 数据，请参考<a href="https://developers.google.com/protocol-buffers/docs/reference/dart-generated" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单记录下如何在 Dart 中使用 Protobuf。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dart" scheme="http://www.sunmoonblog.com/tags/dart/"/>
    
  </entry>
  
</feed>
