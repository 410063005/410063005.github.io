<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sunmoon的博客</title>
  
  <subtitle>点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sunmoonblog.com/"/>
  <updated>2022-03-06T08:53:30.261Z</updated>
  <id>http://www.sunmoonblog.com/</id>
  
  <author>
    <name>Sunmoon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iTerm2快速ssh登录</title>
    <link href="http://www.sunmoonblog.com/2022/03/06/ssh-with-iterm2/"/>
    <id>http://www.sunmoonblog.com/2022/03/06/ssh-with-iterm2/</id>
    <published>2022-03-06T08:24:54.000Z</published>
    <updated>2022-03-06T08:53:30.261Z</updated>
    
    <content type="html"><![CDATA[<p>我有几台服务器。虽然均配置了ssh登录，但日常工作和学习中仍感觉登录服务器不免有些麻烦。如何配置iTerm2快速ssh登录呢？<br><a id="more"></a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>第一步，在 <code>~/.ssh</code> 目录下创建一个脚本，不妨脚本名为 <code>qcloud</code>。脚本文件内容如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect -f</span></span><br><span class="line"><span class="built_in">set</span> user root</span><br><span class="line"><span class="built_in">set</span> host 124.221.147.234</span><br><span class="line"><span class="built_in">set</span> timeout -5</span><br><span class="line">spawn ssh <span class="variable">$user</span>@<span class="variable">$host</span></span><br><span class="line">interact</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure><p>第二步，<code>command + ,</code> 打开 iTerm2 设置:</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/03/06/16465557145174.jpg" alt="-w986"></p><p>第三步，开始使用吧！</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/03/06/16465557915219.jpg" alt="-w920"></p><p>有没有感觉ssh登录效率小小地提高了。</p><p>如果你需要经常在命令行下切换到某个目录工作，也可以使用类似配置。比如，我的博客放在 <code>PublicCode/blog</code> 这个目录下，所以添加以下配置之后我可以直接从 <code>Profiles</code> &gt; <code>博客</code> 进入到指定目录。是不是方便多了?</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/03/06/16465561302286.jpg" alt="-w986"></p><p>此外，iTerm2还支持将Profiles导入导出，方便我们偷懒到底。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/03/06/16465563272988.jpg" alt="-w921"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/zhaoyawei/p/9285588.html" target="_blank" rel="noopener">Mac下使用iTerm2自动ssh登录服务器 - 轻叹花开花落的流年 - 博客园</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我有几台服务器。虽然均配置了ssh登录，但日常工作和学习中仍感觉登录服务器不免有些麻烦。如何配置iTerm2快速ssh登录呢？&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Puppeteer 使用小记</title>
    <link href="http://www.sunmoonblog.com/2021/11/07/use-puppeteer/"/>
    <id>http://www.sunmoonblog.com/2021/11/07/use-puppeteer/</id>
    <published>2021-11-07T14:05:42.000Z</published>
    <updated>2021-11-09T14:26:05.838Z</updated>
    
    <content type="html"><![CDATA[<p>Puppeteer 实战小记——教你如何使用 Puppeteer 来完成模拟登录+抓取数据。<br><a id="more"></a></p><h1 id="Puppeteer-简介"><a href="#Puppeteer-简介" class="headerlink" title="Puppeteer 简介"></a>Puppeteer 简介</h1><p>网上关于 <a href="https://github.com/puppeteer/puppeteer" target="_blank" rel="noopener">Puppeteer</a> 介绍资料很多，所以这里就不过多展开了。只说两点。</p><p>第一，与 Puppeteer 类似的技术很多，早期主要是 Phantom.js。不过随着Google 在 Chrome 59版本开始支持 headless 模式，Ariya Hidayat 决定放弃对 Phantom.js 的维护</p><p>我原本尝试使用 PhantomJS 完成模块登录和抓取数据工作，但遇到了一点问题(问题原因未深究)，随后果断换到 Puppeteer。</p><p>第二，Puppeteer 是一个提供高级别API的 Node 库，简化 headless Chrome 的使用。</p><blockquote><p>Puppeteer（Puppeteer is a Node library which provides a high-level API to control headless Chrome over the DevTools Protocol. It can also be configured to use full (non-headless) Chrome.）</p></blockquote><p>这张图展示了 Puppeteer 的全貌。</p><p><img src="/images/16362948442778.jpg" alt="-w783"></p><ul><li>Puppeteer 使用 DevTools 协议与浏览器通信</li><li>Browser 实例可以拥有多个浏览器上下文</li><li>BrowserContext 实例定义了一个浏览会话，并且可以拥有多个 Page</li><li>Page至少有一个框架：主框架。iframe 可能还会创建其他框架</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用 npm 安装 puppeteer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i puppeteer</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://www.baidu.com'</span>); <span class="comment">//打开百度</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h1 id="Puppeteer-实战"><a href="#Puppeteer-实战" class="headerlink" title="Puppeteer 实战"></a>Puppeteer 实战</h1><p>以下是获取某网站登录态的 Puppeteer 脚本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uname = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">const</span> pwd = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        headless: <span class="literal">false</span>,</span><br><span class="line">        ignoreHTTPSErrors: <span class="literal">true</span>,</span><br><span class="line">        defaultViewport: <span class="literal">false</span>,</span><br><span class="line">        devtools: <span class="literal">false</span>,</span><br><span class="line">        args: [<span class="string">'--disable-features=site-per-process'</span>]</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// page: 用于模拟登录流程</span></span><br><span class="line">    <span class="keyword">const</span> page = (<span class="keyword">await</span> browser.pages())[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开页面并跳转登录页</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://abc.xyz.com/v2/workbench/apps'</span>, &#123; <span class="attr">waitUntil</span>: <span class="string">"networkidle2"</span> &#125;); <span class="comment">// &lt;----- 问题1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到登录页中的frame</span></span><br><span class="line">    <span class="keyword">const</span> frame = page.frames().find(<span class="function"><span class="params">f</span> =&gt;</span> f.name() === <span class="string">'login_iframe'</span>); <span class="comment">// &lt;----- 问题2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到账号登录</span></span><br><span class="line">    <span class="keyword">const</span> ploginSelector = <span class="string">'a#switcher_login.link'</span>;</span><br><span class="line">    <span class="keyword">await</span> frame.waitForSelector(ploginSelector);</span><br><span class="line">    <span class="keyword">await</span> frame.click(ploginSelector);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始账号登录</span></span><br><span class="line">    <span class="keyword">await</span> frame.type(<span class="string">'#u'</span>, uname);</span><br><span class="line">    <span class="keyword">await</span> frame.type(<span class="string">'#p'</span>, pwd);</span><br><span class="line">    <span class="keyword">await</span> frame.click(<span class="string">'#login_button'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.waitForNavigation(&#123; <span class="attr">waitUntil</span>: <span class="string">'networkidle2'</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// page2页面中尝试获取登录token  &lt;----- 问题3</span></span><br><span class="line">    <span class="comment">//await page2.goto('https://abc.xyz.com/v2/workbench/apps');</span></span><br><span class="line">    <span class="comment">// page2.evaluate(function () &#123;</span></span><br><span class="line">    <span class="comment">//     debugger;  &lt;----- 问题4</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cookies = <span class="keyword">await</span> page.cookies(); <span class="comment">// &lt;----- 问题5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> c = <span class="string">''</span>;</span><br><span class="line">    cookies.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        c = c + v.name + <span class="string">'='</span> + v.value + <span class="string">'; '</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>脚本看起来还是简单易懂的。但实际开发过程中还是遇到了不少小坑：</p><h2 id="问题1：网页跳转"><a href="#问题1：网页跳转" class="headerlink" title="问题1：网页跳转"></a>问题1：网页跳转</h2><p>这个案例中要登录的网站是 OAuth 方式，所以登录过程中是有一次页面跳转的，从我们要访问的网页跳转到 OAuth 提供方的网页。</p><p>解决办法：<code>page.goto</code> 方法的 <code>waitUntil</code> 参数传 <code>networkidle2</code>。即，等待足够长的时间保证页面跳转完成</p><h2 id="问题2：无法找到页面元素"><a href="#问题2：无法找到页面元素" class="headerlink" title="问题2：无法找到页面元素"></a>问题2：无法找到页面元素</h2><p>这个其实不是问题，但对 iframe 不了解的话往往会踩到这个坑。实际的网页结构比较复杂，可能有多个 iframe。如果 Puppeteer 脚本中找到指定的 html 元素，不妨看看你要访问的元素是否在 iframe 中！</p><p>解决办法：<code>page.frames()</code> 返回当前页面中的所有 frame。</p><h2 id="问题3：Execution-context-was-destroyed"><a href="#问题3：Execution-context-was-destroyed" class="headerlink" title="问题3：Execution context was destroyed"></a>问题3：Execution context was destroyed</h2><p>如果你遇到以下报错，可以考虑使用另外一个 page 来规避问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Execution context was destroyed, most likely because of a navigation.</span><br></pre></td></tr></table></figure><p>出错这种报错的原因很可能是因为导航，具体解决方法可以参考 <a href="https://www.it1352.com/1107753.html" target="_blank" rel="noopener">Puppeteer执行上下文被破坏</a></p><h2 id="问题4：调试技巧"><a href="#问题4：调试技巧" class="headerlink" title="问题4：调试技巧"></a>问题4：调试技巧</h2><p>技巧一：插入 <code>debugger</code> 启动调试器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">page2.evaluate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>技巧二：<code>devtools</code> 传 <code>true</code> 时打开 DevTools</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const browser = await puppeteer.launch(&#123;</span><br><span class="line">    ...,</span><br><span class="line">    headless: false</span><br><span class="line">    devtools: true,</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="问题5：获取-cookie"><a href="#问题5：获取-cookie" class="headerlink" title="问题5：获取 cookie"></a>问题5：获取 cookie</h2><p>Puppeteer 模拟登录成功后可以获取网页登录态。登录态一般放在 cookie 中，使用 <code>page.cookies()</code> 获取页面 cookie (注意不是 <code>document.cookie</code>，这个无法返回 http only 的 cookie)</p><p>总结一下使用 Puppeteer 的大致步骤：</p><ul><li><a href="https://www.jianshu.com/p/e9db0baf781b" target="_blank" rel="noopener">CentOS 上安装 nodejs</a><ul><li><code>curl --silent --location https://rpm.nodesource.com/setup_12.x | sudo bash</code></li><li><code>yum -y install nodejs</code></li></ul></li></ul><ol><li>使用 npm 安装 Puppeteer。如果遇到安装错误可以参考<a href="https://www.cnblogs.com/ilizhu/p/14504049.html" target="_blank" rel="noopener">这里</a><ul><li><code>npm i puppeteer</code></li></ul></li><li>写 Puppeteer 脚本模拟登录，获取网站登录态。可以参考上面提供的脚本</li><li>写脚本访问网站的数据。这个因不同网站而异，这里不具体展开</li><li>crontab 定时抓取数据。使用 crontab 时我经常把脚本路径弄错，注意 <a href="https://blog.csdn.net/qq_36743482/article/details/83616436" target="_blank" rel="noopener">crontab 路径问题</a><ul><li><code>crontab -e</code> 设置定时任务</li></ul></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/cangqinglang/p/14588014.html" target="_blank" rel="noopener">谈谈 Puppeteer - 苍青浪 - 博客园</a></li><li><a href="https://zhuanlan.zhihu.com/p/33015883" target="_blank" rel="noopener">phantomJs之殇，chrome-headless之生 - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/137922030" target="_blank" rel="noopener">Phantomjs、Selenium之后浪Puppeteer - 知乎</a></li><li><a href="https://github.com/puppeteer/puppeteer/tree/main/examples" target="_blank" rel="noopener">puppeteer/examples at main · puppeteer/puppeteer · GitHub</a></li><li><a href="http://www.puppeteerjs.com/" target="_blank" rel="noopener">Puppeteer v10.4.0</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Puppeteer 实战小记——教你如何使用 Puppeteer 来完成模拟登录+抓取数据。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记一次 _objc_retain 崩溃分析</title>
    <link href="http://www.sunmoonblog.com/2021/08/08/objc-retain-crash/"/>
    <id>http://www.sunmoonblog.com/2021/08/08/objc-retain-crash/</id>
    <published>2021-08-08T02:13:17.000Z</published>
    <updated>2021-08-08T09:05:48.469Z</updated>
    
    <content type="html"><![CDATA[<p>最近收到 iOS 上一个偶现的 <code>SIGSEGV SEGV_ACCERR</code> 崩溃。错误信息显示该崩溃发生在 <code>_objc_retain</code> 方法，让我困惑了很久。经过分析，发现看似内存问题，实则线程问题。<br><a id="more"></a></p><h1 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h1><p>一条典型的错误如下：</p><!-- https://bugly.qq.com/v2/crash-reporting/crashes/9067e7d4ff/2334154/report?pid=2&crashDataType=unSystemExit&start=40 --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 libobjc.A.dylib       _objc_retain + 16</span><br><span class="line">1 AbcDriver_Example     -[AbcRecorder startRecordWithType:] (AbcLocationRecorder.m:151)</span><br><span class="line">2 AbcDriver_Example     __40-[AbcLocationReporter onCollectTimer:]_block_invoke (AbcLocationReporter.m:0)</span><br><span class="line">3 Foundation            ___NSBLOCKOPERATION_IS_CALLING_OUT_TO_A_BLOCK__ + 16</span><br><span class="line">4 Foundation            -[NSBlockOperation main] + 100</span><br><span class="line">5 Foundation            ___NSOPERATION_IS_INVOKING_MAIN__ + 20</span><br><span class="line">6 Foundation            -[NSOperation start] + 784</span><br><span class="line">7 Foundation            ___NSOPERATIONQUEUE_IS_STARTING_AN_OPERATION__ + 20</span><br><span class="line">8 Foundation            ___NSOQSchedule_f + 180</span><br></pre></td></tr></table></figure><p>显示错误发生在 <code>AbcLocationRecorder.m</code> 第151行。第151行代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbcLocationSample *locationSample = [self prepareDataFromAbcLocation:self.latestLocation regeocode:nil];</span><br></pre></td></tr></table></figure><p>代码看起来没有任何问题，也很难将其跟 <code>_objc_retain</code> 方法联系起来。</p><h1 id="类似案例"><a href="#类似案例" class="headerlink" title="类似案例"></a>类似案例</h1><p>处理 iOS 崩溃的经验不多，所以先在网上找了一圈看是否有人遇到类似问题，还果真找到了。</p><h2 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h2><p><a href="https://www.cnblogs.com/song-jw/p/11691715.html" target="_blank" rel="noopener">iOS崩溃分析 - Lightning_S - 博客园</a> 提到了两个崩溃。</p><p>一个是 <code>objc_release</code>，错误如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0  libobjc.A.dylib                0x1b394f150 objc_release + 16</span><br><span class="line">1  _appstore                      0x10184b694 -[YNP_VRHomeCoreViewModel voiceRoomDidChangeSpeakingUser:] + 373 (YNP_VRHomeCoreViewModel.m:373)</span><br><span class="line">2  Aipai_appstore                 0x1015a6144 __63-[YNP_VoiceRoomManager makeDelegatesPerformSelector:obj:async:]_block_invoke + 1633 (YNP_VoiceRoomManager.m:1633)</span><br></pre></td></tr></table></figure><p>另一个是 <code>objc_retain</code>，错误如下：</p><p><img src="/images/16283922797911.jpg" alt></p><p>文章的结论是：</p><ul><li>以上崩溃都是对象引用计数变化时没有正确加锁(线程不安全)导致</li><li>编译器在代码中插入 <code>objc_retainAutoreleasedReturnValue</code>，所以错误日志中会看到 <code>_objc_retain</code></li></ul><h2 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h2><p><a href="https://www.jianshu.com/p/298c69ce33b2" target="_blank" rel="noopener">从一个crash分析到苹果的代码问题 - 简书</a> 提到属性被声明为 <code>nonatomic</code> 时，当对象在一个线程中释放了，另一个线程访问时就可能出问题。</p><p>至于 <code>nonatomic</code> 的线程安全问题，原因如下：</p><blockquote><p>nonatomic取到函数地址后，直接返回指针指向的值，如果这时 *slot 正好被释放，那么返回的就是一个错误的值<br>而atomic会先retain，然后放到自动释放池，这样就能保证返回的对象一定不会被释放</p></blockquote><p>这里直接贴上相关的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) &#123;</span><br><span class="line">    if (offset == 0) &#123;</span><br><span class="line">        return object_getClass(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Retain release world</span><br><span class="line">    id *slot = (id*) ((char*)self + offset);</span><br><span class="line">    if (!atomic) return *slot;</span><br><span class="line">        </span><br><span class="line">    // Atomic retain release world</span><br><span class="line">    spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();</span><br><span class="line">    id value = objc_retain(*slot);</span><br><span class="line">    slotlock.unlock();</span><br><span class="line">    </span><br><span class="line">    // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span><br><span class="line">    return objc_autoreleaseReturnValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h1><p>看过两个类似案例，再来分析自己的问题就有头绪了。出错的第151行代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 主线程中读 self.latestLocation</span><br><span class="line">AbcLocationSample *locationSample = [self prepareDataFromAbcLocation:self.latestLocation regeocode:nil];</span><br></pre></td></tr></table></figure><p>我们很自然地把怀疑目标锁定在 <code>self.latestLocation</code> 这里。<code>latestLocation</code> 属性定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface AbcLocationRecorder () &lt;AbcLocationManagerDelegate&gt;</span><br><span class="line">// latestLocation 访问修饰符为 nonatomic</span><br><span class="line">@property (nonatomic, strong) AbcLocation *latestLocation;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>位置更新时通过如下回调来更新 <code>self.latestLocation</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)mapLocationManager:(AbcLocationManager *)manager didUpdateLocations:(NSArray&lt;AbcLocation *&gt; *)locations &#123;</span><br><span class="line">    if (locations.count &gt; 0) &#123;</span><br><span class="line">        AbcLocation* location = [locations firstObject];</span><br><span class="line">        AbcLog_C(@&quot;定位坐标: %f, %f&quot;, location.location.coordinate.latitude, location.location.coordinate.longitude);</span><br><span class="line">        // 子线程中写 self.latestLocation</span><br><span class="line">        self.latestLocation = location;</span><br><span class="line">        AbcLOCATION_UNLOCK(self.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下：</p><ul><li>latestLocation 访问修饰符为 <code>nonatomic</code></li><li>主线程中读 <code>self.latestLocation</code></li><li>子线程中写 <code>self.latestLocation</code></li><li><font color="red">读写 <code>self.latestLocation</code> 没有加锁！</font></li></ul><p>前面提到这个 <code>SIGSEGV SEGV_ACCERR</code> 崩溃在我们 App 中是偶现的，Bugly 上有不少上报，但实际中跟进问题时却一次也没复现。怎么办？</p><p>我们写个 demo 吧。demo 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong) AbcLocation *latestLocation;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)testFun2</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;queue1&quot;, 0);</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;queue2&quot;, 0);</span><br><span class="line">    dispatch_queue_t queue3 = dispatch_queue_create(&quot;queue3&quot;, 0);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue1, ^&#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2f];</span><br><span class="line">            //@synchronized (self) &#123;</span><br><span class="line">                NSLog(@&quot;last location %@&quot;, self.latestLocation);</span><br><span class="line">            //&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue3, ^&#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2f];</span><br><span class="line">            //@synchronized (self) &#123;</span><br><span class="line">                NSLog(@&quot;last location %@&quot;, self.latestLocation);</span><br><span class="line">            //&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue2, ^&#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //@synchronized (self) &#123;</span><br><span class="line">                self.latestLocation = [[AbcLocation alloc] init];</span><br><span class="line">            //&#125;</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2f];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>运行几次很快就会产生崩溃。找到复现方法后，解决问题就很简单了。多线程读写 <code>self.latestLocation</code> 属性中正确地加锁，保证线程安全就能避免崩溃。</p><h1 id="更多知识"><a href="#更多知识" class="headerlink" title="更多知识"></a>更多知识</h1><p>网上寻找相似案例，是为了快速弄清问题原因。写demo是为了快速找到问题复现方法和解决办法。但我们不能就此止步，因为很多问题还可以更深入。</p><h2 id="objc-autoreleaseReturnValue-和-objc-retainAutoreleasedReturnValue"><a href="#objc-autoreleaseReturnValue-和-objc-retainAutoreleasedReturnValue" class="headerlink" title="objc_autoreleaseReturnValue 和 objc_retainAutoreleasedReturnValue"></a>objc_autoreleaseReturnValue 和 objc_retainAutoreleasedReturnValue</h2><blockquote><p>编译器在代码中插入 <code>objc_retainAutoreleasedReturnValue</code>，所以错误日志中会看到 <code>_objc_retain</code></p></blockquote><p>那什么是 <code>objc_autoreleaseReturnValue</code> 呢？</p><p>在 MRC 的环境里有以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// MRC</span><br><span class="line">+ (id) array &#123;</span><br><span class="line">    return [[NSMutableArray alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道内存分配的原则是”谁分配，谁释放”。这个原则让上述代码很为难，</p><ul><li>不能在 return 之前释放，因为分配出来的对象还没交给调用方法使用</li><li>也不可能在 return 之后释放，因为 return 之后作为分配方没法负责释放了(没有对象指针)</li></ul><p>所以需要将分配出来的对象注册到自动释放池，也延迟释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// MRC</span><br><span class="line">+ (id) array &#123;</span><br><span class="line">    return [[[NSMutableArray alloc] init] autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ARC 为我们自动调用了 <code>autorelease</code> 和 <code>retain</code> 两个方法 (自动释放)。考虑到兼容 MRC 时，ARC 自动调用 <code>autorelease</code> 和 <code>retain</code> 两个方法会带来不必要的开销，所以 ARC 使用 <code>objc_autoreleaseReturnValue</code> 和<br><code>objc_retainAutoreleasedReturnValue</code> 对多余操作优化，以提升性能优化。</p><hr><p><a href="https://www.galloway.me.uk/2012/02/how-does-objc_retainautoreleasedreturnvalue-work/" target="_blank" rel="noopener">How does objc_retainAutoreleasedReturnValue work? - Matt Galloway</a> 中对 <code>objc_retainAutoreleasedReturnValue</code> 有更多解释。这里挑关键点翻译出来。</p><p><code>objc_retainAutoreleasedReturnValue</code> 背后的思路是这样的：如果一个函数返回的对象是 autoreleased 的，并且接下来的对这个对象执行的操作是 <code>retain</code>，那么这里的 <code>autorelease</code> 和 <code>retain</code> 完全是无意义的，不过是在浪费 CPU 时间。如果某些情况下我们可以检测出这种情况，就能节省CPU时间。在App整个运行期间，节省的CPU时间累计下来就是个不小的优化。</p><p><a href="http://www.opensource.apple.com/source/objc4/objc4-493.9/runtime/objc-arr.mm" target="_blank" rel="noopener">Apple’s code</a>提到：</p><blockquote><p>objc_autoreleaseReturnValue() 检查 return 之后调用方的指令。如果调用方是立即调用 objc_retainAutoreleasedReturnValue，则被调用方不会做 autorelease 操作，而是将结果以 thread-local 方式保存。如果调用方并没有调用 objc_retainAutoreleasedReturnValue，则被调用方会做 autorelease 操作。<br>objc_retainAutoreleasedReturnValue 会检查返回值是否跟 thread-local 变量中保存的值一致。如果一致，则直接返回结果。如果不一致，则会执行一次 autorelease 和 retain。无论哪种方式，调用方都能拿到一个 retained reference</p></blockquote><p>考虑你有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (SomeClass*)createMeAnObject &#123;</span><br><span class="line">   SomeClass *obj = [[SomeClass alloc] init];</span><br><span class="line">   obj.string = @&quot;Badger&quot;;</span><br><span class="line">   obj.number = 10;</span><br><span class="line">   return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        self.myObject = [self createMeAnObject];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以重写以上代码，重写后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (SomeClass*)createMeAnObject &#123;</span><br><span class="line">   SomeClass *obj = [[SomeClass alloc] init];</span><br><span class="line">   obj.string = @&quot;Badger&quot;;</span><br><span class="line">   obj.number = 10;</span><br><span class="line">   return [obj autorelease];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        [myObject release];</span><br><span class="line">        SomeClass *temp = [self createMeAnObject];</span><br><span class="line">        myObject = [temp retain];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将 <code>createMeAnObject</code> 内联到 <code>init</code>，则代码变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        [myObject release];</span><br><span class="line">        SomeClass *temp = [[SomeClass alloc] init];</span><br><span class="line">        obj.string = @&quot;Badger&quot;;</span><br><span class="line">        obj.number = 10;</span><br><span class="line">        [temp autorelease];</span><br><span class="line">        myObject = [temp retain];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意以上代码中 <code>[temp autorelease]</code> 后紧接着一个 <code>[temp retain]</code>。这正是新的 Objective-C 运行时可以优化的一个点。</p><p>(译者注：有很多细节的分析，这里略过) 编译一个调用 <code>objc_autoreleaseReturnValue()</code> 和 <code>objc_retainAutoreleasedReturnValue()</code> 的方法时，编译器会添加如下指令作为标记。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thumb mode:</span><br><span class="line">f7ffef56   blx  _objc_msgSend</span><br><span class="line">    463f  mov  r7, r7</span><br><span class="line">f7ffef54   blx  _objc_retainAutoreleasedReturnValue</span><br><span class="line"></span><br><span class="line">ARM mode:</span><br><span class="line">ebffffa0   bl   _objc_msgSend</span><br><span class="line">e1a07007   mov  r7, r7</span><br><span class="line">ebffff9e   bl   _objc_retainAutoreleasedReturnValue</span><br></pre></td></tr></table></figure><p>无论哪种模式，编译器均会添加 <code>mov r7, r7</code>这条看似无任何意义的指令(它将 r7 寄存器的值 move 到 r7寄存器)。不过这条指令是有意义的，编译器将它作为标识，用于告知 <code>objc_autoreleaseReturnValue</code> 方法：调用方接下来会调用 <code>objc_retainAutoreleasedReturnValue</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">id objc_autoreleaseReturnValue(id object) &#123;</span><br><span class="line">    if (thumb_mode &amp;&amp; next_instruction_after_return == 0x463f ||</span><br><span class="line">        arm_mode   &amp;&amp; next_instruction_after_return == 0xe1a07007)</span><br><span class="line">    &#123;</span><br><span class="line">        set_flag(object);</span><br><span class="line">        return object;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return objc_autorelease(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id objc_retainAutoreleasedReturnValue(id object) &#123;</span><br><span class="line">    if (get_flag(object)) &#123;</span><br><span class="line">        clear_flag();</span><br><span class="line">        return object;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return objc_retain(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：以上是伪代码，x86 版本的代码见<a href="https://opensource.apple.com/source/objc4/objc4-493.9/runtime/objc-arr.mm" target="_blank" rel="noopener">这里</a>。</p><p>总结一下：ARC 出现之前，我们不得不在代码中写 autorelease 和 retain。ARC 出现之后，虽然不用再写 autorelease 和 retain，但是遗留代码中的 autorelease 和 retain 会导致很多冗余操作，<code>objc_autoreleaseReturnValue</code> 和 <code>objc_retainAutoreleasedReturnValue</code> 正是为了应对这些冗余操作的优化。</p><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/2f05060fa377?spm=a2c4e.11153940.blogcont690541.7.575f3c89jeD8IS" target="_blank" rel="noopener">objc_autoreleaseReturnValue和objc_retainAutoreleasedReturnValue函数对ARC的优化 - 简书</a></li><li><a href="https://www.galloway.me.uk/2012/02/how-does-objc_retainautoreleasedreturnvalue-work/" target="_blank" rel="noopener">How does objc_retainAutoreleasedReturnValue work? - Matt Galloway</a></li><li><a href="https://opensource.apple.com/source/objc4/objc4-493.9/runtime/objc-arr.mm" target="_blank" rel="noopener">https://opensource.apple.com/source/objc4/objc4-493.9/runtime/objc-arr.mm</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近收到 iOS 上一个偶现的 &lt;code&gt;SIGSEGV SEGV_ACCERR&lt;/code&gt; 崩溃。错误信息显示该崩溃发生在 &lt;code&gt;_objc_retain&lt;/code&gt; 方法，让我困惑了很久。经过分析，发现看似内存问题，实则线程问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.sunmoonblog.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>关于 OC 中的 @weakify</title>
    <link href="http://www.sunmoonblog.com/2021/07/20/oc-weakify/"/>
    <id>http://www.sunmoonblog.com/2021/07/20/oc-weakify/</id>
    <published>2021-07-20T05:59:40.000Z</published>
    <updated>2021-07-20T08:56:21.864Z</updated>
    
    <content type="html"><![CDATA[<p>关于 <code>@weakify</code> 和 <code>@strongify</code> 的一些小知识。<br><a id="more"></a> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">block = ^() &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">block = ^()&#123;</span><br><span class="line">    __strong typeof(weakSelf) self = weakSelf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://halfrost.com/ios_block_retain_circle/#toc-12" target="_blank" rel="noopener">https://halfrost.com/ios_block_retain_circle/#toc-12</a></p><p><a href="https://www.jianshu.com/p/bc794fa07167" target="_blank" rel="noopener">https://www.jianshu.com/p/bc794fa07167</a></p><p><a href="https://stackoverflow.com/questions/28305356/ios-proper-use-of-weakifyself-and-strongifyself" target="_blank" rel="noopener">https://stackoverflow.com/questions/28305356/ios-proper-use-of-weakifyself-and-strongifyself</a></p><p>How @strongify works<br>After @strongify is called, self will have a different pointer address inside the block than it will outside the block. That’s because @strongify declares a new local variable called self each time. (This is why it suppresses the -Wshadow warning, which will “warn whenever a local variable shadows another local variable.”) It’s worth reading and understanding the implementation of these functions. So even though the names are the same, treat them as separate strong references.</p><p>Using @strongify in your code</p><ul><li>(void)someMethod {<br>  if (self.someBOOL) {<pre><code>@weakify(self);_someObjectInstanceVar = [Object objectWithCompletionHandler:^{    @strongify(self);    // self reference #1    if (self.someProperty) {        @weakify(self);        // self reference #2        [[Async HTTPRequest] sendAWithID:self.property.id completionHandler:^(void (^)(NewObject *newObject) {            @strongify(self);            // self reference #3            @weakify(self);            [self showViewWithObject:newObject handler:^{                // self reference #4                @strongify(self);                [self reloadData];            }];        }];    }}];</code></pre>  // etc…<br>}</li></ul><p>However, remember that after your first use of @strongify, self will refer to local, stack variables. These will typically get destroyed when the scope in which they’re defined ends (as long as you aren’t storing them to properties or using them in a nested block). So based on the code you showed, you only need it after // self reference #1.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 &lt;code&gt;@weakify&lt;/code&gt; 和 &lt;code&gt;@strongify&lt;/code&gt; 的一些小知识。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>提升 AppCode 性能的几个小技巧</title>
    <link href="http://www.sunmoonblog.com/2021/05/01/enhance-appcode-performane/"/>
    <id>http://www.sunmoonblog.com/2021/05/01/enhance-appcode-performane/</id>
    <published>2021-05-01T09:18:18.000Z</published>
    <updated>2021-11-07T13:17:58.166Z</updated>
    
    <content type="html"><![CDATA[<p>AppCode 好用是好用，但这性能比起 Xcode 让人很无语。不过，AppCode 的性能是可以优化的。<br><a id="more"></a></p><p>最近的开发过程中发现 AppCode 占了 5GB 内存却仍然卡得干不了活，忍无可忍之下了解了一下如何优化 AppCode 性能。主要的参考资料来自 AppCode 官网。</p><ul><li><a href="https://www.jetbrains.com/help/objc/performance-tuning-tips.html" target="_blank" rel="noopener">Enhance performance | AppCode</a></li></ul><p>资料中提到几个点总结下来就是：</p><ul><li>加大 AppCode 内存</li><li>提升 AppCode code analysis﻿ 速度</li><li>提升 AppCode indexing﻿ 速度</li><li>关闭不必要的 Plugin</li></ul><h1 id="加大内存"><a href="#加大内存" class="headerlink" title="加大内存"></a>加大内存</h1><h2 id="打开内存指示器"><a href="#打开内存指示器" class="headerlink" title="打开内存指示器"></a>打开内存指示器</h2><p>AppCode 卡顿的一个主要原因是堆内存过低。所以我们很<em>有必要打开 AppCode 内存指示器</em>。</p><p>在 AppCode 底部状态上右键点击后出现如下菜单，勾选 “Memory Indicator” 即可打开内存指示器。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198615366659.jpg" alt="-w267"></p><p>我的内存指示器已打开，显示 “264 of 6131M”。内存状态良好。</p><p>注意：当可用的堆内存大小低于最大堆内存的5%时，会有低内存告警。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198618640390.jpg" alt></p><h2 id="加大堆内存"><a href="#加大堆内存" class="headerlink" title="加大堆内存"></a>加大堆内存</h2><p>从 AppCode 顶部菜单中 <strong>Help | Change Memory Settings</strong> 调整堆内存大小。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198617067248.jpg" alt="-w875"></p><p>我的 MacBook 内存大小 16G，已经给 AppCode 分了 6144 MB。已经相当奢侈，不能再加了。(即便 6G 内存，AppCode 还是卡，所以就我遇到的问题而言，瓶颈并不在内存)</p><h1 id="提升代码分析速度"><a href="#提升代码分析速度" class="headerlink" title="提升代码分析速度"></a>提升代码分析速度</h1><blockquote><p>On-the-fly code analysis is one of the most performance-consuming processes in AppCode.</p></blockquote><p>AppCode 的实时代码检查过程是最吃电脑性能的一个过程。针对这个问题，我们可以对实时代码检查进行配置，减少检查过程的性能消耗。</p><p>简单来说，就是减少实时代码检查甚至干脆不要实时检查(等要要检查时再启动)。</p><h2 id="调整代码检查项"><a href="#调整代码检查项" class="headerlink" title="调整代码检查项"></a>调整代码检查项</h2><p>AppCode 默认状态下会打开全部的检查类型(作者：不卡才怪？)，我们可以根据自己的需要进行调整。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198622243684.jpg" alt="-w992"></p><p>其实我们可以放心大胆地全关，因为完全可以在需要时通过 <strong>Code | Inspect Code</strong> 命令来检查。</p><h2 id="调整检查级别"><a href="#调整检查级别" class="headerlink" title="调整检查级别"></a>调整检查级别</h2><p>此外，还可以使用 <strong>Code | Configure Current File Analysis</strong> 命令调整当前已打开文件的检查级别。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198625862232.jpg" alt></p><p>分三种级别：</p><ul><li>None - 不检查</li><li>Syntax - 语法检查</li><li>Inspections - 检查</li></ul><p>不过个人感觉这个功能不太实用。</p><h1 id="提升索引速度"><a href="#提升索引速度" class="headerlink" title="提升索引速度"></a>提升索引速度</h1><p>AppCode 对文件进行索引(代码检查、代码自动补全、代码生成、自动导入功能依赖索引)。不过，不索引那些包含二进制文件、日志以及构建产物的目录并不会影响 AppCode 的代码检查等功能，所以进行索引时我们完全可以将这些目录排除。</p><p>另外，某些文件因过太大或是位于远程机器，索引的代价非常大。所以也应将这些文件排除在外。</p><p>排除文件或目录的方法很简单，在 <strong>Project</strong> 窗口将工程切换到 <strong>Files</strong> 视图，右击想要排除的文件，然后选择 <strong>Mark Directory as | Excluded</strong> </p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198705760997.jpg" alt="-w321"></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198713192648.jpg" alt></p><hr><p>回到前面我提到分配6G内存的情况下 AppCode 仍然卡顿的问题，发现卡顿时 AppCode 一直在索引。检查后发现 <font color="red">AppCode 打开该工程后，索引范围是当前用户的所有文件</font>(即整个 <code>/Users/username/</code> 目录。发现 AppCode 打开其他工程时只会索引当前工程目录中的文件，所以这是 AppCode 的 bug？)。对数量巨大的文件进行索引，几个小时也完成不了吧？</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198709164361.jpg" alt="-w318"></p><p>解决办法：果断排除掉不相关的目录，减少索引时间。</p><h1 id="其他优化技巧"><a href="#其他优化技巧" class="headerlink" title="其他优化技巧"></a>其他优化技巧</h1><p>另外一些优化手段包括：</p><ul><li>关闭 AppCode 中不必要的插件。AppCode 默认加载了很多插件，我们可以关闭不需要的插件以减少内存占用、提升速度</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198717657700.jpg" alt></p><ul><li>保证 AppCode 和 Xcode 版本兼容。如下图，这是我自己遇到的一个情况：AppCode 提示当前 Xcode 版本为 12.4，版本过高。</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198716155390.jpg" alt="-w967"></p><p>不清楚到底有什么影响，不过还是升级到跟 Xcode 12.4 兼容的 AppCode。如下图，AppCode 和 Xcode 兼容时，没有上述的警告。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198719580894.jpg" alt="-w898"></p><ul><li>Download Xcode caches﻿。如下图，勾选这里的 Download Xcode cacheds automatically，某些情况下能提升索引性能。(作者：按官方解释，这里的”某些情况”其实并不多，主要是指升级 Xcode 的情况)</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198720197701.jpg" alt="-w898"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一番折腾之后，AppCode 速度果然上来了。虽然 AppCode 响应速度相对 Xcode 还是有些差距，不过考虑到 AppCode 强大的重构功能还是非常值得使用的！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AppCode 好用是好用，但这性能比起 Xcode 让人很无语。不过，AppCode 的性能是可以优化的。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.sunmoonblog.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>20210306 问题小记</title>
    <link href="http://www.sunmoonblog.com/2021/03/06/variables-debug-info/"/>
    <id>http://www.sunmoonblog.com/2021/03/06/variables-debug-info/</id>
    <published>2021-03-06T01:52:30.000Z</published>
    <updated>2021-05-01T08:59:04.746Z</updated>
    
    <content type="html"><![CDATA[<p>最近对某些第三方Android库做简单的逆向分析。遇到两个问题，记录之。  </p><a id="more"></a><h1 id="Variables-debug-info-not-available"><a href="#Variables-debug-info-not-available" class="headerlink" title="Variables debug info not available"></a>Variables debug info not available</h1><p>Android Studio 中断点调试某些第三方 Android 库提示 Variables debug info not available，无法查看局部变量信息。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16149956735267.jpg" alt></p><p>找到以下资料 <a href="https://stackoverflow.com/questions/1313922/step-through-jdk-source-code-in-intellij-idea" target="_blank" rel="noopener">来源</a></p><blockquote><p>Java classes which are part of the JDK are compiled without debug info for the size and performance reasons.</p></blockquote><p>简单来说是提到出于大小和性能因素考虑，JDK 中的类是不带 debug 信息的。</p><p>类似地，很多第三方 Android 库使用 proguard 等工具混淆和优化后也去掉了 debug 信息，所以调试时无法查看局部变量信息(不过可以查看成员变量信息)。</p><h1 id="无法创建-ScanResult-实例"><a href="#无法创建-ScanResult-实例" class="headerlink" title="无法创建 ScanResult 实例"></a>无法创建 ScanResult 实例</h1><p>通常来说，我们会使用 Android 系统 API 获取 <a href="https://android.googlesource.com/platform/frameworks/base/+/5bab9da/wifi/java/android/net/wifi/ScanResult.java" target="_blank" rel="noopener">android.net.wifi.ScanResult</a> 的实例。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ScanResult&gt; list = wifiManager.getScanResults();</span><br></pre></td></tr></table></figure><p>有时出于某些原因，需要创建 <code>android.net.wifi.ScanResult</code> 实例。一开始，我以为这很简单。</p><p>思路一，直接调用构造方法创建实例不就可以了吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScanResult sr = <span class="keyword">new</span> ScanResult();</span><br><span class="line"></span><br><span class="line">ScanResult sr2 = <span class="keyword">new</span> ScanResult(sr);</span><br></pre></td></tr></table></figure><p>但实际上在 Android SDK 30 (Android 11) 之前，没有这两个构造方法。</p><ul><li><a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/android10-dev/wifi/java/android/net/wifi/ScanResult.java" target="_blank" rel="noopener">ScanResult android 10</a></li><li><a href="https://android.googlesource.com/platform/frameworks/base/+/android-6.0.1_r25/wifi/java/android/net/wifi/ScanResult.java" target="_blank" rel="noopener">ScanResult android 6</a></li></ul><p>在低版本 Android 设备上直接调用 <code>ScanResult</code> 构造方法会报 <code>java.lang.NoSuchMethodError</code> 错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2021-03-06 11:15:48.458 22161-22161/? E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">    Process: com.example.amaploc.demo, PID: 22161</span><br><span class="line">    java.lang.NoSuchMethodError: No direct method &lt;init&gt;()V in class Landroid/net/wifi/ScanResult; or its super classes </span><br><span class="line">    (declaration of &apos;android.net.wifi.ScanResult&apos; appears in /system/framework/framework.jar!classes2.dex)</span><br></pre></td></tr></table></figure><p>思路二，直接调用 <code>ScanResult</code> 构造方法行不通(低版本兼容问题)，那使用反射方式调用呢？但同样遇到兼容性问题：</p><ol><li>不同版本的 SDK 上非公开的构造方法参数不同</li><li>某些厂商可能修改了 <code>ScanResult</code> 构造方法</li></ol><p>思路三，考虑到 <code>ScanResult</code> 实现了 <code>Parcelable</code> 接口，所以可以借助 <code>Parcel</code> 来序列化/反序列化已有的 <code>ScanResult</code> 来生成新的 <code>ScanResult</code> 实例。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198583514111.jpg" alt="-w709"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ScanResult <span class="title">scanResultInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ScanResult parent = sCopyInstance;</span><br><span class="line"></span><br><span class="line">    Parcel p = Parcel.obtain();</span><br><span class="line">    parent.writeToParcel(p, <span class="number">0</span>);</span><br><span class="line">    p.setDataPosition(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ScanResult.CREATOR.createFromParcel(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单又完美地创建 ScanResult 实例</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/1313922/step-through-jdk-source-code-in-intellij-idea" target="_blank" rel="noopener">debugging - Step through JDK source code in IntelliJ IDEA - Stack Overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近对某些第三方Android库做简单的逆向分析。遇到两个问题，记录之。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.sunmoonblog.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>HTTP抓包小记</title>
    <link href="http://www.sunmoonblog.com/2021/02/18/http-cap/"/>
    <id>http://www.sunmoonblog.com/2021/02/18/http-cap/</id>
    <published>2021-02-18T02:01:02.000Z</published>
    <updated>2021-02-19T04:22:40.077Z</updated>
    
    <content type="html"><![CDATA[<p>最近处理一些对第三方应用中HTTPS请求抓包工作。杂七杂八挺烦琐，又容易遗忘。记录之，备不时之需。<br><a id="more"></a></p><h1 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h1><p>抓包工具有很多，选一个顺手的就行。我用的是 whistle。启动方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">whistle run</span><br><span class="line">[i] whistle@2.6.3 started</span><br><span class="line">[i] 1. use your device to visit the following URL list, gets the IP of the URL you can access:</span><br><span class="line">       http://127.0.0.1:8899/</span><br><span class="line">       http://172.30.209.45:8899/</span><br><span class="line">       http://172.20.209.88:8899/</span><br><span class="line">       Note: If all the above URLs are unable to access, check the firewall settings</span><br><span class="line">             For help see https://github.com/avwo/whistle</span><br><span class="line">[i] 2. configure your device to use whistle as its HTTP and HTTPS proxy on IP:8899</span><br><span class="line">[i] 3. use Chrome to visit http://local.whistlejs.com/ to get started</span><br><span class="line">Press [Ctrl+C] to stop whistle...</span><br></pre></td></tr></table></figure><p>启动后直接在浏览器中打开对应地址开始抓包。</p><h1 id="HTTPS-抓包"><a href="#HTTPS-抓包" class="headerlink" title="HTTPS 抓包"></a>HTTPS 抓包</h1><p>抓 HTTP 一般不会遇到什么问题，这里要说的主要是 HTTPS 抓包时遇到的问题。</p><h2 id="问题一：Android-iOS安装和信任证书"><a href="#问题一：Android-iOS安装和信任证书" class="headerlink" title="问题一：Android/iOS安装和信任证书"></a>问题一：Android/iOS安装和信任证书</h2><ul><li>Android 直接下载后从 SD 卡安装即可。安装成功后在<code>设置 &gt; 受信任的凭据 &gt; 用户</code>中查看</li><li>iOS 使用 Safari 浏览器打开证书链接来安装。安装成功后在<code>设置 &gt; 通用 &gt; 描述文件与设备管理</code>中查看。注意iOS上需要手动设置信任第三方证书</li></ul><p><img src="/images/16136148646757.jpg" alt="-w336"></p><p><img src="/images/16136152558859.jpg" alt="-w396"></p><p><img src="/images/16136153959387.jpg" alt="-w426"></p><p>经过如上设置后，可以抓到部分应用中的 HTTPS 请求了。但另一些应用的 HTTPS 请求，仍然无法抓取。大致可以归纳为两种原因(<a href="https://www.cnblogs.com/lulianqi/p/11380794.html#_label2" target="_blank" rel="noopener">部分APP无法代理抓包的原因及解决方法（flutter 抓包）</a>一文总结得不错)：</p><ul><li>HTTP 客户端没有走系统代理。这种情况比较少见，一个典型的例子是 Flutter</li><li>HTTP 客户端不信任第三方证书。这种情况比较多见，例如 Android 平台上滴滴出行、微信(7.0版本之后)</li></ul><p>接下来看Android系统中如何避免应用不信任第三方证书。</p><h2 id="问题二：应用不信任第三方证书"><a href="#问题二：应用不信任第三方证书" class="headerlink" title="问题二：应用不信任第三方证书"></a>问题二：应用不信任第三方证书</h2><p>两个解决办法：</p><ul><li>模拟器(开启root) + 安装系统证书</li><li>真机(无root) +  <a href="https://vxposed.com/" target="_blank" rel="noopener">VirtualXposed</a> + JustTrustMe</li></ul><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>有多种模拟器可供选择。这里推荐两个自带root功能，并且可成功运行大部分主流应用的模拟器。</p><ul><li>Windows 上可以使用夜神模拟器</li><li>Mac 上可以使用 <a href="http://mumu.163.com/help/func/20190129/30131_797867.html" target="_blank" rel="noopener">MuMu模拟器</a></li></ul><p>第一步，将whistle 证书下载到电脑上，名字是 <code>root.crt</code>。执行如下命令得到类似 <code>b4a43da9</code> 这样的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -subject_hash_old -in getssl.crt</span><br></pre></td></tr></table></figure><p>第二步，将 <code>root.crt</code> 重命名成 <code>b4a43da9.0</code>，安装到模拟器上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push b4a43da9.0 /system/etc/security/cacerts/</span><br></pre></td></tr></table></figure><p>第三步，<code>设置 &gt; 受信任的凭据 &gt; 系统</code>中检查证书是否安装成功。</p><p>将 whistle 证书安装成系统证书后，就可以正常抓取部分应用中的 HTTPS 请求。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ul><li>安装 VirtualXposed.apk 和 JustTrustme.apk</li><li>给 VirtualXposed 足够的权限</li><li>在 VirtualXposed 中安装 JustTrustme 和需要抓包测试的应用</li><li>重启 VirtualXposed</li><li>在 VirtualXposed 中打开待抓包的应用</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.cnblogs.com/lulianqi/p/11380794.html#_label2" target="_blank" rel="noopener">部分APP无法代理抓包的原因及解决方法（flutter 抓包） - lulianqi15 - 博客园</a></li><li><a href="https://www.jianshu.com/p/3d981ae674c5" target="_blank" rel="noopener">安卓高版本安装系统证书 HTTPS 抓包 - 简书</a></li><li><a href="https://gaojiajun.cn/2018/08/charles-notTrust-in-android7.0/" target="_blank" rel="noopener">Android7.0及以上charles抓包提示证书无效的解决方法 | 高嘉君的个人博客</a></li><li><a href="https://www.jianshu.com/p/a818a0d0aa9f" target="_blank" rel="noopener">Android 7.0+ 抓包https的一种方案(支持微信7.0) - 简书</a></li><li><a href="https://github.com/asLody/VirtualApp" target="_blank" rel="noopener">asLody/VirtualApp: Virtual Engine for Android(Support 11.0 in business version)</a></li><li><a href="https://www.cnblogs.com/h2zZhou/p/7759889.html" target="_blank" rel="noopener">VirtualApp技术黑产利用研究报告 - h2z - 博客园</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近处理一些对第三方应用中HTTPS请求抓包工作。杂七杂八挺烦琐，又容易遗忘。记录之，备不时之需。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ios-pod-package</title>
    <link href="http://www.sunmoonblog.com/2020/11/27/ios-pod-package/"/>
    <id>http://www.sunmoonblog.com/2020/11/27/ios-pod-package/</id>
    <published>2020-11-27T01:32:56.000Z</published>
    <updated>2021-02-10T01:43:25.928Z</updated>
    
    <content type="html"><![CDATA[<p>了解 pod lib 命令的用法。<br><a id="more"></a></p><h1 id="创建Pod库"><a href="#创建Pod库" class="headerlink" title="创建Pod库"></a>创建Pod库</h1><p>第一步，创建Pod工程。使用 <code>pod lib create</code> 命令创建Pod工程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create &lt;PodName&gt;</span><br></pre></td></tr></table></figure><p>按提示配置选项，完成后自动打开 pod install 并打开 xcworkspace 文件</p><p>第二步，生成 Framework。Xcode中运行Example工程后，会生成对应的Framework文件</p><p><img src="/images/16064419140316.jpg" alt></p><p>不过这种方式生成Framework文件有几个问题：</p><ul><li>兼容性问题 - 生成的Framework只支持模拟器或真机，不能同时二者同时兼容</li><li>自动化问题 - 手动在Xcode操作，不便于自动构建</li></ul><h1 id="生成Framework"><a href="#生成Framework" class="headerlink" title="生成Framework"></a>生成Framework</h1><h2 id="使用-cocoapods-packager-生成"><a href="#使用-cocoapods-packager-生成" class="headerlink" title="使用 cocoapods-packager 生成"></a>使用 cocoapods-packager 生成</h2><p><a href="https://github.com/CocoaPods/cocoapods-packager" target="_blank" rel="noopener">CocoaPods Packager</a> 是一个 CocoaPods 插件，用于从 podspec 生成静态库。</p><blockquote><p>CocoaPods plugin which allows you to generate a static library from a podspec.</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>一种方式是使用 gem install 安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install cocoapods-packager</span><br></pre></td></tr></table></figure><p>不过从 Gem 官方源安装的 cocoapods-packager 版本比较老。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gem list | grep packager</span><br><span class="line">cocoapods-packager (1.5.0)</span><br></pre></td></tr></table></figure><p>另一种方式是从源码安装。</p><ul><li>下载源码</li><li>修改版本号</li><li>安装依赖库</li><li>构建gem安装包</li><li>安装gem包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/CocoaPods/cocoapods-packager.git</span><br><span class="line"></span><br><span class="line"># 修改 lib/cocoapods_packager.rb 文件中的版本号</span><br><span class="line"></span><br><span class="line">bundler install</span><br><span class="line"></span><br><span class="line">sudo gem build cocoapods-packager.gemspec</span><br><span class="line"></span><br><span class="line">sudo gem install cocoapods-packager-1.6.0.gem  -l</span><br></pre></td></tr></table></figure><p>构建安装包。构建成功后生成一个 gem 安装包</p><p><img src="/images/16064526409155.jpg" alt></p><p>安装gem包。使用 <code>sudo gem install &lt;gem包名&gt;</code> 安装。</p><p>检查版本号。安装完成后，使用 <code>gem list | grep packager</code> 检查 cocoapods-packager 版本是否正确</p><p><img src="/images/16064529541769.jpg" alt></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用cocoapods-packager时遇到几个问题，记录如下。</p><h3 id="问题一：没有使用-CDN"><a href="#问题一：没有使用-CDN" class="headerlink" title="问题一：没有使用 CDN"></a>问题一：没有使用 CDN</h3><p><code>pod package</code> 命令默认的 spec-sources 是 <a href="https://github.com/CocoaPods/Specs.git，所以会长时间卡在" target="_blank" rel="noopener">https://github.com/CocoaPods/Specs.git，所以会长时间卡在</a> Cloning spec repo 这一步。</p><p><img src="/images/16064435750825.jpg" alt></p><p>解决办法是指定 spec-sources。<a href="https://github.com/CocoaPods/cocoapods-packager/issues/250" target="_blank" rel="noopener">参考</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod package PodDemo.podspec  --spec-sources=&apos;https://cdn.cocoapods.org/&apos;</span><br></pre></td></tr></table></figure><h3 id="问题二：XCode-12-生成失败"><a href="#问题二：XCode-12-生成失败" class="headerlink" title="问题二：XCode 12 生成失败"></a>问题二：XCode 12 生成失败</h3><p>错误日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">have the same architectures (arm64) and can&apos;t be in the same fat output file</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/CocoaPods/cocoapods-packager/issues/259" target="_blank" rel="noopener">issues/259</a> - have the same architectures (arm64) and can’t be in the same fat output file</li><li><a href="https://github.com/CocoaPods/cocoapods-packager/issues/260" target="_blank" rel="noopener">issues/260</a> - Xcode12.0.1 build failed, can’t generate framework #260</li></ul><p>解决办法是排除特定的架构，避免打包失败。这个办法由<a href="https://github.com/CocoaPods/cocoapods-packager/issues/259" target="_blank" rel="noopener">issues/259</a>提供，我尝试发现在我的机器上可用。</p><p>首先，找到 <code>/Library/Ruby/Gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/cocoapods-packager/pod_utils.rb</code> 文件。</p><p>然后，在该文件第32行后面添加一行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.build_settings[&apos;EXCLUDED_ARCHS[sdk=iphonesimulator*]&apos;] = &apos;arm64&apos;</span><br></pre></td></tr></table></figure><p><img src="/images/16064430755729.jpg" alt></p><p>不过这个解决方案并没有提到问题的原因。推测这里的问题跟 <a href="https://github.com/Carthage/Carthage/blob/master/Documentation/Xcode12Workaround.md" target="_blank" rel="noopener">Carthage</a> Xcode 12 上的打包问题比较类似。Carthage 对此的解释是： </p><blockquote><p>Well, shortly, Carthage builds fat frameworks, which means that the framework contains binaries for all supported architectures. Until Apple Silicon was introduced it all worked just fine, but now there is a conflict as there are duplicate architectures (arm64 for devices and arm64 for simulator). This means that Carthage cannot link architecture specific frameworks to a single fat framework.</p><p>You can find more info in <a href="https://github.com/Carthage/Carthage/issues/3019" target="_blank" rel="noopener">respective issue #3019</a>.</p></blockquote><h3 id="问题三：找不到头文件"><a href="#问题三：找不到头文件" class="headerlink" title="问题三：找不到头文件"></a>问题三：找不到头文件</h3><p>遇到一个很诡异的问题：生成的 Framework 中没有公开的头文件。</p><p>排查了很久，发现是一个非常低级的错误。</p><p>原因是这样的：我使用本地Git仓库中的代码来生成 Framework，所以指定了目录但没有指定tag。在没有指定tag时，cocoapods-packager 使用 HEAD 指向的代码来打包。但是，<font color="red">我的代码写好了(包括头文件和源文件)，但并没有提交到Git仓库！</font>cocoapods-packager 当然无法复制公开的文件到生成的 Framework 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#s.source           = &#123; :git =&gt; &apos;https://github.com/abc/CmLib2.git&apos;, :tag =&gt; s.version.to_s &#125;</span><br><span class="line">s.source           = &#123; :git =&gt; &apos;/Users/abc/PublicCode/CmLib2&apos;&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-Carthage-生成"><a href="#使用-Carthage-生成" class="headerlink" title="使用 Carthage 生成"></a>使用 Carthage 生成</h2><p><a href="https://github.com/Carthage/Carthage" target="_blank" rel="noopener">Carthage</a>用于生成二进制的Framework。对比CocoaPods，Carthage无入侵性。</p><blockquote><p>Carthage is intended to be the simplest way to add frameworks to your Cocoa application.</p><p>Carthage builds your dependencies and provides you with binary frameworks, but you retain full control over your project structure and setup. Carthage does not automatically modify your project files or your build settings.</p></blockquote><p>需要注意的是 Carthage只支持</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/a253017eecce" target="_blank" rel="noopener">cocoapods-packager源码安装 - 简书</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解 pod lib 命令的用法。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NSClassFromString 用法简介</title>
    <link href="http://www.sunmoonblog.com/2020/11/14/ios-class-from-string/"/>
    <id>http://www.sunmoonblog.com/2020/11/14/ios-class-from-string/</id>
    <published>2020-11-14T08:09:17.000Z</published>
    <updated>2021-08-08T02:16:27.027Z</updated>
    
    <content type="html"><![CDATA[<p>简单了解如何使用 <code>NSClassFromString()</code> 函数动态加载类。</p><a id="more"></a><h1 id="NSClassFromString-及相关函数"><a href="#NSClassFromString-及相关函数" class="headerlink" title="NSClassFromString 及相关函数"></a>NSClassFromString 及相关函数</h1><table><thead><tr><th></th><th>OC</th><th>Java</th><th>备注</th></tr></thead><tbody><tr><td>通过名字获取类</td><td>NSClassFromString()</td><td>Class.forName()</td><td></td></tr><tr><td>通过名字获取方法</td><td>NSSelectorFromString()</td><td>Class.getDeclaredMethod()</td><td></td></tr><tr><td>判断方法能否调用</td><td>[NSObject respondsToSelector]</td><td></td><td></td></tr><tr><td>动态调用方法</td><td>[NSInvocation invoke]</td><td>Method.invoke()</td></tr></tbody></table><h2 id="NSClassFromString-介绍"><a href="#NSClassFromString-介绍" class="headerlink" title="NSClassFromString 介绍"></a>NSClassFromString 介绍</h2><p><code>NSClassFromString()</code> 函数的作用是通过名字来获取类 (原文：Obtains a class by name.)。</p><p>这个函数接受类的名字(一个字符串)作为参数，返回值是对应的类对象(如果这个名字对应的类未加载，则返回 <code>nil</code>)。如果参数为 <code>nil</code>，则直接返回 <code>nil</code>。</p><p>OC 的 <code>NSClassFromString()</code> 跟 Java 的 <code>Class.forName()</code> 类似。</p><p>OC 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSObject *target = [[NSClassFromString(className) alloc] init];</span><br></pre></td></tr></table></figure><p>对应的 Java 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单起见这里忽略异常处理</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">Object target = clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 9</span></span><br><span class="line"><span class="comment">// Object target = clazz.getDeclaredConstructor().newInstance()</span></span><br></pre></td></tr></table></figure><h2 id="NSSelectorFromString-介绍"><a href="#NSSelectorFromString-介绍" class="headerlink" title="NSSelectorFromString 介绍"></a>NSSelectorFromString 介绍</h2><p><code>NSSelectorFromString()</code> 函数的作用是通过名字来获取 selector (原文：Returns the selector with a given name)。</p><p>这个函数接受 selector 的名字(一个字符串)作为参数，返回值是对应的 selector。如果参数为 <code>nil</code> 或者无法转换成 UTF-8 字符串，则直接返回 <code>(SEL)0</code>。</p><p>OC 的 <code>NSSelectorFromString()</code> 跟 Java 的 <code>Class.getDeclaredMethod()</code> 方法类似。</p><p>OC 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SEL action = NSSelectorFromString(methodName);</span><br></pre></td></tr></table></figure><p>对应的 Java 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method catMethod = SomeClass<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredMethod</span>(<span class="title">methodName</span>)</span>;</span><br></pre></td></tr></table></figure><p>注意：</p><p><code>SEL</code> 的定义是 <code>typedef struct objc_selector *SEL;</code>。它的用于定义代表 method selector 的类型 (原文：Defines an opaque type that represents a method selector)。</p><h2 id="判断方法是否能调用"><a href="#判断方法是否能调用" class="headerlink" title="判断方法是否能调用"></a>判断方法是否能调用</h2><p><code>[NSObject] - (BOOL)respondsToSelector:(SEL)aSelector;</code> - Returns a Boolean value that indicates whether the receiver implements or inherits a method that can respond to a specified message. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (![target respondsToSelector:action])&#123;</span><br><span class="line">   // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Java中没有对应的用法。</p><h2 id="动态调用方法"><a href="#动态调用方法" class="headerlink" title="动态调用方法"></a>动态调用方法</h2><p><code>[NSInvocation invoke]</code> - Sends the receiver’s message (with arguments) to its target and sets the return value.</p><p>OC代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMethodSignature* methodSig = [target methodSignatureForSelector:action];</span><br><span class="line">NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSig];</span><br><span class="line">[invocation invoke];</span><br></pre></td></tr></table></figure><p>对应的Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method action = ...</span><br><span class="line">action.invoke(target);</span><br></pre></td></tr></table></figure><h1 id="NSStringClass-使用案例"><a href="#NSStringClass-使用案例" class="headerlink" title="NSStringClass 使用案例"></a>NSStringClass 使用案例</h1><p>可以使用 <code>NSStringClass()</code> 动态加载类。如果返回 <code>nil</code>，表示不能加载此类。</p><p>如下面代码所示，有不同的方式创建对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 方式一</span><br><span class="line">id myObj = [[NSClassFromString(@&quot;MyClass&quot;) alloc] init];</span><br><span class="line"></span><br><span class="line">// 方式二</span><br><span class="line">id myObj2 = [[MyClass alloc] init];</span><br></pre></td></tr></table></figure><p>通常来说这两种方式没有太多区别。但是，如果并不存在 <code>MyClass</code> 这个类，那么方式二编译报错。所以如果不确定是否存在 <code>MyClass</code> 这个类的情况下，应当使用方式一来创建对象。</p><p>方式一有这样两个好处：</p><ul><li>“弱”链接</li><li>不需要使用 <code>import</code>。即使没有头文件，只要类存在，就可以创建其对象</li></ul><p>再来看一个实例。某项目需要兼容 v4.3 和 v6.0 版本的百度地图SDK(有点怪，是吧)</p><ul><li>百度地图SDK v4.3 - 没有 <code>BMKCustomMapStyleOption</code>，不支持自定义地图功能</li><li>百度地图SDK v6.0 - 有 <code>BMKCustomMapStyleOption</code>，支持自定义地图功能</li></ul><p>原先的代码是这样写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BMKCustomMapStyleOption *options = [[BMKCustomMapStyleOption alloc] init];</span><br></pre></td></tr></table></figure><p>当使用百度地图SDK v6.0时，这行代码工作正常；当使用百度地图SDK v4.3时，这行代码<font color="red">无法编译</font>，提示 <code>BMKCustomMapStyleOption</code> 引起 “Undefined symbols”。</p><p>我们可以使用 <code>NSClassFromString</code> 避免这里的编译错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id options = [[NSClassFromString(@&quot;BMKCustomMapStyleOption&quot;) alloc] init];</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// MyBMapSettingsAdapter.m</span><br><span class="line"></span><br><span class="line">- (void)setCustomMapStyleOptions:(MyCustomStyleOptions *)styleOptions &#123;</span><br><span class="line">    if (styleOptions) &#123;</span><br><span class="line">        // BMKCustomMapStyleOption *options = [[BMKCustomMapStyleOption alloc] init];</span><br><span class="line">        // options.customMapStyleID = styleOptions.styleId;</span><br><span class="line">        // options.customMapStyleFilePath = styleOptions.stylePath;</span><br><span class="line">        // self.bMapView setCustomMapStyleWithOption...</span><br><span class="line">        </span><br><span class="line">        id options = [[NSClassFromString(@&quot;BMKCustomMapStyleOption&quot;) alloc] init];</span><br><span class="line">        </span><br><span class="line">        if (options) &#123;</span><br><span class="line">            SEL idMethod = NSSelectorFromString(@&quot;setCustomMapStyleID:&quot;);</span><br><span class="line">            [MyBMapSettingsAdapter invokeMethod:options selector:idMethod arg1:styleOptions.styleId];</span><br><span class="line">        </span><br><span class="line">            SEL pathMethod = NSSelectorFromString(@&quot;setCustomMapStyleFilePath:&quot;);</span><br><span class="line">            [MyBMapSettingsAdapter invokeMethod:options selector:pathMethod arg1:styleOptions.stylePath];</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用于解决 &quot;performSelector may cause a leak because its selector is unknown&quot;.</span><br><span class="line">+ (void)invokeMethod:(id)obj selector:(SEL)selector arg1:(id)arg1 &#123;</span><br><span class="line">    if (!obj) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if ([obj respondsToSelector:selector]) &#123;</span><br><span class="line">        IMP imp = [obj methodForSelector:selector];</span><br><span class="line">        void (*func)(id, SEL, id) = (void*)imp;</span><br><span class="line">        func(obj, selector, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--问题现象：+ 反序列化时不成功+ 提交加载相关类后，反序列化成功代码：原因：--><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/3ed2c7bc6653" target="_blank" rel="noopener">OC的反射机制 - 简书</a></li><li><a href="https://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown" target="_blank" rel="noopener">ios - performSelector may cause a leak because its selector is unknown - Stack Overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单了解如何使用 &lt;code&gt;NSClassFromString()&lt;/code&gt; 函数动态加载类。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ios-bundle</title>
    <link href="http://www.sunmoonblog.com/2020/11/13/ios-bundle/"/>
    <id>http://www.sunmoonblog.com/2020/11/13/ios-bundle/</id>
    <published>2020-11-13T08:11:34.000Z</published>
    <updated>2020-11-14T08:08:25.766Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 中如何加载资源。</p><a id="more"></a><h1 id="读取第三方Framework中的资源文件"><a href="#读取第三方Framework中的资源文件" class="headerlink" title="读取第三方Framework中的资源文件"></a>读取第三方Framework中的资源文件</h1><p>先看看IPA文件目录结构。右键选中文件然后”显示包内容”：</p><p><img src="/images/16052551712936.jpg" alt></p><p>图中可以看到百度地图SDK的 mapapi.bundle 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *bundlePath = [[NSBundle mainBundle] pathForResource:@&quot;mapapi&quot; ofType:@&quot;bundle&quot;];</span><br><span class="line">NSLog(@&quot;bundle path  is %@&quot;, bundlePath);</span><br></pre></td></tr></table></figure><p>输出如下日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-11-13 16:10:44.289957+0800 map-sdk-ios-framework[19583:1397775] bundle path  is /private/var/containers/Bundle/Application/57181523-430B-42C0-AFD3-450AC94D14AF/map-sdk-ios-framework.app/mapapi.bundle</span><br></pre></td></tr></table></figure><p>百度地图SDK的 mapapi.bundle 文件包含一张名为 baidumap_logo.png 的图片。</p><p><img src="/images/16052555701661.jpg" alt></p><p>我们可以进一步读取这张图片。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *bundlePath = [[NSBundle mainBundle] pathForResource:@&quot;mapapi&quot; ofType:@&quot;bundle&quot;];</span><br><span class="line">NSData *localData = [NSData dataWithContentsOfFile:[bundlePath stringByAppendingPathComponent:@&quot;images/baidumap_logo.png&quot; ]];</span><br><span class="line">NSLog(@&quot;bundle data is %@&quot;, localData);</span><br></pre></td></tr></table></figure><h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="无法读取依赖工程中的资源"><a href="#无法读取依赖工程中的资源" class="headerlink" title="无法读取依赖工程中的资源"></a>无法读取依赖工程中的资源</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 中如何加载资源。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>H5开发小记</title>
    <link href="http://www.sunmoonblog.com/2020/09/24/h5-dev/"/>
    <id>http://www.sunmoonblog.com/2020/09/24/h5-dev/</id>
    <published>2020-09-24T11:29:29.000Z</published>
    <updated>2020-11-13T04:03:36.121Z</updated>
    
    <content type="html"><![CDATA[<p>离职中。离职前最后一个项目是前端项目，用到了一些之前不了解的工具，也遇到不少的问题。预计接下来几年都不会再接触前端开发工作，但记录一下以备忘、拓展知识广度总是好的。</p><a id="more"></a><p>具体分成三类话题。</p><ul><li>工具</li><li>问题</li><li>技巧</li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>首先谈谈<strong>开发工具</strong>。Chrome Devtools 真是个神器。<a href="(https://juejin.im/post/5f1542e16fb9a07e6f7b80fe">这里</a>)有篇介绍 Devtools 的文章。只挑几个我觉得特别有用的功能说说。</p><p><img src="/images/16009472822261.jpg" alt="-w451"></p><p>一是选择机型，便于在不同分辨率下调试。二是选中元素开关(点击一下后变成蓝色)，打开后选择 html 页面中的元素非常方便</p><p><img src="/images/16009474285734.jpg" alt="-w444"></p><p>第三个是 Replay XHR 功能。只会刷新页面来重新发送 XHR 请求，太 low 了。其实 Replay 一下就足够了！</p><p>另一个好用的开发工具是 Vue.js devtools。怎么好用呢？看图。直接在 Vue.js devtools 中修改数据，UI 也随之变化。调试界面非常方便！</p><p><img src="/images/vuejs-devtools.gif" alt="vuejs-devtools"></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>再来说说遇到的问题(或者说是坑)。</p><h2 id="DOM-与-Vue-js"><a href="#DOM-与-Vue-js" class="headerlink" title="DOM 与 Vue.js"></a>DOM 与 Vue.js</h2><p>首先要说的一个坑就是在 Vue.js 中使用 zepto 操作真实DOM节点引起的一个看似诡异其实很好理解的愚蠢问题。你肯定会质疑为什么 Vue.js 会使用 zepto。实际情况是前端输出的重构文件中用到的 zepto，一是我懒二是确实也不知如何准确地将 zepto 代码翻译成 Vue.js，所以就出现 Vue.js 与 zepto 混用的情况。</p><p>大部分场景下这种做并不会有问题，直接这个点击用户名后编辑的功能：</p><p><img src="/images/edit-name.gif" alt="edit-name"></p><p>伪代码类似这样，其关键在于 <code>vm.inputTeamName = newtxt</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;inputTeamName&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更改名称</span></span><br><span class="line">$(<span class="string">".btn-change"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> td = $(<span class="keyword">this</span>).siblings(<span class="string">'span'</span>);</span><br><span class="line"><span class="keyword">var</span> txt = td.text();</span><br><span class="line"><span class="keyword">var</span> input = $(<span class="string">"&lt;input type='text'value='"</span> + txt + <span class="string">"'/&gt;"</span>);</span><br><span class="line">td.html(input);</span><br><span class="line">input.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line">input.trigger(<span class="string">"focus"</span>);</span><br><span class="line">input.blur(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> newtxt = $(<span class="keyword">this</span>).val();</span><br><span class="line"><span class="keyword">if</span>(newtxt != txt) &#123;</span><br><span class="line">  <span class="comment">// 更新 inputTeamName</span></span><br><span class="line">  vm.inputTeamName = newtxt</span><br><span class="line">td.html(newtxt);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">td.html(newtxt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不过这段代码时灵时不灵。我疑惑了好久。但仔细一想又很简单：操作 span 这个<font color="red">真实DOM节点后</font>，就不能指望 <code></code> 是可靠的了 (毕竟它跟 Vue.js 的<font color="red">虚拟DOM节点</font>相关)</p><p>类似的情况还有操作过真实DOM节点后，<code>v-model</code>指令失效。原因也类似。</p><h2 id="重名组件"><a href="#重名组件" class="headerlink" title="重名组件"></a>重名组件</h2><p>封装了一个 <code>RegisterDialog</code> 组件，组件中指定了 id。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pop-wrap pop-bg02 pop-box01"</span> <span class="attr">id</span>=<span class="string">"pop-box01"</span> <span class="attr">style</span>=<span class="string">"display: none"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"p-title"</span>&gt;</span>绑定手机<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"phone-input"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>RegisterDialog</code> 组件被多处使用。如下图：</p><p><img src="/images/16010202840140.jpg" alt="-w502"></p><p>发现有时操作不能按预期方式操作 <code>RegisterDialog</code>。比如，头像和昵称无法正常显示。推测问题原因是 <code>RegisterDialog</code> 导致 html 页面内元素 ID 冲突。</p><p>一种解决方式是使用更合理的页面结构，保证只有一个 <code>RegisterDialog</code>。如下图：</p><p><img src="/images/16010202885727.jpg" alt="-w503"></p><p>另一种解决方式是避免 <code>RegisterDialog</code> 组件中 div 元素的 ID 写死为 <code>pop-box01</code>，而是使用动态ID。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pop-wrap pop-bg02 pop-box01"</span> <span class="attr">:id</span>=<span class="string">"myID"</span> <span class="attr">style</span>=<span class="string">"display: none"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"p-title"</span>&gt;</span>绑定手机<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"phone-input"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="分享图白边"><a href="#分享图白边" class="headerlink" title="分享图白边"></a>分享图白边</h2><p>我们的H5在某些机型上生成的分享图会出现一条白边。如下图：</p><p><img src="/images/16010220630144.jpg" alt="-w383"></p><p>白边问题的原因是rem和px转化存在小数点。提前将rem转换成px即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fixDimen(domId) &#123;</span><br><span class="line">  <span class="keyword">const</span> ele = <span class="built_in">document</span>.getElementById(domId);</span><br><span class="line">  <span class="keyword">if</span> (ele) &#123;</span><br><span class="line">    <span class="comment">// 解决rem和px转化存在小数点，导致的白边问题</span></span><br><span class="line">    ele.style.width = <span class="string">`<span class="subst">$&#123;ele.offsetWidth&#125;</span>px`</span>;</span><br><span class="line">    ele.style.height = <span class="string">`<span class="subst">$&#123;ele.offsetHeight&#125;</span>px`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="图片跨域"><a href="#图片跨域" class="headerlink" title="图片跨域"></a>图片跨域</h2><p>dom2img 库用于将 DOM 节点转换成图片。使用 dom2img 时要注意图片跨域问题。一种简单的解决办法是将托管在图片服务器上的图片保存到本地，同时修改部分css代码。</p><p>修改前：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://image-1251917893.cos.ap-guangzhou.myqcloud.com/gp-match/css/match.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://image-1251917893.cos.ap-guangzhou.myqcloud.com/gp-match/css/match.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"match.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后本地新增一个 <code>match.css</code> 文件。这个css会重写几个样式(主要是将背景图片指向本地图片，而非图片服务器)以覆盖前一个css中某些规则，以避免图片跨域问题。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.xspr1</span> &#123; <span class="attribute">background-image</span>: <span class="built_in">url</span>(img/xspr1.png); <span class="attribute">background-repeat</span>: no-repeat; <span class="attribute">background-size</span>: <span class="number">9.94rem</span> <span class="number">5.18rem</span>; &#125;</span><br><span class="line"><span class="selector-class">.xspr</span> &#123; <span class="attribute">background-image</span>: <span class="built_in">url</span>(img/xspr.png); <span class="attribute">background-repeat</span>: no-repeat; <span class="attribute">background-size</span>: <span class="number">9.92rem</span> <span class="number">11.21rem</span>; &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="内联CSS"><a href="#内联CSS" class="headerlink" title="内联CSS"></a>内联CSS</h2><p>有时需要在 Vue.js 中内联 css 文件。</p><p>比如我遇到这样一个问题。一些图片和css文件在测试环境中可以正常访问，但发布到正式环境就不行。</p><ul><li>测试环境中能正常访问<ul><li><a href="https://test.igame.qq.com/newcss/admin/hp-match/match.css" target="_blank" rel="noopener">https://test.igame.qq.com/newcss/admin/hp-match/match.css</a></li><li><a href="https://test.igame.qq.com/newcss/admin/hp-match/img/share1.jpg" target="_blank" rel="noopener">https://test.igame.qq.com/newcss/admin/hp-match/img/share1.jpg</a></li></ul></li><li>正式环境中不能正常访问<ul><li><a href="https://igame.qq.com/newcss/admin/hp-match/match.css" target="_blank" rel="noopener">https://igame.qq.com/newcss/admin/hp-match/match.css</a></li><li><a href="https://igame.qq.com/newcss/admin/hp-match/img/share1.jpg" target="_blank" rel="noopener">https://igame.qq.com/newcss/admin/hp-match/img/share1.jpg</a></li></ul></li></ul><p>看 Chrome 提示推测是正式服务器 <code>content-type</code> 配置有问题，它将css文件的作为html返回了，所以无法正常加载css。随之引起图片跨域问题(该css是专门用来解决跨域问题的)</p><p><img src="/images/16010240487770.jpg" alt="-w936"></p><p>无奈我没权限修改正式服务器配置。于是换另一种思路，将 css 内存到 Vue.js。</p><p>修改前：在 <code>index.html</code> 引入 <code>match.css</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"match.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后：在 <code>App.vue</code> 引入 <code>match.css</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./../../../public/match.css'</span>;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><p>修改后成功绕过正式服务器的 <code>content-type</code> 配置问题，可正常加载 <code>match.css</code>，避免了随之而来的图片跨域问题！</p><h2 id="使用图片"><a href="#使用图片" class="headerlink" title="使用图片"></a>使用图片</h2><p>vue 文件中也可以直接使用图片。方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register-dialog.vue</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;img <span class="class"><span class="keyword">class</span></span>=<span class="string">"info-txt-1"</span> :src=<span class="string">"imgs.share_text"</span> alt /&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import head_name from 'src/m</span>odule/xxx/img/head-name.png<span class="string">'</span></span><br><span class="line"><span class="string">import headbox from '</span>src/<span class="built_in">module</span>/xxx/img/headbox.png<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  data() &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      imgs: &#123;</span></span><br><span class="line"><span class="string">        head_name: head_name,</span></span><br><span class="line"><span class="string">        headbox: headbox</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="保存分享图"><a href="#保存分享图" class="headerlink" title="保存分享图"></a>保存分享图</h2><p>一个需求是这样的：用户长按h5保存图片时，实际保存的图片上要求有一个二维码和提示。</p><p><a href="https://blog.csdn.net/w20101310/article/details/60580241/" target="_blank" rel="noopener">微信中如何长按图片保存的是另一张图片_小朱的专栏-CSDN博客</a>中介绍了一种解决方案。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><img src="/images/16009498051466.jpg" alt="-w102"></p><ul><li>chrome devtools 中快速qq登录 (一直觉得H5中QQ登录很麻烦，实际上是没有掌握技巧。使用 Toggle device toolbar 将浏览器切换成PC模式而不是Mobile模式，可以拉起PC端的QQ登录页，然后手机QQ扫一扫登录，非常方便)</li><li>部署不同的 url 的环境 (修改 <code>publish.js</code> 脚本)</li><li>beforeDestroy 响应back 键回退时，以关闭 layer</li><li>同名组件问题 (同ref或同ID)</li><li>无法获取角色信息问题确认</li><li>卡在ssl.ptlogin2.qq.com的问题 (短时间同一测试QQ号在多个Android机器上登录时容易出现这个问题)</li><li>分环境部署 (修改 <code>publish.js</code> 中的 <code>desc</code> 即可)</li><li>css 作用域问题 (dialog 样式)</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/5f1542e16fb9a07e6f7b80fe" target="_blank" rel="noopener">脱离996，Chrome DevTools 面板全攻略！！！ - 掘金</a></li><li><a href="https://blog.csdn.net/w20101310/article/details/60580241/" target="_blank" rel="noopener">微信中如何长按图片保存的是另一张图片_小朱的专栏-CSDN博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;离职中。离职前最后一个项目是前端项目，用到了一些之前不了解的工具，也遇到不少的问题。预计接下来几年都不会再接触前端开发工作，但记录一下以备忘、拓展知识广度总是好的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 内存优化之优化 so 文件</title>
    <link href="http://www.sunmoonblog.com/2020/07/22/flutter-mmamp-memory/"/>
    <id>http://www.sunmoonblog.com/2020/07/22/flutter-mmamp-memory/</id>
    <published>2020-07-22T05:29:59.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>优化 so 大小能否减少 Android 应用的内存？从原理上讲是可以的，实际效果如何？一起来看看吧。</p><a id="more"></a><p>(本文待完善)</p><p>相关文章：</p><ul><li><a href="https://www.sunmoonblog.com/2020/07/16/flutter-split-debug-info/">Flutter split-debug-info 用法介绍</a> - 使用 split-debug-info 可以优化 Flutter libapp.so 大小</li><li><a href="https://www.sunmoonblog.com/2020/07/15/flutter-app-memory-test/">Flutter App 内存测试</a> - 在若干简单场景下测试 Flutter 应用内存，为内存优化提供指导</li></ul><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们知道，Android 应用占用的内存有一类是 <code>Code</code>。<code>dumpsys meminfo</code> 命令的输出中可以看到 Code 类别的内存：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949713220131.jpg" alt></p><p>关于 Code 内存，官网是这样解释的：</p><blockquote><p>Memory that your app uses for code and resources, such as dex bytecode, optimized or compiled dex code, .so libraries, and fonts <a href="https://developer.android.com/studio/profile/memory-profiler#how-counted" target="_blank" rel="noopener">来源</a></p></blockquote><p>简单计算一下，发现 Code 内存大致包括 <code>.so mmap</code> 和 <code>.apk mmap</code>。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949717854679.jpg" alt></p><p>我们可以观察 so 优化前后 <code>.so mmap</code> 的变化来判断优化是否有效果。</p><p>不过还有另外一个问题：Android 应用中通常有很多 so，所以没法通过 <code>.so mmap</code> 来判断单个 so 的优化效果。该怎么办？</p><h1 id="maps-文件"><a href="#maps-文件" class="headerlink" title="maps 文件"></a>maps 文件</h1><p>判断单个 so 的优化效果的方法是查看和分析进程对应的 <code>proc/&lt;pid&gt;/maps</code> 文件。</p><p><a href="https://stackoverflow.com/questions/1401359/understanding-linux-proc-id-maps" target="_blank" rel="noopener">Understanding-linux-proc-id-maps</a> 对 <code>maps</code> 文件有介绍。</p><blockquote><p>Each row in /proc/$PID/maps describes a region of contiguous virtual memory in a process or thread. Each row has the following fields:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">address           perms offset  dev   inode   pathname</span><br><span class="line">08048000-08056000 r-xp 00000000 03:0c 64593   /usr/sbin/gpm</span><br></pre></td></tr></table></figure><ul><li>address - 进程地址空间的起始地址</li><li>permissions - 访问权限</li><li>pathname - 如果该区域是从文件映射来的，pathname 为文件名</li></ul><p>注意，直接在 adb shell 用 cat 查看 maps 文件可能会遇到 permission denied 问题。可以 <code>run-as</code> 命令来避免该问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ ✗ adb shell</span><br><span class="line">HWANE:/ $ run-as</span><br><span class="line">run-as: usage: run-as &lt;package-name&gt; [--user &lt;uid&gt;] &lt;command&gt; [&lt;args&gt;]</span><br><span class="line">run-as com.example.flutter.image.flutter_image_demo  cat /proc/7331/maps \ </span><br><span class="line">  | grep libapp.so</span><br></pre></td></tr></table></figure><p>以下示例查看 <code>com.example.flutter.image.flutter_image_demo</code> 的 maps 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HWANE:/ $ run-as com.example.flutter.image.flutter_image_demo  cat /proc/7331/maps | grep libandroid</span><br><span class="line">7016edb000-7016ef6000 r-xp 00000000 fd:00 7502                           /system/lib64/libandroid.so</span><br><span class="line">7016ef7000-7016efb000 r--p 0001b000 fd:00 7502                           /system/lib64/libandroid.so</span><br></pre></td></tr></table></figure><p>方便起见，可以写个脚本来解析 maps 文件以快速统计每个 so 文件占用内存的总大小。源码见 <a href="https://gist.github.com/410063005/eb8d405d1605e9990620c9f4135762b2" target="_blank" rel="noopener">gist</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">data_list = []</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">    raw_data = input(<span class="string">'paste maps string here: '</span> <span class="keyword">if</span> len(data_list) == <span class="number">0</span> <span class="keyword">else</span> <span class="string">''</span>)</span><br><span class="line">    <span class="keyword">if</span> (raw_data.strip() == <span class="string">''</span>): </span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    data_list.append(raw_data)</span><br><span class="line"></span><br><span class="line">mem_map = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> data_list:</span><br><span class="line">    tmp = item.split(<span class="string">' '</span>)</span><br><span class="line">    addr = tmp[<span class="number">0</span>].split(<span class="string">'-'</span>)</span><br><span class="line">    <span class="keyword">if</span> len(addr) == <span class="number">2</span>:</span><br><span class="line">        mem = (int(addr[<span class="number">1</span>], <span class="number">16</span>) - int(addr[<span class="number">0</span>], <span class="number">16</span>)) / <span class="number">1024.0</span> / <span class="number">1024.0</span></span><br><span class="line"></span><br><span class="line">        key = tmp[<span class="number">-1</span>][<span class="number">-30</span>:]</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> mem_map:</span><br><span class="line">            mem_map[key].append(mem)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            li = []</span><br><span class="line">            li.append(mem)</span><br><span class="line">            mem_map[key] = li</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">for</span> (k, v) <span class="keyword">in</span> mem_map.items():</span><br><span class="line">    print(k, <span class="string">' '</span>, sum(v), <span class="string">'MB'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949755118549.jpg" alt="-w785"></p><h1 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h1><ul><li>测试目标：FlutterImageDemo、Flutter 项目优化前、Flutter 项目优化后</li><li>测试工具：<code>dumpsys meminfo</code> 和 <code>run-as</code></li><li>测试指标：<ul><li><code>libflutter.so</code> 和 <code>libapp.so</code> 文件大小</li><li><code>.so mmap</code></li><li>maps 文件中 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小</li></ul></li></ul><p>数据如下。</p><h2 id="FlutterImageDemo"><a href="#FlutterImageDemo" class="headerlink" title="FlutterImageDemo"></a>FlutterImageDemo</h2><p>FlutterImageDemo 是一个简单的 Flutter 应用。</p><ul><li>包名 <code>com.example.flutter.image.flutter_image_demo</code></li><li>进程号 7331</li><li>APK 包解压出来的 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小分别是 13.9MB 和 6.1MB</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949758838686.jpg" alt></p><p>不得不吐槽下 Mac 上文件大小的计算方式对开发人员实现不友好。我重新算了一下，准确的大小分别是 13.2MB 和 5.8MB。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949759493938.jpg" alt="-w778"></p><p><code>.so mmap</code> 数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys meminfo com.example.flutter.image.flutter_image_demo</span><br><span class="line"></span><br><span class="line">** MEMINFO in pid 7331 [com.example.flutter.image.flutter_image_demo] **</span><br><span class="line">                   Pss  Private  Private  SwapPss     Heap     Heap     Heap</span><br><span class="line">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free</span><br><span class="line">                ------   ------   ------   ------   ------   ------   ------</span><br><span class="line">     .so mmap    14010      584    12600       47</span><br></pre></td></tr></table></figure><p>maps 数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HWANE:/ $ run-as com.example.flutter.image.flutter_image_demo  cat /proc/7331/maps | grep libflutter.so</span><br><span class="line">6fffee6000-70005d9000 r--p 00000000 103:08 39455                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libflutter.so</span><br><span class="line">70005e6000-7000ae9000 r-xp 00700000 103:08 39455                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libflutter.so</span><br><span class="line">7000af6000-7000bd6000 rw-p 00c10000 103:08 39455                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libflutter.so</span><br><span class="line">7000bd6000-7000c25000 r--p 00cf0000 103:08 39455                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libflutter.so</span><br><span class="line">HWANE:/ $ run-as com.example.flutter.image.flutter_image_demo  cat /proc/7331/maps | grep libapp.so</span><br><span class="line">6fff5c3000-6fff5c5000 rw-p 00000000 103:08 45222                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libapp.so</span><br><span class="line">6fff5c5000-6fff85d000 r-xp 00002000 103:08 45222                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libapp.so</span><br><span class="line">6fff85d000-6fffb94000 r--p 0029a000 103:08 45222                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libapp.so</span><br><span class="line">6fffb94000-6fffb95000 rw-p 005d1000 103:08 45222                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libapp.so</span><br></pre></td></tr></table></figure><p>maps 解析后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/lib/arm64/libflutter.so   13.14453125 MB</span><br><span class="line">/lib/arm64/libapp.so   5.8203125 MB</span><br></pre></td></tr></table></figure><h2 id="Flutter-项目优化前"><a href="#Flutter-项目优化前" class="headerlink" title="Flutter 项目优化前"></a>Flutter 项目优化前</h2><p>从优化前的 APK 包解压出来的 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小分别是 5.9MB 和 9.6MB</p><p><code>.so mmap</code> 数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys meminfo com.t.t.i.host</span><br><span class="line">** MEMINFO in pid 15191 [com.t.t.i.host] **</span><br><span class="line">                   Pss  Private  Private  SwapPss     Heap     Heap     Heap</span><br><span class="line">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free</span><br><span class="line">                ------   ------   ------   ------   ------   ------   ------</span><br><span class="line">     .so mmap    16194      452    13896      127</span><br></pre></td></tr></table></figure><p>maps 数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HWANE:/ $ run-as com.t.t.i.host cat /proc/15191/maps  | grep libflutter.so</span><br><span class="line">c16c1000-c17ef000 r--p 00000000 103:08 132483                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libflutter.so</span><br><span class="line">c17ef000-c1baa000 r-xp 0012e000 103:08 132483                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libflutter.so</span><br><span class="line">c1baa000-c1c87000 rw-p 004e9000 103:08 132483                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libflutter.so</span><br><span class="line">c1c87000-c1caf000 r--p 005c6000 103:08 132483                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libflutter.so</span><br><span class="line">HWANE:/ $ run-as com.t.t.i.host cat /proc/15191/maps  | grep libapp.so</span><br><span class="line">c0a0f000-c0a11000 rw-p 00000000 103:08 129024                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libapp.so</span><br><span class="line">c0a11000-c0f55000 r-xp 00002000 103:08 129024                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libapp.so</span><br><span class="line">c0f55000-c13a6000 r--p 00546000 103:08 129024                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libapp.so</span><br><span class="line">c13a6000-c13a7000 rw-p 00997000 103:08 129024                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libapp.so</span><br></pre></td></tr></table></figure><p>maps 解析后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ccpa7w==/lib/arm/libflutter.so   5.9296875 MB</span><br><span class="line">FaZeCcpa7w==/lib/arm/libapp.so   9.59375 MB</span><br></pre></td></tr></table></figure><h2 id="Flutter-项目优化后"><a href="#Flutter-项目优化后" class="headerlink" title="Flutter 项目优化后"></a>Flutter 项目优化后</h2><p>从优化后的 APK 包解压出来的 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小分别是 5.9MB 和 8.6MB</p><p><code>.so mmap</code> 数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys meminfo com.t.t.i.host</span><br><span class="line"></span><br><span class="line">** MEMINFO in pid 14331 [com.t.t.i.host] **</span><br><span class="line">                   Pss  Private  Private  SwapPss     Heap     Heap     Heap</span><br><span class="line">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free</span><br><span class="line">                ------   ------   ------   ------   ------   ------   ------</span><br><span class="line">     .so mmap    16053      452    13572      117</span><br></pre></td></tr></table></figure><p>maps 数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127|HWANE:/ $ run-as com.t.t.i.host cat /proc/14331/maps | grep libflutter.so</span><br><span class="line">c154b000-c1679000 r--p 00000000 103:08 136617                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libflutter.so</span><br><span class="line">c1679000-c1a34000 r-xp 0012e000 103:08 136617                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libflutter.so</span><br><span class="line">c1a34000-c1b11000 rw-p 004e9000 103:08 136617                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libflutter.so</span><br><span class="line">c1b11000-c1b39000 r--p 005c6000 103:08 136617                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libflutter.so</span><br><span class="line">HWANE:/ $ run-as com.t.t.i.host cat /proc/14331/maps | grep libapp.so</span><br><span class="line">c0a8d000-c0a8f000 rw-p 00000000 103:08 131577                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libapp.so</span><br><span class="line">c0a8f000-c0fd2000 r-xp 00002000 103:08 131577                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libapp.so</span><br><span class="line">c0fd2000-c1328000 r--p 00545000 103:08 131577                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libapp.so</span><br><span class="line">c1328000-c1329000 rw-p 0089b000 103:08 131577                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libapp.so</span><br></pre></td></tr></table></figure><p>maps 解析后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V1HTdA==/lib/arm/libflutter.so   5.9296875 MB</span><br><span class="line">0xhjV1HTdA==/lib/arm/libapp.so   8.609375 MB</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>对比 <code>libflutter.so</code> 和 <code>libapp.so</code> 文件大小及 maps 的解析结果，发现数值几乎一致</li><li>对比 <code>.so mmap</code> 内存，看起来跟 so 文件大小相关性不明显 (<font color="red">??? 哪里出错了？</font>)</li></ul><table><thead><tr><th></th><th>libflutter.so文件</th><th>libapp.so文件</th><th><code>.so mmap</code></th><th>maps文件解析</th></tr></thead><tbody><tr><td>FlutterImageDemo</td><td>13.2MB</td><td>5.8MB</td><td>13.7MB</td><td>13.1MB和5.8MB</td></tr><tr><td>优化前</td><td>5.9MB</td><td>9.6MB</td><td>15.8MB</td><td>5.9MB和9.6MB</td></tr><tr><td>优化后</td><td>5.9MB</td><td>8.6MB</td><td>15.7MB</td><td>5.9MB和8.6MB</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;优化 so 大小能否减少 Android 应用的内存？从原理上讲是可以的，实际效果如何？一起来看看吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.sunmoonblog.com/tags/android/"/>
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>(译) Flutter State 生命周期</title>
    <link href="http://www.sunmoonblog.com/2020/07/21/flutter-state-lifecycle/"/>
    <id>http://www.sunmoonblog.com/2020/07/21/flutter-state-lifecycle/</id>
    <published>2020-07-21T09:48:26.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自 <a href="https://medium.com/flutter-community/flutter-lifecycle-for-android-and-ios-developers-8f532307e0c7" target="_blank" rel="noopener">Flutter Lifecycle for Android and iOS Developers | Medium</a>。类比 Android 和 iOS，了解 Flutter State 的生命周期。</p><a id="more"></a><!--One of the most confusing ideas transitioning from Android and/or iOS is to understand how Flutter handles its lifecycle.--><p>从 Android 或 iOS 转到 Flutter 开发，最让人疑惑的是 Flutter 如何处理生命周期。</p><p><strong>onCreate()</strong> 在哪里？<strong>viewDidLoad()</strong> 呢？我应该将业务逻辑放在哪里？为什么只有一个 <code>build</code> 方法？</p><p>本文将解答这些疑惑。</p><h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><p><strong>Activity</strong> 生命周期是 Android 开发必须记住的：</p><ul><li>onCreate</li><li>onStart</li><li>onResume</li></ul><hr><ul><li>onPause</li><li>onStop</li><li>onRestart</li><li>onDestroy</li></ul><p>大部分业务逻辑放在 <strong>onCreate</strong> 方法：初始化 view、数据库、监听器等等。<strong>onResume</strong> 和 <strong>onPause</strong> 是判断用户离开或进入当前页面的好时机。</p><h1 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h1><p>UIViewController 的生命周期如下：</p><ul><li>viewDidLoad</li><li>viewWillAppear</li><li>viewDidAppear</li></ul><hr><ul><li>viewWillDisappear</li><li>viewDidDisappear</li><li>viewDidUnload</li></ul><p>如你所见，两个平台均使用几乎一致的步骤来创建或销毁页面。大部分业务逻辑放在 <strong>viewDidLoad()</strong>，而 <strong>Will/Did Appear/Disappear</strong> 用于保存信息，判断用户何时离开页面等等。</p><h1 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h1><p>在 Flutter 中呢？Widget 也遵循类似规则吗？</p><p>Flutter 中主要有两种 Widget：<strong>StatelessWidget</strong> 和 <strong>StatefulWidget</strong>。本文重点放在 <strong>StatefulWidget</strong>，因为它有点像 <strong>Android</strong> 和 <strong>iOS</strong> 中的某些概念。</p><h2 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2><p>StatefulWidget 是最重要的 Widget，因为它持有 <strong>State</strong>，它知道何时发生变化并进行必要的重绘。它的生命周期如下：</p><ul><li>createState</li><li>initState</li><li>didChangeDependencies</li><li>build</li><li>(didUpdateWidget)</li></ul><p>— — — — — — — — — — —</p><ul><li>deactivate</li><li>dispose</li></ul><p>你可能会注意到创建阶段的 state 比销毁阶段的多，这是因为创建/重建 Widget 及其 State 更复杂。</p><h3 id="createState"><a href="#createState" class="headerlink" title="createState():"></a>createState():</h3><p>构建新的 StatefulWidget 时将调用 createState()，StatefulWidget 的子类必须覆盖这个方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyScreen</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyScreenState createState() =&gt; _MyScreenState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initState"><a href="#initState" class="headerlink" title="initState()"></a>initState()</h3><p>通常需要重写这个方法。它是 Widget 创建后调用的第一个方法，可以理解成 <strong>onCreate()</strong> 或 <strong>viewDidLoad()</strong> 的等价物。在这个方法中可以检查 Widget 某些相关属性：是否有被渲染？当前是否处理 mounted 状态？</p><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>每个 Widget 都有这个属性。当为 Widget.buildContext 赋值后 mounted 的值变成 <strong>true</strong>，Widget 在树中。直到 <strong>dispose</strong> 方法被调用前，mounted 一直为 true。</p><h3 id="addPostFrameCallback"><a href="#addPostFrameCallback" class="headerlink" title="addPostFrameCallback"></a>addPostFrameCallback</h3><p>可以在 <strong>initState</strong> 方法中按如下方式调用 <code>addPostFrameCallback</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/scheduler.dart'</span>;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">  <span class="keyword">super</span>.initState();</span><br><span class="line">  SchedulerBinding.instance.addPostFrameCallback((_) =&gt; &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法为一帧结束时添加回调，回调方法只会调用一次，通知 Widget 构建已完成。</p><h3 id="didChangeDependencies"><a href="#didChangeDependencies" class="headerlink" title="didChangeDependencies"></a>didChangeDependencies</h3><p>widget 构建时第一次调用 initState() 后立即会调用 didChangeDependencies()。如果 <strong>StatefulWidgets</strong> 依赖某个 <strong>InheritedWidget</strong>，后者发生变化时会导致 didChangeDependencies() 再次被调用。</p><h3 id="build"><a href="#build" class="headerlink" title="build()"></a>build()</h3><p>可以肯定地说这是最重要的方法。这个方法依赖整个待渲染的 Widget 树，在 <strong>didChangeDependencies()</strong> 立即被调用。所有的 GUI 渲染发生在这个方法，每次 UI 需要重新渲染时都会调用这个方法。(重新渲染是很廉价的操作)</p><h3 id="didUpdateWidget"><a href="#didUpdateWidget" class="headerlink" title="didUpdateWidget()"></a>didUpdateWidget()</h3><p>这是一个不太常见的生命周期方法。一旦 parent widget 有变化需要重绘 UI 时会调用 didUpdateWidget()。这个方法有一个 <strong>oldWidget</strong> 参数，可以将它跟当前 <strong>widget</strong> 进行比较以执行某些额外的业务逻辑。</p><h3 id="deactivate"><a href="#deactivate" class="headerlink" title="deactivate()"></a>deactivate()</h3><p>这个生命周期方法也不太常见。这个方法被调用时，意味着 Widget 开始进入”死亡”阶段。</p><p>当 framework 从树中移除 State 时会调用本方法。某些情况下，framework 会重新将 State 对象加入到树中。</p><h3 id="dispose"><a href="#dispose" class="headerlink" title="dispose()"></a>dispose()</h3><p>这个方法也非常重要。当 Widget 及其 State 从树中永久移除时会调用这个方法。此后 Widget 不会再被构建。</p><p>你需要在这个方法中做取消对 stream 的监听、销毁动画等操作。它是 <strong>initState</strong> 的反操作。</p><h1 id="WidgetsBindingObserver"><a href="#WidgetsBindingObserver" class="headerlink" title="WidgetsBindingObserver"></a>WidgetsBindingObserver</h1><p>如果我们想监听应用何时进入后台该怎么办？</p><p>可以这样做。对 <strong>StatefulWidget</strong> 做些小改动：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyScreen</span>&gt; <span class="title">with</span> <span class="title">WidgetsBindingObserver</span></span></span><br></pre></td></tr></table></figure><p>我们让 <code>_MyScreenState</code> 实现了抽象类 <strong>WidgetsBindingObserver</strong>，之后就可以观察应用的生命周期状态。在 <strong>initState</strong> 方法中开始观察：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WidgetsBinding.instance.addObserver(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>在 <strong>dispose</strong> 方法中停止观察：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WidgetsBinding.instance.removeObserver(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>接下来在 <strong>didChangeAppLifecycleState</strong> 接收生命周期的变化即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> didChangeAppLifecycleState(AppLifecycleState state) &#123;</span><br><span class="line">  <span class="keyword">super</span>.didChangeAppLifecycleState(state);</span><br><span class="line">  <span class="keyword">if</span> (state == AppLifecycleState.paused) &#123;</span><br><span class="line">    <span class="comment">// went to Background</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (state == AppLifecycleState.resumed) &#123;</span><br><span class="line">    <span class="comment">// came back to Foreground</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个技巧很有用。如果你想在应用进入后台时弹出 notification，或者保存数据，又或者在用户点 back 回退时弹出 popup，都可以使用这个技巧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自 &lt;a href=&quot;https://medium.com/flutter-community/flutter-lifecycle-for-android-and-ios-developers-8f532307e0c7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flutter Lifecycle for Android and iOS Developers | Medium&lt;/a&gt;。类比 Android 和 iOS，了解 Flutter State 的生命周期。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
      <category term="翻译" scheme="http://www.sunmoonblog.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Flutter split-debug-info 用法介绍</title>
    <link href="http://www.sunmoonblog.com/2020/07/16/flutter-split-debug-info/"/>
    <id>http://www.sunmoonblog.com/2020/07/16/flutter-split-debug-info/</id>
    <published>2020-07-16T09:34:18.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>介绍如何使用 Flutter 1.7 提供的 <code>split-debug-info</code> 编译选项来减小包大小。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>先介绍下什么是 <a href="https://en.wikipedia.org/wiki/Obfuscation_(software" target="_blank" rel="noopener">Code obfuscation</a>)。Code obfuscation 翻译过来就是代码混淆。代码混淆是修改应用二进制文件以增加理解难度的过程。混淆会隐藏编译后的 Dart 代码中的函数名和类名，让攻击者难以对应用进行逆向工程。</p><p>目前 Flutter (v1.7.14) stable 分支仅在 <a href="https://flutter.dev/docs/testing/build-modes" target="_blank" rel="noopener">release build</a> 中支持代码混淆。<a href="https://github.com/flutter/flutter/pull/49650" target="_blank" rel="noopener">Pull Request #49650 · flutter/flutter</a> 添加了这个功能。</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>同时使用 <code>--obfuscate</code> 和 <code>--split-debug-info</code> 标志来在 release 版本的应用中开启混淆。<code>--split-debug-info</code> 用于指定一个目录来存放 debug 文件，即 symbol map。目前 Flutter (v1.7.14) stable 分支支持 <code>apk</code>、<code>appbundle</code>、<code>ios</code> 和 <code>ios-framework</code>，master 和 dev 分支上还支持 <code>macos</code> 和 <code>aar</code>。</p><p>示例：编译并混淆一个 APK，在 <code>tmp</code> 目录下保存 symbol map。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter build apk --release --target-platform android-arm64 \</span><br><span class="line"> --obfuscate \</span><br><span class="line"> --split-debug-info=tmp/</span><br></pre></td></tr></table></figure><p>对于 Android 项目，也可以通过在 <code>&lt;project&gt;/app/gradle.properties</code> 中添加如下配置来<a href="https://github.com/flutter/flutter/wiki/Obfuscating-Dart-Code" target="_blank" rel="noopener">开启代码混淆</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extra-gen-snapshot-options=--obfuscate</span><br></pre></td></tr></table></figure><p>编译完成后 <code>tmp</code> 目录将生成一个后缀名为 <code>.symbols</code> 的文件。</p><p>注意：也可以单独使用 <code>--split-debug-info</code>。实际上这个参数是用来减小代码大小的 (即 <code>libapp.so</code> 的大小)</p><p>分别使用如下命令编译 APK。第一条命令生成优化前的 APK，第二条命令生成优化后的 APK。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter build apk --release --target-platform android-arm64</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter build apk --release --target-platform android-arm64 \</span><br><span class="line"> --obfuscate \</span><br><span class="line"> --split-debug-info=tmp/</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/16/15948669243081.jpg" alt></p><p>使用 <code>--split-debug-info</code> 优化后，APK 大小较之前减少 435KB。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/16/15948672793669.jpg" alt="-w727"></p><ul><li>优化前未压缩状态下 <code>libapp.so</code> 大小是 9.7MB</li><li>优化后未压缩状态下 <code>libapp.so</code> 大小是 8.6MB</li></ul><p>真正的减少来自 <code>libapp.so</code>，约 1.1MB。正如文档所言，<code>--split-debug-info</code> 可以减少代码大小。不过考虑到 APK 是压缩包，所以 <code>libapp.so</code> 的减小反映在 APK 包大小变化上并不明显。</p><h1 id="优化效果"><a href="#优化效果" class="headerlink" title="优化效果"></a>优化效果</h1><p>我们项目以 AAR 产物方式集成 Flutter。我从我们最新发布的 APK 中解压出 <code>libapp.so</code>，不作称为 <code>libapp-当前发布包.so</code>。</p><p><code>flutter build aot --release --target-platform android-arm</code> 编译结果为 <code>libapp-优化前.so</code></p><p><code>flutter build aot --release --target-platform android-arm</code> 加上 <code>--obfuscate</code> 和 <code>--split-debug-info</code> 的编译结果为 <code>libapp-优化后.so</code>。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/16/15948868220974.jpg" alt></p><p>可以看到前两个 so 文件大小接近，后一个 so 文件小了将近 0.9MB。(注意：这里的 so 是32位，不同于上一节中的64位，所以文件大小变化不同)。这里的 0.9MB(减小约11%) 并不太起眼，不过考虑到最小的 <code>libapp.so</code> 也有将近 3.7MB，所以其实还是很可观的。</p><table><thead><tr><th>文件</th><th>大小</th><th>备注</th></tr></thead><tbody><tr><td>最小的 <code>libapp.so</code></td><td>3.7MB</td><td>从 <code>flutter create</code> 创建的工程编译而来</td></tr><tr><td><code>libapp-当前发布包.so</code></td><td>8.3MB</td><td>从最新发布的APK解压而来</td></tr><tr><td><code>libapp-优化后.so</code></td><td>7.4MB</td><td>使用 <code>split-debug-info</code> 编译编译</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>官方 <a href="https://flutter.dev/docs/perf/app-size#reducing-app-size" target="_blank" rel="noopener">Measuring your app’s size - Flutter</a> 中提供了几种减小 Flutter 包大小的方法，可以作为参考</p><ul><li>Remove unused resources</li><li>Minimize resource imported from libraries</li><li>Support a limited number of screen densities</li><li>Compress PNG and JPEG files</li></ul><p>其他资料：</p><ul><li><a href="https://github.com/flutter/flutter/wiki/Obfuscating-Dart-Code" target="_blank" rel="noopener">Obfuscating-Dart-Code</a></li><li><a href="https://flutter.dev/docs/deployment/obfuscate" target="_blank" rel="noopener">Obfuscating Dart code - Flutter</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍如何使用 Flutter 1.7 提供的 &lt;code&gt;split-debug-info&lt;/code&gt; 编译选项来减小包大小。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flutter Overlay 用法简介</title>
    <link href="http://www.sunmoonblog.com/2020/07/15/flutter-overlay-usage/"/>
    <id>http://www.sunmoonblog.com/2020/07/15/flutter-overlay-usage/</id>
    <published>2020-07-15T10:20:29.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter Overlay 用法简介。</p><a id="more"></a><h1 id="Overlay-基本用法"><a href="#Overlay-基本用法" class="headerlink" title="Overlay 基本用法"></a>Overlay 基本用法</h1><p><code>Overlay</code> 实际上是一个 <code>Stack</code>，所以 <code>OverlayEntry</code> 的内容可以是 <code>Positioned</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> overlayEntry = OverlayEntry(builder: (context) =&gt; Positioned(...););</span><br><span class="line">Overlay.of(context).insert(overlayEntry);</span><br></pre></td></tr></table></figure><ul><li>显示 Overlay - 使用 <code>Overlay.of(context).insert()</code> 方法</li><li>隐藏 Overlay - 使用 <code>overlayEntry.remove()</code> 方法</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/overlaybasic.gif" alt="overlay-basic"></p><h1 id="Overlay-高级用法"><a href="#Overlay-高级用法" class="headerlink" title="Overlay 高级用法"></a>Overlay 高级用法</h1><h2 id="指定位置"><a href="#指定位置" class="headerlink" title="指定位置"></a>指定位置</h2><p>有时我们想指定 Overlay 的显示位置，实现方式如下：</p><ul><li>先使用 <code>BuildContext.findRenderObject()</code> 来找到当前 Widget 对应的 RenderObject</li><li>再使用 <code>RenderBox.localToGlobal()</code> 找到 Widget 在屏幕上的位置</li></ul><p>具体见 <code>_calcPos()</code> 方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyButton</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> PosCallback callback;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> _MyButton(&#123;Key key, <span class="keyword">this</span>.callback&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  __MyButtonState createState() =&gt; __MyButtonState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">__MyButtonState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">_MyButton</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; _calcPos() &#123;</span><br><span class="line">    RenderBox renderBox = context.findRenderObject();</span><br><span class="line">    <span class="keyword">var</span> size = renderBox.size;</span><br><span class="line">    <span class="keyword">var</span> offset = renderBox.localToGlobal(Offset.zero);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [offset.dx, offset.dy + size.height];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RaisedButton(</span><br><span class="line">      onPressed: () &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; list = _calcPos();</span><br><span class="line">        widget.callback(list[<span class="number">0</span>], list[<span class="number">1</span>]);</span><br><span class="line">      &#125;,</span><br><span class="line">      child: Text(<span class="string">'show overlay'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/overlaypos.gif" alt="overlay-pos"></p><h2 id="跟随滚动"><a href="#跟随滚动" class="headerlink" title="跟随滚动"></a>跟随滚动</h2><p>使用 <a href="https://api.flutter.dev/flutter/rendering/LayerLink-class.html" target="_blank" rel="noopener">LayerLink</a> 来让 Overlay 跟随指定的 Widget 来滚动。</p><ul><li>LayerLink 用于联系 <a href="https://api.flutter.dev/flutter/rendering/LeaderLayer-class.html" target="_blank" rel="noopener">LeaderLayer</a> 和 <a href="https://api.flutter.dev/flutter/rendering/FollowerLayer-class.html" target="_blank" rel="noopener">FollowerLayer</a></li><li>使用 <a href="https://api.flutter.dev/flutter/widgets/CompositedTransformTarget-class.html" target="_blank" rel="noopener">CompositedTransformTarget</a> 来创建 LeaderLayer</li><li>使用 <a href="https://api.flutter.dev/flutter/widgets/CompositedTransformFollower-class.html" target="_blank" rel="noopener">CompositedTransformFollower</a> 来创建 FollowLayer</li></ul><p>代码篇幅较长，这里就不贴上来了。完整代码见 <a href="https://gist.github.com/410063005/4034c395f3305feeb262482a96d4278e" target="_blank" rel="noopener">gist</a>。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/overlayscroll.gif" alt="overlay-scroll"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://medium.com/saugo360/https-medium-com-saugo360-flutter-using-overlay-to-display-floating-widgets-2e6d0e8decb9" target="_blank" rel="noopener">Flutter: Using Overlay to display floating widgets | by AbdulRahman AlHamali | SAUGO 360 | Medium</a></li><li><a href="https://api.flutter.dev/flutter/rendering/LayerLink-class.html" target="_blank" rel="noopener">LayerLink class - rendering library - Dart API</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter Overlay 用法简介。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter App 内存测试</title>
    <link href="http://www.sunmoonblog.com/2020/07/15/flutter-app-memory-test/"/>
    <id>http://www.sunmoonblog.com/2020/07/15/flutter-app-memory-test/</id>
    <published>2020-07-15T06:12:49.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter 应用内存测试数据。</p><a id="more"></a><h1 id="内存测试一-简单-UI"><a href="#内存测试一-简单-UI" class="headerlink" title="内存测试一 - 简单 UI"></a>内存测试一 - 简单 UI</h1><p>分别<strong>使用 Android 和 Flutter 实现最简单的界面</strong>。</p><ul><li>显示一个文本</li><li>显示一个图片</li></ul><p>使用 TextView 显示 “Hello World!” 的 Android Demo，布局如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Hello World!"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 Text Widget 显示 “Hello World!” 的 Flutter Demo，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Center(child: Text(<span class="string">'Hello World!'</span>)),</span><br></pre></td></tr></table></figure><p>显示图片的 Demo 非常类似，这里略过。</p><p>测试数据显示：<strong>Flutter 应用比原生应用占用更多内存，多出来的部分主要包括 Other、Code、Native、Graphics</strong>。(注意：Android Studio 中无法正常显示 Other 部分变化，<code>adb shell dumpsys meminfo</code> 及 Flutter DevTools 中可正常观察到)</p><p>以下是具体测试数据。</p><h2 id="数据一"><a href="#数据一" class="headerlink" title="数据一"></a>数据一</h2><p>机型及配置：华为 Nova 2，Android 8.0，分辨率480dp(3x)。</p><p>Android Text Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944369530168.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944406815956.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944408053563.jpg" alt></p><p>Android Image Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944370128933.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944407225565.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944408363481.jpg" alt></p><p>Flutter Text Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944384753825.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944408943099.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944440141932.jpg" alt></p><p>Flutter Image Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944385231943.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944409251967.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944440514423.jpg" alt></p><h2 id="数据二"><a href="#数据二" class="headerlink" title="数据二"></a>数据二</h2><p>机型及配置：小米 8，分辨率440dp(2.8x)</p><p>Android Text Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944403017361.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944441459158.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944443093212.jpg" alt></p><p>Android Image Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944404063442.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944441807084.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944443368308.jpg" alt></p><p>Flutter Text Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944399044259.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944442195175.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944443788400.jpg" alt></p><p>Flutter Image Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944399984819.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944442627978.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944444195039.jpg" alt></p><h1 id="内存测试二-分配大对象"><a href="#内存测试二-分配大对象" class="headerlink" title="内存测试二 - 分配大对象"></a>内存测试二 - 分配大对象</h1><p>持续在 Dart 代码中分配对象。观察内存变化。</p><p>测试数据显示：<strong>从 Android 角度看，Dart Heap 中分配的对象归类为 “Private Other” 内存</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Uint8List&gt; _memList = <span class="built_in">List</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _addToMemList() &#123;</span><br><span class="line">    <span class="comment">// 点击一次, 分配 10MB 内存</span></span><br><span class="line">    _memList.add(_createData(<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15945451536123.jpg" alt="-w1428"></p><p>随着分配的 Dart 对象，Dart 内存和 Android 内存都在增加</p><ul><li>左图是 Dart 内存<ul><li>Dart Heap Capacity (绿线区域)一直在增长</li><li><font color="red">Dart Heap Used (浅蓝色区域)一直在增长</font></li><li>Dart External (蓝色区域)几乎不变</li></ul></li><li>右图是 Android 内存<ul><li>Total (绿线)一直在增长</li><li><font color="red">Other (紫线)一直在增长</font></li><li>其他几乎不变</li></ul></li></ul><h1 id="内存测试三-显示图片"><a href="#内存测试三-显示图片" class="headerlink" title="内存测试三 - 显示图片"></a>内存测试三 - 显示图片</h1><p>持续在 Dart 代码中<strong>加载并显示</strong>本地图片(1024x1024)。观察内存变化。</p><p>测试数据显示：<strong>Flutter 应用中图片在 Graphics 内存中分配</strong></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947280277523.jpg" alt="-w1666"></p><p>随着加载和显示的图片增多，Dart 内存和 Android 内存都在增加</p><ul><li>左图是 Dart 内存<ul><li>Dart Heap Capacity (绿线区域)一直在增长</li><li>Dart Heap Used (浅蓝色区域)几乎不变</li><li><font color="red">Dart External (蓝色区域)一直在增长</font></li></ul></li><li>右图是 Android 内存<ul><li>Total (绿线)一直在增长</li><li><font color="red">Graphics (橙色区域)波浪形增长</font></li><li>其他几乎不变</li></ul></li></ul><h1 id="内存测试四-预加载图片"><a href="#内存测试四-预加载图片" class="headerlink" title="内存测试四 - 预加载图片"></a>内存测试四 - 预加载图片</h1><p>持续在 Dart 代码中<strong>预加载但不显示</strong>本地图片(1024x1024)。观察内存变化。</p><p>测试数据显示：<strong>Flutter 应用中图片在 Graphics 内存中分配</strong></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947294740934.jpg" alt="-w1294"></p><p>随着预加载的图片增多，Dart 内存和 Android 内存都在增加</p><ul><li>左图是 Dart 内存<ul><li>Dart Heap Capacity (绿线区域)一直在增长</li><li>Dart Heap Used (浅蓝色区域)几乎不变</li><li><font color="red">Dart External (蓝色区域)一直在增长</font></li></ul></li><li>右图是 Android 内存<ul><li>Total (绿线)一直在增长</li><li><font color="red">Graphics (橙色区域)波浪形增长</font></li><li>其他几乎不变</li></ul></li></ul><h1 id="内存测试五-启动多个-Flutter-引擎"><a href="#内存测试五-启动多个-Flutter-引擎" class="headerlink" title="内存测试五 - 启动多个 Flutter 引擎"></a>内存测试五 - 启动多个 Flutter 引擎</h1><p>持续启动 Flutter 引擎，每次增加一个。观察内存变化。</p><p>测试数据显示：<strong>每开启一个 Flutter 引擎，Native 内存大约有5-6MB增长，Private Other 有10MB左右增长</strong></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947866240369.jpg" alt="-w1302"></p><p>随着 Flutter 引擎数量增多，Dart 内存和 Android 内存都在增加</p><ul><li>左图是 Dart 内存<ul><li><font color="red">Dart Heap Used (浅蓝色区域)几乎不变</font></li><li>Dart External (蓝色区域)一直在增长</li></ul></li><li>右图是 Android 内存<ul><li>Total (绿线)一直在增长</li><li><font color="red">Other (紫色区域)一直在快速增长</font></li><li><font color="red">Native (蓝色区域)一直在较快增长</font></li><li>Graphics (橙色区域)无增长</li></ul></li></ul><p>在 Android Studio 中测试结果如下：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947848408890.jpg" alt></p><p>随着 Flutter 引擎数量增多，</p><ul><li>Private Other 一直在增长 (注：注意：Android Studio 中无法正常显示 Other 部分变化，<code>adb shell dumpsys meminfo</code> 及 Flutter DevTools 中可正常观察到)</li><li>Native 内存(蓝色区域)一直在增长</li></ul><h1 id="测试结论"><a href="#测试结论" class="headerlink" title="测试结论"></a>测试结论</h1><ul><li>Flutter 应用比原生应用占用更多内存，多出来的部分主要包括 Other、Code、Native、Graphics <a href="https://developer.android.com/studio/profile/memory-profiler#how-counted" target="_blank" rel="noopener">内存分类</a> <a href="https://developer.android.com/studio/command-line/dumpsys#meminfo" target="_blank" rel="noopener">meminfo</a></li><li>从 Android 角度看，Dart Heap 属性 “Private Other” 内存。Dart 中创建对象会导致 Private Other 内存增长</li><li>Flutter 应用中图片在 Graphics 内存中分配 <a href="https://www.yuque.com/xytech/flutter/avmyht" target="_blank" rel="noopener">闲鱼技术 Android Flutter实践内存初探</a></li><li>每开启一个 Flutter 引擎，Native 内存大约有5-6MB增长，Private Other 有10MB左右增长</li></ul><p>为什么 Flutter 应用会比原生应用占用更多内存？官网给出的一些数据也许能解释部分原因。以下翻译自 <a href="https://flutter.dev/docs/development/add-to-app/performance#memory-and-latency" target="_blank" rel="noopener">Load sequence, performance, and memory - Flutter</a></p><blockquote><p>展示 Flutter UI 会有一定不可忽视的延迟。可以提前启动 Flutter 引擎来减少这个延迟。</p><p>集成 Flutter 到已有应用时要评估预加载 Flutter 引擎(即，加载 Flutter 库、启动 Dart VM、运行 isolate 入口程序)带来的内存开销及延迟。</p><p>在 2015 年的一款低端手机上，Flutter v1.10.3 release-AOT 模式下预热 <code>FlutterEngine</code> 开销如下：</p><ul><li><strong>Android</strong> 42 MB 和 1530 ms。其中有 330 ms 会阻塞主线程</li><li><strong>iOS</strong>  22 MB 和 860 ms。其中有 260 ms 会阻塞主线程</li></ul><p>内存方面，一个测试样本数据如下(根据使用场景会有所变化)</p><ul><li>~4 MB OS’s memory usage for creating pthreads.</li><li>~10 MB GPU driver memory.</li><li>~1 MB for Dart runtime-managed memory.</li><li>~5 MB for Dart-loaded font maps.</li></ul><p>延迟方面，一个测试样本数据如下(根据使用场景会有所变化)</p><ul><li>~20 ms to collect the Flutter assets from the application package.</li><li>~15 ms to dlopen the Flutter engine library.</li><li>~200 ms to create the Dart VM and load the AOT snapshot.</li><li>~200 ms to load Flutter-dependent fonts and assets.</li><li>~400 ms to run the entrypoint, create the first widget tree, and compile the needed GPU shader programs.</li></ul><p>预热 Flutter 引擎的时机应该足够晚，以减小内存占用；同时还要足够早，以避免 Flutter 引擎启动时间跟首帧延迟叠加在一起(否则会感觉启动慢，体验非常糟糕)</p><p>具体预热时机要根据应用的实际结构来决定。通常经验是在将显示 Flutter 页面的前一个页面中预热</p><p>假设引擎已经预热，关联 UI 时的首帧开销如下：</p><ul><li><strong>Android</strong> 320 ms 以及额外的 12 MB (跟屏幕的物理像素尺寸非常相关，physical pixel size)</li><li><strong>iOS</strong> 200 ms 以及额外的 16 MB (跟屏幕的物理像素尺寸非常相关，physical pixel size)</li></ul><p>内存方面，开销主要来自用于渲染的 graphical memory buffer (跟屏幕尺寸相关)</p><p>延迟方面，开销主要是等原生系统回调(提供 surface)以及编译 shader 程序(原文: compiling the remaining shader programs that are not pre-emptively predictable)的时间。这里的延迟仅在第一帧</p><p>Flutter UI 释放后，相关内存也会释放。这里的内存释放跟 <code>FlutterEngine</code> 中的 Flutter State 无关，除非 <code>FlutterEngine</code> 也释放了</p></blockquote><h1 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h1><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947301347638.jpg" alt></p><p>Flutter 应用内存可优化的点分别是：</p><ul><li>Private Others，Dart 代码分配的对象属于这一类。优化点是减少 Dart 代码中不必要的对象分配，尤其是大对象</li><li>Code - 用于处理代码和资源，如 dex 字节码，so 库和字体。优化点是减少 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小</li><li>Graphics - 图形缓冲区队列向屏幕显示像素（包括 GL 表面、GL 纹理等等）所使用的内存。比较好入手的一个优化是减少 Dart 代码中图片占用的内存。另外可以考虑优化 Flutter UI 这一块(同样使用 skia，为什么 Android 原生 UI 占用的内存比 Flutter UI 少？)</li><li>Native - C 或 C++ 代码分配的对象的内存。优化点是减少 Flutter 引擎占用的内存，比如单引擎比多引擎使用更少的内存</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947874114688.jpg" alt="-w1261"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter 应用内存测试数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>(译) Flutter 原理</title>
    <link href="http://www.sunmoonblog.com/2020/07/11/how-flutter-works/"/>
    <id>http://www.sunmoonblog.com/2020/07/11/how-flutter-works/</id>
    <published>2020-07-11T06:29:22.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter 是如何工作的？<br><a id="more"></a></p><p>要点如下：</p><ul><li>Flutter 框架更像一个游戏引擎，而不是传统的应用框架</li><li>Flutter 应用由 Widget 构成，Widget 被渲染到 Skia canvas，最后发送到平台</li><li>Flutter 引擎在对应的平台 shell 中运行</li><li>Flutter UI 发生变化时会被构建和渲染到 Skia Canvas</li><li>Flutter 以 60fps 来更新 UI，并且使用 GPU 完成大部分工作</li></ul><p>原文翻译如下。</p><p>跟其他框架相比，Flutter 以一种全新的方式构建，它更像一个游戏引擎而不是传统应用框架。我想讲讲在大层面上 Flutter 是如何工作的，以及它如何实现高性能。从大的层面来讲，<strong>应用由 Widget 构成，Widget 被渲染到 Skia canvas，最后发送到平台。平台显示 canvas，并且按要求返回事件</strong>。</p><p><img src="/images/15944494180838.jpg" alt></p><p>应用在平台上以 AOT 直接运行 (Your app runs on the platform in natively, Ahead of Time complied.)</p><h1 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h1><p>Flutter 在平台上提供 <code>Shell</code>，用作 Dart VM 和宿主。Shell 是平台相关的，提供对平台原生 API 的访问支持并且建立平台相关的 canvas。</p><p><img src="/images/15944503631949.jpg" alt></p><p>Shell 还用于和 IMEs 和系统应用生命周期事件通信。</p><h1 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h1><p>引擎是平台之上的层，提供 Dart 运行时、Skia、Platform Channel 及其他内容。Flutter Wiki 中的<a href="https://github.com/flutter/engine/wiki#architecture-diagram" target="_blank" rel="noopener">架构图</a>中有更多细节。</p><p><img src="/images/15944505039484.jpg" alt></p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>Flutter 引擎跟应用开发者最相关。它包含你开发应用时需要交互的所有内容。</p><p><img src="/images/15944513053707.jpg" alt></p><p>Flutter 只需简单使用对应的风格就能保持跟 iOS 或 Android 原生一致风格。iOS 使用 Cupertino 风格，Android 使用 Material 风格。</p><p>Flutter 不使用原生组件，而是 Widget。Widget 是 Flutter 应用的组件。Flutter 将 UI 绘制到 Skia Canvas。</p><p>一旦 UI 完成渲染，就进入引擎环境。</p><h1 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h1><p>Flutter 更像游戏引擎，而不是应用框架。Flutter UI 发生变化时会被构建和渲染到 Skia Canvas。Flutter 以 60fps 来更新 UI，并且使用 GPU 完成大部分工作。(所以 Flutter UI 这么流畅)</p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>这里只是大体上讲了一下 Flutter 是如何工作的，实际上 Flutter 底层有许多细节。可以参考这些资料</p><p>代码库：</p><ul><li><a href="https://github.com/flutter/flutter" target="_blank" rel="noopener">Flutter Framework</a></li><li><a href="https://github.com/flutter/engine" target="_blank" rel="noopener">Flutter Engine</a></li></ul><p>技术文档：</p><ul><li><a href="https://docs.google.com/presentation/d/1cw7A4HbvM_Abv320rVgPVGiUP2msVs7tfGbkgdrTy0I/edit#slide=id.p" target="_blank" rel="noopener">Flutter System Architecture Diagrams</a></li><li><a href="https://flutter.io/technical-overview/" target="_blank" rel="noopener">Technical Overview</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter 是如何工作的？&lt;br&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
      <category term="翻译" scheme="http://www.sunmoonblog.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Dart VM Service 简介</title>
    <link href="http://www.sunmoonblog.com/2020/07/07/dart-vm-service/"/>
    <id>http://www.sunmoonblog.com/2020/07/07/dart-vm-service/</id>
    <published>2020-07-07T07:28:13.000Z</published>
    <updated>2020-11-13T02:18:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter 开发工具 DevTools 是不是有些神奇？移动端开发中用到的性能工具通常是原生应用，而 DevTools 却是基于浏览器的。为什么要基于浏览器开发，Dart VM Service Protocol 又是什么？简单了解一下。</p><a id="more"></a><p>Dart DevTools 提供 hot reload、UI 调试和内存分析等各种功能。</p><p><img src="/images/15941055868454.jpg" alt></p><h1 id="Dart-VM-Service-Protocol"><a href="#Dart-VM-Service-Protocol" class="headerlink" title="Dart VM Service Protocol"></a>Dart VM Service Protocol</h1><p>先来看看 Dart VM Service Protocol 是什么。</p><p><a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#rpcs-requests-and-responses" target="_blank" rel="noopener">Dart VM Service Protocol 3.36</a> 介绍如下：</p><blockquote><p>Service Protocol 协议用于跟运行中的 Dart VM 通信</p><p>使用 <code>--observe</code> 启动 Dart VM 后就能使用 Service Protocol。VM 会启动一个 webserver 并通过 WebSocket 为 protocol request 提供服务。也可发送 HTTP (非WebSocket)请求，但这种情况下无法访问 VM <em>event</em></p><p>Service Protocol 使用 <a href="http://www.jsonrpc.org/specification" target="_blank" rel="noopener">JSON-RPC 2.0</a> 来通信</p></blockquote><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>通过 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#getversion" target="_blank" rel="noopener">getVersion</a> 这个例子来看看 RPC 请求和响应。</p><p>RPC request 是一个发送到 server 的 JSON 对象。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>, <span class="comment">// jsonprc 属性可选</span></span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"getVersion"</span>, <span class="comment">//</span></span><br><span class="line">  <span class="attr">"params"</span>: &#123;&#125;, <span class="comment">// params 属性在 Dart 代码中以 named parameters 形式提供</span></span><br><span class="line">  <span class="attr">"id"</span>: <span class="string">"1"</span> <span class="comment">// id 属性可以是 string, number, null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RPC response 也是一个 JSON 对象。</p><p>这是一个成功的 RPC response：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"result"</span>: &#123; <span class="comment">// 请求成功时返回 result 属性</span></span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"Version"</span>, <span class="comment">// type 参数可用于判断准确的返回类型，它是 Response 类的子类</span></span><br><span class="line">    <span class="attr">"major"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"minor"</span>: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">"id"</span>: <span class="string">"1"</span> <span class="comment">// id 属性跟对应请求中的 id 匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个失败的 RPC response：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"error"</span>: &#123; <span class="comment">// 请求失败时返回 error 属性，它包括 code, message 和 data</span></span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">103</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"Stream already subscribed"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">      <span class="attr">"details"</span>: <span class="string">"The stream 'GC' is already subscribed"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">"id"</span>: <span class="string">"2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="error codes">JSON-RPC 规范</a>的基础上，Service Protocol 定义了一些额外的错误码。具体错误见 Service Protocol 文档，这里不展开。</p><h2 id="Event-和-Binary-Event"><a href="#Event-和-Binary-Event" class="headerlink" title="Event 和 Binary Event"></a>Event 和 Binary Event</h2><ul><li>通过使用 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#streamlisten" target="_blank" rel="noopener">streamListen</a> 和 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#streamcancel" target="_blank" rel="noopener">streamCancel</a> RPC，客户端可以收到 VM 中特定 stream 上的事件通通知</li><li>每个 stream 跟一个 <em>stream id</em> 关联</li><li>每个 stream 跟某种类型的事件关联。比如 <em>Isolate</em> stream 提供 isolate 相关的创建和销毁等事件</li><li>客户端通过 WebSocket 异步接收 stream event</li><li>某些事件跟二进制数据关联，通过 WebSocket binary frame 而不是 text frame 发送这些事件</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"json-rpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"streamNotify"</span>,</span><br><span class="line">  <span class="attr">"params"</span>: &#123; <span class="comment">// 参数中包括 streamId 和 event 属性</span></span><br><span class="line">    <span class="attr">"streamId"</span>: <span class="string">"Isolate"</span>,</span><br><span class="line">    <span class="attr">"event"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Event"</span>,</span><br><span class="line">      <span class="attr">"kind"</span>: <span class="string">"IsolateExit"</span>,</span><br><span class="line">      <span class="attr">"isolate"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"@Isolate"</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"isolates/33"</span>,</span><br><span class="line">        <span class="attr">"number"</span>: <span class="string">"51048743613"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"worker-isolate"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>Service Protocol 中的每个响应或事件均有 <code>type</code> 属性，它是 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#response" target="_blank" rel="noopener">Response</a> 子类。客户端可以通过 <code>type</code> 属性判断每种响应或事件的准确类型。</p><ul><li>以 <code>@</code> 开头的 type 表示当前响应是一个 <code>reference</code></li><li>不以 <code>@</code> 开头的 type 表示当前响应是一个 <code>object</code></li></ul><p><code>reference</code> 可提供的信息是 <code>object</code> 的子集</p><h1 id="Dart-VM-Service-Protocol-Extension"><a href="#Dart-VM-Service-Protocol-Extension" class="headerlink" title="Dart VM Service Protocol Extension"></a>Dart VM Service Protocol Extension</h1><p><a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service_extension.md" target="_blank" rel="noopener">Dart VM Service Protocol Extension</a> 与 VM 通信的方式跟 Service Protocol 类似跟类似，但它们并不是核心 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md" target="_blank" rel="noopener">Dart VM Service Protocol</a> 的一部分，仅允许通过某些核心库访问。</p><p>通过添加前缀名来调用对应的 RPC 接口，类似 “ext.dart.libraryName”。比如，调用 <code>ext.dart.io.getSocketProfile</code> 来执行 dart:io 暴露的 <code>getSocketProfile</code> RPC 接口。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单了解 Dart VM Service Protocol 和 Dart VM Service Protocol Extension 后，我们有以下认识：</p><ul><li>Service Protocol 和 Service Protocol Extension 是一套 RPC-JSON 协议</li><li>Service Protocol 兼容性好，可以很容易地集成到现有 IDE</li><li>VM 会启动一个 webserver 并通过 WebSocket 为客户端提供服务</li></ul><p>为什么要基于浏览器来开发 DevTools？有以下几个原因</p><ul><li>浏览器天生支持 WebSocket，所以基于浏览器开发 DevTools 是水到渠成</li><li>基于浏览器开发 DevTools，可兼容多平台</li><li>当前的 DevTools 是使用 Flutter 框架开发的 (没错，Flutter。以前是纯 Dart 开发)，部署成 Web 应用很方便</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#rpcs-requests-and-responses" target="_blank" rel="noopener">sdk/service.md at master · dart-lang/sdk</a></li><li><a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service_extension.md" target="_blank" rel="noopener">sdk/service_extension.md at master · dart-lang/sdk</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652058622&amp;idx=1&amp;sn=3551e237325a72a99ac71ec8c8747a43&amp;chksm=808c93bbb7fb1aad62acae899e59e36596d719c1194a912b26cccf565641c5a2683e675b691e&amp;mpshare=1&amp;scene=1&amp;srcid=0707V7mgrCqByikjM5WbdfpD&amp;sharer_sharetime=1594105478505&amp;sharer_shareid=b5535657e3516bd6d7252ce5f5ed09f4#rd" target="_blank" rel="noopener">​我们用 Flutter 写了一套全新的 Flutter 开发者工具</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter 开发工具 DevTools 是不是有些神奇？移动端开发中用到的性能工具通常是原生应用，而 DevTools 却是基于浏览器的。为什么要基于浏览器开发，Dart VM Service Protocol 又是什么？简单了解一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
      <category term="Dart" scheme="http://www.sunmoonblog.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 引擎崩溃分析方法简介</title>
    <link href="http://www.sunmoonblog.com/2020/07/04/flutter-engine-crash-track/"/>
    <id>http://www.sunmoonblog.com/2020/07/04/flutter-engine-crash-track/</id>
    <published>2020-07-04T02:48:41.000Z</published>
    <updated>2020-11-13T02:18:59.049Z</updated>
    
    <content type="html"><![CDATA[<p>Android 项目信息 Flutter 后上线，偶尔会遇到一些 Flutter 引擎的崩溃。简单记录下如何还原引擎崩溃日志，方便在源码中定位问题。</p><a id="more"></a><h1 id="Flutter-Engine-Crash-堆栈还原"><a href="#Flutter-Engine-Crash-堆栈还原" class="headerlink" title="Flutter Engine Crash 堆栈还原"></a>Flutter Engine Crash 堆栈还原</h1><p>首先，在 <code>bin/internal/engine.version</code> 找到 flutter engine revision</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b851c718295a896918dc93cb1ff14f2f895a1b90</span><br></pre></td></tr></table></figure><p>第二步，下载带符号表的 <code>libflutter.so</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://console.cloud.google.com/storage/browser/flutter_infra/flutter/b851c718295a896918dc93cb1ff14f2f895a1b90</span><br></pre></td></tr></table></figure><p>第三步，利用 <code>ndk-stack</code> 还原堆栈信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/path/to/android-ndk-r16b/ndk-stack -sym /path/to/symbols/armeabi-v7a -dump /path/to/stacktrace.txt</span><br></pre></td></tr></table></figure><p>如果是将 crash 上报到 bugly 平台，则不必使用 <code>ndk-stack</code>，直接在 bugly 上配置符号表即可。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/04/15938295883428.jpg" alt></p><p>配置成功后就能在 bugly 平台上看到 native crash 堆栈信息。</p><p>原始堆栈信息<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/04/15938297243231.jpg" alt></p><p>还原后的堆栈信息<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/04/15938297398367.jpg" alt></p><p>拿到还原后的堆栈信息，就可以对着源码分析问题了。</p><h1 id="一个疑问"><a href="#一个疑问" class="headerlink" title="一个疑问"></a>一个疑问</h1><p>官方提到每个 <code>libflutter.so</code> 文件中有一个 build id，native crash 堆栈中见到的 <code>BuildId</code> 要跟 <code>libflutter.so</code> 的匹配，否则没法还原 native crash 堆栈信息。原文如下：</p><blockquote><p>The build system sets a build id for each libflutter.so file. In the tombstones, you would see the ID like so:</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; #00 pc 000000000062d6e0  /data/app/com.app-tARy3eLH2Y-QN8J0d0WFog==/lib/arm64/libflutter.so!libflutter.so (offset 0x270000) (BuildId: 34ad5bdf0830d77a)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>This equals to a build id of 34ad5bdf0830d77a. The libflutter.so debug files downloaded as shown above could be verified using the file command:</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; % file ~/Downloads/libflutter.so</span><br><span class="line">&gt; /Users/user/Downloads/libflutter.so: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, BuildID[xxHash]=34ad5bdf0830d77a, with debug_info, not stripped</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Ensure the build IDs match, else you will not be able to symbolicate.</p></blockquote><p>不过我往 bugly 上传了一个非严格匹配的符号表(上报 crash 的 app 使用的是自己编译的 <code>libflutter.so</code>，符号表是官方提供的 <code>libflutter.so</code>)，也能还原出来。让人很是疑惑。</p><p>观察了下，bugly 上看到的 native crash 日志中并没有找到类似 <code>(BuildId: 34ad5bdf0830d77a)</code> 这样的信息。<em>推测</em>由此导致匹配变得不严格，所以也能还原出来。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>某个 native crash 还原后得到如下堆栈信息。</p><p><img src="/images/15938315565456.jpg" alt></p><p>首先看到的是 <code>message_loop_impl.cc</code> 中的 <code>MessageLoopImpl::RunExpiredTasksNow</code>。这个方法会立即执行任务队列中的已过期任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageLoopImpl::FlushTasks</span><span class="params">(FlushType type)</span> </span>&#123;</span><br><span class="line">  TRACE_EVENT0(<span class="string">"fml"</span>, <span class="string">"MessageLoop::FlushTasks"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;fml::closure&gt; invocations;</span><br><span class="line"></span><br><span class="line">  task_queue_-&gt;GetTasksToRunNow(queue_id_, type, invocations);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; invocation : invocations) &#123;</span><br><span class="line">    invocation();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;fml::closure&gt; observers =</span><br><span class="line">        task_queue_-&gt;GetObserversToNotify(queue_id_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; observer : observers) &#123;</span><br><span class="line">      observer();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageLoopImpl::RunExpiredTasksNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FlushTasks(FlushType::kAll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看到的是 <code>platform_view_android_jni.cc</code> 中的 <code>FlutterViewUpdateSemantics</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FlutterViewUpdateSemantics</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">                                jobject buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                jobjectArray strings)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用 g_update_semantics_method (Java 层方法)</span></span><br><span class="line">  env-&gt;CallVoidMethod(obj, g_update_semantics_method, buffer, strings);</span><br><span class="line">  <span class="comment">// 检查 Java 代码是否发生异常，有异常则写入 fml 日志中</span></span><br><span class="line">  FML_CHECK(CheckException(env));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RegisterApi</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// g_update_semantics_method 对应的是 </span></span><br><span class="line">  <span class="comment">// Java 层中的 FlutterJNI.updateSemantics() 方法</span></span><br><span class="line">  g_update_semantics_method =</span><br><span class="line">      env-&gt;GetMethodID(g_flutter_jni_class-&gt;obj(), <span class="string">"updateSemantics"</span>,</span><br><span class="line">                       <span class="string">"(Ljava/nio/ByteBuffer;[Ljava/lang/String;)V"</span>);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 Java 代码是否发生异常</span></span><br><span class="line"><span class="comment">// 发生异常时返回 false，否则返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckException</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (env-&gt;ExceptionCheck() == JNI_FALSE)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  jthrowable exception = env-&gt;ExceptionOccurred();</span><br><span class="line">  env-&gt;ExceptionClear();</span><br><span class="line">  FML_LOG(ERROR) &lt;&lt; fml::jni::GetJavaExceptionInfo(env, exception);</span><br><span class="line">  env-&gt;DeleteLocalRef(exception);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后看到的是 <code>logging.cc</code> 第92行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">LogMessage::~LogMessage() &#123;</span><br><span class="line">  stream_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_ANDROID)</span></span><br><span class="line">  android_LogPriority priority =</span><br><span class="line">      (severity_ &lt; <span class="number">0</span>) ? ANDROID_LOG_VERBOSE : ANDROID_LOG_UNKNOWN;</span><br><span class="line">  <span class="keyword">switch</span> (severity_) &#123;</span><br><span class="line">    <span class="keyword">case</span> LOG_INFO:</span><br><span class="line">      priority = ANDROID_LOG_INFO;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LOG_WARNING:</span><br><span class="line">      priority = ANDROID_LOG_WARN;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LOG_ERROR:</span><br><span class="line">      priority = ANDROID_LOG_ERROR;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LOG_FATAL:</span><br><span class="line">      priority = ANDROID_LOG_FATAL;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  __android_log_write(priority, <span class="string">"flutter"</span>, stream_.str().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(OS_IOS)</span></span><br><span class="line">  syslog(LOG_ALERT, <span class="string">"%s"</span>, stream_.str().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; stream_.str();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span>.flush();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (severity_ &gt;= LOG_FATAL) &#123;</span><br><span class="line">    <span class="comment">// 最终的 crash 由这里产生</span></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初看起来可能会有点不明白 crash 如何产生，梳理一下就渐渐明了：</p><ul><li>调用 <code>RunExpiredTasksNow</code> 立即执行队伍中的过期任务</li><li>过期任务中的某一个任务调用了 <code>FlutterViewUpdateSemantics()</code> (C++层)</li><li><code>FlutterViewUpdateSemantics()</code> 调用 <code>FlutterJNI.updateSemantics()</code> (Java层)</li><li><code>FlutterViewUpdateSemantics()</code> 调用 <code>CheckException()</code> 检查 Java 代码执行后是否产生异常</li><li><code>FlutterViewUpdateSemantics()</code> 调用 <code>FML_CHECK()</code> 记录错误日志 (如有 Java 异常)</li></ul><p>所以我们可以把怀疑目标锁定到 <code>FlutterJNI.updateSemantics()</code> 方法。剩下的工作就是进入 Java 层分析该方法的出错原因了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Keep</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterJNI</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Invoked by native to send semantics tree updates from Flutter to Android.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The &#123;<span class="doctag">@code</span> buffer&#125; and &#123;<span class="doctag">@code</span> strings&#125; form a communication protocol that is implemented here:</span></span><br><span class="line"><span class="comment">   * https://github.com/flutter/engine/blob/master/shell/platform/android/platform_view_android.cc#L207</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateSemantics</span><span class="params">(@NonNull ByteBuffer buffer, @NonNull String[] strings)</span> </span>&#123;</span><br><span class="line">    ensureRunningOnMainThread();</span><br><span class="line">    <span class="keyword">if</span> (accessibilityDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">      accessibilityDelegate.updateSemantics(buffer, strings);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO(mattcarroll): log dropped messages when in debug mode (https://github.com/flutter/flutter/issues/25391)</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://fucknmb.com/2019/10/20/%E8%8E%B7%E5%8F%96%E5%B9%B6%E8%BF%98%E5%8E%9FFlutter-Engine-Crash%E5%A0%86%E6%A0%88/" target="_blank" rel="noopener">获取并还原 Flutter Engine Crash 堆栈 | 区长</a></li><li><a href="https://github.com/flutter/flutter/wiki/Crashes" target="_blank" rel="noopener">Crashes · flutter/flutter Wiki</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 项目信息 Flutter 后上线，偶尔会遇到一些 Flutter 引擎的崩溃。简单记录下如何还原引擎崩溃日志，方便在源码中定位问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://www.sunmoonblog.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>mockjs 入门</title>
    <link href="http://www.sunmoonblog.com/2020/07/02/mockjs-basic/"/>
    <id>http://www.sunmoonblog.com/2020/07/02/mockjs-basic/</id>
    <published>2020-07-02T08:17:46.000Z</published>
    <updated>2020-11-13T02:18:59.049Z</updated>
    
    <content type="html"><![CDATA[<p>感觉 mockjs 真是个好东西。简单了解下用法。<br><a id="more"></a></p><h1 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h1><p>先直接上文档 <a href="http://mockjs.com/examples.html#Image" target="_blank" rel="noopener">Mock.js</a>。文档中列出了 mockjs 可以模拟的数据类型，包括：</p><ul><li>string</li><li>number</li><li>bool</li><li>array</li><li>object</li><li>guid</li><li>id</li><li>title</li><li>paragraph</li><li>image</li><li>address</li><li>date</li><li>time</li><li>url</li><li>email</li><li>ip</li><li>regexp</li></ul><p>不要小看这个文档，<strong>你可以打开控制台，随意地试验这些方法。</strong></p><p><img src="/images/15936783153589.jpg" alt="-w795"></p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>这里列举几个我用到的模拟数据。</p><p>模拟 title：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Mock.mock(&#123;<span class="string">'title'</span>: <span class="string">'@title(1)'</span>&#125;)</span><br><span class="line"><span class="comment">// &#123;title: "Qoqhdl"&#125;</span></span><br><span class="line">&gt; Mock.mock(&#123;<span class="string">'title'</span>: <span class="string">'@csentence(6)'</span>&#125;)</span><br><span class="line"><span class="comment">// &#123;title: "容约声量局有。"&#125;</span></span><br></pre></td></tr></table></figure><p>模拟图片：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Mock.mock(&#123;<span class="string">'head'</span>: <span class="string">'@image()'</span>&#125;)</span><br><span class="line"><span class="comment">// &#123;head: "http://dummyimage.com/234x60"&#125;</span></span><br></pre></td></tr></table></figure><p>模拟图片打开之后的效果如下：</p><p><img src="/images/15936788801014.jpg" alt="-w938"></p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>mockjs 的语法还是比较简单易懂的，感觉不必花时间专门研究。不过不妨找一批较全的示例，实在不记得怎么写时可以照着示例来写。这里直接贴上一个示例，它来自<a href="https://github.com/ToNiQian/mockjs" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Mock</span></span><br><span class="line"><span class="keyword">let</span> Mock = <span class="built_in">require</span>(<span class="string">'mockjs'</span>);</span><br><span class="line">Mock.mock(<span class="string">'http://1.json'</span>,<span class="string">'get'</span>,&#123;</span><br><span class="line">    <span class="comment">// 属性 list 的值是一个数组，其中含有 1 到 3 个元素</span></span><br><span class="line">    <span class="string">'list|1-3'</span>: [&#123;</span><br><span class="line">        <span class="comment">// 属性 sid 是一个自增数，起始值为 1，每次增 1</span></span><br><span class="line">        <span class="string">'sid|+1'</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="comment">// 属性 userId 是一个5位的随机码</span></span><br><span class="line">        <span class="string">'userId|5'</span>: <span class="string">''</span>,</span><br><span class="line">        <span class="comment">// 属性 sex 是一个bool值</span></span><br><span class="line">        <span class="string">"sex|1-2"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 属性 city对象 是对象值中2-4个的值</span></span><br><span class="line">        <span class="string">"city|2-4"</span>: &#123;</span><br><span class="line">            <span class="string">"110000"</span>: <span class="string">"北京市"</span>,</span><br><span class="line">            <span class="string">"120000"</span>: <span class="string">"天津市"</span>,</span><br><span class="line">            <span class="string">"130000"</span>: <span class="string">"河北省"</span>,</span><br><span class="line">            <span class="string">"140000"</span>: <span class="string">"山西省"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//属性 grade 是数组当中的一个值</span></span><br><span class="line">        <span class="string">"grade|1"</span>: [</span><br><span class="line">            <span class="string">"1年级"</span>,</span><br><span class="line">            <span class="string">"2年级"</span>,</span><br><span class="line">            <span class="string">"3年级"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">//属性 guid 是唯一机器码</span></span><br><span class="line">        <span class="string">'guid'</span>: <span class="string">'@guid'</span>,</span><br><span class="line">        <span class="comment">//属性 id 是随机id</span></span><br><span class="line">        <span class="string">'id'</span>: <span class="string">'@id'</span>,</span><br><span class="line">        <span class="comment">//属性 title 是一个随机长度的标题</span></span><br><span class="line">        <span class="string">'title'</span>: <span class="string">'@title()'</span>,</span><br><span class="line">        <span class="comment">//属性 paragraph 是一个随机长度的段落</span></span><br><span class="line">        <span class="string">'paragraph'</span>: <span class="string">'@cparagraph'</span>,</span><br><span class="line">        <span class="comment">//属性 image 是一个随机图片 参数分别为size, background, text</span></span><br><span class="line">        <span class="string">'image'</span>: <span class="string">"@image('200x100', '#4A7BF7', 'Hello')"</span>,</span><br><span class="line">        <span class="comment">//属性 address 是一个随机地址</span></span><br><span class="line">        <span class="string">'address'</span>: <span class="string">'@county(true)'</span>,</span><br><span class="line">        <span class="comment">//属性 date 是一个yyyy-MM-dd 的随机日期</span></span><br><span class="line">        <span class="string">'date'</span>: <span class="string">'@date("yyyy-MM-dd")'</span>,</span><br><span class="line">        <span class="comment">//属性 time 是一个 size, background, text 的随机时间</span></span><br><span class="line">        <span class="string">'time'</span>: <span class="string">'@time("HH:mm:ss")'</span>,</span><br><span class="line">        <span class="comment">//属性 url 是一个随机的url</span></span><br><span class="line">        <span class="string">'url'</span>: <span class="string">'@url'</span>,</span><br><span class="line">        <span class="comment">//属性 email 是一个随机email</span></span><br><span class="line">        <span class="string">'email'</span>: <span class="string">'@email'</span>,</span><br><span class="line">        <span class="comment">//属性 ip 是一个随机ip</span></span><br><span class="line">        <span class="string">'ip'</span>: <span class="string">'@ip'</span>,</span><br><span class="line">        <span class="comment">//属性 regexp 是一个正则表达式匹配到的值 如aA1</span></span><br><span class="line">        <span class="string">'regexp'</span>: <span class="regexp">/[a-z][A-Z][0-9]/</span>,</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="其他模拟方式"><a href="#其他模拟方式" class="headerlink" title="其他模拟方式"></a>其他模拟方式</h1><p>以下是另外两个 mock 库，看起来更为强大。</p><ul><li><a href="https://github.com/APIJSON/APIJSON" target="_blank" rel="noopener">APIJSON/APIJSON: 🏆码云最有价值开源项目 🚀后端接口和文档自动化，前端(客户端) 定制返回 JSON 的数据和结构！🏆Gitee Most Valuable Project 🚀A JSON Transmission Protocol and an ORM Library for automatically providing APIs and Docs.</a></li><li><a href="https://github.com/chinesedfan/parrot-mocker-web/blob/master/README-zh.md" target="_blank" rel="noopener">parrot-mocker-web/README-zh.md at master · chinesedfan/parrot-mocker-web</a></li></ul><p><a href="https://segmentfault.com/a/1190000011230904" target="_blank" rel="noopener">AntDesign结合mockjs随机生成图片</a> 提供了另外一种思路：上传一批图片到云端(保证名字有规律)，再使用 mockjs 来拿到图片地址，从而实现在模拟自定义图片。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>mockjs 本身并不是特别有用，不过它结合 vue-admin-template 中的 mock-server，可以直接模拟线上接口，方便在后台尚未提供接口的情况下开始前端页面开发。这一点在某些情况下特别有用，如果事先后台能提供接口协议，保证模拟接口跟实际接口基本一致，生产力应该能大大提高。</p><p>vue-admin-template 中 mock-server 的用法见<a href="https://www.sunmoonblog.com/2020/07/01/vue-mockserver-watch-not-working/">前一篇</a>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">nuysoft/Mock: A simulation data generator</a></li><li><a href="http://mockjs.com/examples.html#Image" target="_blank" rel="noopener">Mock.js</a></li><li><a href="https://github.com/ToNiQian/mockjs" target="_blank" rel="noopener">ToNiQian/mockjs: 一个webpack 搭建的 mock 案例演示</a></li><li><a href="https://juejin.im/post/599c1bfaf265da248d0cc6b6" target="_blank" rel="noopener">Mockjs,再也不用追着后端小伙伴要接口了 - 掘金</a></li><li><a href="https://juejin.im/post/5ce2a960e51d455a2f2201c3" target="_blank" rel="noopener">vue-vue项目中mock.js的使用 - 掘金</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉 mockjs 真是个好东西。简单了解下用法。&lt;br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://www.sunmoonblog.com/tags/javascript/"/>
    
      <category term="Vue" scheme="http://www.sunmoonblog.com/tags/vue/"/>
    
  </entry>
  
</feed>
