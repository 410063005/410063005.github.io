---
layout: post
title: css-part2
keywords: css
description: css
categories: [css]
tags: [css]
group: archive
icon: globe
---

CSS选择器效率从高到低的排序如下:

1. ID选择器 比如#header
2. 类选择器 比如.promo
3. 元素选择器 比如 div
4. 兄弟选择器 比如 h2 + p
5. 子选择器 比如 li > ul
6. 后代选择器 比如 ul a
7. 通用选择器 比如 *
8. 属性选择器 比如 type = “text”
9. 伪类/伪元素选择器 比如 a:hover


使用组合选择器比如#nav a,来选择任何在ID为’nav’的元素里面的链接元素。此刻，我们读这些是从左到右的方式。我们是先找到#nav，然后从它的里面找其他元素。但是浏览器解析这些不是这样的：浏览器解析选择器是从右到左的方式。

在我们看来，#nav里面带了一个a，浏览器却是看到的a在#nav里面。深入了解看 [这里](http://stackoverflow.com/questions/5797014/why-do-browsers-match-CSS-selectors-from-right-to-left)

# 关键选择器

什么是关键选择器，可以如下理解：
>复杂的CSS选择器中最右边部分

所以

	#content .intro {..}

比下面这个选择器要高效：

	#content * {..}

前者：浏览器会寻找.intro的实例（可能会很多），然后沿着DOM树向上查找，确定刚才找到的实例是否在一个带有ID为”content”的容器里面。

后者：选择所有在页面上的单个元素（是每个单个的元素），然后去看看它们是否有一个 #content 的父元素。这是一个非常不高效选择器因为它的关键选择器执行开销太大了。

## 选择器的性能
假设你有一个复杂的页面，它相当巨大并且在你的一个很大很大的站点上。在那个页面上有成百上千甚至上万的 a 标签。

	#social a {…}

这个选择器高效吗？显示是否定的。这里发生的情况是浏览器会在定位到#social区域下的四个链接之前得到页面上所有成千上万的链接。我们的关键选择器匹配了太多我们不感兴趣的其他元素。

为了补救我们可以给每个在社交链接区域的 a 增加一个更特殊、明确的选择器 .social-link

补救前：

	<ul id="social">
	    <li><a href="#" class="twitter">Twitter</a></li>
	    <li><a href="#" class="facebook">Facebook</a></li>
	    <li><a href="#" class="dribble">Dribbble</a></li>
	    <li><a href="#" class="gplus">Google+</a></li>
	</ul>

	#social a {}

补救后：

	<ul id="social">
	    <li><a href="#" class="social-link twitter">Twitter</a></li>
	    <li><a href="#" class="social-link facebook">Facebook</a></li>
	    <li><a href="#" class="social-link dribble">Dribbble</a></li>
	    <li><a href="#" class="social-link gplus">Google+</a></li>
	</ul>

	#social .social-link {}

补救后的新的关键选择器将会匹配更少的元素，这意味着浏览器能够很快的找到它们并渲染特定的样式。

# 过度限制选择器

什么是过度选择器：比如像这样

	html body .wrapper #content a {}

这里的写的太多了，至少3个选择器是完全不需要的，所以说是过度限制器

过度限制选择器的问题在于：首先第一个意味着浏览器不得不寻找所有的 a 元素，然后检查他们是否在一个ID为”content”的元素中，然后如此循环直到HTML标签。这样造成了太多的我们不太想要的花费。

[编写高效的 CSS 选择器]: http://blog.jobbole.com/35339/
