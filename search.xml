<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>(译)Organizing Gradle Projects</title>
      <link href="2022/03/18/gradle-best-practices/"/>
      <url>2022/03/18/gradle-best-practices/</url>
      
        <content type="html"><![CDATA[<p>翻译自《Organizing Gradle Projects》，介绍了Gradle的若干最佳实践。<br><a id="more"></a></p><p>每个软件工程的源代码和构建逻辑应该以有意义的方式来组织。本文介绍了若干最佳实践来实现可读性好、易维护的项目结构。同时也介绍了若干常见问题以及解决方法。</p><h1 id="单独存放不同语言的源码"><a href="#单独存放不同语言的源码" class="headerlink" title="单独存放不同语言的源码"></a>单独存放不同语言的源码</h1><!--Separate language-specific source files--><p>Gradle的编程语言插件建立了发现和编译源码的约定。比如，使用了Java插件的工程会自动编译<code>src/main/java</code>目录下的代码。其他语言的插件也遵循类似的模式。目录路径的最后一部分通常表明了对应的语言。</p><p>某些编译器支持编译同一个源码目录中的不同语言写的代码。Groovy编译器可以处理混放在<code>src/main/groovy</code>目录下的Java和Groovy源码。Gradle建议按不同的语言来存放代码，以达到更好的构建性能。此外，the user and build can make stronger assumptions。</p><p>The following source tree contains Java and Kotlin source files. Java source files live in src/main/java, whereas Kotlin source files live in src/main/kotlin.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build.gradle</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── HelloWorld.java</span><br><span class="line">        └── kotlin</span><br><span class="line">            └── Utils.kt</span><br></pre></td></tr></table></figure><h1 id="不同类型的测试代码分开存放"><a href="#不同类型的测试代码分开存放" class="headerlink" title="不同类型的测试代码分开存放"></a>不同类型的测试代码分开存放</h1><p>Have a look at the sample  <a href="https://docs.gradle.org/current/samples/sample_jvm_multi_project_with_additional_test_types.html" target="_blank" rel="noopener">sample</a> that demonstrates how a separate integration tests configuration can be added to a Java-based project.</p><p>一个项目中有不同类型的测试代码，这个很常见。比如单元测试，集成测试，功能测试或冒烟测试。每种类型的测试代码应当放在专门的源码目录中(可选的)。分开存放对可维护性有好处，也能让你更关注特定类型的测试。</p><p>这个<a href="https://docs.gradle.org/current/samples/sample_jvm_multi_project_with_additional_test_types.html" target="_blank" rel="noopener">sample</a>展示了如何在一个Java项目中添加不同的测试配置。</p><h1 id="尽可能使用标准约定"><a href="#尽可能使用标准约定" class="headerlink" title="尽可能使用标准约定"></a>尽可能使用标准约定</h1><p>Gradle核心插件遵守软件工程范例<a href="https://en.wikipedia.org/wiki/Convention_over_configuration" target="_blank" rel="noopener">convention over configuration</a>。插件逻辑在特定上下文中为用户提供有意义的缺省值以及约定。以<a href="https://docs.gradle.org/current/userguide/java_plugin.html#java_plugin" target="_blank" rel="noopener">Java plugin</a>插件为例：</p><ul><li><code>src/main/java</code>作为缺省的源码位置</li><li>编译后的产物放在<code>build</code>目录</li></ul><p>严格遵守缺省约定的话，加入项目的新开发者能马上知道如何开始工作。当然，约定也支持重新配置，只不过构建脚本的用户和作者更难维护构建逻辑和构建输出。应当尽可能尝试严格遵守缺省约定，除非你需要适配遗留项目结构。参考各相关插件的手册来学习其缺省约定。</p><h1 id="定义settings文件"><a href="#定义settings文件" class="headerlink" title="定义settings文件"></a>定义settings文件</h1><p>每次构建时，Gradle会尝试找到<code>settings.gradle</code>(Groovy DSL)或者<code>settings.gradle.kts</code>(Kotlin DSL)文件。基于这个目的，运行时会沿着目录树结构往上一直搜索到根目录。一旦找到settings文件后立即停止查找。</p><p>一定要在根目录中添加一个<code>settings.gradle</code>以避免性能问题。这个建议对单工程构建和多工程构建都有效。该文件可以为空，也可以定义工程名。</p><p>一个典型的带settings文件的Gradle工程结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── settings.gradle</span><br><span class="line">├── subproject-one</span><br><span class="line">│   └── build.gradle</span><br><span class="line">└── subproject-two</span><br><span class="line">    └── build.gradle</span><br></pre></td></tr></table></figure><h1 id="使用-buildSrc-抽象逻辑"><a href="#使用-buildSrc-抽象逻辑" class="headerlink" title="使用 buildSrc 抽象逻辑"></a>使用 buildSrc 抽象逻辑</h1><p>复杂的构建逻辑通常适合封装成自定义任务或者二进制插件。自定义任务和二进制插件不应放到项目的构建脚本中。如果这些逻辑不需要在多个独立的项目中共享，那么可以使用<code>buildSrc</code>。</p><p><code>buildSrc</code>目录视为一个<a href="https://docs.gradle.org/current/userguide/composite_builds.html#composite_build_intro" target="_blank" rel="noopener">included build</a>。一旦 Gradle 发现这个目录，它会自动编译和测试其中的代码并将其添加到构建脚本的classpath。对于多项目构建(multi-project builds)，只能有一个<code>buildSrc</code>目录，这个目录位于项目根目录。应优先使用<code>buildSrc</code>而不是插件(<a href="https://docs.gradle.org/current/userguide/plugins.html#sec:script_plugins" target="_blank" rel="noopener">script plugins</a>)，因为前者代码更容易维护、重构和测试。</p><p><code>buildSrc</code>使用跟Java和Groovy项目相同的代码结构(<a href="https://docs.gradle.org/current/userguide/java_plugin.html#javalayout" target="_blank" rel="noopener">source code conventions</a>)。它可以直接访问Gradle API。<code>buildSrc</code>目录下的<code>build.gradle</code>脚本中可以添加其他依赖。</p><p><em>Example 1. Custom buildSrc build script</em></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.13'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个包含<code>buildSrc</code>的工程，其项目结构如下。<code>buildSrc</code>下的代码使用跟应用代码类似的包。如果有额外的配置需要，<code>buildSrc</code>目录可以放一个可选的构建脚本(比如，使用插件或声明依赖)。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── buildSrc</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── main</span><br><span class="line">│       │   └── java</span><br><span class="line">│       │       └── com</span><br><span class="line">│       │           └── enterprise</span><br><span class="line">│       │               ├── Deploy.java</span><br><span class="line">│       │               └── DeploymentPlugin.java</span><br><span class="line">│       └── test</span><br><span class="line">│           └── java</span><br><span class="line">│               └── com</span><br><span class="line">│                   └── enterprise</span><br><span class="line">│                       └── DeploymentPluginTest.java</span><br><span class="line">├── settings.gradle</span><br><span class="line">├── subprojecto-one</span><br><span class="line">│   └── build.gradle.kts</span><br><span class="line">└── subproject-two</span><br><span class="line">    └── build.gradle.kts</span><br></pre></td></tr></table></figure><p>注意<code>buildSrc</code>中的变更会引起整个项目变成out-of-date状态。因此，当进行小的增量变更时，<a href="https://docs.gradle.org/current/userguide/command_line_interface.html#sec:command_line_execution_options" target="_blank" rel="noopener">–no-rebuild command-line option</a>可加快编译速度。记住<code>buildSrc</code>修改完成后要定期进行全量构建。</p><h1 id="在-gradle-properties-文件中定义属性"><a href="#在-gradle-properties-文件中定义属性" class="headerlink" title="在 gradle.properties 文件中定义属性"></a>在 gradle.properties 文件中定义属性</h1><p>Gradle中可以在构建脚本中定义属性，也可以在<code>gradle.properties</code>定义属性，或者在命令行参数中定义属性。</p><p>命令行参数中定义属性在ad-hoc场景下很常见。比如，你想传特定的属性值来控制某次构建的运行时行为。构建脚本中的属性很容易带来维护性问题。<code>gradle.properties</code>用于将属性跟构建脚本分离。它适用于保存控制构建环境的属性。</p><p>典型的工程中将<code>gradle.properties</code>文件放在根目录。另外，如果你想将其应用于所有构建任务的话，也可将该文件放在<code>GRADLE_USER_HOME</code>目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── gradle.properties</span><br><span class="line">└── settings.gradle</span><br><span class="line">├── subproject-a</span><br><span class="line">│   └── build.gradle</span><br><span class="line">└── subproject-b</span><br><span class="line">    └── build.gradle</span><br></pre></td></tr></table></figure><h1 id="避免覆盖任务输出"><a href="#避免覆盖任务输出" class="headerlink" title="避免覆盖任务输出"></a>避免覆盖任务输出</h1><p>Task 应当定义输入和输出以利用 <a href="https://docs.gradle.org/current/userguide/more_about_tasks.html#sec:up_to_date_checks" target="_blank" rel="noopener">incremental build functionality</a> 提升性能。当声明 task 的输出时，应当确认输出目录是独有的。</p><p>混合或覆盖不同task的输出，会导致 up-to-date 检查过程复杂化，从而拖慢构建过程。另一方面，文件系统的变化可能让Gradle的构建缓存(<a href="https://docs.gradle.org/current/userguide/build_cache.html#build_cache" target="_blank" rel="noopener">build cache</a>)难以识别和缓存应当缓存的task。</p><h1 id="发布自定义的Gradle"><a href="#发布自定义的Gradle" class="headerlink" title="发布自定义的Gradle"></a>发布自定义的Gradle</h1><p>企业常常想通过定义通用约定或规则来为所有的项目做标准化构建。你可以借助初始化脚本来实现这个功能。<a href="https://docs.gradle.org/current/userguide/init_scripts.html#init_scripts" target="_blank" rel="noopener">Initialization scripts</a>可以非常容易地为同一台机器上的各个项目应同一构建逻辑。比如，使用一个私有的repo以及其凭证。</p><p>这种方式有期缺点。首先，你必须跟公司的所有开发人员沟通标准化设置过程。另外，统一升级初始化脚本逻辑也是个挑战。</p><p>发布自定义Gradle是个可行的解决方案。自定义的Gradle包含标准的Gradle发布版本，以及一个或多个自定义 initialization script。初始化脚本跟发布版本打包在一起，并且可应用到每次的构建上。开发者只需要将他们的 wraper 文件指向自定义Gradle的url。</p><p>创建自定义Gradle发布版本的典型步骤如下：</p><ol><li>实现下载和重新打包Gradle发布版本的逻辑</li><li>定义一个或多个初始化脚本</li><li>将初始化脚本跟Gradle发布包打包到一起</li><li>将Gradle发布包上传到HTTP服务器</li><li>将所有项目的wrapper文件指向自定义Gradle发布版本的url</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources" target="_blank" rel="noopener">Organizing Gradle Projects</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gradle-buildsrc</title>
      <link href="2022/03/18/gradle-buildsrc/"/>
      <url>2022/03/18/gradle-buildsrc/</url>
      
        <content type="html"><![CDATA[<p>简单了解buildSrc用法。<br><a id="more"></a></p><h1 id="buildSrc-介绍"><a href="#buildSrc-介绍" class="headerlink" title="buildSrc 介绍"></a>buildSrc 介绍</h1><p>本节内容翻译自<a href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources" target="_blank" rel="noopener">Organizing Gradle Projects</a>。</p><p>复杂的构建逻辑通常适合封装成自定义任务或者二进制插件。自定义任务和二进制插件不应放到项目的构建脚本中。如果这些逻辑不需要在多个独立的项目中共享，那么可以使用<code>buildSrc</code>。</p><p><code>buildSrc</code>目录视为一个<a href="https://docs.gradle.org/current/userguide/composite_builds.html#composite_build_intro" target="_blank" rel="noopener">included build</a>。一旦 Gradle 发现这个目录，它会自动编译和测试其中的代码并将其添加到构建脚本的classpath。对于多项目构建(multi-project builds)，只能有一个<code>buildSrc</code>目录，这个目录位于项目根目录。应优先使用<code>buildSrc</code>而不是插件(<a href="https://docs.gradle.org/current/userguide/plugins.html#sec:script_plugins" target="_blank" rel="noopener">script plugins</a>)，因为前者代码更容易维护、重构和测试。</p><p><code>buildSrc</code>使用跟Java和Groovy项目相同的代码结构(<a href="https://docs.gradle.org/current/userguide/java_plugin.html#javalayout" target="_blank" rel="noopener">source code conventions</a>)。它可以直接访问Gradle API。<code>buildSrc</code>目录下的<code>build.gradle</code>脚本中可以添加其他依赖。</p><p><em>Example 1. Custom buildSrc build script</em></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.13'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个包含<code>buildSrc</code>的工程，其项目结构如下。<code>buildSrc</code>下的代码使用跟应用代码类似的包。如果有额外的配置需要，<code>buildSrc</code>目录可以放一个可选的构建脚本(比如，使用插件或声明依赖)。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── buildSrc</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── main</span><br><span class="line">│       │   └── java</span><br><span class="line">│       │       └── com</span><br><span class="line">│       │           └── enterprise</span><br><span class="line">│       │               ├── Deploy.java</span><br><span class="line">│       │               └── DeploymentPlugin.java</span><br><span class="line">│       └── test</span><br><span class="line">│           └── java</span><br><span class="line">│               └── com</span><br><span class="line">│                   └── enterprise</span><br><span class="line">│                       └── DeploymentPluginTest.java</span><br><span class="line">├── settings.gradle</span><br><span class="line">├── subprojecto-one</span><br><span class="line">│   └── build.gradle.kts</span><br><span class="line">└── subproject-two</span><br><span class="line">    └── build.gradle.kts</span><br></pre></td></tr></table></figure><p>注意<code>buildSrc</code>中的变更会引起整个项目变成out-of-date状态。因此，当进行小的增量变更时，<a href="https://docs.gradle.org/current/userguide/command_line_interface.html#sec:command_line_execution_options" target="_blank" rel="noopener">–no-rebuild command-line option</a>可加快编译速度。记住<code>buildSrc</code>修改完成后要定期进行全量构建。</p><h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><ul><li>IDEA 新建 gradle 项目</li><li>在项目下新建 <code>buildSrc</code> 目录 (注意是目录而不是 <code>module</code>)</li><li>在 <code>buildSrc</code> 目录下新建或修改 <code>build.gradle</code> 文件。内容如下:</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'groovy'</span></span><br><span class="line">    id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group <span class="string">'com.gradle'</span></span><br><span class="line">version <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'org.codehaus.groovy:groovy-all:3.0.7'</span></span><br><span class="line">    testImplementation <span class="string">group:</span> <span class="string">'junit'</span>, <span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>buildSrc</code> 目录中创建源码目录，<code>src/main/groovy</code><br><img src="/images/16475645072640.jpg" alt="-w716"></li><li>在源码目录下新建一个类 <code>MyTask</code></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span>&#123;</span></span><br><span class="line">    MyTask() &#123;</span><br><span class="line">        <span class="keyword">this</span>.description = <span class="string">"test buildSrc"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="keyword">void</span> start() &#123;</span><br><span class="line">        println <span class="string">'hi, cm, bi bo bi bo... ...'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在项目根目录的 <code>build.gradle</code> 中使用新建的 <code>MyTask</code><br><img src="/images/16475646953948.jpg" alt="-w1391"></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/ca795325d582" target="_blank" rel="noopener">Gradle 创建 buildSrc 文件夹 - 简书</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iTerm2快速ssh登录</title>
      <link href="2022/03/06/ssh-with-iterm2/"/>
      <url>2022/03/06/ssh-with-iterm2/</url>
      
        <content type="html"><![CDATA[<p>我有几台服务器。虽然均配置了ssh登录，但日常工作和学习中仍感觉登录服务器不免有些麻烦。如何配置iTerm2快速ssh登录呢？<br><a id="more"></a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>第一步，在 <code>~/.ssh</code> 目录下创建一个脚本，不妨脚本名为 <code>qcloud</code>。脚本文件内容如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect -f</span></span><br><span class="line"><span class="built_in">set</span> user root</span><br><span class="line"><span class="built_in">set</span> host 124.221.147.234</span><br><span class="line"><span class="built_in">set</span> timeout -5</span><br><span class="line">spawn ssh <span class="variable">$user</span>@<span class="variable">$host</span></span><br><span class="line">interact</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure><p>第二步，<code>command + ,</code> 打开 iTerm2 设置:</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/03/06/16465557145174.jpg" alt="-w986"></p><p>第三步，开始使用吧！</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/03/06/16465557915219.jpg" alt="-w920"></p><p>有没有感觉ssh登录效率小小地提高了。</p><p>如果你需要经常在命令行下切换到某个目录工作，也可以使用类似配置。比如，我的博客放在 <code>PublicCode/blog</code> 这个目录下，所以添加以下配置之后我可以直接从 <code>Profiles</code> &gt; <code>博客</code> 进入到指定目录。是不是方便多了?</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/03/06/16465561302286.jpg" alt="-w986"></p><p>此外，iTerm2还支持将Profiles导入导出，方便我们偷懒到底。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2022/03/06/16465563272988.jpg" alt="-w921"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/zhaoyawei/p/9285588.html" target="_blank" rel="noopener">Mac下使用iTerm2自动ssh登录服务器 - 轻叹花开花落的流年 - 博客园</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Puppeteer 使用小记</title>
      <link href="2021/11/07/use-puppeteer/"/>
      <url>2021/11/07/use-puppeteer/</url>
      
        <content type="html"><![CDATA[<p>Puppeteer 实战小记——教你如何使用 Puppeteer 来完成模拟登录+抓取数据。<br><a id="more"></a></p><h1 id="Puppeteer-简介"><a href="#Puppeteer-简介" class="headerlink" title="Puppeteer 简介"></a>Puppeteer 简介</h1><p>网上关于 <a href="https://github.com/puppeteer/puppeteer" target="_blank" rel="noopener">Puppeteer</a> 介绍资料很多，所以这里就不过多展开了。只说两点。</p><p>第一，与 Puppeteer 类似的技术很多，早期主要是 Phantom.js。不过随着Google 在 Chrome 59版本开始支持 headless 模式，Ariya Hidayat 决定放弃对 Phantom.js 的维护</p><p>我原本尝试使用 PhantomJS 完成模块登录和抓取数据工作，但遇到了一点问题(问题原因未深究)，随后果断换到 Puppeteer。</p><p>第二，Puppeteer 是一个提供高级别API的 Node 库，简化 headless Chrome 的使用。</p><blockquote><p>Puppeteer（Puppeteer is a Node library which provides a high-level API to control headless Chrome over the DevTools Protocol. It can also be configured to use full (non-headless) Chrome.）</p></blockquote><p>这张图展示了 Puppeteer 的全貌。</p><p><img src="/images/16362948442778.jpg" alt="-w783"></p><ul><li>Puppeteer 使用 DevTools 协议与浏览器通信</li><li>Browser 实例可以拥有多个浏览器上下文</li><li>BrowserContext 实例定义了一个浏览会话，并且可以拥有多个 Page</li><li>Page至少有一个框架：主框架。iframe 可能还会创建其他框架</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用 npm 安装 puppeteer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i puppeteer</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://www.baidu.com'</span>); <span class="comment">//打开百度</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h1 id="Puppeteer-实战"><a href="#Puppeteer-实战" class="headerlink" title="Puppeteer 实战"></a>Puppeteer 实战</h1><p>以下是获取某网站登录态的 Puppeteer 脚本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uname = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">const</span> pwd = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        headless: <span class="literal">false</span>,</span><br><span class="line">        ignoreHTTPSErrors: <span class="literal">true</span>,</span><br><span class="line">        defaultViewport: <span class="literal">false</span>,</span><br><span class="line">        devtools: <span class="literal">false</span>,</span><br><span class="line">        args: [<span class="string">'--disable-features=site-per-process'</span>]</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// page: 用于模拟登录流程</span></span><br><span class="line">    <span class="keyword">const</span> page = (<span class="keyword">await</span> browser.pages())[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开页面并跳转登录页</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://abc.xyz.com/v2/workbench/apps'</span>, &#123; <span class="attr">waitUntil</span>: <span class="string">"networkidle2"</span> &#125;); <span class="comment">// &lt;----- 问题1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到登录页中的frame</span></span><br><span class="line">    <span class="keyword">const</span> frame = page.frames().find(<span class="function"><span class="params">f</span> =&gt;</span> f.name() === <span class="string">'login_iframe'</span>); <span class="comment">// &lt;----- 问题2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到账号登录</span></span><br><span class="line">    <span class="keyword">const</span> ploginSelector = <span class="string">'a#switcher_login.link'</span>;</span><br><span class="line">    <span class="keyword">await</span> frame.waitForSelector(ploginSelector);</span><br><span class="line">    <span class="keyword">await</span> frame.click(ploginSelector);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始账号登录</span></span><br><span class="line">    <span class="keyword">await</span> frame.type(<span class="string">'#u'</span>, uname);</span><br><span class="line">    <span class="keyword">await</span> frame.type(<span class="string">'#p'</span>, pwd);</span><br><span class="line">    <span class="keyword">await</span> frame.click(<span class="string">'#login_button'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.waitForNavigation(&#123; <span class="attr">waitUntil</span>: <span class="string">'networkidle2'</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// page2页面中尝试获取登录token  &lt;----- 问题3</span></span><br><span class="line">    <span class="comment">//await page2.goto('https://abc.xyz.com/v2/workbench/apps');</span></span><br><span class="line">    <span class="comment">// page2.evaluate(function () &#123;</span></span><br><span class="line">    <span class="comment">//     debugger;  &lt;----- 问题4</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cookies = <span class="keyword">await</span> page.cookies(); <span class="comment">// &lt;----- 问题5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> c = <span class="string">''</span>;</span><br><span class="line">    cookies.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        c = c + v.name + <span class="string">'='</span> + v.value + <span class="string">'; '</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>脚本看起来还是简单易懂的。但实际开发过程中还是遇到了不少小坑：</p><h2 id="问题1：网页跳转"><a href="#问题1：网页跳转" class="headerlink" title="问题1：网页跳转"></a>问题1：网页跳转</h2><p>这个案例中要登录的网站是 OAuth 方式，所以登录过程中是有一次页面跳转的，从我们要访问的网页跳转到 OAuth 提供方的网页。</p><p>解决办法：<code>page.goto</code> 方法的 <code>waitUntil</code> 参数传 <code>networkidle2</code>。即，等待足够长的时间保证页面跳转完成</p><h2 id="问题2：无法找到页面元素"><a href="#问题2：无法找到页面元素" class="headerlink" title="问题2：无法找到页面元素"></a>问题2：无法找到页面元素</h2><p>这个其实不是问题，但对 iframe 不了解的话往往会踩到这个坑。实际的网页结构比较复杂，可能有多个 iframe。如果 Puppeteer 脚本中找到指定的 html 元素，不妨看看你要访问的元素是否在 iframe 中！</p><p>解决办法：<code>page.frames()</code> 返回当前页面中的所有 frame。</p><h2 id="问题3：Execution-context-was-destroyed"><a href="#问题3：Execution-context-was-destroyed" class="headerlink" title="问题3：Execution context was destroyed"></a>问题3：Execution context was destroyed</h2><p>如果你遇到以下报错，可以考虑使用另外一个 page 来规避问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Execution context was destroyed, most likely because of a navigation.</span><br></pre></td></tr></table></figure><p>出错这种报错的原因很可能是因为导航，具体解决方法可以参考 <a href="https://www.it1352.com/1107753.html" target="_blank" rel="noopener">Puppeteer执行上下文被破坏</a></p><h2 id="问题4：调试技巧"><a href="#问题4：调试技巧" class="headerlink" title="问题4：调试技巧"></a>问题4：调试技巧</h2><p>技巧一：插入 <code>debugger</code> 启动调试器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">page2.evaluate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>技巧二：<code>devtools</code> 传 <code>true</code> 时打开 DevTools</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const browser = await puppeteer.launch(&#123;</span><br><span class="line">    ...,</span><br><span class="line">    headless: false</span><br><span class="line">    devtools: true,</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="问题5：获取-cookie"><a href="#问题5：获取-cookie" class="headerlink" title="问题5：获取 cookie"></a>问题5：获取 cookie</h2><p>Puppeteer 模拟登录成功后可以获取网页登录态。登录态一般放在 cookie 中，使用 <code>page.cookies()</code> 获取页面 cookie (注意不是 <code>document.cookie</code>，这个无法返回 http only 的 cookie)</p><p>总结一下使用 Puppeteer 的大致步骤：</p><ul><li><a href="https://www.jianshu.com/p/e9db0baf781b" target="_blank" rel="noopener">CentOS 上安装 nodejs</a><ul><li><code>curl --silent --location https://rpm.nodesource.com/setup_12.x | sudo bash</code></li><li><code>yum -y install nodejs</code></li></ul></li></ul><ol><li>使用 npm 安装 Puppeteer。如果遇到安装错误可以参考<a href="https://www.cnblogs.com/ilizhu/p/14504049.html" target="_blank" rel="noopener">这里</a><ul><li><code>npm i puppeteer</code></li></ul></li><li>写 Puppeteer 脚本模拟登录，获取网站登录态。可以参考上面提供的脚本</li><li>写脚本访问网站的数据。这个因不同网站而异，这里不具体展开</li><li>crontab 定时抓取数据。使用 crontab 时我经常把脚本路径弄错，注意 <a href="https://blog.csdn.net/qq_36743482/article/details/83616436" target="_blank" rel="noopener">crontab 路径问题</a><ul><li><code>crontab -e</code> 设置定时任务</li></ul></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/cangqinglang/p/14588014.html" target="_blank" rel="noopener">谈谈 Puppeteer - 苍青浪 - 博客园</a></li><li><a href="https://zhuanlan.zhihu.com/p/33015883" target="_blank" rel="noopener">phantomJs之殇，chrome-headless之生 - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/137922030" target="_blank" rel="noopener">Phantomjs、Selenium之后浪Puppeteer - 知乎</a></li><li><a href="https://github.com/puppeteer/puppeteer/tree/main/examples" target="_blank" rel="noopener">puppeteer/examples at main · puppeteer/puppeteer · GitHub</a></li><li><a href="http://www.puppeteerjs.com/" target="_blank" rel="noopener">Puppeteer v10.4.0</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记一次 _objc_retain 崩溃分析</title>
      <link href="2021/08/08/objc-retain-crash/"/>
      <url>2021/08/08/objc-retain-crash/</url>
      
        <content type="html"><![CDATA[<p>最近收到 iOS 上一个偶现的 <code>SIGSEGV SEGV_ACCERR</code> 崩溃。错误信息显示该崩溃发生在 <code>_objc_retain</code> 方法，让我困惑了很久。经过分析，发现看似内存问题，实则线程问题。<br><a id="more"></a></p><h1 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h1><p>一条典型的错误如下：</p><!-- https://bugly.qq.com/v2/crash-reporting/crashes/9067e7d4ff/2334154/report?pid=2&crashDataType=unSystemExit&start=40 --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 libobjc.A.dylib       _objc_retain + 16</span><br><span class="line">1 AbcDriver_Example     -[AbcRecorder startRecordWithType:] (AbcLocationRecorder.m:151)</span><br><span class="line">2 AbcDriver_Example     __40-[AbcLocationReporter onCollectTimer:]_block_invoke (AbcLocationReporter.m:0)</span><br><span class="line">3 Foundation            ___NSBLOCKOPERATION_IS_CALLING_OUT_TO_A_BLOCK__ + 16</span><br><span class="line">4 Foundation            -[NSBlockOperation main] + 100</span><br><span class="line">5 Foundation            ___NSOPERATION_IS_INVOKING_MAIN__ + 20</span><br><span class="line">6 Foundation            -[NSOperation start] + 784</span><br><span class="line">7 Foundation            ___NSOPERATIONQUEUE_IS_STARTING_AN_OPERATION__ + 20</span><br><span class="line">8 Foundation            ___NSOQSchedule_f + 180</span><br></pre></td></tr></table></figure><p>显示错误发生在 <code>AbcLocationRecorder.m</code> 第151行。第151行代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbcLocationSample *locationSample = [self prepareDataFromAbcLocation:self.latestLocation regeocode:nil];</span><br></pre></td></tr></table></figure><p>代码看起来没有任何问题，也很难将其跟 <code>_objc_retain</code> 方法联系起来。</p><h1 id="类似案例"><a href="#类似案例" class="headerlink" title="类似案例"></a>类似案例</h1><p>处理 iOS 崩溃的经验不多，所以先在网上找了一圈看是否有人遇到类似问题，还果真找到了。</p><h2 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h2><p><a href="https://www.cnblogs.com/song-jw/p/11691715.html" target="_blank" rel="noopener">iOS崩溃分析 - Lightning_S - 博客园</a> 提到了两个崩溃。</p><p>一个是 <code>objc_release</code>，错误如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0  libobjc.A.dylib                0x1b394f150 objc_release + 16</span><br><span class="line">1  _appstore                      0x10184b694 -[YNP_VRHomeCoreViewModel voiceRoomDidChangeSpeakingUser:] + 373 (YNP_VRHomeCoreViewModel.m:373)</span><br><span class="line">2  Aipai_appstore                 0x1015a6144 __63-[YNP_VoiceRoomManager makeDelegatesPerformSelector:obj:async:]_block_invoke + 1633 (YNP_VoiceRoomManager.m:1633)</span><br></pre></td></tr></table></figure><p>另一个是 <code>objc_retain</code>，错误如下：</p><p><img src="/images/16283922797911.jpg" alt></p><p>文章的结论是：</p><ul><li>以上崩溃都是对象引用计数变化时没有正确加锁(线程不安全)导致</li><li>编译器在代码中插入 <code>objc_retainAutoreleasedReturnValue</code>，所以错误日志中会看到 <code>_objc_retain</code></li></ul><h2 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h2><p><a href="https://www.jianshu.com/p/298c69ce33b2" target="_blank" rel="noopener">从一个crash分析到苹果的代码问题 - 简书</a> 提到属性被声明为 <code>nonatomic</code> 时，当对象在一个线程中释放了，另一个线程访问时就可能出问题。</p><p>至于 <code>nonatomic</code> 的线程安全问题，原因如下：</p><blockquote><p>nonatomic取到函数地址后，直接返回指针指向的值，如果这时 *slot 正好被释放，那么返回的就是一个错误的值<br>而atomic会先retain，然后放到自动释放池，这样就能保证返回的对象一定不会被释放</p></blockquote><p>这里直接贴上相关的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) &#123;</span><br><span class="line">    if (offset == 0) &#123;</span><br><span class="line">        return object_getClass(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Retain release world</span><br><span class="line">    id *slot = (id*) ((char*)self + offset);</span><br><span class="line">    if (!atomic) return *slot;</span><br><span class="line">        </span><br><span class="line">    // Atomic retain release world</span><br><span class="line">    spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();</span><br><span class="line">    id value = objc_retain(*slot);</span><br><span class="line">    slotlock.unlock();</span><br><span class="line">    </span><br><span class="line">    // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span><br><span class="line">    return objc_autoreleaseReturnValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h1><p>看过两个类似案例，再来分析自己的问题就有头绪了。出错的第151行代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 主线程中读 self.latestLocation</span><br><span class="line">AbcLocationSample *locationSample = [self prepareDataFromAbcLocation:self.latestLocation regeocode:nil];</span><br></pre></td></tr></table></figure><p>我们很自然地把怀疑目标锁定在 <code>self.latestLocation</code> 这里。<code>latestLocation</code> 属性定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface AbcLocationRecorder () &lt;AbcLocationManagerDelegate&gt;</span><br><span class="line">// latestLocation 访问修饰符为 nonatomic</span><br><span class="line">@property (nonatomic, strong) AbcLocation *latestLocation;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>位置更新时通过如下回调来更新 <code>self.latestLocation</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)mapLocationManager:(AbcLocationManager *)manager didUpdateLocations:(NSArray&lt;AbcLocation *&gt; *)locations &#123;</span><br><span class="line">    if (locations.count &gt; 0) &#123;</span><br><span class="line">        AbcLocation* location = [locations firstObject];</span><br><span class="line">        AbcLog_C(@&quot;定位坐标: %f, %f&quot;, location.location.coordinate.latitude, location.location.coordinate.longitude);</span><br><span class="line">        // 子线程中写 self.latestLocation</span><br><span class="line">        self.latestLocation = location;</span><br><span class="line">        AbcLOCATION_UNLOCK(self.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下：</p><ul><li>latestLocation 访问修饰符为 <code>nonatomic</code></li><li>主线程中读 <code>self.latestLocation</code></li><li>子线程中写 <code>self.latestLocation</code></li><li><font color="red">读写 <code>self.latestLocation</code> 没有加锁！</font></li></ul><p>前面提到这个 <code>SIGSEGV SEGV_ACCERR</code> 崩溃在我们 App 中是偶现的，Bugly 上有不少上报，但实际中跟进问题时却一次也没复现。怎么办？</p><p>我们写个 demo 吧。demo 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong) AbcLocation *latestLocation;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)testFun2</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;queue1&quot;, 0);</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;queue2&quot;, 0);</span><br><span class="line">    dispatch_queue_t queue3 = dispatch_queue_create(&quot;queue3&quot;, 0);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue1, ^&#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2f];</span><br><span class="line">            //@synchronized (self) &#123;</span><br><span class="line">                NSLog(@&quot;last location %@&quot;, self.latestLocation);</span><br><span class="line">            //&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue3, ^&#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2f];</span><br><span class="line">            //@synchronized (self) &#123;</span><br><span class="line">                NSLog(@&quot;last location %@&quot;, self.latestLocation);</span><br><span class="line">            //&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue2, ^&#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //@synchronized (self) &#123;</span><br><span class="line">                self.latestLocation = [[AbcLocation alloc] init];</span><br><span class="line">            //&#125;</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2f];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>运行几次很快就会产生崩溃。找到复现方法后，解决问题就很简单了。多线程读写 <code>self.latestLocation</code> 属性中正确地加锁，保证线程安全就能避免崩溃。</p><h1 id="更多知识"><a href="#更多知识" class="headerlink" title="更多知识"></a>更多知识</h1><p>网上寻找相似案例，是为了快速弄清问题原因。写demo是为了快速找到问题复现方法和解决办法。但我们不能就此止步，因为很多问题还可以更深入。</p><h2 id="objc-autoreleaseReturnValue-和-objc-retainAutoreleasedReturnValue"><a href="#objc-autoreleaseReturnValue-和-objc-retainAutoreleasedReturnValue" class="headerlink" title="objc_autoreleaseReturnValue 和 objc_retainAutoreleasedReturnValue"></a>objc_autoreleaseReturnValue 和 objc_retainAutoreleasedReturnValue</h2><blockquote><p>编译器在代码中插入 <code>objc_retainAutoreleasedReturnValue</code>，所以错误日志中会看到 <code>_objc_retain</code></p></blockquote><p>那什么是 <code>objc_autoreleaseReturnValue</code> 呢？</p><p>在 MRC 的环境里有以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// MRC</span><br><span class="line">+ (id) array &#123;</span><br><span class="line">    return [[NSMutableArray alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道内存分配的原则是”谁分配，谁释放”。这个原则让上述代码很为难，</p><ul><li>不能在 return 之前释放，因为分配出来的对象还没交给调用方法使用</li><li>也不可能在 return 之后释放，因为 return 之后作为分配方没法负责释放了(没有对象指针)</li></ul><p>所以需要将分配出来的对象注册到自动释放池，也延迟释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// MRC</span><br><span class="line">+ (id) array &#123;</span><br><span class="line">    return [[[NSMutableArray alloc] init] autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ARC 为我们自动调用了 <code>autorelease</code> 和 <code>retain</code> 两个方法 (自动释放)。考虑到兼容 MRC 时，ARC 自动调用 <code>autorelease</code> 和 <code>retain</code> 两个方法会带来不必要的开销，所以 ARC 使用 <code>objc_autoreleaseReturnValue</code> 和<br><code>objc_retainAutoreleasedReturnValue</code> 对多余操作优化，以提升性能优化。</p><hr><p><a href="https://www.galloway.me.uk/2012/02/how-does-objc_retainautoreleasedreturnvalue-work/" target="_blank" rel="noopener">How does objc_retainAutoreleasedReturnValue work? - Matt Galloway</a> 中对 <code>objc_retainAutoreleasedReturnValue</code> 有更多解释。这里挑关键点翻译出来。</p><p><code>objc_retainAutoreleasedReturnValue</code> 背后的思路是这样的：如果一个函数返回的对象是 autoreleased 的，并且接下来的对这个对象执行的操作是 <code>retain</code>，那么这里的 <code>autorelease</code> 和 <code>retain</code> 完全是无意义的，不过是在浪费 CPU 时间。如果某些情况下我们可以检测出这种情况，就能节省CPU时间。在App整个运行期间，节省的CPU时间累计下来就是个不小的优化。</p><p><a href="http://www.opensource.apple.com/source/objc4/objc4-493.9/runtime/objc-arr.mm" target="_blank" rel="noopener">Apple’s code</a>提到：</p><blockquote><p>objc_autoreleaseReturnValue() 检查 return 之后调用方的指令。如果调用方是立即调用 objc_retainAutoreleasedReturnValue，则被调用方不会做 autorelease 操作，而是将结果以 thread-local 方式保存。如果调用方并没有调用 objc_retainAutoreleasedReturnValue，则被调用方会做 autorelease 操作。<br>objc_retainAutoreleasedReturnValue 会检查返回值是否跟 thread-local 变量中保存的值一致。如果一致，则直接返回结果。如果不一致，则会执行一次 autorelease 和 retain。无论哪种方式，调用方都能拿到一个 retained reference</p></blockquote><p>考虑你有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (SomeClass*)createMeAnObject &#123;</span><br><span class="line">   SomeClass *obj = [[SomeClass alloc] init];</span><br><span class="line">   obj.string = @&quot;Badger&quot;;</span><br><span class="line">   obj.number = 10;</span><br><span class="line">   return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        self.myObject = [self createMeAnObject];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以重写以上代码，重写后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (SomeClass*)createMeAnObject &#123;</span><br><span class="line">   SomeClass *obj = [[SomeClass alloc] init];</span><br><span class="line">   obj.string = @&quot;Badger&quot;;</span><br><span class="line">   obj.number = 10;</span><br><span class="line">   return [obj autorelease];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        [myObject release];</span><br><span class="line">        SomeClass *temp = [self createMeAnObject];</span><br><span class="line">        myObject = [temp retain];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将 <code>createMeAnObject</code> 内联到 <code>init</code>，则代码变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        [myObject release];</span><br><span class="line">        SomeClass *temp = [[SomeClass alloc] init];</span><br><span class="line">        obj.string = @&quot;Badger&quot;;</span><br><span class="line">        obj.number = 10;</span><br><span class="line">        [temp autorelease];</span><br><span class="line">        myObject = [temp retain];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意以上代码中 <code>[temp autorelease]</code> 后紧接着一个 <code>[temp retain]</code>。这正是新的 Objective-C 运行时可以优化的一个点。</p><p>(译者注：有很多细节的分析，这里略过) 编译一个调用 <code>objc_autoreleaseReturnValue()</code> 和 <code>objc_retainAutoreleasedReturnValue()</code> 的方法时，编译器会添加如下指令作为标记。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thumb mode:</span><br><span class="line">f7ffef56   blx  _objc_msgSend</span><br><span class="line">    463f  mov  r7, r7</span><br><span class="line">f7ffef54   blx  _objc_retainAutoreleasedReturnValue</span><br><span class="line"></span><br><span class="line">ARM mode:</span><br><span class="line">ebffffa0   bl   _objc_msgSend</span><br><span class="line">e1a07007   mov  r7, r7</span><br><span class="line">ebffff9e   bl   _objc_retainAutoreleasedReturnValue</span><br></pre></td></tr></table></figure><p>无论哪种模式，编译器均会添加 <code>mov r7, r7</code>这条看似无任何意义的指令(它将 r7 寄存器的值 move 到 r7寄存器)。不过这条指令是有意义的，编译器将它作为标识，用于告知 <code>objc_autoreleaseReturnValue</code> 方法：调用方接下来会调用 <code>objc_retainAutoreleasedReturnValue</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">id objc_autoreleaseReturnValue(id object) &#123;</span><br><span class="line">    if (thumb_mode &amp;&amp; next_instruction_after_return == 0x463f ||</span><br><span class="line">        arm_mode   &amp;&amp; next_instruction_after_return == 0xe1a07007)</span><br><span class="line">    &#123;</span><br><span class="line">        set_flag(object);</span><br><span class="line">        return object;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return objc_autorelease(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id objc_retainAutoreleasedReturnValue(id object) &#123;</span><br><span class="line">    if (get_flag(object)) &#123;</span><br><span class="line">        clear_flag();</span><br><span class="line">        return object;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return objc_retain(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：以上是伪代码，x86 版本的代码见<a href="https://opensource.apple.com/source/objc4/objc4-493.9/runtime/objc-arr.mm" target="_blank" rel="noopener">这里</a>。</p><p>总结一下：ARC 出现之前，我们不得不在代码中写 autorelease 和 retain。ARC 出现之后，虽然不用再写 autorelease 和 retain，但是遗留代码中的 autorelease 和 retain 会导致很多冗余操作，<code>objc_autoreleaseReturnValue</code> 和 <code>objc_retainAutoreleasedReturnValue</code> 正是为了应对这些冗余操作的优化。</p><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/2f05060fa377?spm=a2c4e.11153940.blogcont690541.7.575f3c89jeD8IS" target="_blank" rel="noopener">objc_autoreleaseReturnValue和objc_retainAutoreleasedReturnValue函数对ARC的优化 - 简书</a></li><li><a href="https://www.galloway.me.uk/2012/02/how-does-objc_retainautoreleasedreturnvalue-work/" target="_blank" rel="noopener">How does objc_retainAutoreleasedReturnValue work? - Matt Galloway</a></li><li><a href="https://opensource.apple.com/source/objc4/objc4-493.9/runtime/objc-arr.mm" target="_blank" rel="noopener">https://opensource.apple.com/source/objc4/objc4-493.9/runtime/objc-arr.mm</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 OC 中的 @weakify</title>
      <link href="2021/07/20/oc-weakify/"/>
      <url>2021/07/20/oc-weakify/</url>
      
        <content type="html"><![CDATA[<p>关于 <code>@weakify</code> 和 <code>@strongify</code> 的一些小知识。<br><a id="more"></a> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">block = ^() &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">block = ^()&#123;</span><br><span class="line">    __strong typeof(weakSelf) self = weakSelf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://halfrost.com/ios_block_retain_circle/#toc-12" target="_blank" rel="noopener">https://halfrost.com/ios_block_retain_circle/#toc-12</a></p><p><a href="https://www.jianshu.com/p/bc794fa07167" target="_blank" rel="noopener">https://www.jianshu.com/p/bc794fa07167</a></p><p><a href="https://stackoverflow.com/questions/28305356/ios-proper-use-of-weakifyself-and-strongifyself" target="_blank" rel="noopener">https://stackoverflow.com/questions/28305356/ios-proper-use-of-weakifyself-and-strongifyself</a></p><p>How @strongify works<br>After @strongify is called, self will have a different pointer address inside the block than it will outside the block. That’s because @strongify declares a new local variable called self each time. (This is why it suppresses the -Wshadow warning, which will “warn whenever a local variable shadows another local variable.”) It’s worth reading and understanding the implementation of these functions. So even though the names are the same, treat them as separate strong references.</p><p>Using @strongify in your code</p><ul><li>(void)someMethod {<br>  if (self.someBOOL) {<pre><code>@weakify(self);_someObjectInstanceVar = [Object objectWithCompletionHandler:^{    @strongify(self);    // self reference #1    if (self.someProperty) {        @weakify(self);        // self reference #2        [[Async HTTPRequest] sendAWithID:self.property.id completionHandler:^(void (^)(NewObject *newObject) {            @strongify(self);            // self reference #3            @weakify(self);            [self showViewWithObject:newObject handler:^{                // self reference #4                @strongify(self);                [self reloadData];            }];        }];    }}];</code></pre>  // etc…<br>}</li></ul><p>However, remember that after your first use of @strongify, self will refer to local, stack variables. These will typically get destroyed when the scope in which they’re defined ends (as long as you aren’t storing them to properties or using them in a nested block). So based on the code you showed, you only need it after // self reference #1.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>提升 AppCode 性能的几个小技巧</title>
      <link href="2021/05/01/enhance-appcode-performane/"/>
      <url>2021/05/01/enhance-appcode-performane/</url>
      
        <content type="html"><![CDATA[<p>AppCode 好用是好用，但这性能比起 Xcode 让人很无语。不过，AppCode 的性能是可以优化的。<br><a id="more"></a></p><p>最近的开发过程中发现 AppCode 占了 5GB 内存却仍然卡得干不了活，忍无可忍之下了解了一下如何优化 AppCode 性能。主要的参考资料来自 AppCode 官网。</p><ul><li><a href="https://www.jetbrains.com/help/objc/performance-tuning-tips.html" target="_blank" rel="noopener">Enhance performance | AppCode</a></li></ul><p>资料中提到几个点总结下来就是：</p><ul><li>加大 AppCode 内存</li><li>提升 AppCode code analysis﻿ 速度</li><li>提升 AppCode indexing﻿ 速度</li><li>关闭不必要的 Plugin</li></ul><h1 id="加大内存"><a href="#加大内存" class="headerlink" title="加大内存"></a>加大内存</h1><h2 id="打开内存指示器"><a href="#打开内存指示器" class="headerlink" title="打开内存指示器"></a>打开内存指示器</h2><p>AppCode 卡顿的一个主要原因是堆内存过低。所以我们很<em>有必要打开 AppCode 内存指示器</em>。</p><p>在 AppCode 底部状态上右键点击后出现如下菜单，勾选 “Memory Indicator” 即可打开内存指示器。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198615366659.jpg" alt="-w267"></p><p>我的内存指示器已打开，显示 “264 of 6131M”。内存状态良好。</p><p>注意：当可用的堆内存大小低于最大堆内存的5%时，会有低内存告警。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198618640390.jpg" alt></p><h2 id="加大堆内存"><a href="#加大堆内存" class="headerlink" title="加大堆内存"></a>加大堆内存</h2><p>从 AppCode 顶部菜单中 <strong>Help | Change Memory Settings</strong> 调整堆内存大小。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198617067248.jpg" alt="-w875"></p><p>我的 MacBook 内存大小 16G，已经给 AppCode 分了 6144 MB。已经相当奢侈，不能再加了。(即便 6G 内存，AppCode 还是卡，所以就我遇到的问题而言，瓶颈并不在内存)</p><h1 id="提升代码分析速度"><a href="#提升代码分析速度" class="headerlink" title="提升代码分析速度"></a>提升代码分析速度</h1><blockquote><p>On-the-fly code analysis is one of the most performance-consuming processes in AppCode.</p></blockquote><p>AppCode 的实时代码检查过程是最吃电脑性能的一个过程。针对这个问题，我们可以对实时代码检查进行配置，减少检查过程的性能消耗。</p><p>简单来说，就是减少实时代码检查甚至干脆不要实时检查(等要要检查时再启动)。</p><h2 id="调整代码检查项"><a href="#调整代码检查项" class="headerlink" title="调整代码检查项"></a>调整代码检查项</h2><p>AppCode 默认状态下会打开全部的检查类型(作者：不卡才怪？)，我们可以根据自己的需要进行调整。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198622243684.jpg" alt="-w992"></p><p>其实我们可以放心大胆地全关，因为完全可以在需要时通过 <strong>Code | Inspect Code</strong> 命令来检查。</p><h2 id="调整检查级别"><a href="#调整检查级别" class="headerlink" title="调整检查级别"></a>调整检查级别</h2><p>此外，还可以使用 <strong>Code | Configure Current File Analysis</strong> 命令调整当前已打开文件的检查级别。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198625862232.jpg" alt></p><p>分三种级别：</p><ul><li>None - 不检查</li><li>Syntax - 语法检查</li><li>Inspections - 检查</li></ul><p>不过个人感觉这个功能不太实用。</p><h1 id="提升索引速度"><a href="#提升索引速度" class="headerlink" title="提升索引速度"></a>提升索引速度</h1><p>AppCode 对文件进行索引(代码检查、代码自动补全、代码生成、自动导入功能依赖索引)。不过，不索引那些包含二进制文件、日志以及构建产物的目录并不会影响 AppCode 的代码检查等功能，所以进行索引时我们完全可以将这些目录排除。</p><p>另外，某些文件因过太大或是位于远程机器，索引的代价非常大。所以也应将这些文件排除在外。</p><p>排除文件或目录的方法很简单，在 <strong>Project</strong> 窗口将工程切换到 <strong>Files</strong> 视图，右击想要排除的文件，然后选择 <strong>Mark Directory as | Excluded</strong> </p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198705760997.jpg" alt="-w321"></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198713192648.jpg" alt></p><hr><p>回到前面我提到分配6G内存的情况下 AppCode 仍然卡顿的问题，发现卡顿时 AppCode 一直在索引。检查后发现 <font color="red">AppCode 打开该工程后，索引范围是当前用户的所有文件</font>(即整个 <code>/Users/username/</code> 目录。发现 AppCode 打开其他工程时只会索引当前工程目录中的文件，所以这是 AppCode 的 bug？)。对数量巨大的文件进行索引，几个小时也完成不了吧？</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198709164361.jpg" alt="-w318"></p><p>解决办法：果断排除掉不相关的目录，减少索引时间。</p><h1 id="其他优化技巧"><a href="#其他优化技巧" class="headerlink" title="其他优化技巧"></a>其他优化技巧</h1><p>另外一些优化手段包括：</p><ul><li>关闭 AppCode 中不必要的插件。AppCode 默认加载了很多插件，我们可以关闭不需要的插件以减少内存占用、提升速度</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198717657700.jpg" alt></p><ul><li>保证 AppCode 和 Xcode 版本兼容。如下图，这是我自己遇到的一个情况：AppCode 提示当前 Xcode 版本为 12.4，版本过高。</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198716155390.jpg" alt="-w967"></p><p>不清楚到底有什么影响，不过还是升级到跟 Xcode 12.4 兼容的 AppCode。如下图，AppCode 和 Xcode 兼容时，没有上述的警告。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198719580894.jpg" alt="-w898"></p><ul><li>Download Xcode caches﻿。如下图，勾选这里的 Download Xcode cacheds automatically，某些情况下能提升索引性能。(作者：按官方解释，这里的”某些情况”其实并不多，主要是指升级 Xcode 的情况)</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198720197701.jpg" alt="-w898"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一番折腾之后，AppCode 速度果然上来了。虽然 AppCode 响应速度相对 Xcode 还是有些差距，不过考虑到 AppCode 强大的重构功能还是非常值得使用的！</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20210306 问题小记</title>
      <link href="2021/03/06/variables-debug-info/"/>
      <url>2021/03/06/variables-debug-info/</url>
      
        <content type="html"><![CDATA[<p>最近对某些第三方Android库做简单的逆向分析。遇到两个问题，记录之。  </p><a id="more"></a><h1 id="Variables-debug-info-not-available"><a href="#Variables-debug-info-not-available" class="headerlink" title="Variables debug info not available"></a>Variables debug info not available</h1><p>Android Studio 中断点调试某些第三方 Android 库提示 Variables debug info not available，无法查看局部变量信息。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16149956735267.jpg" alt></p><p>找到以下资料 <a href="https://stackoverflow.com/questions/1313922/step-through-jdk-source-code-in-intellij-idea" target="_blank" rel="noopener">来源</a></p><blockquote><p>Java classes which are part of the JDK are compiled without debug info for the size and performance reasons.</p></blockquote><p>简单来说是提到出于大小和性能因素考虑，JDK 中的类是不带 debug 信息的。</p><p>类似地，很多第三方 Android 库使用 proguard 等工具混淆和优化后也去掉了 debug 信息，所以调试时无法查看局部变量信息(不过可以查看成员变量信息)。</p><h1 id="无法创建-ScanResult-实例"><a href="#无法创建-ScanResult-实例" class="headerlink" title="无法创建 ScanResult 实例"></a>无法创建 ScanResult 实例</h1><p>通常来说，我们会使用 Android 系统 API 获取 <a href="https://android.googlesource.com/platform/frameworks/base/+/5bab9da/wifi/java/android/net/wifi/ScanResult.java" target="_blank" rel="noopener">android.net.wifi.ScanResult</a> 的实例。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ScanResult&gt; list = wifiManager.getScanResults();</span><br></pre></td></tr></table></figure><p>有时出于某些原因，需要创建 <code>android.net.wifi.ScanResult</code> 实例。一开始，我以为这很简单。</p><p>思路一，直接调用构造方法创建实例不就可以了吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScanResult sr = <span class="keyword">new</span> ScanResult();</span><br><span class="line"></span><br><span class="line">ScanResult sr2 = <span class="keyword">new</span> ScanResult(sr);</span><br></pre></td></tr></table></figure><p>但实际上在 Android SDK 30 (Android 11) 之前，没有这两个构造方法。</p><ul><li><a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/android10-dev/wifi/java/android/net/wifi/ScanResult.java" target="_blank" rel="noopener">ScanResult android 10</a></li><li><a href="https://android.googlesource.com/platform/frameworks/base/+/android-6.0.1_r25/wifi/java/android/net/wifi/ScanResult.java" target="_blank" rel="noopener">ScanResult android 6</a></li></ul><p>在低版本 Android 设备上直接调用 <code>ScanResult</code> 构造方法会报 <code>java.lang.NoSuchMethodError</code> 错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2021-03-06 11:15:48.458 22161-22161/? E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">    Process: com.example.amaploc.demo, PID: 22161</span><br><span class="line">    java.lang.NoSuchMethodError: No direct method &lt;init&gt;()V in class Landroid/net/wifi/ScanResult; or its super classes </span><br><span class="line">    (declaration of &apos;android.net.wifi.ScanResult&apos; appears in /system/framework/framework.jar!classes2.dex)</span><br></pre></td></tr></table></figure><p>思路二，直接调用 <code>ScanResult</code> 构造方法行不通(低版本兼容问题)，那使用反射方式调用呢？但同样遇到兼容性问题：</p><ol><li>不同版本的 SDK 上非公开的构造方法参数不同</li><li>某些厂商可能修改了 <code>ScanResult</code> 构造方法</li></ol><p>思路三，考虑到 <code>ScanResult</code> 实现了 <code>Parcelable</code> 接口，所以可以借助 <code>Parcel</code> 来序列化/反序列化已有的 <code>ScanResult</code> 来生成新的 <code>ScanResult</code> 实例。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2021/05/01/16198583514111.jpg" alt="-w709"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ScanResult <span class="title">scanResultInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ScanResult parent = sCopyInstance;</span><br><span class="line"></span><br><span class="line">    Parcel p = Parcel.obtain();</span><br><span class="line">    parent.writeToParcel(p, <span class="number">0</span>);</span><br><span class="line">    p.setDataPosition(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ScanResult.CREATOR.createFromParcel(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单又完美地创建 ScanResult 实例</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/1313922/step-through-jdk-source-code-in-intellij-idea" target="_blank" rel="noopener">debugging - Step through JDK source code in IntelliJ IDEA - Stack Overflow</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP抓包小记</title>
      <link href="2021/02/18/http-cap/"/>
      <url>2021/02/18/http-cap/</url>
      
        <content type="html"><![CDATA[<p>最近处理一些对第三方应用中HTTPS请求抓包工作。杂七杂八挺烦琐，又容易遗忘。记录之，备不时之需。<br><a id="more"></a></p><h1 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h1><p>抓包工具有很多，选一个顺手的就行。我用的是 whistle。启动方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">whistle run</span><br><span class="line">[i] whistle@2.6.3 started</span><br><span class="line">[i] 1. use your device to visit the following URL list, gets the IP of the URL you can access:</span><br><span class="line">       http://127.0.0.1:8899/</span><br><span class="line">       http://172.30.209.45:8899/</span><br><span class="line">       http://172.20.209.88:8899/</span><br><span class="line">       Note: If all the above URLs are unable to access, check the firewall settings</span><br><span class="line">             For help see https://github.com/avwo/whistle</span><br><span class="line">[i] 2. configure your device to use whistle as its HTTP and HTTPS proxy on IP:8899</span><br><span class="line">[i] 3. use Chrome to visit http://local.whistlejs.com/ to get started</span><br><span class="line">Press [Ctrl+C] to stop whistle...</span><br></pre></td></tr></table></figure><p>启动后直接在浏览器中打开对应地址开始抓包。</p><h1 id="HTTPS-抓包"><a href="#HTTPS-抓包" class="headerlink" title="HTTPS 抓包"></a>HTTPS 抓包</h1><p>抓 HTTP 一般不会遇到什么问题，这里要说的主要是 HTTPS 抓包时遇到的问题。</p><h2 id="问题一：Android-iOS安装和信任证书"><a href="#问题一：Android-iOS安装和信任证书" class="headerlink" title="问题一：Android/iOS安装和信任证书"></a>问题一：Android/iOS安装和信任证书</h2><ul><li>Android 直接下载后从 SD 卡安装即可。安装成功后在<code>设置 &gt; 受信任的凭据 &gt; 用户</code>中查看</li><li>iOS 使用 Safari 浏览器打开证书链接来安装。安装成功后在<code>设置 &gt; 通用 &gt; 描述文件与设备管理</code>中查看。注意iOS上需要手动设置信任第三方证书</li></ul><p><img src="/images/16136148646757.jpg" alt="-w336"></p><p><img src="/images/16136152558859.jpg" alt="-w396"></p><p><img src="/images/16136153959387.jpg" alt="-w426"></p><p>经过如上设置后，可以抓到部分应用中的 HTTPS 请求了。但另一些应用的 HTTPS 请求，仍然无法抓取。大致可以归纳为两种原因(<a href="https://www.cnblogs.com/lulianqi/p/11380794.html#_label2" target="_blank" rel="noopener">部分APP无法代理抓包的原因及解决方法（flutter 抓包）</a>一文总结得不错)：</p><ul><li>HTTP 客户端没有走系统代理。这种情况比较少见，一个典型的例子是 Flutter</li><li>HTTP 客户端不信任第三方证书。这种情况比较多见，例如 Android 平台上滴滴出行、微信(7.0版本之后)</li></ul><p>接下来看Android系统中如何避免应用不信任第三方证书。</p><h2 id="问题二：应用不信任第三方证书"><a href="#问题二：应用不信任第三方证书" class="headerlink" title="问题二：应用不信任第三方证书"></a>问题二：应用不信任第三方证书</h2><p>两个解决办法：</p><ul><li>模拟器(开启root) + 安装系统证书</li><li>真机(无root) +  <a href="https://vxposed.com/" target="_blank" rel="noopener">VirtualXposed</a> + JustTrustMe</li></ul><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>有多种模拟器可供选择。这里推荐两个自带root功能，并且可成功运行大部分主流应用的模拟器。</p><ul><li>Windows 上可以使用夜神模拟器</li><li>Mac 上可以使用 <a href="http://mumu.163.com/help/func/20190129/30131_797867.html" target="_blank" rel="noopener">MuMu模拟器</a></li></ul><p>第一步，将whistle 证书下载到电脑上，名字是 <code>root.crt</code>。执行如下命令得到类似 <code>b4a43da9</code> 这样的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -subject_hash_old -in getssl.crt</span><br></pre></td></tr></table></figure><p>第二步，将 <code>root.crt</code> 重命名成 <code>b4a43da9.0</code>，安装到模拟器上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push b4a43da9.0 /system/etc/security/cacerts/</span><br></pre></td></tr></table></figure><p>第三步，<code>设置 &gt; 受信任的凭据 &gt; 系统</code>中检查证书是否安装成功。</p><p>将 whistle 证书安装成系统证书后，就可以正常抓取部分应用中的 HTTPS 请求。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ul><li>安装 VirtualXposed.apk 和 JustTrustme.apk</li><li>给 VirtualXposed 足够的权限</li><li>在 VirtualXposed 中安装 JustTrustme 和需要抓包测试的应用</li><li>重启 VirtualXposed</li><li>在 VirtualXposed 中打开待抓包的应用</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.cnblogs.com/lulianqi/p/11380794.html#_label2" target="_blank" rel="noopener">部分APP无法代理抓包的原因及解决方法（flutter 抓包） - lulianqi15 - 博客园</a></li><li><a href="https://www.jianshu.com/p/3d981ae674c5" target="_blank" rel="noopener">安卓高版本安装系统证书 HTTPS 抓包 - 简书</a></li><li><a href="https://gaojiajun.cn/2018/08/charles-notTrust-in-android7.0/" target="_blank" rel="noopener">Android7.0及以上charles抓包提示证书无效的解决方法 | 高嘉君的个人博客</a></li><li><a href="https://www.jianshu.com/p/a818a0d0aa9f" target="_blank" rel="noopener">Android 7.0+ 抓包https的一种方案(支持微信7.0) - 简书</a></li><li><a href="https://github.com/asLody/VirtualApp" target="_blank" rel="noopener">asLody/VirtualApp: Virtual Engine for Android(Support 11.0 in business version)</a></li><li><a href="https://www.cnblogs.com/h2zZhou/p/7759889.html" target="_blank" rel="noopener">VirtualApp技术黑产利用研究报告 - h2z - 博客园</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ios-pod-package</title>
      <link href="2020/11/27/ios-pod-package/"/>
      <url>2020/11/27/ios-pod-package/</url>
      
        <content type="html"><![CDATA[<p>了解 pod lib 命令的用法。<br><a id="more"></a></p><h1 id="创建Pod库"><a href="#创建Pod库" class="headerlink" title="创建Pod库"></a>创建Pod库</h1><p>第一步，创建Pod工程。使用 <code>pod lib create</code> 命令创建Pod工程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create &lt;PodName&gt;</span><br></pre></td></tr></table></figure><p>按提示配置选项，完成后自动打开 pod install 并打开 xcworkspace 文件</p><p>第二步，生成 Framework。Xcode中运行Example工程后，会生成对应的Framework文件</p><p><img src="/images/16064419140316.jpg" alt></p><p>不过这种方式生成Framework文件有几个问题：</p><ul><li>兼容性问题 - 生成的Framework只支持模拟器或真机，不能同时二者同时兼容</li><li>自动化问题 - 手动在Xcode操作，不便于自动构建</li></ul><h1 id="生成Framework"><a href="#生成Framework" class="headerlink" title="生成Framework"></a>生成Framework</h1><h2 id="使用-cocoapods-packager-生成"><a href="#使用-cocoapods-packager-生成" class="headerlink" title="使用 cocoapods-packager 生成"></a>使用 cocoapods-packager 生成</h2><p><a href="https://github.com/CocoaPods/cocoapods-packager" target="_blank" rel="noopener">CocoaPods Packager</a> 是一个 CocoaPods 插件，用于从 podspec 生成静态库。</p><blockquote><p>CocoaPods plugin which allows you to generate a static library from a podspec.</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>一种方式是使用 gem install 安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install cocoapods-packager</span><br></pre></td></tr></table></figure><p>不过从 Gem 官方源安装的 cocoapods-packager 版本比较老。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gem list | grep packager</span><br><span class="line">cocoapods-packager (1.5.0)</span><br></pre></td></tr></table></figure><p>另一种方式是从源码安装。</p><ul><li>下载源码</li><li>修改版本号</li><li>安装依赖库</li><li>构建gem安装包</li><li>安装gem包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/CocoaPods/cocoapods-packager.git</span><br><span class="line"></span><br><span class="line"># 修改 lib/cocoapods_packager.rb 文件中的版本号</span><br><span class="line"></span><br><span class="line">bundler install</span><br><span class="line"></span><br><span class="line">sudo gem build cocoapods-packager.gemspec</span><br><span class="line"></span><br><span class="line">sudo gem install cocoapods-packager-1.6.0.gem  -l</span><br></pre></td></tr></table></figure><p>构建安装包。构建成功后生成一个 gem 安装包</p><p><img src="/images/16064526409155.jpg" alt></p><p>安装gem包。使用 <code>sudo gem install &lt;gem包名&gt;</code> 安装。</p><p>检查版本号。安装完成后，使用 <code>gem list | grep packager</code> 检查 cocoapods-packager 版本是否正确</p><p><img src="/images/16064529541769.jpg" alt></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用cocoapods-packager时遇到几个问题，记录如下。</p><h3 id="问题一：没有使用-CDN"><a href="#问题一：没有使用-CDN" class="headerlink" title="问题一：没有使用 CDN"></a>问题一：没有使用 CDN</h3><p><code>pod package</code> 命令默认的 spec-sources 是 <a href="https://github.com/CocoaPods/Specs.git，所以会长时间卡在" target="_blank" rel="noopener">https://github.com/CocoaPods/Specs.git，所以会长时间卡在</a> Cloning spec repo 这一步。</p><p><img src="/images/16064435750825.jpg" alt></p><p>解决办法是指定 spec-sources。<a href="https://github.com/CocoaPods/cocoapods-packager/issues/250" target="_blank" rel="noopener">参考</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod package PodDemo.podspec  --spec-sources=&apos;https://cdn.cocoapods.org/&apos;</span><br></pre></td></tr></table></figure><h3 id="问题二：XCode-12-生成失败"><a href="#问题二：XCode-12-生成失败" class="headerlink" title="问题二：XCode 12 生成失败"></a>问题二：XCode 12 生成失败</h3><p>错误日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">have the same architectures (arm64) and can&apos;t be in the same fat output file</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/CocoaPods/cocoapods-packager/issues/259" target="_blank" rel="noopener">issues/259</a> - have the same architectures (arm64) and can’t be in the same fat output file</li><li><a href="https://github.com/CocoaPods/cocoapods-packager/issues/260" target="_blank" rel="noopener">issues/260</a> - Xcode12.0.1 build failed, can’t generate framework #260</li></ul><p>解决办法是排除特定的架构，避免打包失败。这个办法由<a href="https://github.com/CocoaPods/cocoapods-packager/issues/259" target="_blank" rel="noopener">issues/259</a>提供，我尝试发现在我的机器上可用。</p><p>首先，找到 <code>/Library/Ruby/Gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/cocoapods-packager/pod_utils.rb</code> 文件。</p><p>然后，在该文件第32行后面添加一行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.build_settings[&apos;EXCLUDED_ARCHS[sdk=iphonesimulator*]&apos;] = &apos;arm64&apos;</span><br></pre></td></tr></table></figure><p><img src="/images/16064430755729.jpg" alt></p><p>不过这个解决方案并没有提到问题的原因。推测这里的问题跟 <a href="https://github.com/Carthage/Carthage/blob/master/Documentation/Xcode12Workaround.md" target="_blank" rel="noopener">Carthage</a> Xcode 12 上的打包问题比较类似。Carthage 对此的解释是： </p><blockquote><p>Well, shortly, Carthage builds fat frameworks, which means that the framework contains binaries for all supported architectures. Until Apple Silicon was introduced it all worked just fine, but now there is a conflict as there are duplicate architectures (arm64 for devices and arm64 for simulator). This means that Carthage cannot link architecture specific frameworks to a single fat framework.</p><p>You can find more info in <a href="https://github.com/Carthage/Carthage/issues/3019" target="_blank" rel="noopener">respective issue #3019</a>.</p></blockquote><h3 id="问题三：找不到头文件"><a href="#问题三：找不到头文件" class="headerlink" title="问题三：找不到头文件"></a>问题三：找不到头文件</h3><p>遇到一个很诡异的问题：生成的 Framework 中没有公开的头文件。</p><p>排查了很久，发现是一个非常低级的错误。</p><p>原因是这样的：我使用本地Git仓库中的代码来生成 Framework，所以指定了目录但没有指定tag。在没有指定tag时，cocoapods-packager 使用 HEAD 指向的代码来打包。但是，<font color="red">我的代码写好了(包括头文件和源文件)，但并没有提交到Git仓库！</font>cocoapods-packager 当然无法复制公开的文件到生成的 Framework 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#s.source           = &#123; :git =&gt; &apos;https://github.com/abc/CmLib2.git&apos;, :tag =&gt; s.version.to_s &#125;</span><br><span class="line">s.source           = &#123; :git =&gt; &apos;/Users/abc/PublicCode/CmLib2&apos;&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-Carthage-生成"><a href="#使用-Carthage-生成" class="headerlink" title="使用 Carthage 生成"></a>使用 Carthage 生成</h2><p><a href="https://github.com/Carthage/Carthage" target="_blank" rel="noopener">Carthage</a>用于生成二进制的Framework。对比CocoaPods，Carthage无入侵性。</p><blockquote><p>Carthage is intended to be the simplest way to add frameworks to your Cocoa application.</p><p>Carthage builds your dependencies and provides you with binary frameworks, but you retain full control over your project structure and setup. Carthage does not automatically modify your project files or your build settings.</p></blockquote><p>需要注意的是 Carthage只支持</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/a253017eecce" target="_blank" rel="noopener">cocoapods-packager源码安装 - 简书</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NSClassFromString 用法简介</title>
      <link href="2020/11/14/ios-class-from-string/"/>
      <url>2020/11/14/ios-class-from-string/</url>
      
        <content type="html"><![CDATA[<p>简单了解如何使用 <code>NSClassFromString()</code> 函数动态加载类。</p><a id="more"></a><h1 id="NSClassFromString-及相关函数"><a href="#NSClassFromString-及相关函数" class="headerlink" title="NSClassFromString 及相关函数"></a>NSClassFromString 及相关函数</h1><table><thead><tr><th></th><th>OC</th><th>Java</th><th>备注</th></tr></thead><tbody><tr><td>通过名字获取类</td><td>NSClassFromString()</td><td>Class.forName()</td><td></td></tr><tr><td>通过名字获取方法</td><td>NSSelectorFromString()</td><td>Class.getDeclaredMethod()</td><td></td></tr><tr><td>判断方法能否调用</td><td>[NSObject respondsToSelector]</td><td></td><td></td></tr><tr><td>动态调用方法</td><td>[NSInvocation invoke]</td><td>Method.invoke()</td></tr></tbody></table><h2 id="NSClassFromString-介绍"><a href="#NSClassFromString-介绍" class="headerlink" title="NSClassFromString 介绍"></a>NSClassFromString 介绍</h2><p><code>NSClassFromString()</code> 函数的作用是通过名字来获取类 (原文：Obtains a class by name.)。</p><p>这个函数接受类的名字(一个字符串)作为参数，返回值是对应的类对象(如果这个名字对应的类未加载，则返回 <code>nil</code>)。如果参数为 <code>nil</code>，则直接返回 <code>nil</code>。</p><p>OC 的 <code>NSClassFromString()</code> 跟 Java 的 <code>Class.forName()</code> 类似。</p><p>OC 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSObject *target = [[NSClassFromString(className) alloc] init];</span><br></pre></td></tr></table></figure><p>对应的 Java 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单起见这里忽略异常处理</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">Object target = clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 9</span></span><br><span class="line"><span class="comment">// Object target = clazz.getDeclaredConstructor().newInstance()</span></span><br></pre></td></tr></table></figure><h2 id="NSSelectorFromString-介绍"><a href="#NSSelectorFromString-介绍" class="headerlink" title="NSSelectorFromString 介绍"></a>NSSelectorFromString 介绍</h2><p><code>NSSelectorFromString()</code> 函数的作用是通过名字来获取 selector (原文：Returns the selector with a given name)。</p><p>这个函数接受 selector 的名字(一个字符串)作为参数，返回值是对应的 selector。如果参数为 <code>nil</code> 或者无法转换成 UTF-8 字符串，则直接返回 <code>(SEL)0</code>。</p><p>OC 的 <code>NSSelectorFromString()</code> 跟 Java 的 <code>Class.getDeclaredMethod()</code> 方法类似。</p><p>OC 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SEL action = NSSelectorFromString(methodName);</span><br></pre></td></tr></table></figure><p>对应的 Java 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method catMethod = SomeClass<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredMethod</span>(<span class="title">methodName</span>)</span>;</span><br></pre></td></tr></table></figure><p>注意：</p><p><code>SEL</code> 的定义是 <code>typedef struct objc_selector *SEL;</code>。它的用于定义代表 method selector 的类型 (原文：Defines an opaque type that represents a method selector)。</p><h2 id="判断方法是否能调用"><a href="#判断方法是否能调用" class="headerlink" title="判断方法是否能调用"></a>判断方法是否能调用</h2><p><code>[NSObject] - (BOOL)respondsToSelector:(SEL)aSelector;</code> - Returns a Boolean value that indicates whether the receiver implements or inherits a method that can respond to a specified message. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (![target respondsToSelector:action])&#123;</span><br><span class="line">   // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Java中没有对应的用法。</p><h2 id="动态调用方法"><a href="#动态调用方法" class="headerlink" title="动态调用方法"></a>动态调用方法</h2><p><code>[NSInvocation invoke]</code> - Sends the receiver’s message (with arguments) to its target and sets the return value.</p><p>OC代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMethodSignature* methodSig = [target methodSignatureForSelector:action];</span><br><span class="line">NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSig];</span><br><span class="line">[invocation invoke];</span><br></pre></td></tr></table></figure><p>对应的Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method action = ...</span><br><span class="line">action.invoke(target);</span><br></pre></td></tr></table></figure><h1 id="NSStringClass-使用案例"><a href="#NSStringClass-使用案例" class="headerlink" title="NSStringClass 使用案例"></a>NSStringClass 使用案例</h1><p>可以使用 <code>NSStringClass()</code> 动态加载类。如果返回 <code>nil</code>，表示不能加载此类。</p><p>如下面代码所示，有不同的方式创建对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 方式一</span><br><span class="line">id myObj = [[NSClassFromString(@&quot;MyClass&quot;) alloc] init];</span><br><span class="line"></span><br><span class="line">// 方式二</span><br><span class="line">id myObj2 = [[MyClass alloc] init];</span><br></pre></td></tr></table></figure><p>通常来说这两种方式没有太多区别。但是，如果并不存在 <code>MyClass</code> 这个类，那么方式二编译报错。所以如果不确定是否存在 <code>MyClass</code> 这个类的情况下，应当使用方式一来创建对象。</p><p>方式一有这样两个好处：</p><ul><li>“弱”链接</li><li>不需要使用 <code>import</code>。即使没有头文件，只要类存在，就可以创建其对象</li></ul><p>再来看一个实例。某项目需要兼容 v4.3 和 v6.0 版本的百度地图SDK(有点怪，是吧)</p><ul><li>百度地图SDK v4.3 - 没有 <code>BMKCustomMapStyleOption</code>，不支持自定义地图功能</li><li>百度地图SDK v6.0 - 有 <code>BMKCustomMapStyleOption</code>，支持自定义地图功能</li></ul><p>原先的代码是这样写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BMKCustomMapStyleOption *options = [[BMKCustomMapStyleOption alloc] init];</span><br></pre></td></tr></table></figure><p>当使用百度地图SDK v6.0时，这行代码工作正常；当使用百度地图SDK v4.3时，这行代码<font color="red">无法编译</font>，提示 <code>BMKCustomMapStyleOption</code> 引起 “Undefined symbols”。</p><p>我们可以使用 <code>NSClassFromString</code> 避免这里的编译错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id options = [[NSClassFromString(@&quot;BMKCustomMapStyleOption&quot;) alloc] init];</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// MyBMapSettingsAdapter.m</span><br><span class="line"></span><br><span class="line">- (void)setCustomMapStyleOptions:(MyCustomStyleOptions *)styleOptions &#123;</span><br><span class="line">    if (styleOptions) &#123;</span><br><span class="line">        // BMKCustomMapStyleOption *options = [[BMKCustomMapStyleOption alloc] init];</span><br><span class="line">        // options.customMapStyleID = styleOptions.styleId;</span><br><span class="line">        // options.customMapStyleFilePath = styleOptions.stylePath;</span><br><span class="line">        // self.bMapView setCustomMapStyleWithOption...</span><br><span class="line">        </span><br><span class="line">        id options = [[NSClassFromString(@&quot;BMKCustomMapStyleOption&quot;) alloc] init];</span><br><span class="line">        </span><br><span class="line">        if (options) &#123;</span><br><span class="line">            SEL idMethod = NSSelectorFromString(@&quot;setCustomMapStyleID:&quot;);</span><br><span class="line">            [MyBMapSettingsAdapter invokeMethod:options selector:idMethod arg1:styleOptions.styleId];</span><br><span class="line">        </span><br><span class="line">            SEL pathMethod = NSSelectorFromString(@&quot;setCustomMapStyleFilePath:&quot;);</span><br><span class="line">            [MyBMapSettingsAdapter invokeMethod:options selector:pathMethod arg1:styleOptions.stylePath];</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用于解决 &quot;performSelector may cause a leak because its selector is unknown&quot;.</span><br><span class="line">+ (void)invokeMethod:(id)obj selector:(SEL)selector arg1:(id)arg1 &#123;</span><br><span class="line">    if (!obj) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if ([obj respondsToSelector:selector]) &#123;</span><br><span class="line">        IMP imp = [obj methodForSelector:selector];</span><br><span class="line">        void (*func)(id, SEL, id) = (void*)imp;</span><br><span class="line">        func(obj, selector, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--问题现象：+ 反序列化时不成功+ 提交加载相关类后，反序列化成功代码：原因：--><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/3ed2c7bc6653" target="_blank" rel="noopener">OC的反射机制 - 简书</a></li><li><a href="https://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown" target="_blank" rel="noopener">ios - performSelector may cause a leak because its selector is unknown - Stack Overflow</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ios-bundle</title>
      <link href="2020/11/13/ios-bundle/"/>
      <url>2020/11/13/ios-bundle/</url>
      
        <content type="html"><![CDATA[<p>iOS 中如何加载资源。</p><a id="more"></a><h1 id="读取第三方Framework中的资源文件"><a href="#读取第三方Framework中的资源文件" class="headerlink" title="读取第三方Framework中的资源文件"></a>读取第三方Framework中的资源文件</h1><p>先看看IPA文件目录结构。右键选中文件然后”显示包内容”：</p><p><img src="/images/16052551712936.jpg" alt></p><p>图中可以看到百度地图SDK的 mapapi.bundle 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *bundlePath = [[NSBundle mainBundle] pathForResource:@&quot;mapapi&quot; ofType:@&quot;bundle&quot;];</span><br><span class="line">NSLog(@&quot;bundle path  is %@&quot;, bundlePath);</span><br></pre></td></tr></table></figure><p>输出如下日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-11-13 16:10:44.289957+0800 map-sdk-ios-framework[19583:1397775] bundle path  is /private/var/containers/Bundle/Application/57181523-430B-42C0-AFD3-450AC94D14AF/map-sdk-ios-framework.app/mapapi.bundle</span><br></pre></td></tr></table></figure><p>百度地图SDK的 mapapi.bundle 文件包含一张名为 baidumap_logo.png 的图片。</p><p><img src="/images/16052555701661.jpg" alt></p><p>我们可以进一步读取这张图片。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *bundlePath = [[NSBundle mainBundle] pathForResource:@&quot;mapapi&quot; ofType:@&quot;bundle&quot;];</span><br><span class="line">NSData *localData = [NSData dataWithContentsOfFile:[bundlePath stringByAppendingPathComponent:@&quot;images/baidumap_logo.png&quot; ]];</span><br><span class="line">NSLog(@&quot;bundle data is %@&quot;, localData);</span><br></pre></td></tr></table></figure><h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="无法读取依赖工程中的资源"><a href="#无法读取依赖工程中的资源" class="headerlink" title="无法读取依赖工程中的资源"></a>无法读取依赖工程中的资源</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>H5开发小记</title>
      <link href="2020/09/24/h5-dev/"/>
      <url>2020/09/24/h5-dev/</url>
      
        <content type="html"><![CDATA[<p>离职中。离职前最后一个项目是前端项目，用到了一些之前不了解的工具，也遇到不少的问题。预计接下来几年都不会再接触前端开发工作，但记录一下以备忘、拓展知识广度总是好的。</p><a id="more"></a><p>具体分成三类话题。</p><ul><li>工具</li><li>问题</li><li>技巧</li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>首先谈谈<strong>开发工具</strong>。Chrome Devtools 真是个神器。<a href="(https://juejin.im/post/5f1542e16fb9a07e6f7b80fe">这里</a>)有篇介绍 Devtools 的文章。只挑几个我觉得特别有用的功能说说。</p><p><img src="/images/16009472822261.jpg" alt="-w451"></p><p>一是选择机型，便于在不同分辨率下调试。二是选中元素开关(点击一下后变成蓝色)，打开后选择 html 页面中的元素非常方便</p><p><img src="/images/16009474285734.jpg" alt="-w444"></p><p>第三个是 Replay XHR 功能。只会刷新页面来重新发送 XHR 请求，太 low 了。其实 Replay 一下就足够了！</p><p>另一个好用的开发工具是 Vue.js devtools。怎么好用呢？看图。直接在 Vue.js devtools 中修改数据，UI 也随之变化。调试界面非常方便！</p><p><img src="/images/vuejs-devtools.gif" alt="vuejs-devtools"></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>再来说说遇到的问题(或者说是坑)。</p><h2 id="DOM-与-Vue-js"><a href="#DOM-与-Vue-js" class="headerlink" title="DOM 与 Vue.js"></a>DOM 与 Vue.js</h2><p>首先要说的一个坑就是在 Vue.js 中使用 zepto 操作真实DOM节点引起的一个看似诡异其实很好理解的愚蠢问题。你肯定会质疑为什么 Vue.js 会使用 zepto。实际情况是前端输出的重构文件中用到的 zepto，一是我懒二是确实也不知如何准确地将 zepto 代码翻译成 Vue.js，所以就出现 Vue.js 与 zepto 混用的情况。</p><p>大部分场景下这种做并不会有问题，直接这个点击用户名后编辑的功能：</p><p><img src="/images/edit-name.gif" alt="edit-name"></p><p>伪代码类似这样，其关键在于 <code>vm.inputTeamName = newtxt</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;inputTeamName&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更改名称</span></span><br><span class="line">$(<span class="string">".btn-change"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> td = $(<span class="keyword">this</span>).siblings(<span class="string">'span'</span>);</span><br><span class="line"><span class="keyword">var</span> txt = td.text();</span><br><span class="line"><span class="keyword">var</span> input = $(<span class="string">"&lt;input type='text'value='"</span> + txt + <span class="string">"'/&gt;"</span>);</span><br><span class="line">td.html(input);</span><br><span class="line">input.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line">input.trigger(<span class="string">"focus"</span>);</span><br><span class="line">input.blur(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> newtxt = $(<span class="keyword">this</span>).val();</span><br><span class="line"><span class="keyword">if</span>(newtxt != txt) &#123;</span><br><span class="line">  <span class="comment">// 更新 inputTeamName</span></span><br><span class="line">  vm.inputTeamName = newtxt</span><br><span class="line">td.html(newtxt);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">td.html(newtxt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不过这段代码时灵时不灵。我疑惑了好久。但仔细一想又很简单：操作 span 这个<font color="red">真实DOM节点后</font>，就不能指望 <code></code> 是可靠的了 (毕竟它跟 Vue.js 的<font color="red">虚拟DOM节点</font>相关)</p><p>类似的情况还有操作过真实DOM节点后，<code>v-model</code>指令失效。原因也类似。</p><h2 id="重名组件"><a href="#重名组件" class="headerlink" title="重名组件"></a>重名组件</h2><p>封装了一个 <code>RegisterDialog</code> 组件，组件中指定了 id。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pop-wrap pop-bg02 pop-box01"</span> <span class="attr">id</span>=<span class="string">"pop-box01"</span> <span class="attr">style</span>=<span class="string">"display: none"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"p-title"</span>&gt;</span>绑定手机<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"phone-input"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>RegisterDialog</code> 组件被多处使用。如下图：</p><p><img src="/images/16010202840140.jpg" alt="-w502"></p><p>发现有时操作不能按预期方式操作 <code>RegisterDialog</code>。比如，头像和昵称无法正常显示。推测问题原因是 <code>RegisterDialog</code> 导致 html 页面内元素 ID 冲突。</p><p>一种解决方式是使用更合理的页面结构，保证只有一个 <code>RegisterDialog</code>。如下图：</p><p><img src="/images/16010202885727.jpg" alt="-w503"></p><p>另一种解决方式是避免 <code>RegisterDialog</code> 组件中 div 元素的 ID 写死为 <code>pop-box01</code>，而是使用动态ID。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pop-wrap pop-bg02 pop-box01"</span> <span class="attr">:id</span>=<span class="string">"myID"</span> <span class="attr">style</span>=<span class="string">"display: none"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"p-title"</span>&gt;</span>绑定手机<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"phone-input"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="分享图白边"><a href="#分享图白边" class="headerlink" title="分享图白边"></a>分享图白边</h2><p>我们的H5在某些机型上生成的分享图会出现一条白边。如下图：</p><p><img src="/images/16010220630144.jpg" alt="-w383"></p><p>白边问题的原因是rem和px转化存在小数点。提前将rem转换成px即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fixDimen(domId) &#123;</span><br><span class="line">  <span class="keyword">const</span> ele = <span class="built_in">document</span>.getElementById(domId);</span><br><span class="line">  <span class="keyword">if</span> (ele) &#123;</span><br><span class="line">    <span class="comment">// 解决rem和px转化存在小数点，导致的白边问题</span></span><br><span class="line">    ele.style.width = <span class="string">`<span class="subst">$&#123;ele.offsetWidth&#125;</span>px`</span>;</span><br><span class="line">    ele.style.height = <span class="string">`<span class="subst">$&#123;ele.offsetHeight&#125;</span>px`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="图片跨域"><a href="#图片跨域" class="headerlink" title="图片跨域"></a>图片跨域</h2><p>dom2img 库用于将 DOM 节点转换成图片。使用 dom2img 时要注意图片跨域问题。一种简单的解决办法是将托管在图片服务器上的图片保存到本地，同时修改部分css代码。</p><p>修改前：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://image-1251917893.cos.ap-guangzhou.myqcloud.com/gp-match/css/match.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://image-1251917893.cos.ap-guangzhou.myqcloud.com/gp-match/css/match.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"match.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后本地新增一个 <code>match.css</code> 文件。这个css会重写几个样式(主要是将背景图片指向本地图片，而非图片服务器)以覆盖前一个css中某些规则，以避免图片跨域问题。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.xspr1</span> &#123; <span class="attribute">background-image</span>: <span class="built_in">url</span>(img/xspr1.png); <span class="attribute">background-repeat</span>: no-repeat; <span class="attribute">background-size</span>: <span class="number">9.94rem</span> <span class="number">5.18rem</span>; &#125;</span><br><span class="line"><span class="selector-class">.xspr</span> &#123; <span class="attribute">background-image</span>: <span class="built_in">url</span>(img/xspr.png); <span class="attribute">background-repeat</span>: no-repeat; <span class="attribute">background-size</span>: <span class="number">9.92rem</span> <span class="number">11.21rem</span>; &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="内联CSS"><a href="#内联CSS" class="headerlink" title="内联CSS"></a>内联CSS</h2><p>有时需要在 Vue.js 中内联 css 文件。</p><p>比如我遇到这样一个问题。一些图片和css文件在测试环境中可以正常访问，但发布到正式环境就不行。</p><ul><li>测试环境中能正常访问<ul><li><a href="https://test.igame.qq.com/newcss/admin/hp-match/match.css" target="_blank" rel="noopener">https://test.igame.qq.com/newcss/admin/hp-match/match.css</a></li><li><a href="https://test.igame.qq.com/newcss/admin/hp-match/img/share1.jpg" target="_blank" rel="noopener">https://test.igame.qq.com/newcss/admin/hp-match/img/share1.jpg</a></li></ul></li><li>正式环境中不能正常访问<ul><li><a href="https://igame.qq.com/newcss/admin/hp-match/match.css" target="_blank" rel="noopener">https://igame.qq.com/newcss/admin/hp-match/match.css</a></li><li><a href="https://igame.qq.com/newcss/admin/hp-match/img/share1.jpg" target="_blank" rel="noopener">https://igame.qq.com/newcss/admin/hp-match/img/share1.jpg</a></li></ul></li></ul><p>看 Chrome 提示推测是正式服务器 <code>content-type</code> 配置有问题，它将css文件的作为html返回了，所以无法正常加载css。随之引起图片跨域问题(该css是专门用来解决跨域问题的)</p><p><img src="/images/16010240487770.jpg" alt="-w936"></p><p>无奈我没权限修改正式服务器配置。于是换另一种思路，将 css 内存到 Vue.js。</p><p>修改前：在 <code>index.html</code> 引入 <code>match.css</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"match.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后：在 <code>App.vue</code> 引入 <code>match.css</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./../../../public/match.css'</span>;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><p>修改后成功绕过正式服务器的 <code>content-type</code> 配置问题，可正常加载 <code>match.css</code>，避免了随之而来的图片跨域问题！</p><h2 id="使用图片"><a href="#使用图片" class="headerlink" title="使用图片"></a>使用图片</h2><p>vue 文件中也可以直接使用图片。方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register-dialog.vue</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;img <span class="class"><span class="keyword">class</span></span>=<span class="string">"info-txt-1"</span> :src=<span class="string">"imgs.share_text"</span> alt /&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import head_name from 'src/m</span>odule/xxx/img/head-name.png<span class="string">'</span></span><br><span class="line"><span class="string">import headbox from '</span>src/<span class="built_in">module</span>/xxx/img/headbox.png<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  data() &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      imgs: &#123;</span></span><br><span class="line"><span class="string">        head_name: head_name,</span></span><br><span class="line"><span class="string">        headbox: headbox</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="保存分享图"><a href="#保存分享图" class="headerlink" title="保存分享图"></a>保存分享图</h2><p>一个需求是这样的：用户长按h5保存图片时，实际保存的图片上要求有一个二维码和提示。</p><p><a href="https://blog.csdn.net/w20101310/article/details/60580241/" target="_blank" rel="noopener">微信中如何长按图片保存的是另一张图片_小朱的专栏-CSDN博客</a>中介绍了一种解决方案。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><img src="/images/16009498051466.jpg" alt="-w102"></p><ul><li>chrome devtools 中快速qq登录 (一直觉得H5中QQ登录很麻烦，实际上是没有掌握技巧。使用 Toggle device toolbar 将浏览器切换成PC模式而不是Mobile模式，可以拉起PC端的QQ登录页，然后手机QQ扫一扫登录，非常方便)</li><li>部署不同的 url 的环境 (修改 <code>publish.js</code> 脚本)</li><li>beforeDestroy 响应back 键回退时，以关闭 layer</li><li>同名组件问题 (同ref或同ID)</li><li>无法获取角色信息问题确认</li><li>卡在ssl.ptlogin2.qq.com的问题 (短时间同一测试QQ号在多个Android机器上登录时容易出现这个问题)</li><li>分环境部署 (修改 <code>publish.js</code> 中的 <code>desc</code> 即可)</li><li>css 作用域问题 (dialog 样式)</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/5f1542e16fb9a07e6f7b80fe" target="_blank" rel="noopener">脱离996，Chrome DevTools 面板全攻略！！！ - 掘金</a></li><li><a href="https://blog.csdn.net/w20101310/article/details/60580241/" target="_blank" rel="noopener">微信中如何长按图片保存的是另一张图片_小朱的专栏-CSDN博客</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 内存优化之优化 so 文件</title>
      <link href="2020/07/22/flutter-mmamp-memory/"/>
      <url>2020/07/22/flutter-mmamp-memory/</url>
      
        <content type="html"><![CDATA[<p>优化 so 大小能否减少 Android 应用的内存？从原理上讲是可以的，实际效果如何？一起来看看吧。</p><a id="more"></a><p>(本文待完善)</p><p>相关文章：</p><ul><li><a href="https://www.sunmoonblog.com/2020/07/16/flutter-split-debug-info/">Flutter split-debug-info 用法介绍</a> - 使用 split-debug-info 可以优化 Flutter libapp.so 大小</li><li><a href="https://www.sunmoonblog.com/2020/07/15/flutter-app-memory-test/">Flutter App 内存测试</a> - 在若干简单场景下测试 Flutter 应用内存，为内存优化提供指导</li></ul><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们知道，Android 应用占用的内存有一类是 <code>Code</code>。<code>dumpsys meminfo</code> 命令的输出中可以看到 Code 类别的内存：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949713220131.jpg" alt></p><p>关于 Code 内存，官网是这样解释的：</p><blockquote><p>Memory that your app uses for code and resources, such as dex bytecode, optimized or compiled dex code, .so libraries, and fonts <a href="https://developer.android.com/studio/profile/memory-profiler#how-counted" target="_blank" rel="noopener">来源</a></p></blockquote><p>简单计算一下，发现 Code 内存大致包括 <code>.so mmap</code> 和 <code>.apk mmap</code>。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949717854679.jpg" alt></p><p>我们可以观察 so 优化前后 <code>.so mmap</code> 的变化来判断优化是否有效果。</p><p>不过还有另外一个问题：Android 应用中通常有很多 so，所以没法通过 <code>.so mmap</code> 来判断单个 so 的优化效果。该怎么办？</p><h1 id="maps-文件"><a href="#maps-文件" class="headerlink" title="maps 文件"></a>maps 文件</h1><p>判断单个 so 的优化效果的方法是查看和分析进程对应的 <code>proc/&lt;pid&gt;/maps</code> 文件。</p><p><a href="https://stackoverflow.com/questions/1401359/understanding-linux-proc-id-maps" target="_blank" rel="noopener">Understanding-linux-proc-id-maps</a> 对 <code>maps</code> 文件有介绍。</p><blockquote><p>Each row in /proc/$PID/maps describes a region of contiguous virtual memory in a process or thread. Each row has the following fields:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">address           perms offset  dev   inode   pathname</span><br><span class="line">08048000-08056000 r-xp 00000000 03:0c 64593   /usr/sbin/gpm</span><br></pre></td></tr></table></figure><ul><li>address - 进程地址空间的起始地址</li><li>permissions - 访问权限</li><li>pathname - 如果该区域是从文件映射来的，pathname 为文件名</li></ul><p>注意，直接在 adb shell 用 cat 查看 maps 文件可能会遇到 permission denied 问题。可以 <code>run-as</code> 命令来避免该问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ ✗ adb shell</span><br><span class="line">HWANE:/ $ run-as</span><br><span class="line">run-as: usage: run-as &lt;package-name&gt; [--user &lt;uid&gt;] &lt;command&gt; [&lt;args&gt;]</span><br><span class="line">run-as com.example.flutter.image.flutter_image_demo  cat /proc/7331/maps \ </span><br><span class="line">  | grep libapp.so</span><br></pre></td></tr></table></figure><p>以下示例查看 <code>com.example.flutter.image.flutter_image_demo</code> 的 maps 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HWANE:/ $ run-as com.example.flutter.image.flutter_image_demo  cat /proc/7331/maps | grep libandroid</span><br><span class="line">7016edb000-7016ef6000 r-xp 00000000 fd:00 7502                           /system/lib64/libandroid.so</span><br><span class="line">7016ef7000-7016efb000 r--p 0001b000 fd:00 7502                           /system/lib64/libandroid.so</span><br></pre></td></tr></table></figure><p>方便起见，可以写个脚本来解析 maps 文件以快速统计每个 so 文件占用内存的总大小。源码见 <a href="https://gist.github.com/410063005/eb8d405d1605e9990620c9f4135762b2" target="_blank" rel="noopener">gist</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">data_list = []</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">    raw_data = input(<span class="string">'paste maps string here: '</span> <span class="keyword">if</span> len(data_list) == <span class="number">0</span> <span class="keyword">else</span> <span class="string">''</span>)</span><br><span class="line">    <span class="keyword">if</span> (raw_data.strip() == <span class="string">''</span>): </span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    data_list.append(raw_data)</span><br><span class="line"></span><br><span class="line">mem_map = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> data_list:</span><br><span class="line">    tmp = item.split(<span class="string">' '</span>)</span><br><span class="line">    addr = tmp[<span class="number">0</span>].split(<span class="string">'-'</span>)</span><br><span class="line">    <span class="keyword">if</span> len(addr) == <span class="number">2</span>:</span><br><span class="line">        mem = (int(addr[<span class="number">1</span>], <span class="number">16</span>) - int(addr[<span class="number">0</span>], <span class="number">16</span>)) / <span class="number">1024.0</span> / <span class="number">1024.0</span></span><br><span class="line"></span><br><span class="line">        key = tmp[<span class="number">-1</span>][<span class="number">-30</span>:]</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> mem_map:</span><br><span class="line">            mem_map[key].append(mem)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            li = []</span><br><span class="line">            li.append(mem)</span><br><span class="line">            mem_map[key] = li</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">for</span> (k, v) <span class="keyword">in</span> mem_map.items():</span><br><span class="line">    print(k, <span class="string">' '</span>, sum(v), <span class="string">'MB'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949755118549.jpg" alt="-w785"></p><h1 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h1><ul><li>测试目标：FlutterImageDemo、Flutter 项目优化前、Flutter 项目优化后</li><li>测试工具：<code>dumpsys meminfo</code> 和 <code>run-as</code></li><li>测试指标：<ul><li><code>libflutter.so</code> 和 <code>libapp.so</code> 文件大小</li><li><code>.so mmap</code></li><li>maps 文件中 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小</li></ul></li></ul><p>数据如下。</p><h2 id="FlutterImageDemo"><a href="#FlutterImageDemo" class="headerlink" title="FlutterImageDemo"></a>FlutterImageDemo</h2><p>FlutterImageDemo 是一个简单的 Flutter 应用。</p><ul><li>包名 <code>com.example.flutter.image.flutter_image_demo</code></li><li>进程号 7331</li><li>APK 包解压出来的 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小分别是 13.9MB 和 6.1MB</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949758838686.jpg" alt></p><p>不得不吐槽下 Mac 上文件大小的计算方式对开发人员实现不友好。我重新算了一下，准确的大小分别是 13.2MB 和 5.8MB。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/22/15949759493938.jpg" alt="-w778"></p><p><code>.so mmap</code> 数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys meminfo com.example.flutter.image.flutter_image_demo</span><br><span class="line"></span><br><span class="line">** MEMINFO in pid 7331 [com.example.flutter.image.flutter_image_demo] **</span><br><span class="line">                   Pss  Private  Private  SwapPss     Heap     Heap     Heap</span><br><span class="line">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free</span><br><span class="line">                ------   ------   ------   ------   ------   ------   ------</span><br><span class="line">     .so mmap    14010      584    12600       47</span><br></pre></td></tr></table></figure><p>maps 数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HWANE:/ $ run-as com.example.flutter.image.flutter_image_demo  cat /proc/7331/maps | grep libflutter.so</span><br><span class="line">6fffee6000-70005d9000 r--p 00000000 103:08 39455                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libflutter.so</span><br><span class="line">70005e6000-7000ae9000 r-xp 00700000 103:08 39455                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libflutter.so</span><br><span class="line">7000af6000-7000bd6000 rw-p 00c10000 103:08 39455                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libflutter.so</span><br><span class="line">7000bd6000-7000c25000 r--p 00cf0000 103:08 39455                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libflutter.so</span><br><span class="line">HWANE:/ $ run-as com.example.flutter.image.flutter_image_demo  cat /proc/7331/maps | grep libapp.so</span><br><span class="line">6fff5c3000-6fff5c5000 rw-p 00000000 103:08 45222                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libapp.so</span><br><span class="line">6fff5c5000-6fff85d000 r-xp 00002000 103:08 45222                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libapp.so</span><br><span class="line">6fff85d000-6fffb94000 r--p 0029a000 103:08 45222                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libapp.so</span><br><span class="line">6fffb94000-6fffb95000 rw-p 005d1000 103:08 45222                         /data/app/com.example.flutter.image.flutter_image_demo-FcAoMElVHeoIhc0Ac6coTQ==/lib/arm64/libapp.so</span><br></pre></td></tr></table></figure><p>maps 解析后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/lib/arm64/libflutter.so   13.14453125 MB</span><br><span class="line">/lib/arm64/libapp.so   5.8203125 MB</span><br></pre></td></tr></table></figure><h2 id="Flutter-项目优化前"><a href="#Flutter-项目优化前" class="headerlink" title="Flutter 项目优化前"></a>Flutter 项目优化前</h2><p>从优化前的 APK 包解压出来的 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小分别是 5.9MB 和 9.6MB</p><p><code>.so mmap</code> 数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys meminfo com.t.t.i.host</span><br><span class="line">** MEMINFO in pid 15191 [com.t.t.i.host] **</span><br><span class="line">                   Pss  Private  Private  SwapPss     Heap     Heap     Heap</span><br><span class="line">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free</span><br><span class="line">                ------   ------   ------   ------   ------   ------   ------</span><br><span class="line">     .so mmap    16194      452    13896      127</span><br></pre></td></tr></table></figure><p>maps 数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HWANE:/ $ run-as com.t.t.i.host cat /proc/15191/maps  | grep libflutter.so</span><br><span class="line">c16c1000-c17ef000 r--p 00000000 103:08 132483                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libflutter.so</span><br><span class="line">c17ef000-c1baa000 r-xp 0012e000 103:08 132483                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libflutter.so</span><br><span class="line">c1baa000-c1c87000 rw-p 004e9000 103:08 132483                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libflutter.so</span><br><span class="line">c1c87000-c1caf000 r--p 005c6000 103:08 132483                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libflutter.so</span><br><span class="line">HWANE:/ $ run-as com.t.t.i.host cat /proc/15191/maps  | grep libapp.so</span><br><span class="line">c0a0f000-c0a11000 rw-p 00000000 103:08 129024                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libapp.so</span><br><span class="line">c0a11000-c0f55000 r-xp 00002000 103:08 129024                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libapp.so</span><br><span class="line">c0f55000-c13a6000 r--p 00546000 103:08 129024                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libapp.so</span><br><span class="line">c13a6000-c13a7000 rw-p 00997000 103:08 129024                            /data/app/com.t.t.i.host--zWkLmLHuo53FaZeCcpa7w==/lib/arm/libapp.so</span><br></pre></td></tr></table></figure><p>maps 解析后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ccpa7w==/lib/arm/libflutter.so   5.9296875 MB</span><br><span class="line">FaZeCcpa7w==/lib/arm/libapp.so   9.59375 MB</span><br></pre></td></tr></table></figure><h2 id="Flutter-项目优化后"><a href="#Flutter-项目优化后" class="headerlink" title="Flutter 项目优化后"></a>Flutter 项目优化后</h2><p>从优化后的 APK 包解压出来的 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小分别是 5.9MB 和 8.6MB</p><p><code>.so mmap</code> 数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys meminfo com.t.t.i.host</span><br><span class="line"></span><br><span class="line">** MEMINFO in pid 14331 [com.t.t.i.host] **</span><br><span class="line">                   Pss  Private  Private  SwapPss     Heap     Heap     Heap</span><br><span class="line">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free</span><br><span class="line">                ------   ------   ------   ------   ------   ------   ------</span><br><span class="line">     .so mmap    16053      452    13572      117</span><br></pre></td></tr></table></figure><p>maps 数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127|HWANE:/ $ run-as com.t.t.i.host cat /proc/14331/maps | grep libflutter.so</span><br><span class="line">c154b000-c1679000 r--p 00000000 103:08 136617                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libflutter.so</span><br><span class="line">c1679000-c1a34000 r-xp 0012e000 103:08 136617                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libflutter.so</span><br><span class="line">c1a34000-c1b11000 rw-p 004e9000 103:08 136617                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libflutter.so</span><br><span class="line">c1b11000-c1b39000 r--p 005c6000 103:08 136617                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libflutter.so</span><br><span class="line">HWANE:/ $ run-as com.t.t.i.host cat /proc/14331/maps | grep libapp.so</span><br><span class="line">c0a8d000-c0a8f000 rw-p 00000000 103:08 131577                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libapp.so</span><br><span class="line">c0a8f000-c0fd2000 r-xp 00002000 103:08 131577                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libapp.so</span><br><span class="line">c0fd2000-c1328000 r--p 00545000 103:08 131577                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libapp.so</span><br><span class="line">c1328000-c1329000 rw-p 0089b000 103:08 131577                            /data/app/com.t.t.i.host-Cf28XWHWRKP40xhjV1HTdA==/lib/arm/libapp.so</span><br></pre></td></tr></table></figure><p>maps 解析后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V1HTdA==/lib/arm/libflutter.so   5.9296875 MB</span><br><span class="line">0xhjV1HTdA==/lib/arm/libapp.so   8.609375 MB</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>对比 <code>libflutter.so</code> 和 <code>libapp.so</code> 文件大小及 maps 的解析结果，发现数值几乎一致</li><li>对比 <code>.so mmap</code> 内存，看起来跟 so 文件大小相关性不明显 (<font color="red">??? 哪里出错了？</font>)</li></ul><table><thead><tr><th></th><th>libflutter.so文件</th><th>libapp.so文件</th><th><code>.so mmap</code></th><th>maps文件解析</th></tr></thead><tbody><tr><td>FlutterImageDemo</td><td>13.2MB</td><td>5.8MB</td><td>13.7MB</td><td>13.1MB和5.8MB</td></tr><tr><td>优化前</td><td>5.9MB</td><td>9.6MB</td><td>15.8MB</td><td>5.9MB和9.6MB</td></tr><tr><td>优化后</td><td>5.9MB</td><td>8.6MB</td><td>15.7MB</td><td>5.9MB和8.6MB</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译) Flutter State 生命周期</title>
      <link href="2020/07/21/flutter-state-lifecycle/"/>
      <url>2020/07/21/flutter-state-lifecycle/</url>
      
        <content type="html"><![CDATA[<p>翻译自 <a href="https://medium.com/flutter-community/flutter-lifecycle-for-android-and-ios-developers-8f532307e0c7" target="_blank" rel="noopener">Flutter Lifecycle for Android and iOS Developers | Medium</a>。类比 Android 和 iOS，了解 Flutter State 的生命周期。</p><a id="more"></a><!--One of the most confusing ideas transitioning from Android and/or iOS is to understand how Flutter handles its lifecycle.--><p>从 Android 或 iOS 转到 Flutter 开发，最让人疑惑的是 Flutter 如何处理生命周期。</p><p><strong>onCreate()</strong> 在哪里？<strong>viewDidLoad()</strong> 呢？我应该将业务逻辑放在哪里？为什么只有一个 <code>build</code> 方法？</p><p>本文将解答这些疑惑。</p><h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><p><strong>Activity</strong> 生命周期是 Android 开发必须记住的：</p><ul><li>onCreate</li><li>onStart</li><li>onResume</li></ul><hr><ul><li>onPause</li><li>onStop</li><li>onRestart</li><li>onDestroy</li></ul><p>大部分业务逻辑放在 <strong>onCreate</strong> 方法：初始化 view、数据库、监听器等等。<strong>onResume</strong> 和 <strong>onPause</strong> 是判断用户离开或进入当前页面的好时机。</p><h1 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h1><p>UIViewController 的生命周期如下：</p><ul><li>viewDidLoad</li><li>viewWillAppear</li><li>viewDidAppear</li></ul><hr><ul><li>viewWillDisappear</li><li>viewDidDisappear</li><li>viewDidUnload</li></ul><p>如你所见，两个平台均使用几乎一致的步骤来创建或销毁页面。大部分业务逻辑放在 <strong>viewDidLoad()</strong>，而 <strong>Will/Did Appear/Disappear</strong> 用于保存信息，判断用户何时离开页面等等。</p><h1 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h1><p>在 Flutter 中呢？Widget 也遵循类似规则吗？</p><p>Flutter 中主要有两种 Widget：<strong>StatelessWidget</strong> 和 <strong>StatefulWidget</strong>。本文重点放在 <strong>StatefulWidget</strong>，因为它有点像 <strong>Android</strong> 和 <strong>iOS</strong> 中的某些概念。</p><h2 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2><p>StatefulWidget 是最重要的 Widget，因为它持有 <strong>State</strong>，它知道何时发生变化并进行必要的重绘。它的生命周期如下：</p><ul><li>createState</li><li>initState</li><li>didChangeDependencies</li><li>build</li><li>(didUpdateWidget)</li></ul><p>— — — — — — — — — — —</p><ul><li>deactivate</li><li>dispose</li></ul><p>你可能会注意到创建阶段的 state 比销毁阶段的多，这是因为创建/重建 Widget 及其 State 更复杂。</p><h3 id="createState"><a href="#createState" class="headerlink" title="createState():"></a>createState():</h3><p>构建新的 StatefulWidget 时将调用 createState()，StatefulWidget 的子类必须覆盖这个方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyScreen</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyScreenState createState() =&gt; _MyScreenState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initState"><a href="#initState" class="headerlink" title="initState()"></a>initState()</h3><p>通常需要重写这个方法。它是 Widget 创建后调用的第一个方法，可以理解成 <strong>onCreate()</strong> 或 <strong>viewDidLoad()</strong> 的等价物。在这个方法中可以检查 Widget 某些相关属性：是否有被渲染？当前是否处理 mounted 状态？</p><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>每个 Widget 都有这个属性。当为 Widget.buildContext 赋值后 mounted 的值变成 <strong>true</strong>，Widget 在树中。直到 <strong>dispose</strong> 方法被调用前，mounted 一直为 true。</p><h3 id="addPostFrameCallback"><a href="#addPostFrameCallback" class="headerlink" title="addPostFrameCallback"></a>addPostFrameCallback</h3><p>可以在 <strong>initState</strong> 方法中按如下方式调用 <code>addPostFrameCallback</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/scheduler.dart'</span>;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">  <span class="keyword">super</span>.initState();</span><br><span class="line">  SchedulerBinding.instance.addPostFrameCallback((_) =&gt; &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法为一帧结束时添加回调，回调方法只会调用一次，通知 Widget 构建已完成。</p><h3 id="didChangeDependencies"><a href="#didChangeDependencies" class="headerlink" title="didChangeDependencies"></a>didChangeDependencies</h3><p>widget 构建时第一次调用 initState() 后立即会调用 didChangeDependencies()。如果 <strong>StatefulWidgets</strong> 依赖某个 <strong>InheritedWidget</strong>，后者发生变化时会导致 didChangeDependencies() 再次被调用。</p><h3 id="build"><a href="#build" class="headerlink" title="build()"></a>build()</h3><p>可以肯定地说这是最重要的方法。这个方法依赖整个待渲染的 Widget 树，在 <strong>didChangeDependencies()</strong> 立即被调用。所有的 GUI 渲染发生在这个方法，每次 UI 需要重新渲染时都会调用这个方法。(重新渲染是很廉价的操作)</p><h3 id="didUpdateWidget"><a href="#didUpdateWidget" class="headerlink" title="didUpdateWidget()"></a>didUpdateWidget()</h3><p>这是一个不太常见的生命周期方法。一旦 parent widget 有变化需要重绘 UI 时会调用 didUpdateWidget()。这个方法有一个 <strong>oldWidget</strong> 参数，可以将它跟当前 <strong>widget</strong> 进行比较以执行某些额外的业务逻辑。</p><h3 id="deactivate"><a href="#deactivate" class="headerlink" title="deactivate()"></a>deactivate()</h3><p>这个生命周期方法也不太常见。这个方法被调用时，意味着 Widget 开始进入”死亡”阶段。</p><p>当 framework 从树中移除 State 时会调用本方法。某些情况下，framework 会重新将 State 对象加入到树中。</p><h3 id="dispose"><a href="#dispose" class="headerlink" title="dispose()"></a>dispose()</h3><p>这个方法也非常重要。当 Widget 及其 State 从树中永久移除时会调用这个方法。此后 Widget 不会再被构建。</p><p>你需要在这个方法中做取消对 stream 的监听、销毁动画等操作。它是 <strong>initState</strong> 的反操作。</p><h1 id="WidgetsBindingObserver"><a href="#WidgetsBindingObserver" class="headerlink" title="WidgetsBindingObserver"></a>WidgetsBindingObserver</h1><p>如果我们想监听应用何时进入后台该怎么办？</p><p>可以这样做。对 <strong>StatefulWidget</strong> 做些小改动：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyScreen</span>&gt; <span class="title">with</span> <span class="title">WidgetsBindingObserver</span></span></span><br></pre></td></tr></table></figure><p>我们让 <code>_MyScreenState</code> 实现了抽象类 <strong>WidgetsBindingObserver</strong>，之后就可以观察应用的生命周期状态。在 <strong>initState</strong> 方法中开始观察：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WidgetsBinding.instance.addObserver(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>在 <strong>dispose</strong> 方法中停止观察：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WidgetsBinding.instance.removeObserver(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>接下来在 <strong>didChangeAppLifecycleState</strong> 接收生命周期的变化即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> didChangeAppLifecycleState(AppLifecycleState state) &#123;</span><br><span class="line">  <span class="keyword">super</span>.didChangeAppLifecycleState(state);</span><br><span class="line">  <span class="keyword">if</span> (state == AppLifecycleState.paused) &#123;</span><br><span class="line">    <span class="comment">// went to Background</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (state == AppLifecycleState.resumed) &#123;</span><br><span class="line">    <span class="comment">// came back to Foreground</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个技巧很有用。如果你想在应用进入后台时弹出 notification，或者保存数据，又或者在用户点 back 回退时弹出 popup，都可以使用这个技巧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter split-debug-info 用法介绍</title>
      <link href="2020/07/16/flutter-split-debug-info/"/>
      <url>2020/07/16/flutter-split-debug-info/</url>
      
        <content type="html"><![CDATA[<p>介绍如何使用 Flutter 1.7 提供的 <code>split-debug-info</code> 编译选项来减小包大小。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>先介绍下什么是 <a href="https://en.wikipedia.org/wiki/Obfuscation_(software" target="_blank" rel="noopener">Code obfuscation</a>)。Code obfuscation 翻译过来就是代码混淆。代码混淆是修改应用二进制文件以增加理解难度的过程。混淆会隐藏编译后的 Dart 代码中的函数名和类名，让攻击者难以对应用进行逆向工程。</p><p>目前 Flutter (v1.7.14) stable 分支仅在 <a href="https://flutter.dev/docs/testing/build-modes" target="_blank" rel="noopener">release build</a> 中支持代码混淆。<a href="https://github.com/flutter/flutter/pull/49650" target="_blank" rel="noopener">Pull Request #49650 · flutter/flutter</a> 添加了这个功能。</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>同时使用 <code>--obfuscate</code> 和 <code>--split-debug-info</code> 标志来在 release 版本的应用中开启混淆。<code>--split-debug-info</code> 用于指定一个目录来存放 debug 文件，即 symbol map。目前 Flutter (v1.7.14) stable 分支支持 <code>apk</code>、<code>appbundle</code>、<code>ios</code> 和 <code>ios-framework</code>，master 和 dev 分支上还支持 <code>macos</code> 和 <code>aar</code>。</p><p>示例：编译并混淆一个 APK，在 <code>tmp</code> 目录下保存 symbol map。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter build apk --release --target-platform android-arm64 \</span><br><span class="line"> --obfuscate \</span><br><span class="line"> --split-debug-info=tmp/</span><br></pre></td></tr></table></figure><p>对于 Android 项目，也可以通过在 <code>&lt;project&gt;/app/gradle.properties</code> 中添加如下配置来<a href="https://github.com/flutter/flutter/wiki/Obfuscating-Dart-Code" target="_blank" rel="noopener">开启代码混淆</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extra-gen-snapshot-options=--obfuscate</span><br></pre></td></tr></table></figure><p>编译完成后 <code>tmp</code> 目录将生成一个后缀名为 <code>.symbols</code> 的文件。</p><p>注意：也可以单独使用 <code>--split-debug-info</code>。实际上这个参数是用来减小代码大小的 (即 <code>libapp.so</code> 的大小)</p><p>分别使用如下命令编译 APK。第一条命令生成优化前的 APK，第二条命令生成优化后的 APK。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter build apk --release --target-platform android-arm64</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter build apk --release --target-platform android-arm64 \</span><br><span class="line"> --obfuscate \</span><br><span class="line"> --split-debug-info=tmp/</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/16/15948669243081.jpg" alt></p><p>使用 <code>--split-debug-info</code> 优化后，APK 大小较之前减少 435KB。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/16/15948672793669.jpg" alt="-w727"></p><ul><li>优化前未压缩状态下 <code>libapp.so</code> 大小是 9.7MB</li><li>优化后未压缩状态下 <code>libapp.so</code> 大小是 8.6MB</li></ul><p>真正的减少来自 <code>libapp.so</code>，约 1.1MB。正如文档所言，<code>--split-debug-info</code> 可以减少代码大小。不过考虑到 APK 是压缩包，所以 <code>libapp.so</code> 的减小反映在 APK 包大小变化上并不明显。</p><h1 id="优化效果"><a href="#优化效果" class="headerlink" title="优化效果"></a>优化效果</h1><p>我们项目以 AAR 产物方式集成 Flutter。我从我们最新发布的 APK 中解压出 <code>libapp.so</code>，不作称为 <code>libapp-当前发布包.so</code>。</p><p><code>flutter build aot --release --target-platform android-arm</code> 编译结果为 <code>libapp-优化前.so</code></p><p><code>flutter build aot --release --target-platform android-arm</code> 加上 <code>--obfuscate</code> 和 <code>--split-debug-info</code> 的编译结果为 <code>libapp-优化后.so</code>。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/16/15948868220974.jpg" alt></p><p>可以看到前两个 so 文件大小接近，后一个 so 文件小了将近 0.9MB。(注意：这里的 so 是32位，不同于上一节中的64位，所以文件大小变化不同)。这里的 0.9MB(减小约11%) 并不太起眼，不过考虑到最小的 <code>libapp.so</code> 也有将近 3.7MB，所以其实还是很可观的。</p><table><thead><tr><th>文件</th><th>大小</th><th>备注</th></tr></thead><tbody><tr><td>最小的 <code>libapp.so</code></td><td>3.7MB</td><td>从 <code>flutter create</code> 创建的工程编译而来</td></tr><tr><td><code>libapp-当前发布包.so</code></td><td>8.3MB</td><td>从最新发布的APK解压而来</td></tr><tr><td><code>libapp-优化后.so</code></td><td>7.4MB</td><td>使用 <code>split-debug-info</code> 编译编译</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>官方 <a href="https://flutter.dev/docs/perf/app-size#reducing-app-size" target="_blank" rel="noopener">Measuring your app’s size - Flutter</a> 中提供了几种减小 Flutter 包大小的方法，可以作为参考</p><ul><li>Remove unused resources</li><li>Minimize resource imported from libraries</li><li>Support a limited number of screen densities</li><li>Compress PNG and JPEG files</li></ul><p>其他资料：</p><ul><li><a href="https://github.com/flutter/flutter/wiki/Obfuscating-Dart-Code" target="_blank" rel="noopener">Obfuscating-Dart-Code</a></li><li><a href="https://flutter.dev/docs/deployment/obfuscate" target="_blank" rel="noopener">Obfuscating Dart code - Flutter</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Flutter Overlay 用法简介</title>
      <link href="2020/07/15/flutter-overlay-usage/"/>
      <url>2020/07/15/flutter-overlay-usage/</url>
      
        <content type="html"><![CDATA[<p>Flutter Overlay 用法简介。</p><a id="more"></a><h1 id="Overlay-基本用法"><a href="#Overlay-基本用法" class="headerlink" title="Overlay 基本用法"></a>Overlay 基本用法</h1><p><code>Overlay</code> 实际上是一个 <code>Stack</code>，所以 <code>OverlayEntry</code> 的内容可以是 <code>Positioned</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> overlayEntry = OverlayEntry(builder: (context) =&gt; Positioned(...););</span><br><span class="line">Overlay.of(context).insert(overlayEntry);</span><br></pre></td></tr></table></figure><ul><li>显示 Overlay - 使用 <code>Overlay.of(context).insert()</code> 方法</li><li>隐藏 Overlay - 使用 <code>overlayEntry.remove()</code> 方法</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/overlaybasic.gif" alt="overlay-basic"></p><h1 id="Overlay-高级用法"><a href="#Overlay-高级用法" class="headerlink" title="Overlay 高级用法"></a>Overlay 高级用法</h1><h2 id="指定位置"><a href="#指定位置" class="headerlink" title="指定位置"></a>指定位置</h2><p>有时我们想指定 Overlay 的显示位置，实现方式如下：</p><ul><li>先使用 <code>BuildContext.findRenderObject()</code> 来找到当前 Widget 对应的 RenderObject</li><li>再使用 <code>RenderBox.localToGlobal()</code> 找到 Widget 在屏幕上的位置</li></ul><p>具体见 <code>_calcPos()</code> 方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyButton</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> PosCallback callback;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> _MyButton(&#123;Key key, <span class="keyword">this</span>.callback&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  __MyButtonState createState() =&gt; __MyButtonState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">__MyButtonState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">_MyButton</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; _calcPos() &#123;</span><br><span class="line">    RenderBox renderBox = context.findRenderObject();</span><br><span class="line">    <span class="keyword">var</span> size = renderBox.size;</span><br><span class="line">    <span class="keyword">var</span> offset = renderBox.localToGlobal(Offset.zero);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [offset.dx, offset.dy + size.height];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RaisedButton(</span><br><span class="line">      onPressed: () &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; list = _calcPos();</span><br><span class="line">        widget.callback(list[<span class="number">0</span>], list[<span class="number">1</span>]);</span><br><span class="line">      &#125;,</span><br><span class="line">      child: Text(<span class="string">'show overlay'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/overlaypos.gif" alt="overlay-pos"></p><h2 id="跟随滚动"><a href="#跟随滚动" class="headerlink" title="跟随滚动"></a>跟随滚动</h2><p>使用 <a href="https://api.flutter.dev/flutter/rendering/LayerLink-class.html" target="_blank" rel="noopener">LayerLink</a> 来让 Overlay 跟随指定的 Widget 来滚动。</p><ul><li>LayerLink 用于联系 <a href="https://api.flutter.dev/flutter/rendering/LeaderLayer-class.html" target="_blank" rel="noopener">LeaderLayer</a> 和 <a href="https://api.flutter.dev/flutter/rendering/FollowerLayer-class.html" target="_blank" rel="noopener">FollowerLayer</a></li><li>使用 <a href="https://api.flutter.dev/flutter/widgets/CompositedTransformTarget-class.html" target="_blank" rel="noopener">CompositedTransformTarget</a> 来创建 LeaderLayer</li><li>使用 <a href="https://api.flutter.dev/flutter/widgets/CompositedTransformFollower-class.html" target="_blank" rel="noopener">CompositedTransformFollower</a> 来创建 FollowLayer</li></ul><p>代码篇幅较长，这里就不贴上来了。完整代码见 <a href="https://gist.github.com/410063005/4034c395f3305feeb262482a96d4278e" target="_blank" rel="noopener">gist</a>。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/overlayscroll.gif" alt="overlay-scroll"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://medium.com/saugo360/https-medium-com-saugo360-flutter-using-overlay-to-display-floating-widgets-2e6d0e8decb9" target="_blank" rel="noopener">Flutter: Using Overlay to display floating widgets | by AbdulRahman AlHamali | SAUGO 360 | Medium</a></li><li><a href="https://api.flutter.dev/flutter/rendering/LayerLink-class.html" target="_blank" rel="noopener">LayerLink class - rendering library - Dart API</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter App 内存测试</title>
      <link href="2020/07/15/flutter-app-memory-test/"/>
      <url>2020/07/15/flutter-app-memory-test/</url>
      
        <content type="html"><![CDATA[<p>Flutter 应用内存测试数据。</p><a id="more"></a><h1 id="内存测试一-简单-UI"><a href="#内存测试一-简单-UI" class="headerlink" title="内存测试一 - 简单 UI"></a>内存测试一 - 简单 UI</h1><p>分别<strong>使用 Android 和 Flutter 实现最简单的界面</strong>。</p><ul><li>显示一个文本</li><li>显示一个图片</li></ul><p>使用 TextView 显示 “Hello World!” 的 Android Demo，布局如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Hello World!"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 Text Widget 显示 “Hello World!” 的 Flutter Demo，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Center(child: Text(<span class="string">'Hello World!'</span>)),</span><br></pre></td></tr></table></figure><p>显示图片的 Demo 非常类似，这里略过。</p><p>测试数据显示：<strong>Flutter 应用比原生应用占用更多内存，多出来的部分主要包括 Other、Code、Native、Graphics</strong>。(注意：Android Studio 中无法正常显示 Other 部分变化，<code>adb shell dumpsys meminfo</code> 及 Flutter DevTools 中可正常观察到)</p><p>以下是具体测试数据。</p><h2 id="数据一"><a href="#数据一" class="headerlink" title="数据一"></a>数据一</h2><p>机型及配置：华为 Nova 2，Android 8.0，分辨率480dp(3x)。</p><p>Android Text Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944369530168.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944406815956.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944408053563.jpg" alt></p><p>Android Image Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944370128933.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944407225565.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944408363481.jpg" alt></p><p>Flutter Text Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944384753825.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944408943099.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944440141932.jpg" alt></p><p>Flutter Image Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944385231943.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944409251967.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944440514423.jpg" alt></p><h2 id="数据二"><a href="#数据二" class="headerlink" title="数据二"></a>数据二</h2><p>机型及配置：小米 8，分辨率440dp(2.8x)</p><p>Android Text Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944403017361.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944441459158.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944443093212.jpg" alt></p><p>Android Image Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944404063442.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944441807084.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944443368308.jpg" alt></p><p>Flutter Text Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944399044259.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944442195175.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944443788400.jpg" alt></p><p>Flutter Image Demo<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944399984819.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944442627978.jpg" alt><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15944444195039.jpg" alt></p><h1 id="内存测试二-分配大对象"><a href="#内存测试二-分配大对象" class="headerlink" title="内存测试二 - 分配大对象"></a>内存测试二 - 分配大对象</h1><p>持续在 Dart 代码中分配对象。观察内存变化。</p><p>测试数据显示：<strong>从 Android 角度看，Dart Heap 中分配的对象归类为 “Private Other” 内存</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Uint8List&gt; _memList = <span class="built_in">List</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _addToMemList() &#123;</span><br><span class="line">    <span class="comment">// 点击一次, 分配 10MB 内存</span></span><br><span class="line">    _memList.add(_createData(<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15945451536123.jpg" alt="-w1428"></p><p>随着分配的 Dart 对象，Dart 内存和 Android 内存都在增加</p><ul><li>左图是 Dart 内存<ul><li>Dart Heap Capacity (绿线区域)一直在增长</li><li><font color="red">Dart Heap Used (浅蓝色区域)一直在增长</font></li><li>Dart External (蓝色区域)几乎不变</li></ul></li><li>右图是 Android 内存<ul><li>Total (绿线)一直在增长</li><li><font color="red">Other (紫线)一直在增长</font></li><li>其他几乎不变</li></ul></li></ul><h1 id="内存测试三-显示图片"><a href="#内存测试三-显示图片" class="headerlink" title="内存测试三 - 显示图片"></a>内存测试三 - 显示图片</h1><p>持续在 Dart 代码中<strong>加载并显示</strong>本地图片(1024x1024)。观察内存变化。</p><p>测试数据显示：<strong>Flutter 应用中图片在 Graphics 内存中分配</strong></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947280277523.jpg" alt="-w1666"></p><p>随着加载和显示的图片增多，Dart 内存和 Android 内存都在增加</p><ul><li>左图是 Dart 内存<ul><li>Dart Heap Capacity (绿线区域)一直在增长</li><li>Dart Heap Used (浅蓝色区域)几乎不变</li><li><font color="red">Dart External (蓝色区域)一直在增长</font></li></ul></li><li>右图是 Android 内存<ul><li>Total (绿线)一直在增长</li><li><font color="red">Graphics (橙色区域)波浪形增长</font></li><li>其他几乎不变</li></ul></li></ul><h1 id="内存测试四-预加载图片"><a href="#内存测试四-预加载图片" class="headerlink" title="内存测试四 - 预加载图片"></a>内存测试四 - 预加载图片</h1><p>持续在 Dart 代码中<strong>预加载但不显示</strong>本地图片(1024x1024)。观察内存变化。</p><p>测试数据显示：<strong>Flutter 应用中图片在 Graphics 内存中分配</strong></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947294740934.jpg" alt="-w1294"></p><p>随着预加载的图片增多，Dart 内存和 Android 内存都在增加</p><ul><li>左图是 Dart 内存<ul><li>Dart Heap Capacity (绿线区域)一直在增长</li><li>Dart Heap Used (浅蓝色区域)几乎不变</li><li><font color="red">Dart External (蓝色区域)一直在增长</font></li></ul></li><li>右图是 Android 内存<ul><li>Total (绿线)一直在增长</li><li><font color="red">Graphics (橙色区域)波浪形增长</font></li><li>其他几乎不变</li></ul></li></ul><h1 id="内存测试五-启动多个-Flutter-引擎"><a href="#内存测试五-启动多个-Flutter-引擎" class="headerlink" title="内存测试五 - 启动多个 Flutter 引擎"></a>内存测试五 - 启动多个 Flutter 引擎</h1><p>持续启动 Flutter 引擎，每次增加一个。观察内存变化。</p><p>测试数据显示：<strong>每开启一个 Flutter 引擎，Native 内存大约有5-6MB增长，Private Other 有10MB左右增长</strong></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947866240369.jpg" alt="-w1302"></p><p>随着 Flutter 引擎数量增多，Dart 内存和 Android 内存都在增加</p><ul><li>左图是 Dart 内存<ul><li><font color="red">Dart Heap Used (浅蓝色区域)几乎不变</font></li><li>Dart External (蓝色区域)一直在增长</li></ul></li><li>右图是 Android 内存<ul><li>Total (绿线)一直在增长</li><li><font color="red">Other (紫色区域)一直在快速增长</font></li><li><font color="red">Native (蓝色区域)一直在较快增长</font></li><li>Graphics (橙色区域)无增长</li></ul></li></ul><p>在 Android Studio 中测试结果如下：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947848408890.jpg" alt></p><p>随着 Flutter 引擎数量增多，</p><ul><li>Private Other 一直在增长 (注：注意：Android Studio 中无法正常显示 Other 部分变化，<code>adb shell dumpsys meminfo</code> 及 Flutter DevTools 中可正常观察到)</li><li>Native 内存(蓝色区域)一直在增长</li></ul><h1 id="测试结论"><a href="#测试结论" class="headerlink" title="测试结论"></a>测试结论</h1><ul><li>Flutter 应用比原生应用占用更多内存，多出来的部分主要包括 Other、Code、Native、Graphics <a href="https://developer.android.com/studio/profile/memory-profiler#how-counted" target="_blank" rel="noopener">内存分类</a> <a href="https://developer.android.com/studio/command-line/dumpsys#meminfo" target="_blank" rel="noopener">meminfo</a></li><li>从 Android 角度看，Dart Heap 属性 “Private Other” 内存。Dart 中创建对象会导致 Private Other 内存增长</li><li>Flutter 应用中图片在 Graphics 内存中分配 <a href="https://www.yuque.com/xytech/flutter/avmyht" target="_blank" rel="noopener">闲鱼技术 Android Flutter实践内存初探</a></li><li>每开启一个 Flutter 引擎，Native 内存大约有5-6MB增长，Private Other 有10MB左右增长</li></ul><p>为什么 Flutter 应用会比原生应用占用更多内存？官网给出的一些数据也许能解释部分原因。以下翻译自 <a href="https://flutter.dev/docs/development/add-to-app/performance#memory-and-latency" target="_blank" rel="noopener">Load sequence, performance, and memory - Flutter</a></p><blockquote><p>展示 Flutter UI 会有一定不可忽视的延迟。可以提前启动 Flutter 引擎来减少这个延迟。</p><p>集成 Flutter 到已有应用时要评估预加载 Flutter 引擎(即，加载 Flutter 库、启动 Dart VM、运行 isolate 入口程序)带来的内存开销及延迟。</p><p>在 2015 年的一款低端手机上，Flutter v1.10.3 release-AOT 模式下预热 <code>FlutterEngine</code> 开销如下：</p><ul><li><strong>Android</strong> 42 MB 和 1530 ms。其中有 330 ms 会阻塞主线程</li><li><strong>iOS</strong>  22 MB 和 860 ms。其中有 260 ms 会阻塞主线程</li></ul><p>内存方面，一个测试样本数据如下(根据使用场景会有所变化)</p><ul><li>~4 MB OS’s memory usage for creating pthreads.</li><li>~10 MB GPU driver memory.</li><li>~1 MB for Dart runtime-managed memory.</li><li>~5 MB for Dart-loaded font maps.</li></ul><p>延迟方面，一个测试样本数据如下(根据使用场景会有所变化)</p><ul><li>~20 ms to collect the Flutter assets from the application package.</li><li>~15 ms to dlopen the Flutter engine library.</li><li>~200 ms to create the Dart VM and load the AOT snapshot.</li><li>~200 ms to load Flutter-dependent fonts and assets.</li><li>~400 ms to run the entrypoint, create the first widget tree, and compile the needed GPU shader programs.</li></ul><p>预热 Flutter 引擎的时机应该足够晚，以减小内存占用；同时还要足够早，以避免 Flutter 引擎启动时间跟首帧延迟叠加在一起(否则会感觉启动慢，体验非常糟糕)</p><p>具体预热时机要根据应用的实际结构来决定。通常经验是在将显示 Flutter 页面的前一个页面中预热</p><p>假设引擎已经预热，关联 UI 时的首帧开销如下：</p><ul><li><strong>Android</strong> 320 ms 以及额外的 12 MB (跟屏幕的物理像素尺寸非常相关，physical pixel size)</li><li><strong>iOS</strong> 200 ms 以及额外的 16 MB (跟屏幕的物理像素尺寸非常相关，physical pixel size)</li></ul><p>内存方面，开销主要来自用于渲染的 graphical memory buffer (跟屏幕尺寸相关)</p><p>延迟方面，开销主要是等原生系统回调(提供 surface)以及编译 shader 程序(原文: compiling the remaining shader programs that are not pre-emptively predictable)的时间。这里的延迟仅在第一帧</p><p>Flutter UI 释放后，相关内存也会释放。这里的内存释放跟 <code>FlutterEngine</code> 中的 Flutter State 无关，除非 <code>FlutterEngine</code> 也释放了</p></blockquote><h1 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h1><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947301347638.jpg" alt></p><p>Flutter 应用内存可优化的点分别是：</p><ul><li>Private Others，Dart 代码分配的对象属于这一类。优化点是减少 Dart 代码中不必要的对象分配，尤其是大对象</li><li>Code - 用于处理代码和资源，如 dex 字节码，so 库和字体。优化点是减少 <code>libflutter.so</code> 和 <code>libapp.so</code> 大小</li><li>Graphics - 图形缓冲区队列向屏幕显示像素（包括 GL 表面、GL 纹理等等）所使用的内存。比较好入手的一个优化是减少 Dart 代码中图片占用的内存。另外可以考虑优化 Flutter UI 这一块(同样使用 skia，为什么 Android 原生 UI 占用的内存比 Flutter UI 少？)</li><li>Native - C 或 C++ 代码分配的对象的内存。优化点是减少 Flutter 引擎占用的内存，比如单引擎比多引擎使用更少的内存</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/15/15947874114688.jpg" alt="-w1261"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译) Flutter 原理</title>
      <link href="2020/07/11/how-flutter-works/"/>
      <url>2020/07/11/how-flutter-works/</url>
      
        <content type="html"><![CDATA[<p>Flutter 是如何工作的？<br><a id="more"></a></p><p>要点如下：</p><ul><li>Flutter 框架更像一个游戏引擎，而不是传统的应用框架</li><li>Flutter 应用由 Widget 构成，Widget 被渲染到 Skia canvas，最后发送到平台</li><li>Flutter 引擎在对应的平台 shell 中运行</li><li>Flutter UI 发生变化时会被构建和渲染到 Skia Canvas</li><li>Flutter 以 60fps 来更新 UI，并且使用 GPU 完成大部分工作</li></ul><p>原文翻译如下。</p><p>跟其他框架相比，Flutter 以一种全新的方式构建，它更像一个游戏引擎而不是传统应用框架。我想讲讲在大层面上 Flutter 是如何工作的，以及它如何实现高性能。从大的层面来讲，<strong>应用由 Widget 构成，Widget 被渲染到 Skia canvas，最后发送到平台。平台显示 canvas，并且按要求返回事件</strong>。</p><p><img src="/images/15944494180838.jpg" alt></p><p>应用在平台上以 AOT 直接运行 (Your app runs on the platform in natively, Ahead of Time complied.)</p><h1 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h1><p>Flutter 在平台上提供 <code>Shell</code>，用作 Dart VM 和宿主。Shell 是平台相关的，提供对平台原生 API 的访问支持并且建立平台相关的 canvas。</p><p><img src="/images/15944503631949.jpg" alt></p><p>Shell 还用于和 IMEs 和系统应用生命周期事件通信。</p><h1 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h1><p>引擎是平台之上的层，提供 Dart 运行时、Skia、Platform Channel 及其他内容。Flutter Wiki 中的<a href="https://github.com/flutter/engine/wiki#architecture-diagram" target="_blank" rel="noopener">架构图</a>中有更多细节。</p><p><img src="/images/15944505039484.jpg" alt></p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>Flutter 引擎跟应用开发者最相关。它包含你开发应用时需要交互的所有内容。</p><p><img src="/images/15944513053707.jpg" alt></p><p>Flutter 只需简单使用对应的风格就能保持跟 iOS 或 Android 原生一致风格。iOS 使用 Cupertino 风格，Android 使用 Material 风格。</p><p>Flutter 不使用原生组件，而是 Widget。Widget 是 Flutter 应用的组件。Flutter 将 UI 绘制到 Skia Canvas。</p><p>一旦 UI 完成渲染，就进入引擎环境。</p><h1 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h1><p>Flutter 更像游戏引擎，而不是应用框架。Flutter UI 发生变化时会被构建和渲染到 Skia Canvas。Flutter 以 60fps 来更新 UI，并且使用 GPU 完成大部分工作。(所以 Flutter UI 这么流畅)</p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>这里只是大体上讲了一下 Flutter 是如何工作的，实际上 Flutter 底层有许多细节。可以参考这些资料</p><p>代码库：</p><ul><li><a href="https://github.com/flutter/flutter" target="_blank" rel="noopener">Flutter Framework</a></li><li><a href="https://github.com/flutter/engine" target="_blank" rel="noopener">Flutter Engine</a></li></ul><p>技术文档：</p><ul><li><a href="https://docs.google.com/presentation/d/1cw7A4HbvM_Abv320rVgPVGiUP2msVs7tfGbkgdrTy0I/edit#slide=id.p" target="_blank" rel="noopener">Flutter System Architecture Diagrams</a></li><li><a href="https://flutter.io/technical-overview/" target="_blank" rel="noopener">Technical Overview</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart VM Service 简介</title>
      <link href="2020/07/07/dart-vm-service/"/>
      <url>2020/07/07/dart-vm-service/</url>
      
        <content type="html"><![CDATA[<p>Flutter 开发工具 DevTools 是不是有些神奇？移动端开发中用到的性能工具通常是原生应用，而 DevTools 却是基于浏览器的。为什么要基于浏览器开发，Dart VM Service Protocol 又是什么？简单了解一下。</p><a id="more"></a><p>Dart DevTools 提供 hot reload、UI 调试和内存分析等各种功能。</p><p><img src="/images/15941055868454.jpg" alt></p><h1 id="Dart-VM-Service-Protocol"><a href="#Dart-VM-Service-Protocol" class="headerlink" title="Dart VM Service Protocol"></a>Dart VM Service Protocol</h1><p>先来看看 Dart VM Service Protocol 是什么。</p><p><a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#rpcs-requests-and-responses" target="_blank" rel="noopener">Dart VM Service Protocol 3.36</a> 介绍如下：</p><blockquote><p>Service Protocol 协议用于跟运行中的 Dart VM 通信</p><p>使用 <code>--observe</code> 启动 Dart VM 后就能使用 Service Protocol。VM 会启动一个 webserver 并通过 WebSocket 为 protocol request 提供服务。也可发送 HTTP (非WebSocket)请求，但这种情况下无法访问 VM <em>event</em></p><p>Service Protocol 使用 <a href="http://www.jsonrpc.org/specification" target="_blank" rel="noopener">JSON-RPC 2.0</a> 来通信</p></blockquote><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>通过 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#getversion" target="_blank" rel="noopener">getVersion</a> 这个例子来看看 RPC 请求和响应。</p><p>RPC request 是一个发送到 server 的 JSON 对象。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>, <span class="comment">// jsonprc 属性可选</span></span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"getVersion"</span>, <span class="comment">//</span></span><br><span class="line">  <span class="attr">"params"</span>: &#123;&#125;, <span class="comment">// params 属性在 Dart 代码中以 named parameters 形式提供</span></span><br><span class="line">  <span class="attr">"id"</span>: <span class="string">"1"</span> <span class="comment">// id 属性可以是 string, number, null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RPC response 也是一个 JSON 对象。</p><p>这是一个成功的 RPC response：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"result"</span>: &#123; <span class="comment">// 请求成功时返回 result 属性</span></span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"Version"</span>, <span class="comment">// type 参数可用于判断准确的返回类型，它是 Response 类的子类</span></span><br><span class="line">    <span class="attr">"major"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"minor"</span>: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">"id"</span>: <span class="string">"1"</span> <span class="comment">// id 属性跟对应请求中的 id 匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个失败的 RPC response：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"error"</span>: &#123; <span class="comment">// 请求失败时返回 error 属性，它包括 code, message 和 data</span></span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">103</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"Stream already subscribed"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">      <span class="attr">"details"</span>: <span class="string">"The stream 'GC' is already subscribed"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">"id"</span>: <span class="string">"2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="error codes">JSON-RPC 规范</a>的基础上，Service Protocol 定义了一些额外的错误码。具体错误见 Service Protocol 文档，这里不展开。</p><h2 id="Event-和-Binary-Event"><a href="#Event-和-Binary-Event" class="headerlink" title="Event 和 Binary Event"></a>Event 和 Binary Event</h2><ul><li>通过使用 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#streamlisten" target="_blank" rel="noopener">streamListen</a> 和 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#streamcancel" target="_blank" rel="noopener">streamCancel</a> RPC，客户端可以收到 VM 中特定 stream 上的事件通通知</li><li>每个 stream 跟一个 <em>stream id</em> 关联</li><li>每个 stream 跟某种类型的事件关联。比如 <em>Isolate</em> stream 提供 isolate 相关的创建和销毁等事件</li><li>客户端通过 WebSocket 异步接收 stream event</li><li>某些事件跟二进制数据关联，通过 WebSocket binary frame 而不是 text frame 发送这些事件</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"json-rpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"streamNotify"</span>,</span><br><span class="line">  <span class="attr">"params"</span>: &#123; <span class="comment">// 参数中包括 streamId 和 event 属性</span></span><br><span class="line">    <span class="attr">"streamId"</span>: <span class="string">"Isolate"</span>,</span><br><span class="line">    <span class="attr">"event"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Event"</span>,</span><br><span class="line">      <span class="attr">"kind"</span>: <span class="string">"IsolateExit"</span>,</span><br><span class="line">      <span class="attr">"isolate"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"@Isolate"</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"isolates/33"</span>,</span><br><span class="line">        <span class="attr">"number"</span>: <span class="string">"51048743613"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"worker-isolate"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>Service Protocol 中的每个响应或事件均有 <code>type</code> 属性，它是 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#response" target="_blank" rel="noopener">Response</a> 子类。客户端可以通过 <code>type</code> 属性判断每种响应或事件的准确类型。</p><ul><li>以 <code>@</code> 开头的 type 表示当前响应是一个 <code>reference</code></li><li>不以 <code>@</code> 开头的 type 表示当前响应是一个 <code>object</code></li></ul><p><code>reference</code> 可提供的信息是 <code>object</code> 的子集</p><h1 id="Dart-VM-Service-Protocol-Extension"><a href="#Dart-VM-Service-Protocol-Extension" class="headerlink" title="Dart VM Service Protocol Extension"></a>Dart VM Service Protocol Extension</h1><p><a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service_extension.md" target="_blank" rel="noopener">Dart VM Service Protocol Extension</a> 与 VM 通信的方式跟 Service Protocol 类似跟类似，但它们并不是核心 <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md" target="_blank" rel="noopener">Dart VM Service Protocol</a> 的一部分，仅允许通过某些核心库访问。</p><p>通过添加前缀名来调用对应的 RPC 接口，类似 “ext.dart.libraryName”。比如，调用 <code>ext.dart.io.getSocketProfile</code> 来执行 dart:io 暴露的 <code>getSocketProfile</code> RPC 接口。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单了解 Dart VM Service Protocol 和 Dart VM Service Protocol Extension 后，我们有以下认识：</p><ul><li>Service Protocol 和 Service Protocol Extension 是一套 RPC-JSON 协议</li><li>Service Protocol 兼容性好，可以很容易地集成到现有 IDE</li><li>VM 会启动一个 webserver 并通过 WebSocket 为客户端提供服务</li></ul><p>为什么要基于浏览器来开发 DevTools？有以下几个原因</p><ul><li>浏览器天生支持 WebSocket，所以基于浏览器开发 DevTools 是水到渠成</li><li>基于浏览器开发 DevTools，可兼容多平台</li><li>当前的 DevTools 是使用 Flutter 框架开发的 (没错，Flutter。以前是纯 Dart 开发)，部署成 Web 应用很方便</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#rpcs-requests-and-responses" target="_blank" rel="noopener">sdk/service.md at master · dart-lang/sdk</a></li><li><a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service_extension.md" target="_blank" rel="noopener">sdk/service_extension.md at master · dart-lang/sdk</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652058622&amp;idx=1&amp;sn=3551e237325a72a99ac71ec8c8747a43&amp;chksm=808c93bbb7fb1aad62acae899e59e36596d719c1194a912b26cccf565641c5a2683e675b691e&amp;mpshare=1&amp;scene=1&amp;srcid=0707V7mgrCqByikjM5WbdfpD&amp;sharer_sharetime=1594105478505&amp;sharer_shareid=b5535657e3516bd6d7252ce5f5ed09f4#rd" target="_blank" rel="noopener">​我们用 Flutter 写了一套全新的 Flutter 开发者工具</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 引擎崩溃分析方法简介</title>
      <link href="2020/07/04/flutter-engine-crash-track/"/>
      <url>2020/07/04/flutter-engine-crash-track/</url>
      
        <content type="html"><![CDATA[<p>Android 项目信息 Flutter 后上线，偶尔会遇到一些 Flutter 引擎的崩溃。简单记录下如何还原引擎崩溃日志，方便在源码中定位问题。</p><a id="more"></a><h1 id="Flutter-Engine-Crash-堆栈还原"><a href="#Flutter-Engine-Crash-堆栈还原" class="headerlink" title="Flutter Engine Crash 堆栈还原"></a>Flutter Engine Crash 堆栈还原</h1><p>首先，在 <code>bin/internal/engine.version</code> 找到 flutter engine revision</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b851c718295a896918dc93cb1ff14f2f895a1b90</span><br></pre></td></tr></table></figure><p>第二步，下载带符号表的 <code>libflutter.so</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://console.cloud.google.com/storage/browser/flutter_infra/flutter/b851c718295a896918dc93cb1ff14f2f895a1b90</span><br></pre></td></tr></table></figure><p>第三步，利用 <code>ndk-stack</code> 还原堆栈信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/path/to/android-ndk-r16b/ndk-stack -sym /path/to/symbols/armeabi-v7a -dump /path/to/stacktrace.txt</span><br></pre></td></tr></table></figure><p>如果是将 crash 上报到 bugly 平台，则不必使用 <code>ndk-stack</code>，直接在 bugly 上配置符号表即可。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/04/15938295883428.jpg" alt></p><p>配置成功后就能在 bugly 平台上看到 native crash 堆栈信息。</p><p>原始堆栈信息<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/04/15938297243231.jpg" alt></p><p>还原后的堆栈信息<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/07/04/15938297398367.jpg" alt></p><p>拿到还原后的堆栈信息，就可以对着源码分析问题了。</p><h1 id="一个疑问"><a href="#一个疑问" class="headerlink" title="一个疑问"></a>一个疑问</h1><p>官方提到每个 <code>libflutter.so</code> 文件中有一个 build id，native crash 堆栈中见到的 <code>BuildId</code> 要跟 <code>libflutter.so</code> 的匹配，否则没法还原 native crash 堆栈信息。原文如下：</p><blockquote><p>The build system sets a build id for each libflutter.so file. In the tombstones, you would see the ID like so:</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; #00 pc 000000000062d6e0  /data/app/com.app-tARy3eLH2Y-QN8J0d0WFog==/lib/arm64/libflutter.so!libflutter.so (offset 0x270000) (BuildId: 34ad5bdf0830d77a)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>This equals to a build id of 34ad5bdf0830d77a. The libflutter.so debug files downloaded as shown above could be verified using the file command:</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; % file ~/Downloads/libflutter.so</span><br><span class="line">&gt; /Users/user/Downloads/libflutter.so: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, BuildID[xxHash]=34ad5bdf0830d77a, with debug_info, not stripped</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Ensure the build IDs match, else you will not be able to symbolicate.</p></blockquote><p>不过我往 bugly 上传了一个非严格匹配的符号表(上报 crash 的 app 使用的是自己编译的 <code>libflutter.so</code>，符号表是官方提供的 <code>libflutter.so</code>)，也能还原出来。让人很是疑惑。</p><p>观察了下，bugly 上看到的 native crash 日志中并没有找到类似 <code>(BuildId: 34ad5bdf0830d77a)</code> 这样的信息。<em>推测</em>由此导致匹配变得不严格，所以也能还原出来。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>某个 native crash 还原后得到如下堆栈信息。</p><p><img src="/images/15938315565456.jpg" alt></p><p>首先看到的是 <code>message_loop_impl.cc</code> 中的 <code>MessageLoopImpl::RunExpiredTasksNow</code>。这个方法会立即执行任务队列中的已过期任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageLoopImpl::FlushTasks</span><span class="params">(FlushType type)</span> </span>&#123;</span><br><span class="line">  TRACE_EVENT0(<span class="string">"fml"</span>, <span class="string">"MessageLoop::FlushTasks"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;fml::closure&gt; invocations;</span><br><span class="line"></span><br><span class="line">  task_queue_-&gt;GetTasksToRunNow(queue_id_, type, invocations);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; invocation : invocations) &#123;</span><br><span class="line">    invocation();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;fml::closure&gt; observers =</span><br><span class="line">        task_queue_-&gt;GetObserversToNotify(queue_id_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; observer : observers) &#123;</span><br><span class="line">      observer();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageLoopImpl::RunExpiredTasksNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FlushTasks(FlushType::kAll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看到的是 <code>platform_view_android_jni.cc</code> 中的 <code>FlutterViewUpdateSemantics</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FlutterViewUpdateSemantics</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">                                jobject buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                jobjectArray strings)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用 g_update_semantics_method (Java 层方法)</span></span><br><span class="line">  env-&gt;CallVoidMethod(obj, g_update_semantics_method, buffer, strings);</span><br><span class="line">  <span class="comment">// 检查 Java 代码是否发生异常，有异常则写入 fml 日志中</span></span><br><span class="line">  FML_CHECK(CheckException(env));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RegisterApi</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// g_update_semantics_method 对应的是 </span></span><br><span class="line">  <span class="comment">// Java 层中的 FlutterJNI.updateSemantics() 方法</span></span><br><span class="line">  g_update_semantics_method =</span><br><span class="line">      env-&gt;GetMethodID(g_flutter_jni_class-&gt;obj(), <span class="string">"updateSemantics"</span>,</span><br><span class="line">                       <span class="string">"(Ljava/nio/ByteBuffer;[Ljava/lang/String;)V"</span>);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 Java 代码是否发生异常</span></span><br><span class="line"><span class="comment">// 发生异常时返回 false，否则返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckException</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (env-&gt;ExceptionCheck() == JNI_FALSE)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  jthrowable exception = env-&gt;ExceptionOccurred();</span><br><span class="line">  env-&gt;ExceptionClear();</span><br><span class="line">  FML_LOG(ERROR) &lt;&lt; fml::jni::GetJavaExceptionInfo(env, exception);</span><br><span class="line">  env-&gt;DeleteLocalRef(exception);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后看到的是 <code>logging.cc</code> 第92行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">LogMessage::~LogMessage() &#123;</span><br><span class="line">  stream_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_ANDROID)</span></span><br><span class="line">  android_LogPriority priority =</span><br><span class="line">      (severity_ &lt; <span class="number">0</span>) ? ANDROID_LOG_VERBOSE : ANDROID_LOG_UNKNOWN;</span><br><span class="line">  <span class="keyword">switch</span> (severity_) &#123;</span><br><span class="line">    <span class="keyword">case</span> LOG_INFO:</span><br><span class="line">      priority = ANDROID_LOG_INFO;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LOG_WARNING:</span><br><span class="line">      priority = ANDROID_LOG_WARN;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LOG_ERROR:</span><br><span class="line">      priority = ANDROID_LOG_ERROR;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LOG_FATAL:</span><br><span class="line">      priority = ANDROID_LOG_FATAL;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  __android_log_write(priority, <span class="string">"flutter"</span>, stream_.str().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(OS_IOS)</span></span><br><span class="line">  syslog(LOG_ALERT, <span class="string">"%s"</span>, stream_.str().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; stream_.str();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span>.flush();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (severity_ &gt;= LOG_FATAL) &#123;</span><br><span class="line">    <span class="comment">// 最终的 crash 由这里产生</span></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初看起来可能会有点不明白 crash 如何产生，梳理一下就渐渐明了：</p><ul><li>调用 <code>RunExpiredTasksNow</code> 立即执行队伍中的过期任务</li><li>过期任务中的某一个任务调用了 <code>FlutterViewUpdateSemantics()</code> (C++层)</li><li><code>FlutterViewUpdateSemantics()</code> 调用 <code>FlutterJNI.updateSemantics()</code> (Java层)</li><li><code>FlutterViewUpdateSemantics()</code> 调用 <code>CheckException()</code> 检查 Java 代码执行后是否产生异常</li><li><code>FlutterViewUpdateSemantics()</code> 调用 <code>FML_CHECK()</code> 记录错误日志 (如有 Java 异常)</li></ul><p>所以我们可以把怀疑目标锁定到 <code>FlutterJNI.updateSemantics()</code> 方法。剩下的工作就是进入 Java 层分析该方法的出错原因了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Keep</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterJNI</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Invoked by native to send semantics tree updates from Flutter to Android.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The &#123;<span class="doctag">@code</span> buffer&#125; and &#123;<span class="doctag">@code</span> strings&#125; form a communication protocol that is implemented here:</span></span><br><span class="line"><span class="comment">   * https://github.com/flutter/engine/blob/master/shell/platform/android/platform_view_android.cc#L207</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateSemantics</span><span class="params">(@NonNull ByteBuffer buffer, @NonNull String[] strings)</span> </span>&#123;</span><br><span class="line">    ensureRunningOnMainThread();</span><br><span class="line">    <span class="keyword">if</span> (accessibilityDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">      accessibilityDelegate.updateSemantics(buffer, strings);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO(mattcarroll): log dropped messages when in debug mode (https://github.com/flutter/flutter/issues/25391)</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://fucknmb.com/2019/10/20/%E8%8E%B7%E5%8F%96%E5%B9%B6%E8%BF%98%E5%8E%9FFlutter-Engine-Crash%E5%A0%86%E6%A0%88/" target="_blank" rel="noopener">获取并还原 Flutter Engine Crash 堆栈 | 区长</a></li><li><a href="https://github.com/flutter/flutter/wiki/Crashes" target="_blank" rel="noopener">Crashes · flutter/flutter Wiki</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mockjs 入门</title>
      <link href="2020/07/02/mockjs-basic/"/>
      <url>2020/07/02/mockjs-basic/</url>
      
        <content type="html"><![CDATA[<p>感觉 mockjs 真是个好东西。简单了解下用法。<br><a id="more"></a></p><h1 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h1><p>先直接上文档 <a href="http://mockjs.com/examples.html#Image" target="_blank" rel="noopener">Mock.js</a>。文档中列出了 mockjs 可以模拟的数据类型，包括：</p><ul><li>string</li><li>number</li><li>bool</li><li>array</li><li>object</li><li>guid</li><li>id</li><li>title</li><li>paragraph</li><li>image</li><li>address</li><li>date</li><li>time</li><li>url</li><li>email</li><li>ip</li><li>regexp</li></ul><p>不要小看这个文档，<strong>你可以打开控制台，随意地试验这些方法。</strong></p><p><img src="/images/15936783153589.jpg" alt="-w795"></p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>这里列举几个我用到的模拟数据。</p><p>模拟 title：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Mock.mock(&#123;<span class="string">'title'</span>: <span class="string">'@title(1)'</span>&#125;)</span><br><span class="line"><span class="comment">// &#123;title: "Qoqhdl"&#125;</span></span><br><span class="line">&gt; Mock.mock(&#123;<span class="string">'title'</span>: <span class="string">'@csentence(6)'</span>&#125;)</span><br><span class="line"><span class="comment">// &#123;title: "容约声量局有。"&#125;</span></span><br></pre></td></tr></table></figure><p>模拟图片：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Mock.mock(&#123;<span class="string">'head'</span>: <span class="string">'@image()'</span>&#125;)</span><br><span class="line"><span class="comment">// &#123;head: "http://dummyimage.com/234x60"&#125;</span></span><br></pre></td></tr></table></figure><p>模拟图片打开之后的效果如下：</p><p><img src="/images/15936788801014.jpg" alt="-w938"></p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>mockjs 的语法还是比较简单易懂的，感觉不必花时间专门研究。不过不妨找一批较全的示例，实在不记得怎么写时可以照着示例来写。这里直接贴上一个示例，它来自<a href="https://github.com/ToNiQian/mockjs" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Mock</span></span><br><span class="line"><span class="keyword">let</span> Mock = <span class="built_in">require</span>(<span class="string">'mockjs'</span>);</span><br><span class="line">Mock.mock(<span class="string">'http://1.json'</span>,<span class="string">'get'</span>,&#123;</span><br><span class="line">    <span class="comment">// 属性 list 的值是一个数组，其中含有 1 到 3 个元素</span></span><br><span class="line">    <span class="string">'list|1-3'</span>: [&#123;</span><br><span class="line">        <span class="comment">// 属性 sid 是一个自增数，起始值为 1，每次增 1</span></span><br><span class="line">        <span class="string">'sid|+1'</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="comment">// 属性 userId 是一个5位的随机码</span></span><br><span class="line">        <span class="string">'userId|5'</span>: <span class="string">''</span>,</span><br><span class="line">        <span class="comment">// 属性 sex 是一个bool值</span></span><br><span class="line">        <span class="string">"sex|1-2"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 属性 city对象 是对象值中2-4个的值</span></span><br><span class="line">        <span class="string">"city|2-4"</span>: &#123;</span><br><span class="line">            <span class="string">"110000"</span>: <span class="string">"北京市"</span>,</span><br><span class="line">            <span class="string">"120000"</span>: <span class="string">"天津市"</span>,</span><br><span class="line">            <span class="string">"130000"</span>: <span class="string">"河北省"</span>,</span><br><span class="line">            <span class="string">"140000"</span>: <span class="string">"山西省"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//属性 grade 是数组当中的一个值</span></span><br><span class="line">        <span class="string">"grade|1"</span>: [</span><br><span class="line">            <span class="string">"1年级"</span>,</span><br><span class="line">            <span class="string">"2年级"</span>,</span><br><span class="line">            <span class="string">"3年级"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">//属性 guid 是唯一机器码</span></span><br><span class="line">        <span class="string">'guid'</span>: <span class="string">'@guid'</span>,</span><br><span class="line">        <span class="comment">//属性 id 是随机id</span></span><br><span class="line">        <span class="string">'id'</span>: <span class="string">'@id'</span>,</span><br><span class="line">        <span class="comment">//属性 title 是一个随机长度的标题</span></span><br><span class="line">        <span class="string">'title'</span>: <span class="string">'@title()'</span>,</span><br><span class="line">        <span class="comment">//属性 paragraph 是一个随机长度的段落</span></span><br><span class="line">        <span class="string">'paragraph'</span>: <span class="string">'@cparagraph'</span>,</span><br><span class="line">        <span class="comment">//属性 image 是一个随机图片 参数分别为size, background, text</span></span><br><span class="line">        <span class="string">'image'</span>: <span class="string">"@image('200x100', '#4A7BF7', 'Hello')"</span>,</span><br><span class="line">        <span class="comment">//属性 address 是一个随机地址</span></span><br><span class="line">        <span class="string">'address'</span>: <span class="string">'@county(true)'</span>,</span><br><span class="line">        <span class="comment">//属性 date 是一个yyyy-MM-dd 的随机日期</span></span><br><span class="line">        <span class="string">'date'</span>: <span class="string">'@date("yyyy-MM-dd")'</span>,</span><br><span class="line">        <span class="comment">//属性 time 是一个 size, background, text 的随机时间</span></span><br><span class="line">        <span class="string">'time'</span>: <span class="string">'@time("HH:mm:ss")'</span>,</span><br><span class="line">        <span class="comment">//属性 url 是一个随机的url</span></span><br><span class="line">        <span class="string">'url'</span>: <span class="string">'@url'</span>,</span><br><span class="line">        <span class="comment">//属性 email 是一个随机email</span></span><br><span class="line">        <span class="string">'email'</span>: <span class="string">'@email'</span>,</span><br><span class="line">        <span class="comment">//属性 ip 是一个随机ip</span></span><br><span class="line">        <span class="string">'ip'</span>: <span class="string">'@ip'</span>,</span><br><span class="line">        <span class="comment">//属性 regexp 是一个正则表达式匹配到的值 如aA1</span></span><br><span class="line">        <span class="string">'regexp'</span>: <span class="regexp">/[a-z][A-Z][0-9]/</span>,</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="其他模拟方式"><a href="#其他模拟方式" class="headerlink" title="其他模拟方式"></a>其他模拟方式</h1><p>以下是另外两个 mock 库，看起来更为强大。</p><ul><li><a href="https://github.com/APIJSON/APIJSON" target="_blank" rel="noopener">APIJSON/APIJSON: 🏆码云最有价值开源项目 🚀后端接口和文档自动化，前端(客户端) 定制返回 JSON 的数据和结构！🏆Gitee Most Valuable Project 🚀A JSON Transmission Protocol and an ORM Library for automatically providing APIs and Docs.</a></li><li><a href="https://github.com/chinesedfan/parrot-mocker-web/blob/master/README-zh.md" target="_blank" rel="noopener">parrot-mocker-web/README-zh.md at master · chinesedfan/parrot-mocker-web</a></li></ul><p><a href="https://segmentfault.com/a/1190000011230904" target="_blank" rel="noopener">AntDesign结合mockjs随机生成图片</a> 提供了另外一种思路：上传一批图片到云端(保证名字有规律)，再使用 mockjs 来拿到图片地址，从而实现在模拟自定义图片。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>mockjs 本身并不是特别有用，不过它结合 vue-admin-template 中的 mock-server，可以直接模拟线上接口，方便在后台尚未提供接口的情况下开始前端页面开发。这一点在某些情况下特别有用，如果事先后台能提供接口协议，保证模拟接口跟实际接口基本一致，生产力应该能大大提高。</p><p>vue-admin-template 中 mock-server 的用法见<a href="https://www.sunmoonblog.com/2020/07/01/vue-mockserver-watch-not-working/">前一篇</a>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">nuysoft/Mock: A simulation data generator</a></li><li><a href="http://mockjs.com/examples.html#Image" target="_blank" rel="noopener">Mock.js</a></li><li><a href="https://github.com/ToNiQian/mockjs" target="_blank" rel="noopener">ToNiQian/mockjs: 一个webpack 搭建的 mock 案例演示</a></li><li><a href="https://juejin.im/post/599c1bfaf265da248d0cc6b6" target="_blank" rel="noopener">Mockjs,再也不用追着后端小伙伴要接口了 - 掘金</a></li><li><a href="https://juejin.im/post/5ce2a960e51d455a2f2201c3" target="_blank" rel="noopener">vue-vue项目中mock.js的使用 - 掘金</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-admin-template 中 mock-server 的用法</title>
      <link href="2020/07/01/vue-mockserver-watch-not-working/"/>
      <url>2020/07/01/vue-mockserver-watch-not-working/</url>
      
        <content type="html"><![CDATA[<p>简单记录一下 vue-admin-template 中 mock-server 的用法。<br><a id="more"></a></p><p>最近刚接触一个 vue 项目。发现该项目是基于 vue-admin-template 的，但并没有很好地利用 vue-admin-template 的 <a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/mock-api.html" target="_blank" rel="noopener">Mock Data</a> 功能。这个功能正好能解决我目前的痛点：后台接口预计很久之后才能给到，而缺少接口的情况下前端页面中很多边边角角的工作并不好处理。</p><p>所以我了解了下如何使用在 vue-admin-template 中模拟数据。</p><p>vue-admin-template 提供两种模拟方式：</p><ul><li>本地模拟 - 这是使用 <a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">mockjs</a> 进行纯前端模拟。其原理是拦截了所有的请求并代理到本地，然后进行数据模拟。大部分情况下够用，但有几个问题：一是调试工具中看不到网络数据；二是s可能影响依赖 <code>XMLHttpRequest</code> 的库</li><li>线上模拟 - 本地启动一个 mock-server 来模拟数据，其模拟数据仍然来自 <a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">mockjs</a></li></ul><p>我们重点看线上模拟这种方式。</p><h1 id="配置和用法"><a href="#配置和用法" class="headerlink" title="配置和用法"></a>配置和用法</h1><p>先安装 <code>mockjs</code> 和 <code>chokidar</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install mockjs</span><br><span class="line">npm install chokidar</span><br></pre></td></tr></table></figure><p><a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/mock-api.html#%E7%A7%BB%E9%99%A4" target="_blank" rel="noopener">官方 Wiki</a> 提到的配置方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">  // change xxx-api/login =&gt; mock/login</span><br><span class="line">  // detail: https://cli.vuejs.org/config/#devserver-proxy</span><br><span class="line">  [process.env.VUE_APP_BASE_API]: &#123;</span><br><span class="line">    target: `http://localhost:$&#123;port&#125;/mock`,</span><br><span class="line">    changeOrigin: true,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      [&apos;^&apos; + process.env.VUE_APP_BASE_API]: &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">after: require(&apos;./mock/mock-server.js&apos;)</span><br></pre></td></tr></table></figure><p>但这个文档较旧，跟当前<a href="https://github.com/PanJiaChen/vue-admin-template/blob/permission-control/vue.config.js" target="_blank" rel="noopener">最新源码</a> 中的配置有较大差异。源码的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  port: port,</span><br><span class="line">  open: true,</span><br><span class="line">  overlay: &#123;</span><br><span class="line">    warnings: false,</span><br><span class="line">    errors: true</span><br><span class="line">  &#125;,</span><br><span class="line">  before: require(&apos;./mock/mock-server.js&apos;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>注意<strong>之前的 <code>after</code> 变成了 <code>before</code>，并且不再需要为 devServer 配置 proxy 了</strong>。 </p><p><img src="/images/15936059512268.jpg" alt></p><p>之后就可以在 <code>mock</code> 目录下写模拟数据了。 </p><p><img src="/images/15936061733008.jpg" alt></p><p><code>mock</code> 目录下各个文件的作用如下：</p><ul><li><code>mock-server.js</code> - mock-server 的源码</li><li><code>index.js</code> - 引入用到的模拟数据文件</li><li>其他 js 文件 - 模拟数据文件</li></ul><p><code>mock</code> 目录下各个文件的依赖关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mock-server.js</span><br><span class="line"> -&gt; index.js</span><br><span class="line">  -&gt; 其他 js 文件</span><br></pre></td></tr></table></figure><p>来看一个实例。</p><p>第一步，在 <code>register.js</code> 文件中定义一条模拟数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  &#123;</span><br><span class="line">    url: <span class="string">'/cm/reg/sendcode'</span>,</span><br><span class="line">    type: <span class="string">'post'</span>,</span><br><span class="line">    response: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> items = data.items</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        r: <span class="number">0</span>,</span><br><span class="line">        msg: <span class="string">'hello22'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>第二步，在 <code>index.js</code> 文件引入 <code>register.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> register <span class="keyword">from</span> <span class="string">'./register'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mocks = [</span><br><span class="line">  ...user,</span><br><span class="line">  ...table,</span><br><span class="line">  ...register</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>第三步，在 vue 文件中请求上面定义的模拟数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">post(&#123;</span><br><span class="line">  url: &apos;/cm/reg/sendcode&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意这里的 <code>post()</code> 方法用到一个 <code>axios</code> 实例，该 <code>axios</code> 实例的 baseUrl 为 <code>https://localhost/dev-api</code>。所以模拟请求的目标地址为 <code>https://localhost/dev-api/cm/reg/sendcode</code>。如下图，</p><p><img src="/images/15936068577258.jpg" alt="-w434"></p><p><img src="/images/15936068933224.jpg" alt="-w428"></p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>mock-server 有一个很赞的功能，每次修改 <code>mock</code> 目录下文件后，mock-server 会执行 hot reload，重新加载最新的数据。如下图，注意可以看到 “Mock Server hot reload success!”</p><p><img src="/images/15936071064085.jpg" alt></p><p>但我遇到一个小坑，无论如何修改 <code>mock</code> 目录下的文件都不会出现 hot reload。</p><p>反复检查后发现，我目前开发的这个 vue 项目虽然是基于 vue-admin-template 的，但是将原始工程中的部分源文件路径调整了。其中一个调整是将 <code>mock</code> 调整成 <code>src/mock</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockDir = path.join(process.cwd(), <span class="string">'mock'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// watch files, hot reload mock server</span></span><br><span class="line">  chokidar.watch(mockDir, &#123;</span><br><span class="line">    ignored: <span class="regexp">/mock-server/</span>,</span><br><span class="line">    ignoreInitial: <span class="literal">true</span></span><br><span class="line">  &#125;).on(<span class="string">'all'</span>, (event, path) =&gt; &#123; ... &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但 mock-server 监听的是 cwd 中的 <code>mock</code> 目录，所以修改 <code>mock</code> 目录中的模拟数据文件后，无法 hot reload。解决办法很简单，调整一下路径，改成监听 cwd 中的 <code>src/mock</code> 目录即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockDir = path.join(process.cwd(), <span class="string">'src/mock'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// watch files, hot reload mock server</span></span><br><span class="line">  chokidar.watch(mockDir, &#123;</span><br><span class="line">    ignored: <span class="regexp">/mock-server/</span>,</span><br><span class="line">    ignoreInitial: <span class="literal">true</span></span><br><span class="line">  &#125;).on(<span class="string">'all'</span>, (event, path) =&gt; &#123; ... &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他可能遇到的问题见 <a href="https://github.com/PanJiaChen/vue-element-admin/issues?page=2&amp;q=mock+server" target="_blank" rel="noopener">issues</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/mock-api.html" target="_blank" rel="noopener">Mock Data</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vant Toast 无法显示的问题</title>
      <link href="2020/07/01/vue-toast-not-show/"/>
      <url>2020/07/01/vue-toast-not-show/</url>
      
        <content type="html"><![CDATA[<p>使用 Vant Toast 时发现有些场景下无法显示。简单记录一下问题原因和解决方法。</p><a id="more"></a><h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>问题是这样的：界面上有一个注册对话框，当检查到用户输入有误使用 Vant Toast 弹出错误提示信息。比如，当用户没有输入手机号时，提示手机号为不能为空。</p><p><img src="/images/15935700432089.jpg" alt="-w371"></p><p>弹出错误提示 Toast 的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toast.fail(<span class="string">'手机号不能为空'</span>)</span><br></pre></td></tr></table></figure><p>但发现 Toast 始终无法显示。</p><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>检查样式后发现对话框的 <code>z-index</code> 过大。这里看到的是 9999</p><p><img src="/images/15935702844010.jpg" alt="-w1049"></p><p>Toast 实际已经弹出，但是它的 <code>z-index</code> 小于对话框的 <code>z-index</code>，导致 Toast 被对话框挡住，所以无法显示。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>解决办法很简单。</p><p>首先，在 vue 文件里写一个简单的 <code>toast</code> 样式，指定其 <code>z-index</code> 为 10000 (确保比对话框的大就行)。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- app.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.toast &#123;</span><br><span class="line">z-index: 10000 !important;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，弹出 Toast 时指定相应的样式即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toast.fail(&#123;<span class="attr">message</span>: <span class="string">'手机号不能为空'</span>, <span class="attr">className</span>: <span class="string">'toast'</span>&#125;)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.w3schools.com/cssref/pr_pos_z-index.asp" target="_blank" rel="noopener">CSS z-index property</a></li><li><a href="https://github.com/youzan/vant/issues/3145" target="_blank" rel="noopener">如果Toast先弹出过，因为z-indx计算，会被后使用的popup组件遮住，如果在popup里面需要使用Toast的话，就会被遮住了，这该如何解决？ · Issue #3145 · youzan/vant</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction to Dart VM</title>
      <link href="2020/06/30/dartvm/"/>
      <url>2020/06/30/dartvm/</url>
      
        <content type="html"><![CDATA[<p>翻译自 <a href="https://mrale.ph/dartvm/" target="_blank" rel="noopener">Dart VM</a>，非常详细地介绍了 Dart 代码运行机制。<br><a id="more"></a><br>Dart VM 是一个用于原生地执行 Dart 代码的组件集合。它主要包含如下部分：</p><ul><li>运行时系统<ul><li>对象模型</li><li>GC</li><li>Snapshot</li></ul></li><li>核心库</li><li>通过 <em>service protocol</em> 访问的 Development Experience 组件<ul><li>调试</li><li>分析</li><li>热加载</li></ul></li><li>Just-in-Time (JIT) 和 Ahead-of-Time (AOT) 编译流水线</li><li>解释器</li><li>ARM 模拟器</li></ul><p>Dart VM 这个名字是历史遗留的。在某种意义上 Dart VM 能为上层编程语言提供执行环境，但这个名字并不意味着 Dart VM 中 Dart 代码总是解释执行或 JTI 编译的。比如，可以使用 Dart VM AOT 流水线将 Dart 代码编译成机器码，然后在精简版本的 Dart VM 中执行，称之为 <em>precompiled runtime</em>，它既不包含任何编译器组件，也不能动态加载 Dart 源码。</p><h1 id="Dart-VM-是如何运行代码的？"><a href="#Dart-VM-是如何运行代码的？" class="headerlink" title="Dart VM 是如何运行代码的？"></a>Dart VM 是如何运行代码的？</h1><p>Dart VM 有多种方式执行代码，比如：</p><ul><li>使用 JIT 从源码或 Kernel binary</li><li>从 snapshot<ul><li>AOT snapshot</li><li>AppJIT snapshot</li></ul></li></ul><p>这些方式之间的主要不同在于 VM 将 Dart 源码转换成可执行代码的时机和方式。执行代码的运行时环境是相同的。</p><p>VM 中的 Dart 代码运行在 <em>isolate</em>，对 isolate 的最好描述是这样的：一个隔离的 Dart 世界，有其自己的内存(<em>heap</em>)，通常有自己的线程(<em>mutator thread</em>)。可以有多个 isolate 并发执行 Dart 代码，但 isolate 不能直接共享任何状态，只能通过 <em>port</em> 发送消息来通信(不要将这里的 port 跟 network port 混淆)。</p><p><img src="https://mrale.ph/dartvm/images/isolates.png" alt></p><p>OS 线程跟 isolate 之间的关系比较模糊，具体依赖于 VM 是如何 embed 到应用中的。只能保证如下几个规则：</p><ul><li>OS 线程同一时刻只能进入一个 isolate。如果线程想进入另一个 isolate，它必须离开当前 isolate</li><li>同一时刻一个 isolate 只能有一个 <em>mutator</em> 线程。mutator 线程是指执行 Dart 代码并能访问 VM 公开 C API 的线程</li></ul><p>当然，同一个 OS 线程可以先进入一个 isolate，执行 Dart 代码，然后离开这个 isolate 并进入另一个 isolate。类似的，多个不同的线程可以进入同一个 isolate 并执行代码，只要不是同时发生。</p><p>除了单个 mutator 线程外，一个 isolate 还能跟多个辅助线程关联，比如：</p><ul><li>一个后台运行的 JIT 编译器线程</li><li>多个 GC sweeper 线程</li><li>多个并发 GC maker 线程</li></ul><p>VM 内部使用线程池(<a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/thread_pool.h#L14" target="_blank" rel="noopener">ThreadPool</a>)管理 OS 线程，代码围绕 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/thread_pool.h#L17" target="_blank" rel="noopener">ThreadPool::Task</a> 而非 OS 线程来组织。比如，GC VM 向全局 VM 线程池提交 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/heap/sweeper.cc#L100" target="_blank" rel="noopener">SweeperTask</a> 后并不是生成一个专门的线程来执行后台清理工作，线程池可能会选择一个空闲的线程，或者在没有线程可用时生成一个新线程。类似的，用于 isolate 消息处理的 event loop 的缺省实现也并不是真的生成专门的 event loop 线程，而是在新消息到达时向线程池提交 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/message_handler.cc#L19" target="_blank" rel="noopener">MessageHandlerTask</a>。</p><p>源码清单：</p><ul><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/isolate.h#L151" target="_blank" rel="noopener">Isolate</a> 类代表 isolate</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/heap/heap.h#L28" target="_blank" rel="noopener">Heap</a> 类代表 isolate 的 heap</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/thread.h#L204" target="_blank" rel="noopener">Thread</a> 类描述与 isolate 关联的线程的状态。注意这里的名字 Thread 容易让人混淆，因为实际上所有作为 mutator 关联到同一个 isolate 的所有的操作系统线程会重用同一个 Thread 实例。</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/dart_api_impl.cc#L1586" target="_blank" rel="noopener">Dart_RunLoop</a> 和 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/message_handler.h#L17" target="_blank" rel="noopener">MessageHandler</a> 是 isolate 消息处理的缺省实现</li></ul><h2 id="JIT-模式源码运行"><a href="#JIT-模式源码运行" class="headerlink" title="JIT 模式源码运行"></a>JIT 模式源码运行</h2><p>这一节是关于在命令行下执行 Dart 时的过程。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// hello.dart</span><br><span class="line">main() =&gt; <span class="built_in">print</span>(<span class="string">'Hello, World!'</span>);</span><br><span class="line">$ dart hello.dart</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><p>Dart 2 开始 VM 不再支持直接从原始代码执行 Dart，而是执行指定的 <em>Kernel binaries</em> (也称之为 <em>dill files</em>)，其中包含系列化后的 <a href="https://github.com/dart-lang/sdk/blob/master/pkg/kernel/README.md" target="_blank" rel="noopener">Kernel ASTs</a>。Dart 源码转换成 Kernel AST 的任务由 <a href="https://github.com/dart-lang/sdk/tree/master/pkg/front_end" target="_blank" rel="noopener">common front-end (CFE)</a> 完成，CFE 由 Dart 写成，在不同的 Dart 工具共享(比如 VM，dart2js，Dart Dev Compiler)。</p><p><img src="/images/15934867158439.jpg" alt></p><p>为了保留直接执行 Dart 代码的便捷性，标准的 <code>dart</code> 执行命令带有一个叫 <em>kernel service</em> 的 isolate，它负责将 Dart 源码编译成 Kernel binary。之后 VM 后运行生成的 Kernel binary。</p><p><img src="/images/15934867009562.jpg" alt></p><p>不过这并非 CFE 和 VM 运行 Dart 代码唯一的组合方式。比如，Flutter 完全将 <em>compilation to Kernel</em> 和      <em>execution from Kernel</em> 两个过程分离到不同的设备上：编译发生在开发机(<em>host</em>)，而执行发生在移动设备(<em>device</em>)，它接收通过 <code>flutter</code> tool 发送来的 Kernel binary。</p><p><img src="/images/15934866911219.jpg" alt><br><img src="https://mrale.ph/dartvm/images/flutter-cfe.png" alt></p><p>注意 <code>flutter</code> tool 自己并不解析 Dart，它启动另一个进程 <code>frontend_server</code>。<code>frontend_server</code> 是对 CFE 的包装，并且进行某些 Flutter 特定的 Kernel-to-Kernel 转换。<code>frontend_server</code> 将 Dart 代码转换成 Kernel binary 文件，<code>flutter</code> tool 将这些文件发送到设备。当开发者想使用 <em>hot reload</em> 特性时，就需要 <code>frontend_server</code> 是常驻进程了：<code>frontend_server</code> 可以根据前一次编译来重用 CFE 状态，只编译发生实际变动的代码。</p><p>Kernel binary 加载到 VM 后会被解析成代码不同程序实体的对象。不过解析是延迟进行的：最初只加载库和类的基本信息。每个来自 Kernel binary 的实体都有一个指向 Kernel binary 的指针，以便之后需要时能加载更多信息。</p><blockquote><p>使用 <code>Raw...</code> 前缀来指代 VM 内部分配的特定对象。这是 VM 的命名习惯：VM 内部对象布局由一个位于 <code>raw_object.h</code> 头文件中以 Raw 开头的 C++ 类来定义。比如 <code>RawClass</code> 是一个描述 Dart 类的 VM 对象，而 <code>RawField</code> 是一个描述 Dart 类中 Dart 字段的对象。在后台讨论运行时系统和对象模型那节中我们还会回到这个话题。</p></blockquote><p><img src="/images/15934878531318.jpg" alt></p><p>类的信息只在之后运行时需要时才完全反序列化(比如，查找类成员，分配对象等等)。这一阶段，类成员读取自 Kernel binary。不过，此时只有成员签名，完整的函数方法此时并没有完全反序列化。</p><p><img src="/images/15934880714981.jpg" alt></p><p>这时运行时已经从 Kernel binary 加载了足够信息，可以成功解析和调用方法。比如，它可以从一个库中解析和调用 <code>main</code> 函数。</p><p>源码清单：</p><ul><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/kernel/lib/ast.dart" target="_blank" rel="noopener">package:kernel/ast.dart</a> 定义了描述 Kernel AST 的类</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/front_end" target="_blank" rel="noopener">package:front_end</a> 用于解析 Dart 源码并从源码构建 AST</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/kernel_loader.cc#L211" target="_blank" rel="noopener">kernel::KernelLoader::LoadEntireProgram</a> 是将 Kernel AST 反序列化成对应 VM 对象的入口</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/vm/bin/kernel_service.dart" target="_blank" rel="noopener">pkg/vm/bin/kernel_service.dart</a> 实现了 Kernel Service isolate</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/kernel_isolate.cc" target="_blank" rel="noopener">runtime/vm/kernel_isolate.cc</a> 将 Dart 实现跟 VM 的其他部分粘合起来</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/vm" target="_blank" rel="noopener">package:vm</a> 包含基于 Kernel 的 VM 的大部分功能，比如不同的 Kernel-to-Kernel 转换，由于一些历史原因一些 VM 特定的转换仍然放在 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/kernel" target="_blank" rel="noopener">package:kernel</a> 中</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/kernel/lib/transformations/continuation.dart" target="_blank" rel="noopener">package:kernel/transformations/continuation.dart</a> 是一个复杂转换的好例子，它对 <code>async</code>、<code>async*</code> 以及 <code>sync*</code> 函数进行脱糖处理 </li></ul><p>动手尝试！如果你对 Kernel binary 格式以及 VM 用法感兴趣，可以使用 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/vm/bin/gen_kernel.dart" target="_blank" rel="noopener">pkg/vm/bin/gen_kernel.dart</a> 来从 Dart 源码生成一个 Kernel binary 文件。生成的 binary 文件可以使用 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/vm/bin/dump_kernel.dart" target="_blank" rel="noopener">pkg/vm/bin/dump_kernel.dart</a> 进行 dump 操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Take hello.dart and compile it to hello.dill Kernel binary using CFE.</span></span><br><span class="line">$ dart pkg/vm/bin/gen_kernel.dart                        \</span><br><span class="line">       --platform out/ReleaseX64/vm_platform_strong.dill \</span><br><span class="line">       -o hello.dill                                     \</span><br><span class="line">       hello.dart</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dump textual representation of Kernel AST.</span></span><br><span class="line">$ dart pkg/vm/bin/dump_kernel.dart hello.dill hello.kernel.txt</span><br></pre></td></tr></table></figure><p>当你尝试使用 <code>gen_kernel.dart</code> 时你你发现它需要一个名为 <em>platform</em> 的东西，这个参数用于指定一个包含所有核心库(例如 <code>dart:core</code>，<code>dart:async</code>)的 AST 的文件。如果你本地编译过 Dart SDK，可以使用 out 目录下的 platform 文件，比如 <code>out/ReleaseX64/vm_platform_strong.dill</code>。(译者注：如果你本地编译过 Flutter 引擎，也可以使用 <code>engine/src/out/host_debug_unopt/vm_platform_strong.dill</code>)。另外，你也可以使用 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/front_end/tool/_fasta/compile_platform.dart" target="_blank" rel="noopener">pkg/front_end/tool/_fasta/compile_platform.dart</a> 生成 platform。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Produce outline and platform files using the given libraries list.</span></span><br><span class="line">$ dart pkg/front_end/tool/_fasta/compile_platform.dart \</span><br><span class="line">       dart:core                                       \</span><br><span class="line">       sdk/lib/libraries.json                          \</span><br><span class="line">       vm_outline.dill vm_platform.dill vm_outline.dill</span><br></pre></td></tr></table></figure><p>译者注：我在本地操作了一把，成功！</p><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 dill</span></span><br><span class="line">$ dart /Users/cm/wd/engine/src/third_party/dart/pkg/vm/bin/gen_kernel.dart \</span><br><span class="line">--platform /Users/cm/wd/engine/src/out/host_debug_unopt/vm_platform_strong.dill \</span><br><span class="line">-o hello.dill \</span><br><span class="line">   hello.dart</span><br><span class="line"><span class="comment"># dump dill</span></span><br><span class="line">$ dart /Users/cm/wd/engine/src/third_party/dart/pkg/vm/bin/dump_kernel.dart \</span><br><span class="line">hello.dill hello.kernel.txt</span><br></pre></td></tr></table></figure><p><img src="/images/15934899027428.jpg" alt></p><p><img src="/images/15934899450735.jpg" alt></p><p>所有函数体初始时只有占位符而不是实际的可执行代码：占位符指向 <code>LazyCompileStub</code>，它只是请求运行时系统为当前函数生成可执行代码并且对新生成的代码进行尾调用(tail-calls this newly generated code)。</p><p><img src="/images/15934979827846.jpg" alt></p><p>函数第一次编译时以上过程由 <em>unoptimizing compiler</em> 完成。</p><p><img src="/images/15934980438450.jpg" alt></p><p><em>Unoptimizing compiler</em> 按以下两个步骤生成机器码：</p><ol><li>遍历函数体的序列化后的 AST，为函数体生成 <em>control flow graph</em> (CFG)。CFG 由 <em>intermediate language</em> (IL) 指令块组成。这个阶段使用的 IL 指令类似基于栈的 VM 中的指令：从栈中取出操作数，执行操作后将结果放回同一个栈 (注意：实际上并不是所有的函数都有实际的 Dart/Kernel AST 函数体，比如 C++ 中定义的 native 方法或 artificial tear-off functions generated by Dart VM，这些场景中 IL 是从从头构造的而不是从 Kernel AST 生成的)</li><li>生成的 CFG 直接编译成机器码：每个 IL 指令扩展成多个机器语言指令</li></ol><p>这个阶段中没有进行优化，unoptimizing compiler 的主要目标是快速生成可执行代码。</p><p>This also means that unoptimizing compiler does not attempt to statically resolve any calls that were not resolved in Kernel binary, so calls (MethodInvocation or PropertyGet AST nodes) are compiled as if they were completely dynamic. VM 目前不使用任何形式的基于的 <em>virtual table</em> 或 <em>interface table</em> 的分发方法，而是使用 <a href="https://en.wikipedia.org/wiki/Inline_caching" target="_blank" rel="noopener">inline caching</a> 实现动态调用。</p><p>inline caching 背后的主要思想是在 call site specific cache 中保存方法解析的结果(The core idea behind inline caching is to cache results of method resolution in a call site specific cache.)。注意：原始的 inline caching 实现实际上是用来对函数的 native 代码打补丁。VM 使用的 inline caching 有如下组成：</p><ul><li>call site specific cache (RawICData 对象)，将接收方的类映射成方法，如果接收方的类匹配上就调用这个方法。这个 cache 还保存一些辅助信息，比如调用计数，用于记录指定类在这个 call site 中出现的次数</li><li>shared lookup stub，实现方法调用的快捷路径。该 stub 在指定 cache 中检查是否包含能跟接收方的类匹配的 entry，如果有，则 stub 将增调用频率计数。否则，stub 将请求运行时系统进行方法解析。解析方法后会更新 cache，之后的方法调用不必再经过运行时系统。</li></ul><p>下图展示了跟 <code>animal.toFace()</code> call site 关联的 inline cache 的结构和方法，这个方法在一个 <code>Dog</code> 实例上执行两次，在另一个 <code>Cat</code> 实例上执行一次。</p><p><img src="/images/15934995543159.jpg" alt></p><p>Unoptimizing compiler 本身足够执行任意 Dart 代码。但它生成的代码非常慢，这也是为什么 VM 还实现了 <em>adaptive optimizing</em> 编译流水线。adaptive optimizing 背后的思想是对一个运行中的程序的执行分析结果来驱动优化决策：</p><p>unoptimized code (未经优化的代码) 运行时会收集以下信息：</p><ul><li>dynamic call site 对应的 inline cache 收集接收者的类型信息</li><li>每个函数和块的执行计数器记录代码热点</li></ul><p>当一个函数的执行计数数达到某个阈值时，该函数被提交给 <em>background optimizing compiler</em> 进行优化。</p><p>优化编译以跟未优化编译相同的方式开始：遍历序列化后的 Kernel AST 来为待优化的函数构建未优化的 IL。不过，现在跟直接将 unoptimized IL 转成机器码不同的是，optimizing compiler 将 unoptimized IL 转换成 static single assignment (SSA) 格式的 optimized IL。SSA 格式的 IL 接下来会基于收集到的类型反馈来进行一系列常规的以及 Dart 特有的优化：比如  e.g. inlining, range analysis, type propagation, representation selection, store-to-load and load-to-load forwarding, global value numbering, allocation sinking, etc. 最后，使用 linear scan register allocator 将 optimized IL 转换成机器码。</p><p>优化编译完成后 background compiler 要求 mutator thread 进入一个安全点，并且将优化后的代码关联到待优化的函数。下次函数执行时，它将使用优化后的代码。</p><p>注意：有些函数包含长时间执行的循环，所以在函数运行期间从 unoptimized code 切换到 optimized code 也是有意义的。这个过程称为 <em>on stack replacement</em> (OSR)，它的名字来自于这样一个事实：栈帧从函数的某个版本被透明地替换成同一函数的另一个版本。</p><p><img src="/images/15935012109939.jpg" alt></p><p>源码清单：</p><ul><li>编译器源码见 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler" target="_blank" rel="noopener">runtime/vm/compiler</a> 目录</li><li>编译流水线入口见 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/jit/compiler.cc#L701" target="_blank" rel="noopener">CompileParsedFunctionHelper::Compile</a></li><li>IL 由 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/backend/il.h" target="_blank" rel="noopener">runtime/vm/compiler/backend/il.h</a> 定义</li><li>Kernel-to-IL 的转换从 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/frontend/kernel_binary_flowgraph.cc#L1929" target="_blank" rel="noopener">kernel::StreamingFlowGraphBuilder::BuildGraph</a> 开始</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/stub_code_x64.cc#L1795" target="_blank" rel="noopener">StubCode::GenerateNArgsCheckInlineCacheStub</a> 为 inline-cache stub 生成机器码，<a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/runtime_entry.cc#L1073" target="_blank" rel="noopener">InlineCacheMissHandler</a> 处理 IC 缺失</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/compiler_pass.cc" target="_blank" rel="noopener">runtime/vm/compiler/compiler_pass.cc</a> 定义 optimizing compiler pass 和 order</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/jit/jit_call_specializer.h#L12" target="_blank" rel="noopener">JitCallSpecializer</a> 完成大部分 type-feedback based specialization</li></ul><p>动手尝试！VM 提供一些选项用于控制 JIT，并能 dump 由 JIT 编译的函数的 IL 和机器码.</p><p>Flag    Description<br>–print-flow-graph[-optimized]    Print IL for all (or only optimized) compilations<br>–disassemble[-optimized]    Disassemble all (or only optimized) compiled functions<br>–print-flow-graph-filter=xyz,abc,…    Restrict output triggered by previous flags only to the functions which contain one of the comma separated substrings in their names<br>–compiler-passes=…    Fine control over compiler passes: force IL to be printed before/after a certain pass. Disable passes by name. Pass help for more information<br>–no-background-compilation    Disable background compilation, and compile all hot functions on the main thread. Useful for experimentation, otherwise short running programs might finish before background compiler compiles hot function</p><p>例如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Run test.dart and dump optimized IL and machine code for</span><br><span class="line"># function(s) that contain(s) &quot;myFunction&quot; in its name.</span><br><span class="line"># Disable background compilation for determinism.</span><br><span class="line">$ dart --print-flow-graph-optimized         \</span><br><span class="line">       --disassemble-optimized              \</span><br><span class="line">       --print-flow-graph-filter=myFunction \</span><br><span class="line">       --no-background-compilation          \</span><br><span class="line">       test.dart</span><br></pre></td></tr></table></figure><p>另外需要强调的是 optimizing compiler 是基于对应用执行结果分析而得出的假设来生成优化后的代码的。比如，观察到动态调用只将 <code>C</code> 类作为接收者，会将这个动态调用转换成直接调用，并验证接收者的类型为 <code>C</code>。但是，后续的调用可能打破这种假设：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> printAnimal(obj) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Animal &#123;'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'  <span class="subst">$&#123;obj.toString()&#125;</span>'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'&#125;'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call printAnimal(...) a lot of times with an intance of Cat.</span></span><br><span class="line"><span class="comment">// As a result printAnimal(...) will be optimized under the</span></span><br><span class="line"><span class="comment">// assumption that obj is always a Cat.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++)</span><br><span class="line">  printAnimal(Cat());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now call printAnimal(...) with a Dog - optimized version</span></span><br><span class="line"><span class="comment">// can not handle such an object, because it was</span></span><br><span class="line"><span class="comment">// compiled under assumption that obj is always a Cat.</span></span><br><span class="line"><span class="comment">// This leads to deoptimization.</span></span><br><span class="line">printAnimal(Dog());</span><br></pre></td></tr></table></figure><p>任何时候如果 optimized code 做了某种假设，但这些假设并不来自静态不可变信息，则应该防范假设被打破，并且能在打破假设的场景中恢复。</p><p>这种恢复过程称为 <em>deoptimization</em> (反优化)：无论何时当 optimized code 不能处理某种 case 时，简单地切换成 unoptimized code 对应的匹配点并继续执行。unoptimized code 没有做任何假设，所以能处理任何可能的输入。</p><blockquote><p>注意：进入 unoptimized 函数正确的执行点非常重要，因为方法有副作用。比如上面的例子中，deoptimization 发生在调用第一个 <code>print</code> 调用后。Matching instructions that deoptimize to positions in the unoptimized code in VM is done using deopt ids</p></blockquote><p>VM 通常会在 deoptimization 发生时抛弃函数的 optimized 版本，并且在之后使用更新后的 type feedback 重新进行优化。</p><p>VM 有两种方式来防范编译做出的假设被破坏：</p><ul><li>inline check (比如，<code>CheckSmi</code> 和 <code>CheckClass</code> IL 指令) 用于在编译器做出假设的 use site 中验证假设仍然成立。比如，将动态调用转换成直接调用时编译器会在直接调用前增加检查。检查失败时发生的 deoptimization 被称为 <em>eager deoptimization</em>，因为检查后它马上发生</li><li>全局守卫，用于提示运行时在 optimized code 依赖的东西被修改后抛弃这些 optimized code。比如，optimizing compiler 可能发现 <code>C</code> 类没有被其他类继承，并且在类型传递时使用了这个信息。但是接下来动态加载的代码可能引入了一个继承自 <code>C</code> 类的类，所以之前假设不成立。这时运行时需要抛弃所有基于 <code>C</code> 类没有子类这个假设优化得到的 optimized code。运行时可能发现某些失效的 optimized code 在执行栈中，这种情况下受影响的栈帧需要被标记以反优化。这种 deoptimization 称为 <em>lazy deoptimization</em>：因为它会延迟到控制流回到 optimized code 时才发生</li></ul><p>代码清单：</p><ul><li>Deoptimizer 机制见 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/deopt_instructions.cc" target="_blank" rel="noopener">runtime/vm/deopt_instructions.cc</a>。它实际上是一个用于 <em>deoptimization instructions</em> 的迷你解释器，用于描述从 optimized code 状态重建必要的 unoptimized code 状态</li><li><p>Deoptimization 指令由 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/backend/flow_graph_compiler_x64.cc#L68" target="_blank" rel="noopener">CompilerDeoptInfo::CreateDeoptInfo</a> 为 optimized code 中每个潜在的 deoptimization location 生成 deoptimization 指令</p></li><li><p><code>--trace-deoptimization</code> 用于 VM 输出每个 deoptimization 的原因和位置</p></li><li><code>--trace-deoptimization-verbose</code> 用于 VM 为每个 deoptimization instruction 输出一行日志</li></ul><h2 id="从-snapshot-运行"><a href="#从-snapshot-运行" class="headerlink" title="从 snapshot 运行"></a>从 snapshot 运行</h2><p>VM 具备对 isolate 堆(更准确地说是堆中的对象图)序列化成二进制 <em>snapshot</em> 的能力。snapshot 可用于启动 VM isolate 时重建相同状态。</p><p><img src="/images/15935061109366.jpg" alt></p><p>snapshot 使用低级格式，便于快速启动。它实际上是待创建对象的列表，以及如何联系这些对象的指令。snapshot 背后的初始思想是：相比解析 Dart 源码来逐步创建 VM 内部数据结构，VM 可以快速从 snapshot 得到所有必要的数据结构来启动 isolate。</p><p>最初，snapshot 中并不包含机器码。后来随着 AOT compiler 的开发，snapshot 中也可包含机器码。开发 AOT compiler 以及 snapshots-with-code 的目的是允许 VM 用于 JITing 不可用(平台本身限制)的那些平台。</p><p>snapshots-with-code 跟普通 snapshot 几乎相同，一个小的区别在于：前者包含一个 code section，这个区域跟其他区域不同，并不需要反序列化。code section 允许映射到内存时直接作为 heap 的一部分。</p><p><img src="/images/15935067498616.jpg" alt></p><p>代码清单：</p><ul><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/clustered_snapshot.cc" target="_blank" rel="noopener">runtime/vm/clustered_snapshot.cc</a> 处理 snapshot 的序列化与反序列化。有一系列 Dart_CreateXyzSnapshot[AsAssembly] 方法用于将 heap 导出成 snapshot，例如 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/dart_api_impl.cc#L6238" target="_blank" rel="noopener">Dart_CreateAppJITSnapshotAsBlobs</a> 和 <a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/dart_api_impl.cc#L5986" target="_blank" rel="noopener">Dart_CreateAppAOTSnapshotAsAssembly</a></li></ul><h2 id="从-AppJIT-snapshot-运行"><a href="#从-AppJIT-snapshot-运行" class="headerlink" title="从 AppJIT snapshot 运行"></a>从 AppJIT snapshot 运行</h2><p>引入 AppJIT snapshot 是为解决大型 Dart 应用的启动时间，例如 <code>dartanalyzer</code> 或 <code>dart2js</code>。这些工具用于小工程时完成实际工作的时间跟 VM 花在 JIT 上的时间一样多(译者注：言下之意是，VM 花了太多时间对大型 Dart 应用进行 JIT 处理，而这些应用用于处理小工程时实际工作本身并不会耗时太多？)</p><p>AppJIT snapshot 可用于处理这种问题：一个应用可以在 VM 使用一些模拟的训练数据运行，之后将生成的代码和 VM 内部数据结构序列化成 AppJIT snapshot。不同于以源码和 Kernel binary 形式来分发应用，而是分发 AppJIT snapshot。当在实际数据上执行时的 execution profile 无法匹配到训练阶段时观察到的 execution profile，从这种 snapshot 启动的 VM 仍然可以 JIT—</p><p><img src="/images/15935079364904.jpg" alt></p><p>动手尝试！给 <code>dart</code> 命令传 <code>--snapshot-kind=app-jit --snapshot=path-to-snapshot</code> 参数会生成 AppJIT snapshot。如下的例子为 <code>dart2js</code> 生成和使用 AppJIT snapshot。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run from source in JIT mode.</span></span><br><span class="line">$ dart pkg/compiler/lib/src/dart2js.dart -o hello.js hello.dart</span><br><span class="line">Compiled 7,359,592 characters Dart to 10,620 characters JavaScript <span class="keyword">in</span> 2.07 seconds</span><br><span class="line">Dart file (hello.dart) compiled to JavaScript: hello.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># Training run to generate app-jit snapshot</span></span><br><span class="line">$ dart --snapshot-kind=app-jit --snapshot=dart2js.snapshot \</span><br><span class="line">       pkg/compiler/lib/src/dart2js.dart -o hello.js hello.dart</span><br><span class="line">Compiled 7,359,592 characters Dart to 10,620 characters JavaScript <span class="keyword">in</span> 2.05 seconds</span><br><span class="line">Dart file (hello.dart) compiled to JavaScript: hello.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run from app-jit snapshot.</span></span><br><span class="line">$ dart dart2js.snapshot -o hello.js hello.dart</span><br><span class="line">Compiled 7,359,592 characters Dart to 10,620 characters JavaScript <span class="keyword">in</span> 0.73 seconds</span><br><span class="line">Dart file (hello.dart) compiled to JavaScript: hello.js</span><br></pre></td></tr></table></figure><h2 id="从-AppAOT-snapshot-运行"><a href="#从-AppAOT-snapshot-运行" class="headerlink" title="从 AppAOT snapshot 运行"></a>从 AppAOT snapshot 运行</h2><p>AOT snapshot 初始是为无法开启 JIT 编译的平台引入的，但它们也可用于快速启动以及性能强一致性(可接受潜在性能损失)的场景。</p><blockquote><p>关于 JIT 和 AOT 性能特性之间的比较常常有很多混淆。JIT 能访问到准确的本地类型信息，以及应用运行期间的 execution profile，但它付出的代价是较慢的预热过程。AOT 可以推断和验证全局属性(代价是较长的编译时间)，但没有应用如何实际执行的信息。换句话说，AOT 编译的代码实际没有预热过程，启动后几乎就能达到性能峰值。当前 Dart VM JIT 有最好的性能峰值，而 Dart VM AOT 有最短的启动时间。</p></blockquote><p>无法 JIT 意味着：</p><ol><li>AOT snapshot 必须包含应用执行期间每个可能被调用的函数的可执行代码</li><li>这些可执行代码不能依赖任何在执行期间可能被违反的假设</li></ol><p>为了满足这些需求，AOT 编译时会进行全局静态分析(<em>type flow analysis</em>，TFA)以确定从一些已知的入口出发，应用的哪些部分是可达的；会分配哪些类的实例；以及程序的 type flow 是怎样的。所有这些分析都是保守的：即它们更看重正确性。这与 JIT 更看重高性能是截然不同的。JIT 总是可以在必要时”反优化”到 unoptimized code 来实现正确的行为。</p><p>所有潜在可达的函数被编译成 native code，不做任何推测优化(All potentially reachable functions are then compiled to native code without any speculative optimizations)。当然，仍然会使用 type flow 信息对代码进行处理(比如，取消虚调用 devirtualize calls)。</p><p>所以函数编译完成后生成 snapshot。生成的 snapshot 可以在 <em>precompiled runtime</em>，这是一个特别的 Dart VM，没有 JIT 组件及动态加载代码的能力。</p><p><img src="/images/15935100043901.jpg" alt></p><p>源码清单：</p><ul><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/vm/lib/transformations/type_flow/transformer.dart" target="_blank" rel="noopener">package:vm/transformations/type_flow/transformer.dart</a> 是 type flow 分析及基于 TFA 转换的入口</li><li><a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/runtime/vm/compiler/aot/precompiler.cc#L190" target="_blank" rel="noopener">Precompiler::DoCompileAll</a> 是   VM 中 AOT 编译循环(the AOT compilation loop in the VM)的入口</li></ul><p>动手尝试！目前 Dart SDK 并不包含 AOT 编译流水线，那些依赖这个特性的项目(比如 Flutter)必须自行从 SDK 构建这个功能。<a href="https://github.com/dart-lang/sdk/blob/cb6127570889bed147cbe6292cb2c0ba35271d58/pkg/vm/tool/precompiler2" target="_blank" rel="noopener">pkg/vm/tool/precompiler2</a> 脚本是个不错的参考，它演示了流水线是如何组织的，哪些二进制产物必须被构建。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Need to build normal dart executable and runtime for running AOT code.</span></span><br><span class="line">$ tool/build.py -m release -a x64 runtime dart_precompiled_runtime</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now compile an application using AOT compiler</span></span><br><span class="line">$ pkg/vm/tool/precompiler2 hello.dart hello.aot</span><br><span class="line"></span><br><span class="line"><span class="comment"># Execute AOT snapshot using runtime for AOT code</span></span><br><span class="line">$ out/ReleaseX64/dart_precompiled_runtime hello.aot</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><p>注意：如果想检查生成的 AOT 代码，类似 <code>--print-flow-graph-optimized</code> 或 <code>--disassemble-optimized</code> 这些参数也可以传给 <code>precompiler2</code> 脚本。</p><h1 id="Runtime-System"><a href="#Runtime-System" class="headerlink" title="Runtime System"></a>Runtime System</h1><p>敬请期待 (译者注：原文还在完善中)</p><h1 id="Object-Model"><a href="#Object-Model" class="headerlink" title="Object Model"></a>Object Model</h1><p>敬请期待 (译者注：原文还在完善中)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译) 使用 DevTools 分析 Flutter 内存</title>
      <link href="2020/06/29/flutter-memory/"/>
      <url>2020/06/29/flutter-memory/</url>
      
        <content type="html"><![CDATA[<p>翻译自 <a href="https://raw.githubusercontent.com/flutter/website/master/src/docs/development/tools/devtools/memory.md" target="_blank" rel="noopener">Using the Memory view</a>，学习如何使用 DevTools 中的来分析 Flutter 应用的内存。</p><a id="more"></a><p>个人感觉目前 DevTools (0.8.0)还不太稳定，我的 Mac 机器上查看内存一段时间后经常无响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; flutter pub global list</span><br><span class="line">devtools 0.8.0+2</span><br></pre></td></tr></table></figure><h2 id="它是什么"><a href="#它是什么" class="headerlink" title="它是什么?"></a>它是什么?</h2><p>使用类构建方法(比如，<code>new MyClass()</code> 或 <code>MyClass()</code>)分配的 Dart 对象存活于称为堆的内存中。</p><!--DevTools Memory pane lets you peek at how an isolate is usingmemory at a given moment. This pane, using Snapshot andReset, can display accumulator counts. The accumulatorscan be used to study the rate of memory allocations,if you suspect your application is leaking memory or hasother bugs relating to memory allocation.--><p>DevTools 的内存面板用于查看指定时刻时的 isolate 内存。这个面板使用 Snapshot 和 Reset 来展示 accumulator 计数。如果你怀疑应用中存在内存泄漏或其他内存相关的 bug，可以使用 accumulator 分析内存分配情况。</p><!--Memory profiling consists of four parts, each increasingin granularity:--><p>内存分析由四部分组成，精细度从低到高分别是:</p><ul><li>Memory overview chart</li><li>Event timeline</li><li>Snapshot classes</li><li>Class instances</li></ul><!--<p>  <strong>Use [profile mode][] when running your app to analyze performance.</strong><br>  Memory usage is not indicative of release performance unless your<br>  application is run in profile mode. In general, memory usage is<br>  fairly accurate, in relative terms, between debug, release, or<br>  profile modes. Profile mode might show higher absolute memory usage<br>  because a service isolate is created to profile your application.<br>  This isolate won’t exist in release mode. Absolute memory used might<br>  also be higher in debug versus release mode. In release mode,<br>  work can be computed and optimized ahead of time, while in debug<br>  mode that same work might have to be computed at runtime,<br>  requiring more information.<br>–&gt;</p><blockquote><p><strong>分析性能时请以 [profile mode][<a href="https://flutter.dev/docs/testing/build-modes#profile]">https://flutter.dev/docs/testing/build-modes#profile]</a> 启动应用。</strong> 除非以 profile mode 运行，否则看到的内存使用量并不代表实际发布模式的内存使用量。无论是 debug, release 还是 profile 模式，测出来的内存值都是相当准确的。不过由于要启动一个 service isolate 用于分析应用，所以 profile mode 可能会显示更高的绝对内存使用量。这个 isolate 在发布模式下并不存在。相比发布模式，debug 模式的绝对内存使用量也会更高。在发布模式中，可以提前进行计算或优化处理，而在 debug 模式中相同工作只能在运行时进行，所以需要更多信息(译者注: 也意味占用更多内存)。</p></blockquote><!--## Memory anatomy--><h2 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h2><!--Use a timeseries graph to visualize the state of the Flutter memoryat successive intervals of time. Each data point on the chartcorresponds to the timestamp (x-axis) of measured quantities (y-axis)of the heap, for example, usage, capacity, external, garbagecollection, and resident set size.--><p>使用时间序列图形来可视化一段连续时间内的 Flutter 内存状态。图表中的每个数据点分别对应堆(heap)的时间戳(x轴)和测量值(y轴)。测量值有多种，比如 usage, capacity, external, garbage<br>collection, 和 resident set size</p><p><img src="/images/15952331308847.jpg" alt></p><!--<dl markdown="1"><dt markdown="1">**Legend**</dt><dd>All collected measurements regarding the memory.    Clicking a legend name hides or shows that data.</dd><dt markdown="1">**Range selector**</dt><dd>All memory data collected (timeseries).    The left-most or first time/data (memory information),    in the selector is when the application was launched.    The right-most or last time/data is the continual memory    information being received (live) until the application is    stopped.</dd><dt markdown="1">**Range selector view**</dt><dd>Detailed view of the data collected    for this timeseries range (non-gray area).</dd><dt markdown="1">**X-axis timestamp**</dt><dd>Time of the collected memory information    (capacity, used, external, RSS (resident set size),    and GC (garbage collection).</dd><dt markdown="1">**Hover information of collected data**</dt><dd>At a particular time (x-axis) the detailed collected    memory data.</dd><dt markdown="1">**Garbage collection occurred**</dt><dd>Compaction of the heap occurred.</dd><dt markdown="1">**Event timeline**</dt><dd>When a user action occurred (such as the    Snapshot or Reset button being clicked).</dd><dt markdown="1">**Snapshot**</dt><dd markdown="1">Display a table of current active    memory objects (see    [Snapshot classes](#snapshot-classes)).<dt markdown="1">**Reset accumulator**</dt><dd markdown="1">Reset values, to zero, under the    Accumulator column in the Snapshot classes table.<dt markdown="1">**Filtering classes**</dt><dd>PENDING</dd><dt markdown="1">**Snapshot classes**</dt><dd>Clicking the Snapshot button (top right area)    displays a table of current memory objects.    The memory objects can be sorted by class name,    size, allocated instances, and so on.</dd><dt markdown="1">**Accumulator counts since reset**</dt><dd>Clicking the Reset button (top right area) resets    the accumulated instances count. Clicking Snapshot    after a reset displays the number of new instances    allocated since last reset.    This is useful for finding memory leaks.</dd><dt markdown="1">**Class instances**</dt><dd>Clicking a class in the Snapshot class table    displays the number of active instances for that class.</dd><dt markdown="1">**Inspecting contents of an instance**</dt><dd>PENDING</dd><dt markdown="1">**Total active objects and classes in the heap**</dt><dd>Total classes allocated in the heap and total objects    (instances) in the heap.</dd>--><p><strong>图例</strong></p><p>所有收集到的内存相关的测量值。点击图例名会隐藏或显示对应数据。</p><p><strong>Range selector</strong></p><p>所有收集到的内存数据(时间线)。selector 中最左边/第一个 time/data(或 memory information)对应于应用启动时，最右边/最后一个 time/data 对应于应用结束时收到内存信息。</p><p><strong>Range selector view</strong></p><p>timeserie range 中收集到的的数据的详细视图。</p><p><strong>X轴 时间戳</strong></p><p>收集到内存信息时对应的时间(capacity, used, external, RSS (resident set size),<br>   和 GC (garbage collection)。</p><p><strong>Hover information of collected data</strong></p><p>特定时间(x-axis)详细的内存数据。</p><p><strong>Garbage collection occurred</strong></p><p>Compaction of the heap occurred.</p><p><strong>Event timeline</strong></p><p>用户操作发生的时间 (such as the Snapshot or Reset button being clicked)</p><p><strong>Snapshot</strong></p><p>以表格形式显示内存中存活的对象</p><p><strong>Reset accumulator</strong></p><p>将 Snapshot class 表中 Accumulator 那一列下的值重置为 0</p><p><strong>Filtering classes</strong></p><p>PENDING</p><p><strong>Snapshot classes</strong></p><p>点击右上角的 Snapshot 按钮将显示以表格形式显示内存中的对象。这些对象可以按类名、大小、实例等条件排序。</p><p><strong>Accumulator counts since reset</strong></p><p>点击右上角的 Reset 按钮将重置 accumulated instances count。点击重置之后再点击 Snapshot 将展示上次重置之后新分配的实例。这在查找内存泄漏时非常有用。</p><p><strong>Class instances</strong></p><p>点击 Snapshot class 表中的 class 将展示该类对应的存活实例。</p><p><strong>Inspecting contents of an instance</strong></p><p>PENDING</p><p><strong>Total active objects and classes in the heap</strong></p><p>堆中分配的全部类以及全部对象</p><h2 id="Memory-overview-chart"><a href="#Memory-overview-chart" class="headerlink" title="Memory overview chart"></a>Memory overview chart</h2><p><img src="/images/15952347134525.jpg" alt></p><p>这是一个用于帮助可视化展示不同时间 heap 内存情况的时间序列图。</p><p>图中的 x-axis 是时间线。它在应用运行时每 500ms 读取一次内存值。y-axis 上(从上到下)的分别是：</p><p><strong>Capacity</strong></p><p>当前堆大小</p><p><strong>GC</strong></p><p>是事发生 GC。更多关于 Dart 如何处理 GC 请参考 <a href="https://medium.com/flutter/flutter-dont-fear-the-garbage-collector-d69b3ff1ca30" target="_blank" rel="noopener">Don’t Fear the Garbage Collector</a></p><p><strong>Used</strong></p><p>堆中的 Dart 对象</p><p><strong>External</strong></p><p>不在 Dart 堆中但仍然是总内存的一部分的那部分内存。在 external 内存中的对象是 native object(比如，已解码的图片)。原生系统使用 Dart embedder 向 Dart VM 暴露这些对象。Dart embedder 创建 Dart wrapper 用于 Dart 代码跟这些原生资源通信。</p><!--<dd markdown="1">Memory that is not in the Dart heap but is still part  of the total memory footprint. Objects in external memory would be  native objects (for example, from a memory read from a file,  or a decoded image). The native objects are exposed to the Dart  VM from the native OS (such as Android, Linux, Windows, iOS)  using a Dart embedder. The embedder creates a Dart wrapper with  a finalizer, allowing Dart code to communicate with these native  resources. Flutter has an embedder for Android and iOS.  For more information, see [Dart on the Server][server] or  [Custom Flutter Engine Embedders][embedder].--><p><img src="/images/15952351903784.jpg" alt></p><p>想查看 RSS (resident set size)，在图例中点击 RSS 的名字即可。</p><!--To view RSS (resident set size), click the name of the RSS locatedin the legend.--><ul><li>RSS 显示了进程使用的全部内存。它不包含被 swap out 的内存，但包含已加载的 shared library 内存，以及全部的栈内存和堆内存。</li></ul><!--* The resident set size displays the amount of memory to a process.  It doesn't include memory that is swapped out. It includes memory  from shared libraries that are loaded, as well as all stack and  heap memory.--><!--For more information, see [Dart VM internals][vm].--><p>更多信息请参考 <a href="https://mrale.ph/dartvm/" target="_blank" rel="noopener">Dart VM internals</a>。</p><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p><img src="/images/15952353620278.jpg" alt></p><p>这个图表展示了 DevTools 事件与跟内存时间线的关系。停在时间线的标记上将展示事件发生的时机。这个功能有助于发现可能的内存泄漏。</p><!--This chart displays DevTools events (such as Snapshot and Reset buttonclicks) in relation to the memory chart timeline. Hovering over themarkers in the Event timeline displays the time when the event occurred.This helps identify when a memory leak might have occurred in thetimeline (x-axis).--><!--Clicking the **Snapshot** button shows the current state of the heap withregard to all active classes and their instances. When the **Reset** buttonis pressed, the accumulator for all classes resets to zero.The reset is temporally tied, using a faint blue horizontal bar,to the previous snapshot. Clicking the **Reset** button again resets theaccumulators since the last reset and temporally ties the latestreset to the previous reset.--><p><strong>Snapshot</strong> 按钮将显示当前堆中所有存活的 class 及其实例。点击 <strong>Reset</strong> 按钮时，所有 accumulator 重置成 0。使用浅蓝色水平条将 Reset 跟之前的 Snapshot 连接。再次点击 <strong>Reset</strong> 按钮时重置 accumulator 并且暂时将最新的 reset 跟上次 reset 连接。</p><h2 id="Snapshot-classes"><a href="#Snapshot-classes" class="headerlink" title="Snapshot classes"></a>Snapshot classes</h2><p><img src="/images/15952357576151.jpg" alt></p><p>这个面板显示堆中分配的 class 及其所有实例，已分配内存大小，以及 accumulator (从上次 reset 开始计起)</p><!--This pane shows classes allocated in the heap, total instances,total bytes allocated, and an accumulator of allocations sincethe last reset.--><p><strong>Size</strong></p><p>堆中当前对象占用的全部内存</p><p><strong>Count</strong></p><p>堆中当前对象数量</p><p><strong>Accumulator</strong></p><p>上次 reset 后堆中的对象数量</p><p><strong>Class</strong></p><p>当前 class 的对象数量。点击类名会显示该类的实例列表</p><h2 id="Class-instances"><a href="#Class-instances" class="headerlink" title="Class instances"></a>Class instances</h2><!--Displays a list of class instances by their handle name.[PENDING: add a link to inspecting data values.]--><p>展示类实例列表。</p><h2 id="Memory-actions"><a href="#Memory-actions" class="headerlink" title="Memory actions"></a>Memory actions</h2><p><img src="/images/15952458407426.jpg" alt></p><h3 id="Liveness-of-the-memory-overview-chart"><a href="#Liveness-of-the-memory-overview-chart" class="headerlink" title="Liveness of the memory overview chart"></a>Liveness of the memory overview chart</h3><p><strong>Pause</strong></p><p>暂停 memory overview 以查看当前数据。注意：此时仍然会接收数据；Range selector 继续往右更新。</p><p><strong>Resume</strong></p><p>memory overview 正在运行中，展示最新时间以及最新的内存数据。</p><h3 id="Managing-the-objects-and-statistics-in-the-heap"><a href="#Managing-the-objects-and-statistics-in-the-heap" class="headerlink" title="Managing the objects and statistics in the heap"></a>Managing the objects and statistics in the heap</h3><p><strong>Snapshot</strong></p><p>返回堆中的存活对象列表。Accumulator 那一列展示了上次 reset 后分配对象的数量</p><p><strong>Reset</strong></p><p>重置 Snapshot classes table 中的 Accumulator 列，并刷新数据</p><p><strong>Filter</strong></p><p>Snapshot classes table 只展示选中的 package 下的 class</p><p><strong>GC</strong></p><p>发起 GC</p><!--## Glossary of VM terms--><h2 id="VM-术语汇总"><a href="#VM-术语汇总" class="headerlink" title="VM 术语汇总"></a>VM 术语汇总</h2><!--Here are some computer science concepts that will help you betterunderstand how your application uses memory.--><p>这里是一些有助于你更好理解应用是如何使用内存的计算机科学基础概念。</p><!--<dd>GC is the process of searching the    heap to locate, and reclaim, regions of "dead" memory&mdash;memory    that is no longer being used by an application. This process    allows the memory to be re-used and minimizes the risk of an    application running out of memory, causing it to crash. Garbage    collection is performed automatically by the Dart VM. In DevTools,    you can perform garbage collection on demand by clicking the    GC button.</dd>--><p><dl markdown="1"></dl></p><p><dt markdown="1"><strong>Garbage collection (GC)</strong></dt></p><dd>GC 是指在堆中定位和回收已”死亡”的内存的过程&mdash;即不再被应用使用的内存。这个过程允许内存被重新使用，将应用内存不足导致崩溃的风险最小化。Dart VM 自动回收垃圾。在 DevTools 中可以点击 GC 按钮主动回收垃圾。</dd><br><dt markdown="1"><strong>Heap</strong></dt><br><dd>Dart 对象在内存上动态分配，这块内存称之为堆。堆上分配的对象不再被引用时(由 GC 完成)或应用结束时将会释放。一个对象不被引用时，认为它已死亡。一个对象被引用时，它则是存活的。</dd><br><dt markdown="1"><strong>Isolates</strong></dt><br><dd markdown="1">Dart 通过 isolate 来支持并发。可以将 isolate 理解成无开销的进程。每个 isolate 有自己的内存和代码，它们不会被其他 isolate 影响。详情请参考 [The Event Loop and Dart][event-loop].<br><dt markdown="1"><strong>Memory leak</strong></dt><br><dd>当对象仍然存活(意味着另一个对象引用它)，却不再被使用(即其他对象不应引用它)时认为发生了内存泄漏。这种对象无法被 GC，所以会仍然占用堆空间，导致内存碎片。内存泄漏给 VM 带来不必要的压力，难以调试。</dd><br><dt markdown="1"><strong>Virtual machine (VM)</strong></dt><br><dd>Dart 虚拟机是直接执行 Dart 代码的软件。</dd><p>[embedder]: /flutter/flutter/wiki/Custom-Flutter-Engine-Embedders<br>[vm]: <a href="https://mrale.ph/dartvm/" target="_blank" rel="noopener">https://mrale.ph/dartvm/</a><br>[event-loop]: NaN/articles/archive/event-loop<br>[profile mode]: /docs/testing/build-modes#profile<br>[release mode]: /docs/testing/build-modes#release<br>[debug mode]: /docs/testing/build-modes#debug<br>[Don’t Fear the Garbage Collector]: NaN/flutter-dont-fear-the-garbage-collector-d69b3ff1ca30</p></dd>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart Protobuf 用法简介</title>
      <link href="2020/06/24/dart-protobuf/"/>
      <url>2020/06/24/dart-protobuf/</url>
      
        <content type="html"><![CDATA[<p>简单记录下如何在 Dart 中使用 Protobuf。</p><a id="more"></a><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developers.google.com/protocol-buffers/docs/reference/dart-generated" target="_blank" rel="noopener">Dart Generated Code</a></li><li><a href="https://github.com/dart-lang/protobuf/tree/master/protoc_plugin" target="_blank" rel="noopener">dart-lang/protobuf</a></li></ul><p>注意点：</p><ul><li>Protobuf 编译器依赖独立安装的<a href="https://github.com/dart-lang/dart-protoc-plugin" target="_blank" rel="noopener">Dart 插件</a>来生成 Dart 代码 <a href="https://developers.google.com/protocol-buffers/docs/reference/dart-generated" target="_blank" rel="noopener">参考来源</a></li><li>Dart 要求 Protobuf 编译器版本为 3.0.0 及以上 <a href="https://github.com/dart-lang/protobuf/tree/master/protoc_plugin" target="_blank" rel="noopener">参考来源</a></li><li>Dart 只支持 <a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">proto3</a> scheme <a href="https://github.com/dart-lang/protobuf/tree/master/protoc_plugin" target="_blank" rel="noopener">参考来源</a> <del>Dart 只支持 <a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">proto2</a> scheme <a href="https://github.com/dart-lang/protobuf/tree/master/protoc_plugin" target="_blank" rel="noopener">参考来源</a></del></li></ul><h1 id="安装和编译"><a href="#安装和编译" class="headerlink" title="安装和编译"></a>安装和编译</h1><p>第一步，安装 Protobuf 编译器。可以从 <a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">Protobuf release</a> 页面下载和安装，也可以 <code>brew install protobuf</code> 安装。</p><p>第二步，安装 Protobuf Dart 插件。</p><ul><li>下载<a href="https://github.com/dart-lang/protobuf.git" target="_blank" rel="noopener">代码</a>。<code>git clone https://github.com/dart-lang/protobuf.git</code></li><li><strong>编译插件</strong>。调用 <code>pub install</code> 编译插件，编译后源码 <code>bin</code> 目录下可以找到 <code>proto-gen-dart</code> 文件。如果出错，可以使用 <code>pub --trace install</code> 查看详细错误日志</li><li>使用插件。将插件配置到 PATH 路径中，或者调用 <code>protoc</code> 时使用 <code>--plugin</code> 参数指定插件路径</li></ul><p>第三步，运行 protoc 编译生成 <code>.proto.dart</code> 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  aproj_pub_proj git:(cm) ✗ protoc --proto_path=proto --dart_out=build/gen --plugin=/Users/xxx/Documents/GitHub/protobuf/protoc_plugin/bin proto/aproj/comm_conn.proto</span><br><span class="line">protoc-gen-dart: program not found or is not executable</span><br><span class="line">--dart_out: protoc-gen-dart: Plugin failed with status code 1.</span><br><span class="line">➜  aproj_pub_proj git:(cm) ✗ protoc --proto_path=proto --dart_out=build/gen --plugin=/Users/xxx/Documents/GitHub/protobuf/protoc_plugin/bin/protoc-gen-dart proto/aproj/comm_conn.proto</span><br><span class="line">/Users/kingcmchen/Documents/GitHub/protobuf/protoc_plugin/bin/protoc-gen-dart: line 3: dart: command not found</span><br><span class="line">--dart_out: protoc-gen-dart: Plugin failed with status code 127.</span><br></pre></td></tr></table></figure><ul><li>第一次出错是因为 <code>--plugin</code> 指定的 Dart 插件路径不正确，应当指定具体文件而不是文件所在的目录</li><li>第二次出错是因为 Dart 插件依赖 <code>dart</code> 命令，要确保 PATH 中有配置 <code>dart</code>。 </li></ul><p>PATH 中配置 <code>dart</code> 命令方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DART_PATH=&quot;$HOME/flutter/bin/cache/dart-sdk/bin&quot;</span><br></pre></td></tr></table></figure><p>编译成功！</p><p><img src="media/15635014696032/15635045817933.jpg" alt="-w770"></p><h1 id="发送字符串"><a href="#发送字符串" class="headerlink" title="发送字符串"></a>发送字符串</h1><p>先使用 Dart 实现简单的服务器端 <code>SimpleServer</code> 和客户端 <code>SimpleClient</code>，代码分别如下。</p><p><code>SimpleServer</code> 收到客户端发送的数据，转换成大写的 UTF-8 后发回客户端，并关闭 Socket。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  ServerSocket serverSocket =</span><br><span class="line">      <span class="keyword">await</span> ServerSocket.bind(InternetAddress.anyIPv4, <span class="number">6760</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Started'</span>);</span><br><span class="line"></span><br><span class="line">  serverSocket.listen((Socket socket) &#123;</span><br><span class="line">    socket.listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; event) <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> msg = utf8.decode(event);</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Received <span class="subst">$msg</span>'</span>);</span><br><span class="line">      socket.write(msg.toUpperCase());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">await</span> socket.close();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SimpleClient</code> 向服务器端发送 ‘hello’，并且接收和输出服务器端的响应。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  Socket socket = <span class="keyword">await</span> Socket.connect(<span class="string">'127.0.0.1'</span>, <span class="number">6760</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Connected'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// listen to the received data event stream</span></span><br><span class="line">  socket.listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; event) &#123;</span><br><span class="line">    <span class="built_in">print</span>(utf8.decode(event));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send hello</span></span><br><span class="line">  socket.add(utf8.encode(<span class="string">'hello'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait 5 seconds</span></span><br><span class="line">  <span class="keyword">await</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .. and close the socket</span></span><br><span class="line">  socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="发送-Protobuf-数据"><a href="#发送-Protobuf-数据" class="headerlink" title="发送 Protobuf 数据"></a>发送 Protobuf 数据</h1><p>如何在使用 Protobuf 数据在 <code>SimpleServer</code> 和 <code>SimpleClient</code> 之间通信？</p><p>注意，生成的 <code>.pb.dart</code> 文件中有如下 <code>import</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:fixnum/fixnum.dart&apos;;</span><br><span class="line">import &apos;package:protobuf/protobuf.dart&apos; as $pb;</span><br></pre></td></tr></table></figure><p>所以相应地需要在 <code>pubspec.yaml</code> 中添加对应的依赖。</p><p>第一步，为工程添加 <code>fixnum</code> 和 <a href="https://pub.dev/packages/protobuf" target="_blank" rel="noopener">protobuf</a> 依赖。添加后记得运行 <code>flutter pb get</code> 同步一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  http: 0.12.0+2</span><br><span class="line">  fixnum: 0.10.9</span><br><span class="line">  protobuf: 0.13.15</span><br></pre></td></tr></table></figure><p>第二步，将生成的 <code>.pb.dart</code> 文件拷贝到工程，供 <code>SimpleServer</code> 和 <code>SimpleClient</code> 引用。</p><p>第三步，修改服务器端 <code>SimpleServer</code> 和客户端 <code>SimpleClient</code> 代码，使用 Protobuf 通信。修改后的代码分别如下：</p><p><code>SimpleServer</code> 收到客户端发送的 Protobuf 数据并以 JSON 格式打印出来，然后向客户端发送 Protobuf 数据 <code>CommRsp</code>，最后关闭 Socket。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'comm_conn.pb.dart'</span>;</span><br><span class="line"></span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  ServerSocket serverSocket =</span><br><span class="line">      <span class="keyword">await</span> ServerSocket.bind(InternetAddress.anyIPv4, <span class="number">6760</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Started'</span>);</span><br><span class="line"></span><br><span class="line">  serverSocket.listen((Socket socket) &#123;</span><br><span class="line">    socket.listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; event) <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> msg = CommReq.fromBuffer(event).writeToJson();</span><br><span class="line"></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Received <span class="subst">$msg</span>'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> rsp = CommRsp.create();</span><br><span class="line">      rsp.cmd = <span class="number">0</span>;</span><br><span class="line">      rsp.result = <span class="number">0</span>;</span><br><span class="line">      rsp.uid = <span class="string">'41006'</span>;</span><br><span class="line">      <span class="comment">// socket.write(writeToBuffer);</span></span><br><span class="line">      socket.add(rsp.writeToBuffer());</span><br><span class="line">      socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SimpleClient</code> 向服务器端发送 Protobuf 数据 <code>CommReq</code>，并且接收和打印服务器端的响应。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'comm_conn.pb.dart'</span>;</span><br><span class="line"></span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  Socket socket = <span class="keyword">await</span> Socket.connect(<span class="string">'127.0.0.1'</span>, <span class="number">6760</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Connected'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// listen to the received data event stream</span></span><br><span class="line">  socket.listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; event) &#123;</span><br><span class="line">    <span class="built_in">print</span>(CommRsp.fromBuffer(event));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send hello</span></span><br><span class="line">  <span class="keyword">var</span> req = CommReq.create();</span><br><span class="line">  req.cmd = <span class="number">0</span>;</span><br><span class="line">  req.uid = <span class="string">'cm'</span>;</span><br><span class="line">  req.ext1 = <span class="string">'hello'</span>;</span><br><span class="line">  socket.add(req.writeToBuffer());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .. and close the socket</span></span><br><span class="line">  <span class="keyword">await</span> socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意以下两点：</p><ul><li>注意 Protobuf 数据字段分为 required 字段和 optional 字段</li><li>使用 <code>socket.add()</code> 发送数据而不是 <code>socket.write()</code>。注意 <code>socket.write()</code> 先对要发送的数据编码后再调用 <code>socket.add()</code>，实际发送的是编码后的数据</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> write(<span class="built_in">Object</span> obj) &#123;</span><br><span class="line">  <span class="built_in">String</span> string = <span class="string">'<span class="subst">$obj</span>'</span>;</span><br><span class="line">  <span class="keyword">if</span> (string.isEmpty) <span class="keyword">return</span>;</span><br><span class="line">  add(_encoding.encode(string));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何在 Dart 中创建和解析 Protobuf 数据，请参考<a href="https://developers.google.com/protocol-buffers/docs/reference/dart-generated" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart 入门笔记</title>
      <link href="2020/06/23/dart-basic/"/>
      <url>2020/06/23/dart-basic/</url>
      
        <content type="html"><![CDATA[<p>Dart 基础知识笔记。</p><a id="more"></a><h1 id="tour"><a href="#tour" class="headerlink" title="tour"></a>tour</h1><p><a href="http://s0dart0dev.icopy.site/guides/language/language-tour" target="_blank" rel="noopener">http://s0dart0dev.icopy.site/guides/language/language-tour</a></p><ul><li><code>main()</code> 函数是 Dart 程序的入口</li><li><code>main()</code> 函数返回 <code>void</code> 并具有可选的 <code>List&lt;String&gt;</code> 参数作为参数</li><li>所有对象都从 <code>Object</code> 类继承</li><li>Dart 是强类型</li><li>当您想明确地不希望有任何类型时，使用特殊类型 <code>dynamic</code></li><li>Dart 可以在函数内创建函数（ 嵌套 函数或局部函数 ），可以创建匿名函数</li><li>Dart 支持顶级变量</li><li>标识符以下划线（_）开头时表示私有成员变量</li><li>Dart 支持类型推断，<code>var name = &#39;Bob&#39;;</code> 这里的 name 类型推断为 String</li><li>未初始化的变量的初始值为 <code>null</code>，包括数字类型</li><li>Dart 字符串是 UTF-16 代码单元(code unit)的序列，在字符串中表示32位 Unicode 值时需要特殊语法 <code>Runes</code></li><li>在字符串前添加 r 来创建”原始”字符串，<code>var s = r&#39;In a raw string</code></li><li>在Dart中，数组是 <code>List</code> 对象</li><li>Dart 支持集合字面量，<code>var halogens = {&#39;fluorine&#39;, &#39;chlorine&#39;}</code></li><li><code>{}</code> 默认为 Map 类型，<code>var names = {};</code> 创建了 <code>Map</code> 而不是 <code>Set</code></li><li>Dart <code>new</code> 关键字是可选的 (Dart 2开始)</li><li>Dart 中函数也是对象，其类型为 <code>Function</code>，可以将函数分配给变量或作为参数传递给其他函数</li><li>Dart 中的箭头语法 <code>=&gt; expr</code> 用于简化仅包含一个表达式的函数</li><li>Dart 函数可以具有两种类型的参数： required和optional . 首先列出必需的参数，然后列出所有可选参数</li><li>Dart 函数的可选参数可以是命名参数，也可以是位置参数</li><li>Dart 函数可以使用 <code>=</code> 来定义命名参数和位置参数的默认值。默认值必须是编译时常量</li><li><code>~/</code> 返回除法的整数结果</li><li>Dart 中的 <code>switch</code> 语句使用 <code>==</code> 比较整数、字符串、枚举或编译时常量</li><li>Dart的所有异常都是未经检查的异常</li><li>Dart 提供 <code>Exception</code> 和 <code>Error</code> 类型，并且支持将任何非 <code>null</code> 对象作为异常抛出</li><li>某些语言（例如Java）将文件的组织与类的组织联系在一起-每个文件只能定义一个顶级类. Dart没有此限制</li><li>Dart 是一种具有类和基于 Mixin 的继承的面向对象语言</li><li>Object 的 <code>runtimeType</code> 属性返回对象类型</li><li>所有实例变量都会生成一个隐式的 getter 方法. 非 final 的实例变量还会生成隐式的 setter 方法</li><li>Dart 中每个类都隐式定义一个接口</li><li>Dart 泛型在运行时会携带其类型信息 (相反，Java中 的泛型使用了 erasure ，这意味着在运行时会删除泛型类型参数. 在 Java 中，您可以测试对象是否为 List，但不能测试对象是否为 List<string> )</string></li><li>Dart 使用 async 和 await 关键字支持异步编程，使您可以编写看起来类似于同步代码的异步代码</li><li>可以使用 Future API 或 <code>async/await</code> 关键字处理 Future 结果</li><li>可以使用 Stream API 或 <code>await for</code> 处理 Stream 结果</li><li>仅 dart2js 支持延迟加载库. Flutter，Dart VM和dartdevc不支持延迟加载</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟导入库</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:greetings/hello.dart'</span> <span class="keyword">deferred</span> <span class="keyword">as</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用库</span></span><br><span class="line">Future greet() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> hello.loadLibrary();</span><br><span class="line">  hello.printGreeting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>开发过程中可以使用 <code>assert(condition , optionalMessage)</code> 断言，检查某些条件是否为真。断言通常由工具或框架决定是否生效：</p><ul><li>Flutter 在 debug 模式下启用断言</li><li>默认情况下，仅开发工具（例如 <a href="http://s0dart0dev.icopy.site/tools/dartdevc" target="_blank" rel="noopener">dartdevc</a>）启用断言</li><li>某些工具，比如 <a href="http://s0dart0dev.icopy.site/server/tools/dart-vm" target="_blank" rel="noopener">dart</a> 通过 <code>--enable-asserts</code> 标志启用断言</li></ul><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>Dart 中的构造函数跟 Java 中的构造函数还是有不小的区别，所以值得独立作为一节来讨论。</p><p>这里先列出了 Dart 构造函数相关的一些术语。</p><ul><li>Default constructors</li><li>Named constructors</li><li>Initializer list</li><li>Redirecting constructors</li><li>Constant constructors</li><li>Factory constructors</li></ul><p>如果你清楚这些术语，说明你已经基本掌握了 Dart 构造函数，完全可以略过本节。如果不清楚，不妨往下看。</p><p>Dart 中通过创建一个与其类具有相同名称的函数来声明一个构造函数。可以很方便地将构造函数参数赋值给实例变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Syntactic sugar for setting x and y</span></span><br><span class="line">  <span class="comment">// before the constructor body runs.</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dart 中使用命名构造函数可为一个类实现多个构造函数或提供额外的清晰度：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Named constructor</span></span><br><span class="line">  Point.origin() &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建函数的执行顺序如下：</p><ul><li>初始化列表</li><li>超类的无参数构造函数</li><li>主类的无参数构造函数</li></ul><p>注意：如果超类没有未命名，无参数的构造函数，则必须手动调用超类中的构造函数之一</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  Employee() : <span class="keyword">super</span>.fromJson(getDefaultData());</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现并非总是创建其类的新实例的构造函数时，要使用 <code>factory</code> 关键字。示例如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _cache is library-private, thanks to</span></span><br><span class="line">  <span class="comment">// the _ in front of its name.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache =</span><br><span class="line">      &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">return</span> _cache.putIfAbsent(</span><br><span class="line">        name, () =&gt; Logger._internal(name));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mute) <span class="built_in">print</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h1><p>每个类都隐式定义一个接口。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A person. The implicit interface contains greet().</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// In the interface, but visible only in this library.</span></span><br><span class="line">  <span class="keyword">final</span> _name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not in the interface, since this is a constructor.</span></span><br><span class="line">  Person(<span class="keyword">this</span>._name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In the interface.</span></span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">'Hello, <span class="subst">$who</span>. I am <span class="subst">$_name</span>.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An implementation of the Person interface.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Impostor</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> _name =&gt; <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">'Hi <span class="subst">$who</span>. Do you know who I am?'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h1><p>Mixins是在多个类层次结构中重用类代码的一种方式。</p><p>首先看如何实现 mixin。使用 <code>mixin</code> 关键字创建一个扩展自 Object 且不声明构造函数的类。还可以使用 <code>on</code> 关键字来限定可以使用该 mixin 的类</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> Musical &#123;</span><br><span class="line">  <span class="built_in">bool</span> canPlayPiano = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canCompose = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canConduct = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> entertainMe() &#123;</span><br><span class="line">    <span class="keyword">if</span> (canPlayPiano) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Playing piano'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (canConduct) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Waving hands'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Humming to self'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> MusicalPerformer <span class="keyword">on</span> Musician &#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看如何使用 mixin</p><h1 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h1><p>从设计者角度来说是一些锦上添花的语言特性，但从开发者角度来确实很方便。</p><p>类型推断</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">num</span> highScore(<span class="built_in">List</span>&lt;<span class="built_in">num</span>&gt; scores) &#123;</span><br><span class="line">  <span class="keyword">var</span> highest = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> score <span class="keyword">in</span> scores) &#123;</span><br><span class="line">    <span class="keyword">if</span> (score &gt; highest) highest = score;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> highest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展操作符 <code>...</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> list2 = [<span class="number">0</span>, ...list];</span><br><span class="line"><span class="keyword">assert</span>(list2.length == <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>nullable 扩展操作符 <code>...?</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list;</span><br><span class="line"><span class="keyword">var</span> list2 = [<span class="number">0</span>, ...?list];</span><br><span class="line"><span class="keyword">assert</span>(list2.length == <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>命名参数 (Named parameters) <code>paramName : value</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义命名参数</span></span><br><span class="line"><span class="comment">/// Sets the [bold] and [hidden] flags ...</span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定命名参数</span></span><br><span class="line">enableFlags(bold: <span class="keyword">true</span>, hidden: <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>位置参数 (Positional parameters) </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用[]标记一组可选的位置参数</span></span><br><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>级联操作符 <code>..</code>。这个操作符可以节省创建临时变量的步骤。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">querySelector</span>(<span class="string">'#sample_text_id'</span>)</span><br><span class="line">    ..text = <span class="string">'Click me!'</span></span><br><span class="line">    ..onClick.listen(reverseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="string">'apples'</span>, <span class="string">'bananas'</span>, <span class="string">'oranges'</span>];</span><br><span class="line">list.forEach((item) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;list.indexOf(item)&#125;</span>: <span class="subst">$item</span>'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>??=</code> 操作符。这个操作符让代码更简洁</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assign value to b if b is null; otherwise, b stays the same</span></span><br><span class="line">b ??= value;</span><br></pre></td></tr></table></figure><p><code>??</code> 操作符。这个操作符让代码更简洁</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 name 为 null 则返回 'Guest'</span></span><br><span class="line"><span class="built_in">String</span> playerName(<span class="built_in">String</span> name) =&gt; name ?? <span class="string">'Guest'</span>;</span><br></pre></td></tr></table></figure><p><code>?.</code> 操作符，表示有条件的成员访问，最左边的操作数可以为 null</p><p>typedef 用于给函数类型提供一个名称</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Compare = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedCollection</span> </span>&#123;</span><br><span class="line">  Compare compare;</span><br><span class="line"></span><br><span class="line">  SortedCollection(<span class="keyword">this</span>.compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initial, broken implementation.</span></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  SortedCollection coll = SortedCollection(sort);</span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> <span class="built_in">Function</span>);</span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> Compare);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h1><ul><li>使用 <code>operator</code> 来重载操作符</li><li>noSuchMethod</li><li>callable class。对于实现了 <code>call()</code> 方法的类，可以像调用函数一样调用该类的实例</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://renato.athaydes.com/posts/interesting-dart-features.html#quick-dart-overview" target="_blank" rel="noopener">https://renato.athaydes.com/posts/interesting-dart-features.html#quick-dart-overview</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 引擎编译、运行与调试</title>
      <link href="2020/06/10/compile-flutter-engine/"/>
      <url>2020/06/10/compile-flutter-engine/</url>
      
        <content type="html"><![CDATA[<p>介绍 Flutter 引擎编译、运行与调试的操作步骤。<br><a id="more"></a></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ul><li>安装 <a href="https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html#_setting_up" target="_blank" rel="noopener"><code>depot_tools</code></a> 并<font color="red">添加到环境变量</font>。<code>gclient</code> 来自 depot_tools 工具</li><li>fork <a href="https://github.com/flutter/engine" target="_blank" rel="noopener">flutter/engine</a> (注意配置 ssh 访问)</li><li>创建空的 <code>engine</code> 目录并在目录中创建 <code>.gclient</code> 配置文件</li><li>在 <code>engine</code> 目录中执行 <code>gclient sync</code> (它会 <code>git clone</code> 必要的项目及其依赖)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line"><span class="built_in">export</span> PATH=/path/to/depot_tools:<span class="variable">$PATH</span></span><br><span class="line">mkdir engine</span><br><span class="line"><span class="built_in">cd</span> engine</span><br><span class="line">touch .gclient</span><br><span class="line"></span><br><span class="line"><span class="comment"># edit .gclient</span></span><br><span class="line">gclient sync</span><br></pre></td></tr></table></figure><p><code>.gitclient</code> 配置如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">solutions = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"managed"</span>: False,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"src/flutter"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"https://github.com/&lt;your_name&gt;/engine.git"</span>,</span><br><span class="line">    <span class="attr">"custom_deps"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"deps_file"</span>: <span class="string">"DEPS"</span>,</span><br><span class="line">    <span class="attr">"safesync_url"</span>: <span class="string">""</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><font color="red">切换源码</font>。编译前的一个重要操作是将源码切换到 <strong>本地 Flutter SDK</strong> 的 engine version  (一个 commit id) 对应的提交点，避免可能出现的报错</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地 Flutter SDK 引擎版本, 这个文件中是包含对应的 commit id </span></span><br><span class="line">vim src/flutter/bin/internal/engine.version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整代码</span></span><br><span class="line"><span class="built_in">cd</span> engine/src/flutter</span><br><span class="line">git reset --hard &lt;commit id&gt;</span><br><span class="line">gclient sync -D --with_branch_heads --with_tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备构建文件</span></span><br><span class="line"><span class="built_in">cd</span> engine/src</span><br><span class="line"></span><br><span class="line"><span class="comment"># flutter 1.12 使用以下命令生成 host_debug_unopt 编译配置</span></span><br><span class="line"><span class="comment"># ./flutter/tools/gn --runtime-mode debug</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># flutter 1.17 使用以下命令生成 host_debug_unopt 编译配置</span></span><br><span class="line">./flutter/tools/gn --unoptimized</span><br><span class="line"></span><br><span class="line"><span class="comment"># android arm (armeabi-v7a) 编译配置</span></span><br><span class="line">./flutter/tools/gn --android --unoptimized</span><br><span class="line"></span><br><span class="line"><span class="comment"># android arm64 (armeabi-v8a) 编译配置</span></span><br><span class="line">./flutter/tools/gn --android --unoptimized --runtime-mode=debug --android-cpu=arm64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">ninja -C out/host_debug_unopt -j 16</span><br><span class="line">ninja -C out/android_debug_unopt -j 16</span><br><span class="line">ninja -C out/android_debug_unopt_arm64 -j 16</span><br></pre></td></tr></table></figure><p>尤其注意这里的 <code>ninja -C out/host_debug_unopt</code> 命令。官方文档提到它是必要的：</p><blockquote><p>Note that if you use particular android or ios engine build, you will need to have corresponding host build available next to it: if you use android_debug_unopt, you should have built host_debug_unopt, android_profile -&gt; host_profile, etc.</p></blockquote><p>这个命令的编译结果包含 <code>dart-sdk</code>，使用自己构建的 Flutter 引擎编译 App 时会调用 <code>dart-sdk</code> 中相关工具。</p><p>编译完成后的目录如下：</p><p><img src="/images/15917899522184.jpg" alt="编译后的Flutter产物"></p><h2 id="常见编译问题"><a href="#常见编译问题" class="headerlink" title="常见编译问题"></a>常见编译问题</h2><p>编译 Flutter 其实并不复杂，运气好的话不会遇到任何问题，运气不好的话会遇到一些错误。不过出错通常是因为环境问题。</p><p>如果遇到错误，不妨先检查以下几项：</p><ul><li>确认当前使用的是 <font color="red">Python 2.7</font> - <code>flutter/tools/gn</code> 依赖的是 Python 2。如果当前环境中使用 Python 3 会出现各种诡异错误</li><li>确认已经将 <code>depot_tools</code> 工具添加到环境变量 - <code>depot_tools</code> 工具包含几个用于编译 Flutter 引擎的命令 <code>gclient</code> 和 <code>ninja</code>。如果找不到这些命令，也会编译失败</li><li>切换引擎源码 - Flutter 引擎源码和本地 Flutter SDK 不匹配时可能会编译失败，编译前应确认已经将 Flutter 引擎源码切换到对应的提交点</li></ul><h3 id="Python-版本问题"><a href="#Python-版本问题" class="headerlink" title="Python 版本问题"></a>Python 版本问题</h3><p>这里简单记录一下我<strong>编译 Flutter 引擎时遇到的 Python 版本问题及解决方法</strong>。如果你没有遇到 Python 版本问题，可以直接忽略这一节。</p><p>我的 MacBook 系统内置了 Python 2.7，安装的第三方软件 Anaconda 自带的 Python 3.7。命令行下 <code>python</code> 默认的是 Anaconda 的 Python 3.7，不做任何处理时调用 <code>flutter/tools/gn</code> 会报 Python 语法错误。</p><p>推荐使用 <a href="https://pypi.org/project/virtualenv/" target="_blank" rel="noopener">virtualenv</a> 来为 Flutter 引擎源码工程创建虚拟的 Python 2.7 环境，激活该环境后再来编译 Flutter 源码，可以有效避免各种 Python 版本折腾。操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到 Flutter 引擎源码目录</span></span><br><span class="line"><span class="built_in">cd</span> path/to/engine/<span class="built_in">source</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建名为 myenv 的 Python 2.7 环境</span></span><br><span class="line">virtualenv -p /usr/bin/python myenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活 myenv 环境</span></span><br><span class="line"><span class="built_in">source</span> myenv/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 Flutter 引擎</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 myenv 环境</span></span><br><span class="line">deactivate</span><br></pre></td></tr></table></figure><h3 id="缺省头文件"><a href="#缺省头文件" class="headerlink" title="缺省头文件"></a>缺省头文件</h3><p>在云主机(Centos 7)上编译 Flutter 引擎源码时，glfw 库报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">../../third_party/glfw/src/x11_platform.h:39:10: fatal error: &apos;X11/Xcursor/Xcursor.h&apos; file not found</span><br><span class="line">#include &lt;X11/Xcursor/Xcursor.h&gt;</span><br><span class="line">         ^~~~~~~~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure><p><a href="https://www.glfw.org/docs/latest/compile.html#compile_deps_x11" target="_blank" rel="noopener">glfw</a> 提到解决办法如下：</p><blockquote><p> For example, on Ubuntu and other distributions based on Debian GNU/Linux, you need to install the xorg-dev package, which pulls in all X.org header packages.</p></blockquote><p>安装相关的库即可，方式如下(你可能要根据实际情况调整)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install libX11-devel</span><br><span class="line">yum install libXcursor-devel</span><br><span class="line">yum install libXrandr-devel</span><br><span class="line">yum install libXxf86vm-devel</span><br></pre></td></tr></table></figure><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><h2 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>命令行中使用自定义引擎：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 Flutter 工程</span></span><br><span class="line">flutter create --org com.yourdomain your_app_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用本地引擎运行 Flutter App</span></span><br><span class="line">flutter run</span><br><span class="line">  --<span class="built_in">local</span>-engine-src-path &lt;engine path&gt;/src</span><br><span class="line">  --<span class="built_in">local</span>-engine=android_debug_unopt_arm64</span><br></pre></td></tr></table></figure><p>IDE 中使用自定义引擎：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 Flutter 工程</span></span><br><span class="line">flutter create --org com.yourdomain your_app_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Android Studio 中打开 以上工程</span></span><br><span class="line"><span class="comment"># 注意这里是 Android 工程视角，即打开目录为  your_app_name/android</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 gradle.properties 文件中添加 localEngineOut 属性</span></span><br></pre></td></tr></table></figure><p>在 gradle.properties 文件中添加 localEngineOut 属性，配置如下：</p><p><img src="/images/15919469811663.jpg" alt="配置 localEngineOut"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localEngineOut=&lt;engine_dir&gt;/out/android_debug_unopt_arm64</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>应当指定的本地引擎应当跟 Android 系统架构匹配，比如 armeabi-v8a 机器上使用 <code>android_debug_unopt_arm64</code></li><li>尤其注意<font color="red">某些项目通过自行将 Flutter SDK <code>libflutter.so</code> 拷贝到代码库的方式来集成 Flutter，这会导致上述方式失效，实际运行时并不会加载指定的本地引擎</font>。解决方法是将拷贝对应的目录下(如 <code>android_debug_unopt_arm64</code>)的 <code>libflutter.so</code> 覆盖代码库中已有有 <code>libflutter.so</code> 即可</li></ul><h2 id="常见运行错误"><a href="#常见运行错误" class="headerlink" title="常见运行错误"></a>常见运行错误</h2><p>最常见的问题是找不到指定的引擎导致无法运行 Flutter App。原因通常包括：</p><ul><li>引擎文件路径写错</li><li>架构不匹配。以我手头的测试机华为 Nova 2 为例，它要求使用 arm64 类型的引擎，而我编译时没有注意到这一点，选择的是 arm 类型，最后发现引擎架构不匹配</li><li>缺少 <code>host</code> 产物。错误提示如下图</li></ul><p><img src="/images/15917910631520.jpg" alt></p><p>我自己遇到另外一个比较奇特的错误，通常应该不会遇到，但这里也记录下供参考。</p><p>事情经过是这样的：我的 MacBook 硬盘只有 256G，目前空间已经偏紧张，考虑编译 Flutter 引擎占 CPU 影响本地机器性能外加占用太多硬盘空间，所以我突发奇想。</p><ul><li>首先在个人的 Linux 云主机上编译 Flutter 引擎(果然比本地快很多)</li><li>然后将 Linux 云主机的硬盘挂在 MacBook 当本地文件使用</li><li>最后使用远程机器上的 Flutter 引擎运行 App：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载远程机器目录</span></span><br><span class="line">sshfs root@dev-host:/data/github/ ~/RemoteMount</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用远程机器上的 Flutter 引擎</span></span><br><span class="line">flutter run --<span class="built_in">local</span>-engine-src-path ~/RemoteMount/src --<span class="built_in">local</span>-engine=android_debug_unopt_arm6</span><br></pre></td></tr></table></figure><p>最后出错，错误信息如下：</p><p><img src="/images/15917915426079.jpg" alt="无法执行 dart 命令"></p><p>无法执行 dart 命令！Mac 系统当然无法执行 Linux 平台的二进制文件。</p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>断点调试 Flutter 引擎来一步步观察引擎代码如何运行，是学习 Flutter 引擎代码的一个好办法。在介绍如何调试 Flutter 引擎前我们先来看看 Flutter 开发中可能遇到哪些调试场景：</p><ol><li>调试 Flutter App Dart 代码</li><li>调试 Flutter SDK Dart 代码</li><li>调试 Flutter 引擎 Java 代码</li><li>调试 Flutter 引擎 C++ 代码</li></ol><p>第一种场景非常简单，只要在 VS Code 中给 Flutter App 中的 Dart 代码打上断点即可进行调试。</p><p>第二种场景也比较简单，在 VS Code 中配置 Dart &amp; Flutter 插件，允许调试第三方库和 Flutter SDK Dart 代码即可在相关源码中设置断点进行调试</p><p><img src="/images/15919475359354.jpg" alt="允许调试第三方库"></p><h2 id="调试-Java-代码"><a href="#调试-Java-代码" class="headerlink" title="调试 Java 代码"></a>调试 Java 代码</h2><p>再来看第三种场景，调试 Flutter 引擎中的 Java 代码。主要是参考以下资料(建议动手操作一下)：</p><ul><li><a href="https://github.com/flutter/flutter/wiki/Debugging-the-engine#debugging-android-builds-with-android-studio" target="_blank" rel="noopener">Debugging Android builds with Android Studio</a> </li></ul><p>步骤如下：</p><ul><li>第一步，将 <code>engine/src/flutter/shell/platform/android</code> 工程(称之为<em>Flutter 引擎工程</em>)导入到 Android Studio。注意一定是这个目录！另外，确认该工程的 Android SDK 和 JDK 版本正确 (当前分别是 29 和 8)</li><li>第二步，使用自定义 Flutter 引擎运行 Flutter App(称之为<em>Flutter App 工程</em>)，具体见上文描述</li><li>第三步，<em>Flutter 引擎工程</em> 中给源码设置断点并启动 Debugger 连接到已启动的 Flutter App 进程</li></ul><p>各步骤的截图如下：</p><p>第一步，<em>Flutter 引擎工程</em>导入到 Android</p><p><img src="/images/15917938999628.jpg" alt="导入引擎工程"></p><p><img src="/images/15917940191380.jpg" alt="引擎工程结构"></p><p>第二步，Android Studio 中打开<em>Flutter App 工程</em> 并启动 Flutter App</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 创建 Flutter App</span><br><span class="line">flutter create --org com.yourdomain your_app_name</span><br><span class="line"></span><br><span class="line"># 在 Android Studio 中打开 Flutter App 工程</span><br><span class="line"># 注意工程路径是 your_app_name/android</span><br></pre></td></tr></table></figure><p><img src="/images/15919478792182.jpg" alt="Android Studio 中启动 Flutter App"></p><p>第三步，在 <em>Flutter 引擎工程</em> 将 Debugger 连接到已启动 Flutter App</p><p><img src="/images/15917949940372.jpg" alt="AttachDebugger"></p><p><img src="/images/15917950421254.jpg" alt="选择应用进程"></p><p><img src="/images/15917952600049.jpg" alt="进入调试状态"></p><p>有时候，我们想在更早的地方设置断点调试，比如在 libflutter.so 被加载前加断点调试，如何实现？</p><p>技巧在于第二步启动 Flutter App 时选择一个 <em>合适的时机</em>(通常是在断点之前) 调用 <a href="https://developer.android.com/reference/android/os/Debug.html#waitForDebugger(" target="_blank" rel="noopener">Debug.waitForDebugger</a>) 方法让应用启动后进入等待 Debugger 的状态。</p><p>示例：在 <code>Application.onCreate()</code> 中调用 <code>Debug.waitForDebugger()</code>，应用一直处于等待状态，直到有 Debugger 连接上来才继续执行。</p><p><img src="/images/15917945368597.jpg" alt="让应用等待Debugger"></p><p><img src="/images/15917947943674.jpg" alt="应用等待Debugger中"></p><h2 id="调试-C-代码"><a href="#调试-C-代码" class="headerlink" title="调试 C++ 代码"></a>调试 C++ 代码</h2><p>最后来看怎样调试 Flutter 引擎 C++ 代码。主要参考资料是：</p><ul><li><a href="https://fucknmb.com/2019/12/06/Flutter-Engine-C-%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2/" target="_blank" rel="noopener">Flutter Engine C++ 源码调试初探 | 区长</a></li><li><a href="https://xinbaos.github.io/Flutter%20Engine%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/" target="_blank" rel="noopener">Flutter Engine源码调试 | xinbao的书屋</a></li></ul><p>简单来说，是使用 lldb 来调试 Flutter 引擎 C++ 代码。可以使用不同的方式来完成 lldb 调试，但实际操作起都比较麻烦。</p><p>个人理解主要麻烦之处在于，一是如何将 <code>lldb_server</code> 推送到开发设备并运行起来，二是如何从开发机正确地启动 <code>lldb_client</code>。</p><p>从这些麻烦的方法中，我选择了一个相对简单的动手实践了一下并加以总结。步骤概括如下：</p><table><thead><tr><th>步骤</th><th>操作</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>第一步</td><td>编译 Flutter 引擎</td><td>生成自定义引擎用于调试</td><td></td></tr><tr><td>第二步</td><td>导入 Flutter 引擎源码到 VS Code</td><td>支持 Flutter 引擎源码跳转及断点跟踪</td><td>后文称<em>VS Code Flutter 引擎工程</em></td></tr><tr><td>第三步</td><td>安装 VS Code 插件 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools" target="_blank" rel="noopener">C/C++ for Visual Studio Code</a> 和 <a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb" target="_blank" rel="noopener">CodeLLDB</a></td><td>在 VS Code 中集成 lldb 调试功能</td><td></td></tr><tr><td>第四步</td><td>安装 <a href="https://mirrors.tencent.com/AndroidSDK/" target="_blank" rel="noopener">lldb</a> 和 <a href="https://github.com/lizhangqu/flutter_lldb" target="_blank" rel="noopener">flutter_lldb</a></td><td>1、lldb 用于调试 C++ 代码，2、flutter_lldb 用于简化 lldb 的使用</td><td></td></tr><tr><td>第五步</td><td>运行 Flutter App</td><td>加载和运行自定义引擎</td><td><code>flutter run</code> 或 Android Studio 中运行均可</td></tr><tr><td>第六步</td><td>执行 <code>flutter_lldb</code> 命令</td><td>1、生成调试配置参数，2、在调试设备上启动 <code>lldb_server</code></td><td></td></tr><tr><td>第七步</td><td><em>VS Code Flutter 引擎工程</em> 中配置 lldb 调试配置参数</td><td></td><td></td></tr><tr><td>第八步</td><td><em>VS Code Flutter 引擎工程</em> 中设置断点，F5 启动调试</td><td></td></tr></tbody></table><p>为了便于理解和动手操作操作，这里给出一些截图。</p><p>第一步，编译 Flutter 引擎。注意确认已生成 <code>out/host_debug_unopt</code></p><p><img src="/images/15917899522184.jpg" alt="编译后的Flutter产物"></p><p>第二步，导入 Flutter 引擎源码到 VS Code</p><ul><li>先将 <a href="[JSON Compilation Database Format Specification](https://clang.llvm.org/docs/JSONCompilationDatabase.html">engine/src/out/compile_commands.json</a>) 拷贝到 <code>engine/src/flutter/</code></li><li>VS Code 中打开 <code>engine/src/flutter/</code></li></ul><p>第三步，安装 VS Code 插件，集成 lldb 调试功能</p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools" target="_blank" rel="noopener">C/C++ for Visual Studio Code</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb" target="_blank" rel="noopener">CodeLLDB</a></li></ul><p><img src="/images/15920201317113.jpg" alt></p><p>第四步，安装 <a href="https://mirrors.tencent.com/AndroidSDK/" target="_blank" rel="noopener">lldb</a> 和 <a href="https://github.com/lizhangqu/flutter_lldb" target="_blank" rel="noopener">flutter_lldb</a>。</p><p>注意：</p><ul><li>lldb 安装在 Android SDK 中。如 Android SDK 已有 lldb，则可略过这一步</li><li>有一个坑，目前 Android Studio 内置 lldb，但却并不安装在 Android SDK 中，所以外部工具无法方便地调用 AS 内置 lldb，而 Android SDK Manager 软件列表中目前不再提供 lldb 安装，所以只能手工下载和安装 <a href="https://mirrors.tencent.com/AndroidSDK/" target="_blank" rel="noopener">lldb</a> </li></ul><p><img src="/images/15919488081458.jpg" alt></p><p>第五步，运行 Flutter App</p><p>第六步，执行 <code>flutter_lldb</code> 命令</p><p><img src="/images/15919495376462.jpg" alt></p><p><code>flutter_lldb</code> 输出的配置参数类似如下这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"remote_lldb"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"lldb"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"attach"</span>,</span><br><span class="line">            <span class="attr">"pid"</span>: <span class="string">"28006"</span>,</span><br><span class="line">            <span class="attr">"initCommands"</span>: [</span><br><span class="line">                <span class="string">"platform select remote-android"</span>,</span><br><span class="line">                <span class="string">"platform connect unix-abstract-connect:///data/data/com.yourdomain.your_app_name/debug.socket"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"postRunCommands"</span>: [</span><br><span class="line">                <span class="string">"add-dsym /Users/abc/wd/engine/src/out/android_debug_unopt_arm64/libflutter.so"</span>,</span><br><span class="line">                <span class="string">"settings set target.source-map /Users/abc/wd/engine/src /Users/chenming/wd/engine/src"</span></span><br><span class="line">            ],</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>flutter_lldb</code> 脚本基于 Python 2.7，使用前请确认当前 Python 环境</li><li><code>flutter_lldb</code> 脚本与调试设备通信，使用前请确认<font color="red">已连接调试设备且已启动应用</font></li></ul><p>第七步，在 VS Code 中配置 lldb 命令调试参数。直接将上一步中 <code>flutter_lldb</code> 输出的配置参数拷贝到 <code>launch.json</code> 中即可</p><p><img src="/images/15919505100224.jpg" alt></p><p>第八步，<em>VS Flutter 引擎工程</em> 中设置断点，F5 启动调试</p><p>一切正常的话，Debugger 将成功连接应用进程，进入调试状态，如下图：</p><p><img src="/images/15919523220636.jpg" alt="进t入调试状态"></p><p>Debug Console 输出显示已经成功连接到指定的进程</p><p><img src="/images/15919524582827.jpg" alt="成功连接指定的进程"></p><p>千万不要被上述繁琐的步骤吓到了。实际上，第一步到第四步只是准备阶段(只需准备一次)，第五步到第八步才是真正的操作步骤(调试时需反复多次操作)。用一张图来总结下第五步到第八步：</p><p><img src="/images/15919533524350.jpg" alt="-w767"></p><p>操作几次之后，你会发现实际过程更简单。其实并不用真的的每次都要重新配置 <code>launch.json</code>，只不过是修改下 pid 而已。</p><p>UPDATE：使用小米手机能正常调试 Flutter 引擎，但华为手机 Nova 2 上可以成功到 <code>Attached to process</code> 却无法进入调试状态。使用 NDK Sample 中的 HelloJNI 华为 Nova 2 验证，发现也不能正常调试，所以推测是华为手机问题。</p><p>(2020-07-24 更新：以下是 iOS 上调试 Flutter 引擎的步骤)</p><ol><li>将 Flutte Engine 工程的 <code>products.xcodeproj</code> 拖进需要调试的 Flutter Demo 工程目录</li><li><code>Genrated.xcconfig</code> 中添加如下配置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FLUTTER_ROOT=$&#123;FlutterSDK 路径&#125;</span><br><span class="line">FLUTTER_APPLICATION_PATH=$&#123;Demo工程路径&#125;</span><br><span class="line">FLUTTER_TARGET=$&#123;Demo工程路径&#125;/lib/main.dart</span><br><span class="line">FLUTTER_BUILD_DIR=build</span><br><span class="line">SYMROOT=$&#123;SOURCE_ROOT&#125;/../build/ios</span><br><span class="line">FLUTTER_FRAMEWORK_DIR=$&#123;Flutter_Engine代码路径&#125;/src/out/ios_debug_sim_unopt</span><br><span class="line">FLUTTER_BUILD_NAME=1.0.0</span><br><span class="line">FLUTTER_BUILD_NUMBER=1</span><br><span class="line">FLUTTER_ENGINE=$&#123;Flutter_Engine代码路径&#125;</span><br><span class="line">LOCAL_ENGINE=$&#123;输出的路径（ios_debug_sim_unopt）&#125;</span><br><span class="line">ARCHS=$&#123;支持的架构(arm64)&#125;</span><br></pre></td></tr></table></figure><p>之后即可单步调试。</p><!-- 详细步骤见 https://docs.qq.com/doc/DR21rc21wZ0dKUFhu --><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>简单介绍如何编译 Flutter 引擎，以及常见问题</li><li>介绍如何从命令行和 IDE 运行自定义 Flutter 引擎，以及常见问题</li><li>简单介绍如何调试 Flutter App 及 Flutter SDK 中的 Dart 代码</li><li>详细介绍如何调试 Flutter 引擎中的 Java 代码和 C++ 代码</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/flutter/flutter/wiki/Compiling-the-engine" target="_blank" rel="noopener">编译 Flutter 引擎</a></li><li><a href="https://www.jianshu.com/p/ff84455fb451" target="_blank" rel="noopener">Flutter Engine与SDK的定制化与编译 - 简书</a></li><li><a href="https://github.com/flutter/flutter/wiki/Debugging-the-engine#debugging-android-builds-with-android-studio" target="_blank" rel="noopener">Debugging the engine · flutter/flutter Wiki</a></li><li><a href="https://fucknmb.com/2019/12/06/Flutter-Engine-C-%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2/" target="_blank" rel="noopener">Flutter Engine C++ 源码调试初探 | 区长</a></li><li><a href="https://xinbaos.github.io/Flutter%20Engine%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/" target="_blank" rel="noopener">Flutter Engine源码调试 | xinbao的书屋</a></li><li><a href="https://zhuanlan.zhihu.com/p/38626359" target="_blank" rel="noopener">调试Flutter Native Engine初探 - 知乎</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart File</title>
      <link href="2020/06/04/dart-file/"/>
      <url>2020/06/04/dart-file/</url>
      
        <content type="html"><![CDATA[<p>简单了解 Dart File 类的用法。</p><a id="more"></a><h1 id="Dart-File-类"><a href="#Dart-File-类" class="headerlink" title="Dart File 类"></a>Dart File 类</h1><p>原文见<a href="https://api.dartlang.org/stable/2.4.0/dart-io/File-class.html" target="_blank" rel="noopener">这里</a></p><p>File 表示文件系统中某个文件的引用。</p><p>File 实例是个对象，它持有 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/path.html" target="_blank" rel="noopener">path</a> 并对其进行操作。可以使用 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/FileSystemEntity/parent.html" target="_blank" rel="noopener">parent</a> getter 获取父目录，<code>parent</code> 属性继承自 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/FileSystemEntity-class.html" target="_blank" rel="noopener">FileSystemEntity</a>。</p><p>使用 pathname 创建新的 File 对象来访问文件系统上的文件。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFile = <span class="keyword">new</span> File(<span class="string">'file.txt'</span>);</span><br></pre></td></tr></table></figure><p>File 类包含操作文件及其内容的方法。使用这些方法，可以打开和关闭文件，读写文件，创建和删除文件，以及检查文件是否存在。</p><p>读写文件时，可以使用 stream (通过 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/openRead.html" target="_blank" rel="noopener">openRead</a>)，随机访问操作 (通过 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/open.html" target="_blank" rel="noopener">open</a>)，或者类似 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/readAsString.html" target="_blank" rel="noopener">readAsString</a> 这样的便捷方法。</p><p>File 类中的方法大部分都有同步和异步两种形式，比如 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/readAsString.html" target="_blank" rel="noopener">readAsString</a> 和 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/readAsStringSync.html" target="_blank" rel="noopener">readAsStringSync</a>。除非有特别的理由，通常应当使用异步方法以避免阻塞程序。</p><p>如果构造 File 对象的 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/path.html" target="_blank" rel="noopener">path</a> 是一个符号链接，而非文件，则 File 类的方法会操作链接指向的最终目标文件。不过，<a href="https://api.dartlang.org/stable/2.4.0/dart-io/FileSystemEntity/delete.html" target="_blank" rel="noopener">delete</a> 和 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/FileSystemEntity/deleteSync.html" target="_blank" rel="noopener">deleteSync</a> 方法除外，这两个方法是对符号链接进行操作。</p><h1 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h1><p>下面示例代码使用异步的 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/readAsString.html" target="_blank" rel="noopener">readAsString</a> 方法读取文件，它将整个文件内容视为一个字符串：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">new</span> File(<span class="string">'file.txt'</span>).readAsString().then((<span class="built_in">String</span> contents) &#123;</span><br><span class="line">    <span class="built_in">print</span>(contents);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更灵活更有用的方法是使用 <a href="https://api.dartlang.org/stable/2.4.0/dart-async/Stream-class.html" target="_blank" rel="noopener">Stream</a> 方式读文件。调用 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/openRead.html" target="_blank" rel="noopener">openRead</a> 方法打开文件，该方法返回 stream，这个 stream 以字节块的方式返回文件数据。可以监听 stream 来获取数据并进行必要的处理。可以继续使用不同的 transformer 操作数据来得到想要的数据格式。</p><p>可以使用 stream 方式来读取大文件，并提供 transformer 来操作数据。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">final</span> file = <span class="keyword">new</span> File(<span class="string">'file.txt'</span>);</span><br><span class="line">  Stream&lt;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;&gt; inputStream = file.openRead();</span><br><span class="line"></span><br><span class="line">  inputStream</span><br><span class="line">    .transform(utf8.decoder)       <span class="comment">// Decode bytes to UTF-8.</span></span><br><span class="line">    .transform(<span class="keyword">new</span> LineSplitter()) <span class="comment">// Convert stream to individual lines.</span></span><br><span class="line">    .listen((<span class="built_in">String</span> line) &#123;        <span class="comment">// Process results.</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'<span class="subst">$line</span>: <span class="subst">$&#123;line.length&#125;</span> bytes'</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      onDone: () &#123; <span class="built_in">print</span>(<span class="string">'File is now closed.'</span>); &#125;,</span><br><span class="line">      onError: (e) &#123; <span class="built_in">print</span>(e.toString()); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h1><p>使用 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/writeAsString.html" target="_blank" rel="noopener">writeAsString</a> 方法写文件。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> filename = <span class="string">'file.txt'</span>;</span><br><span class="line">  <span class="keyword">new</span> File(filename).writeAsString(<span class="string">'some content'</span>)</span><br><span class="line">    .then((File file) &#123;</span><br><span class="line">      <span class="comment">// Do something with the file.</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用 <a href="https://api.dartlang.org/stable/2.4.0/dart-async/Stream-class.html" target="_blank" rel="noopener">Stream</a> 来写入文件。调用 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/openWrite.html" target="_blank" rel="noopener">openWrite</a> 方法打开文件，返回结果是 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/IOSink-class.html" target="_blank" rel="noopener">IOSink</a>，可以向 IOSink 写入数据。记得操作完成后调用 <a href="https://api.dartlang.org/stable/2.4.0/dart-io/IOSink/close.html" target="_blank" rel="noopener">IOSink.close</a> 关闭 sink。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> file = <span class="keyword">new</span> File(<span class="string">'file.txt'</span>);</span><br><span class="line">  <span class="keyword">var</span> sink = file.openWrite();</span><br><span class="line">  sink.write(<span class="string">'FILE ACCESSED <span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>\n'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Close the IOSink to free system resources.</span></span><br><span class="line">  sink.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用-Future"><a href="#使用-Future" class="headerlink" title="使用 Future"></a>使用 Future</h1><p>为避免意外阻塞程序，File 类的一些方法使用 <a href="https://api.dartlang.org/stable/2.4.0/dart-async/Future-class.html" target="_blank" rel="noopener">Future</a> 作为返回值。比如，<a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/length.html" target="_blank" rel="noopener">length</a> 方法用于获取文件长度，返回的是 Future。调用 <code>then</code> 方法注册回调函数，获取到文件长度后会回调这个函数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">final</span> file = <span class="keyword">new</span> File(<span class="string">'file.txt'</span>);</span><br><span class="line"></span><br><span class="line">  file.length().then((len) &#123;</span><br><span class="line">    <span class="built_in">print</span>(len);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 <code>length()</code> 外，其他几个方法也返回 Future，包括：<a href="https://api.dartlang.org/stable/2.4.0/dart-io/FileSystemEntity/exists.html" target="_blank" rel="noopener">exists</a>，<a href="https://api.dartlang.org/stable/2.4.0/dart-io/File/lastModified.html" target="_blank" rel="noopener">lastModified</a>，<a href="https://api.dartlang.org/stable/2.4.0/dart-io/FileSystemEntity/stat.html" target="_blank" rel="noopener">stat</a> 等等。</p><h1 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h1><ul><li><a href="https://www.dartlang.org/dart-by-example/#files-directories-and-symlinks" target="_blank" rel="noopener">Dart by Example</a> provides additional task-oriented code samples that show how to use various API from the Directory class and the related File class.</li><li>I<a href="https://www.dartlang.org/docs/dart-up-and-running/ch03.html#dartio---io-for-command-line-apps" target="_blank" rel="noopener">I/O for Command-Line Apps</a> a section from A Tour of the Dart Libraries covers files and directories.</li><li><a href="https://www.dartlang.org/docs/tutorials/cmdline/" target="_blank" rel="noopener">Write Command-Line Apps</a>, a tutorial about writing command-line apps, includes information about files and directories.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FutureBuilder 与 StreamBuilder</title>
      <link href="2020/06/04/future-builder-stream-builder/"/>
      <url>2020/06/04/future-builder-stream-builder/</url>
      
        <content type="html"><![CDATA[<p>翻译一些 Future 和 FutureBuilder 以及 Stream 和 StreamBuilder 相关的资料。</p><a id="more"></a><h1 id="FutureBuilder"><a href="#FutureBuilder" class="headerlink" title="FutureBuilder"></a>FutureBuilder</h1><p>FutureBuilder 是一个基于 Future 最后一次结果进行构建的 Widget。</p><p>Future 必须在较早的时间点获取，比如 <a href="https://api.flutter.dev/flutter/widgets/State/initState.html" target="_blank" rel="noopener">State.initState</a>、<code>State.didUpdateConfig</code> 或 <a href="https://api.flutter.dev/flutter/widgets/State/didChangeDependencies.html" target="_blank" rel="noopener">State.didChangeDependencies</a>。<font color="red">一定不要在 <a href="https://api.flutter.dev/flutter/widgets/State/build.html" target="_blank" rel="noopener">State.build</a> 或 <a href="https://api.flutter.dev/flutter/widgets/StatelessWidget/build.html" target="_blank" rel="noopener">StatelessWidget.build</a> 方法中构建 FutureBuilder 的同时去获取 Future</font>。如果创建 FutureBuilder 的同时也去创建 Future，FutureBuilder 的父节点每次构建时会导致异步任务也重启。</p><p>Future 结束时调用 <a href="https://api.flutter.dev/flutter/widgets/State/setState.html" target="_blank" rel="noopener">State.setState</a> 以便让 Widget 重建。Flutter 流水线决定如何调用 <a href="https://api.flutter.dev/flutter/widgets/FutureBuilder/builder.html" target="_blank" rel="noopener">builder</a> 回调，该回调接收一个跟时间无关的、代表 Future 交互过程的 snapshot 序列 (receive a timing-dependent sub-sequence of the snapshots that represent the interaction with the future)</p><h2 id="Builder-contract"><a href="#Builder-contract" class="headerlink" title="Builder contract"></a>Builder contract</h2><p>假设 <a href="https://api.flutter.dev/flutter/widgets/FutureBuilder/initialData.html" target="_blank" rel="noopener">initialData</a> 为 null，对于成功结束的 Future <code>builder</code> 被回调两次(<code>waiting</code> 和 <code>done</code>)或一次(<code>done</code>)</p><ul><li><code>waiting</code> - <code>new AsyncSnapshot&lt;String&gt;.withData(ConnectionState.waiting, null)</code></li><li><code>done</code> - <code>new AsyncSnapshot&lt;String&gt;.withData(ConnectionState.done, &#39;some data&#39;)</code></li></ul><p>对于出错的 Future <code>builder</code> 被回调两次(<code>waiting</code> 和 <code>error</code>)或一次 (<code>done</code>)</p><ul><li><code>waiting</code> - <code>new AsyncSnapshot&lt;String&gt;.withData(ConnectionState.waiting, null)</code></li><li><code>error</code> - <code>new AsyncSnapshot&lt;String&gt;.withError(ConnectionState.done, &#39;some error&#39;)</code></li></ul><p>通过 <a href="https://api.flutter.dev/flutter/widgets/FutureBuilder/initialData.html" target="_blank" rel="noopener">initialData</a> 来指定初始的 snapshot (initial snapshot data)。使用这个字段来保证 <code>builder</code> 在 Future 结束之前也被调用一次，这时的 snapshot 持有的值即 <code>initialData</code> 而非缺省的 <code>null</code>。</p><p>The data and error fields of the snapshot change only as the connection state field transitions from waiting to done, and they will be retained when changing the FutureBuilder configuration to another future. If the old future has already completed successfully with data as above, changing configuration to a new future results in snapshot pairs of the form:</p><p>只在连接状态字段 (the connection state field) 从 <code>waiting</code> 变成 <code>done</code> 时 snapshot 的 <code>data</code> 和 <code>error</code> 字段才会变化。FutureBuilder 的 future 由原先切换成新的 future 时 <code>data</code> 和 <code>error</code> 并不变化。</p><p>If the old future has already completed successfully with data as above, changing configuration to a new future results in snapshot pairs of the form:</p><p>仅当旧的 future 成功结束时，切换到一个新的 Future 才会导致出现如下变化：</p><ul><li><code>new AsyncSnapshot&lt;String&gt;.withData(ConnectionState.none, &#39;data of first future&#39;)</code></li><li><code>new AsyncSnapshot&lt;String&gt;.withData(ConnectionState.waiting, &#39;data of second future&#39;)</code></li></ul><p>In general, the latter will be produced only when the new future is non-null, and the former only when the old future is non-null.</p><p>A FutureBuilder behaves identically to a StreamBuilder configured with future?.asStream(), except that snapshots with ConnectionState.active may appear for the latter, depending on how the stream is implemented.</p><h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>原文见<a href="https://itnext.io/how-to-use-streams-in-dart-part-1-4503fec0cdd7" target="_blank" rel="noopener">这里</a>。</p><p>对多数想要深入了解 Dart (或者有类似概念)的程序员来说 Stream 是个理解起来有挑战的话题，因为想要弄懂这个概念需要尝试一些例子。本文尝试讲清 Dart Stream 的用法，并且在系列文章中构建一些能感知的例子加强理解。</p><h2 id="Dart-Stream-用法"><a href="#Dart-Stream-用法" class="headerlink" title="Dart Stream 用法"></a>Dart Stream 用法</h2><p>原文见<a href="https://itnext.io/how-to-use-streams-in-dart-part-1-4503fec0cdd7" target="_blank" rel="noopener">这里</a>。</p><p>对多数想要深入了解 Dart (或者有类似概念)的程序员来说 Stream 是个理解起来有挑战的话题，因为想要弄懂这个概念需要尝试一些例子。本文尝试讲清 Dart Stream 的用法，并且在系列文章中构建一些能感知的例子加强理解。</p><h2 id="Stream-是什么"><a href="#Stream-是什么" class="headerlink" title="Stream 是什么"></a>Stream 是什么</h2><p>Dart 官方文档中是这样定义 Stream 的：</p><blockquote><p>A source of asynchronous data events. A Stream provides a way to receive a sequence of events. Each event is either a data event, also called an element of the stream, or an error event, which is a notification that something has failed. When a stream has emitted all its event, a single “done” event will notify the listener that the end has been reached.</p><p>api.dartlang.org</p></blockquote><p>翻译如下(发现跟 <a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a> 中 <a href="http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/Flowable.html" target="_blank" rel="noopener">Flowable</a> 的概念基本一样的)</p><blockquote><p>它是异步数据事件源。Stream 提供接收事件序列的方法。每个事件要么是数据事件，也称为 stream 元素；要么是错误事件，它代表某个失败。当 stream 发射完所有事件后，会使用 “done” 事件通知监听器 stream 已结束。</p></blockquote><p>Stream 指的是数据从 A 流动到的 B 的通道。在这个通道中可以在到达 B 之前对”读入”的数据进行不同的变换。以小块来传输而不是整体传输数据时这个通道非常有用。</p><p>Dart 中使用 SDK 提供的工具类来使用 Stream。这些工具类提供方法将数据推到 stream 中，并通知 stream 的监听器捕获数据。</p><p>代表 stream 的最通用的类是 <code>Stream&lt;T&gt;</code>。但通常不直接使用这个类，而是在 Dart 库的其他类中向外暴露这个类。所以可以将其视为用于跟数据流动通道交互的接口。</p><h2 id="Basic-example-with-StreamController"><a href="#Basic-example-with-StreamController" class="headerlink" title="Basic example with StreamController"></a>Basic example with StreamController<t></t></h2><p><code>StreamController&lt;T&gt;</code> 包含一个 stream，允许消费者向它发送数据事件、结束事件以及错误事件。可以使用 <code>streamController.stream</code> 访问及调用<a href="[documentation](https://api.dartlang.org/stable/2.1.1/dart-async/Stream-class.html?source=post_page---------------------------">文档</a>)中定义的方法。</p><p>来看个 <code>StreamController&lt;T&gt;</code> 类的例子:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> streamController = StreamController();</span><br><span class="line"><span class="comment">// Accessing the stream and listening for data event</span></span><br><span class="line">streamController.stream.listen((data) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Got eem! <span class="subst">$data</span>'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上代码片断允许监听 stream 通道上输入的数据块。我们对这个数据的响应方式是将其打印到控制台。</p><p>我猜接下来的疑问是：<em>如何触发监听器事件呢？</em> 答案是：<em>向 stream 喂数据。</em> 通过 <code>EventSink&lt;T&gt;</code> 的 <code>add()</code> 方法向 stream 喂数据。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">streamController.sink.add(<span class="string">'Added this string'</span>);</span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line"><span class="comment">// Got eem! Added this string</span></span><br></pre></td></tr></table></figure><p>stream 上的 <code>listen()</code> 方法也能用于捕获错误信息。监听 stream 时会生成一个 <code>StreamSubscription&lt;T&gt;</code> 对象。这个对象可用于处理不同的事件，比如数据、数据、结束 (调用 stream 的 <code>close()</code> 方法时产生结束事件)。</p><p>这是 <code>listen()</code> 方法的完整定义：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StreamSubscription&lt;T&gt; listen (</span><br><span class="line">  <span class="keyword">void</span> onData(T event), </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">Function</span> onError,</span><br><span class="line">    <span class="keyword">void</span> onDone(), <span class="comment">// Invoked when the stream is closed</span></span><br><span class="line">    <span class="built_in">bool</span> cancelOnError <span class="comment">// Kills the stream when an error occurs</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>像这样调用 “error” 和 “done” 事件：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">streamController.sink.addError(<span class="string">'Houston, we have a problem!'</span>); <span class="comment">// Got an error! Houston, we have a problem!</span></span><br><span class="line">streamController.sink.close(); <span class="comment">// Mission complete!</span></span><br></pre></td></tr></table></figure><p><a href="https://dartpad.dartlang.org/3baf3a9c229dcfa962878905e478a1a7?source=post_page---------------------------" target="_blank" rel="noopener">Try this on DartPad</a></p><h2 id="Streams-exposed-through-libraries"><a href="#Streams-exposed-through-libraries" class="headerlink" title="Streams exposed through libraries"></a>Streams exposed through libraries</h2><p>尽管 <code>StreamController&lt;T&gt;</code> 允许我们更好精细地控制 stream，但内置的 Dart 库其实内部也大量使用 Stream。比如，以下代码创建一个服务器： </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> server = <span class="keyword">await</span> HttpServer.bind(<span class="string">'localhost'</span>, <span class="number">8080</span>);</span><br><span class="line">  <span class="comment">// HttpServer exposes a Stream&lt;T&gt; interface</span></span><br><span class="line">  server.listen((HttpRequest request) &#123;</span><br><span class="line">    request.response.write(<span class="string">'Hello, World!'</span>);</span><br><span class="line">    request.response.close();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码初始化一个 <code>HttpServer</code> 用于创建 web 服务器。这个类暴露 <code>Stream&lt;T&gt;</code> 接口，这意味着我们可以监听这个 stream，它包含用户在浏览器访问该 web 服务器时发出的请求。</p><p>另一个例子是 web 浏览器也暴露 stream：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:html'</span>;</span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">querySelector</span>(<span class="string">'button'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `onClick` is a Stream&lt;T&gt; instance that receives user click data events</span></span><br><span class="line">  button.onClick.listen((_) =&gt; <span class="built_in">print</span>(<span class="string">'Button clicked!'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器中用户交互行为有点击，滚动及输入等等，这些行为作为”数据”事件发射到 stream 中。另外，HTML 元素也暴露 <code>Stream&lt;T&gt;</code> 用于处理用户在页面上的交互。</p><p>还有很多类使用 Stream。这里想要说的是，你不必直接初始化 <code>Stream&lt;T&gt;</code> 对象，而是 SDK 库中的类为你初始化。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Stream 提供一种强大的数据块处理方式。由于是以异步的方式操作，所以得到的好处是以非阻塞式的方式来运行代码。建议阅读文章，尤其是 <code>dart:async</code> 库，它包含有用于异步编程的 <code>Streams</code> 和 <code>Futures</code>。</p><p>下一篇将介绍如何对 stream 进行变换，并且展示了 stream 用法的常用设计模式。</p><hr><p>原文见<a href="https://creativebracket.com/how-to-use-streams-in-dart-2/?source=post_page---------------------------" target="_blank" rel="noopener">这里</a>。</p><p>是前一篇中我们学习了 stream，以及两种跟 stream 交互的方式，另外还看到了使用 <code>StreamController&lt;T&gt;</code> 类型处理 stream 的灵活性，以及 Dart 库暴露 <code>Stream&lt;T&gt;</code> 类型供监听和数据处理。</p><p>本篇将先看看如何使用 Stream Transformers 对 stream 进行变换。之后学习 stream 用法的常用设计模式。</p><h2 id="Stream-Transformer-是什么"><a href="#Stream-Transformer-是什么" class="headerlink" title="Stream Transformer 是什么?"></a>Stream Transformer 是什么?</h2><p>Stream Transformer 允许对 stream 进行数据变换。这些变换被推进 stream，并且被所有监听器接收。</p><p>Dart 使用 <code>StreamTransformer&lt;S,T&gt;</code> 类进行 stream 变换，它有三种不同的形式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Creates a transformer based on the provided `onListen` callback</span></span><br><span class="line">StreamTransformer(</span><br><span class="line">  StreamSubscription&lt;T&gt; onListen(</span><br><span class="line">    Stream&lt;S&gt; stream,</span><br><span class="line">    <span class="built_in">bool</span> cancelOnError</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 2. Creates a transformer based on the provided `bind` callback fn</span></span><br><span class="line">StreamTransformer.fromBind(</span><br><span class="line">  Stream&lt;T&gt; bind(Stream&lt;S&gt;)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 3. Creates a transformer that will delegate events to the</span></span><br><span class="line"><span class="comment">// provided `handleData`, `handleError` and `handleDone` callback functions</span></span><br><span class="line">StreamTransformer.fromHandlers(&#123;</span><br><span class="line">  <span class="keyword">void</span> handleData(</span><br><span class="line">    S data,</span><br><span class="line">    EventSink&lt;T&gt; sink</span><br><span class="line">  ),</span><br><span class="line">  <span class="keyword">void</span> handleError(</span><br><span class="line">    <span class="built_in">Object</span> error,</span><br><span class="line">    StackTrace stackTrace,</span><br><span class="line">    EventSink&lt;T&gt; sink</span><br><span class="line">  ),</span><br><span class="line">  <span class="keyword">void</span> handleDone(</span><br><span class="line">    EventSink&lt;T&gt; sink</span><br><span class="line">  ), </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>For this post I will focus on </p><p>本文重点介绍 <code>StreamTransformer.fromHandlers(...)</code>，因为它最容易使用。以下是一个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> streamTransformer = StreamTransformer&lt;<span class="built_in">num</span>, <span class="built_in">num</span>&gt;.fromHandlers(</span><br><span class="line">    handleData: (<span class="built_in">num</span> data, EventSink sink) &#123;</span><br><span class="line">      <span class="comment">// The actual transformation we're making</span></span><br><span class="line">      <span class="comment">// here is multiplying $data by 2</span></span><br><span class="line">      sink.add(data * <span class="number">2</span>);</span><br><span class="line">    &#125;, </span><br><span class="line">    handleError: (<span class="built_in">Object</span> error, StackTrace stacktrace, EventSink sink) &#123;</span><br><span class="line">      sink.addError(<span class="string">'Something went wrong: <span class="subst">$error</span>'</span>);</span><br><span class="line">    &#125;, </span><br><span class="line">    handleDone: (EventSink sink) =&gt; sink.close(),</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p><code>StreamTransformer.fromHandlers(...)</code> 命名构造方法接收回调函数，有三个命名参数：</p><ul><li><code>handleData</code>: 这个方法响应 stream 发射的任意数据事件。它的参数是发射事件中的数据，<code>EventSink&lt;T&gt;</code> 实例则是当前变换所属的 stream 的成员。<code>EventSink&lt;T&gt;.add()</code> 方法用于向 stream 的监听器重传变换后的数据。</li><li><code>handleError</code>: 这个方法响应 stream 发射的任意错误事件。它的参数包含错误信息，stack trace 以及 <code>EventSink&lt;T&gt;</code> 实例。该实例的 <code>addError()</code> 方法用于向监听器发送自定义的错误信息。</li><li><code>handleDone</code>: 当 stream 中没有更多数据需要处理时运行这个方法。调用 stream 的 <code>EventSink&lt;T&gt;</code> 实例的 <code>close()</code> 方法时会出现没有数据需要处理的情况。</li></ul><p>使用时，将 <code>streamTransformer</code> 作为 stream 的 <code>transform()</code> 方法参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> controller = StreamController&lt;<span class="built_in">num</span>&gt;();</span><br><span class="line"><span class="comment">// Call the `transform` method on the controller's stream</span></span><br><span class="line"><span class="comment">// while passing in the stream transformer</span></span><br><span class="line"><span class="keyword">var</span> controllerStream = controller.stream.transform(streamTransformer);</span><br><span class="line"><span class="comment">// Just print out transformations to the console</span></span><br><span class="line">controllerStream.listen(<span class="built_in">print</span>);</span><br><span class="line"><span class="comment">// Add data to stream to see transformations in effect</span></span><br><span class="line">controller.sink.add(<span class="number">1</span>); <span class="comment">// 2</span></span><br><span class="line">controller.sink.add(<span class="number">2</span>); <span class="comment">// 4</span></span><br><span class="line">controller.sink.add(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">controller.sink.add(<span class="number">4</span>); <span class="comment">// 8</span></span><br><span class="line">controller.sink.add(<span class="number">5</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h2 id="Single-subscription-vs-Broadcast-streams"><a href="#Single-subscription-vs-Broadcast-streams" class="headerlink" title="Single subscription vs Broadcast streams"></a>Single subscription vs Broadcast streams</h2><p>有两种形式的 stream：单个订阅或者广播。概念上的区别是单个订阅只一个监听器。添加多个监听器抛出异常：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">controllerStream.listen(<span class="built_in">print</span>);</span><br><span class="line">controllerStream.listen(<span class="built_in">print</span>); <span class="comment">// Throws the error below:</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="comment">// Uncaught exception: Bad state: Stream has already been listened to.</span></span><br></pre></td></tr></table></figure><p>但广播 stream 允许定义多个数据监听器。使用广播 stream 修正以上代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> controller = StreamController&lt;<span class="built_in">num</span>&gt;.broadcast();</span><br></pre></td></tr></table></figure><p>再测试一次，结果如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">controllerStream.listen(<span class="built_in">print</span>);</span><br><span class="line">controllerStream.listen(<span class="built_in">print</span>)</span><br><span class="line"><span class="comment">// --</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h2 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h2><p>Dart Stream 的优雅之处在于所有平台的 API 以一致的方式来实现，无论是 web，服务器端还是移动端。这一事实展示了 “light bulb moment”，你能跨平台写可重用的逻辑，只要它用的是 Stream API。 (原文：This fact presents a “light bulb moment” where we can write reusable logic for use across the platforms as long as it utilizes the Stream API.)</p><p>这种模式可称为 Business Logic Components ( 简称 BLoC)，我们将在第三部分介绍它。</p><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="https://www.dartlang.org/tutorials/language/streams" target="_blank" rel="noopener">Asynchronous Programming: Streams</a></li><li><a href="https://api.dartlang.org/stable/2.2.0/dart-async/StreamTransformer-class.html" target="_blank" rel="noopener">StreamTransformer&lt;S, T&gt; Class Documentation</a></li></ul><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html" target="_blank" rel="noopener">FutureBuilder class - widgets library - Dart API</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 应用集成浅析</title>
      <link href="2020/03/10/flutter-add-to-app/"/>
      <url>2020/03/10/flutter-add-to-app/</url>
      
        <content type="html"><![CDATA[<p>简单分析下 Flutter 如何集成到现有 Android 应用中。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>截止目前 Flutter (1.12.13+hotfix.5)，集成到 Android 应用已经非常简单了。</p><blockquote><p>Flutter can be embedded into your existing Android application piecemeal, as a source code Gradle subproject or as AARs.</p></blockquote><p>无非两种集成方式：源码集成或 AAR 产物集成。，这里不再赘述，仅做简单总结。</p><ul><li>Android Studio 3.6 + Flutter IntelliJ plugin (version 42及以上) 可以方便快速地自动集成 Flutter 模块</li><li>Flutter 的 Android 引擎使用 Java 8 特性，所以要记得开启 1.8 兼容，否则会提示 “default interface methods” 问题</li><li><a href="https://flutter.dev/docs/development/add-to-app/android/project-setup#option-b---depend-on-the-modules-source-code" target="_blank" rel="noopener">源码集成</a> 时注意 Android 工程和 Flutter 工程在同级目录下</li><li>注意编译模式及CPU架构，不匹配的话会出现找不到 <code>libflutter.so</code> 的问题</li><li>Flutter 的 AOT(ahead of time) 编译产物只支持 <code>armeabi-v7a</code> 和 <code>arm64-v8a</code>，x86 下可进行 debug (Just-In-Time, JIT 模式)，但不能安装 release 包</li></ul><h1 id="产物集成"><a href="#产物集成" class="headerlink" title="产物集成"></a>产物集成</h1><p>产物集成相比源码集成更简单。主要步骤如下，具体过程可参考<a href="https://flutter.dev/docs/development/add-to-app/android/project-setup#create-a-flutter-module" target="_blank" rel="noopener">官方文档</a>。</p><p>第一步，生成 AAR。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd flutter_project</span><br><span class="line">flutter build aar</span><br></pre></td></tr></table></figure><p>缺省编译所有模式下的产物，包括 debug, profile 和 release。不想编译 profile 模式产物的话，加上 <code>--no-profile</code> 即可。</p><p>另外注意编译 AAR 有限制，仅能为 plugin 或 module 工程编译 AAR 产物，否则提示如下错误。</p><p><img src="/images/15843459718378.jpg" alt="-w541"></p><p>第二步，添加产物仓库及依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">  // AAR 产物本地仓库</span><br><span class="line">  maven &#123;</span><br><span class="line">      url &apos;/Users/user/wd/xyz/build/host/outputs/repo&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  // Flutter 框架官方仓库</span><br><span class="line">  maven &#123;</span><br><span class="line">      url &apos;http://download.flutter.io&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  debugImplementation &apos;com.tencent.xyz:flutter_debug:1.0</span><br><span class="line">  profileImplementation &apos;com.tencent.xyz:flutter_profile:1.0</span><br><span class="line">  releaseImplementation &apos;com.tencent.xyz:flutter_release:1.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/15843474921970.jpg" alt="-w700"></p><h1 id="源码集成"><a href="#源码集成" class="headerlink" title="源码集成"></a>源码集成</h1><p>第一步，创建 Flutter 项目。在 host app 的同级目录下创建 <code>my_flutter</code> 项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd some/path/</span><br><span class="line">$ flutter create -t module --org com.example my_flutter</span><br></pre></td></tr></table></figure><p>第二步，引入 Flutter 项目并作为模块。在 host app 的 <code>settings.gradle</code> 文件中添加如下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">setBinding(<span class="keyword">new</span> Binding([<span class="string">gradle:</span> <span class="keyword">this</span>]))                                 <span class="comment">// new</span></span><br><span class="line">evaluate(<span class="keyword">new</span> File(                                                      <span class="comment">// new</span></span><br><span class="line">  settingsDir.parentFile,                                               <span class="comment">// new</span></span><br><span class="line">  <span class="string">'my_flutter/.android/include_flutter.groovy'</span>                          <span class="comment">// new</span></span><br><span class="line">)) </span><br><span class="line">include <span class="string">':my_flutter'</span></span><br><span class="line">project(<span class="string">':my_flutter'</span>).projectDir = <span class="keyword">new</span> File(<span class="string">'../my_flutter'</span>)</span><br></pre></td></tr></table></figure><p>这段配置的作用不妨视作黑魔法，其作用如下：</p><ul><li>将 <code>my_flutter</code> <strong>Flutter Project</strong> 作为名为 <code>:flutter</code> 的 <strong>Android Library Module</strong>，引入到当前 <strong>Android Project</strong></li><li>查找并保存 <code>my_flutter</code> 依赖的 Flutter 插件</li></ul><p>第三步，添加对 <code>:flutter</code> module 的依赖。在 host app 的 <code>build.gradle</code> 中加上以下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation project(<span class="string">':flutter'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是手工操作步骤。在 Android 3.6 中可以自动操作，同样也会产生跟上面相同的配置。</p><p>Android Studio 3.6 中打开 host app，并新建一个 Flutter Module：</p><p><img src="/images/15837916714301.jpg" alt="-w633"></p><p>创建完成后生成的配置如下：</p><p><img src="/images/15837922861555.jpg" alt="-w1185"></p><p>可见，无论手工操作还是自动操作，源码集成的关键在于这几个脚本：</p><ul><li><del>my_flutter/.android/include_flutter.groovy</del> - 黑魔法，用于在 Android 工程引入 Flutter 工程，我们略过</li><li><code>my_flutter/.android/Flutter/build.gradle</code> - 这个脚本决定 Flutter 工程如何构建，它引入 Flutter SDK 中的 <code>flutter.gradle</code> 脚本</li><li><code>&lt;Flutter SDK&gt;/packages/flutter_tools/gradle/flutter.gradle</code> - 集成 Flutter 工程的核心</li></ul><p>接下来我将分析 <code>build.gradle</code> 和 <code>flutter.gradle</code> 两个脚本是如何将 Flutter 集成到 Android 应用的。</p><h1 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h1><p>先来分析 <code>my_flutter/.android/Flutter/build.gradle</code>。</p><p>第一步，加载并解析 <code>.android</code> 目录下的 <code>local.properties</code> 文件。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载 .android 目录下的 local.properties 文件</span></span><br><span class="line"><span class="keyword">def</span> localProperties = <span class="keyword">new</span> Properties()</span><br><span class="line"><span class="keyword">def</span> localPropertiesFile = <span class="keyword">new</span> File(buildscript.sourceFile.parentFile.parentFile, <span class="string">'local.properties'</span>)</span><br><span class="line"><span class="keyword">if</span> (localPropertiesFile.exists()) &#123;</span><br><span class="line">    localPropertiesFile.withReader(<span class="string">'UTF-8'</span>) &#123; reader -&gt;</span><br><span class="line">        localProperties.load(reader)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 flutter.sdk(必选)</span></span><br><span class="line"><span class="keyword">def</span> flutterRoot = localProperties.getProperty(<span class="string">'flutter.sdk'</span>)</span><br><span class="line"><span class="keyword">if</span> (flutterRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="string">"Flutter SDK not found. Define location with flutter.sdk in the local.properties file."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 flutter.versionCode(可选)</span></span><br><span class="line"><span class="keyword">def</span> flutterVersionCode = localProperties.getProperty(<span class="string">'flutter.versionCode'</span>)</span><br><span class="line"><span class="keyword">if</span> (flutterVersionCode == <span class="literal">null</span>) &#123;</span><br><span class="line">    flutterVersionCode = <span class="string">'1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 flutter.versionName(可选)</span></span><br><span class="line"><span class="keyword">def</span> flutterVersionName = localProperties.getProperty(<span class="string">'flutter.versionName'</span>)</span><br><span class="line"><span class="keyword">if</span> (flutterVersionName == <span class="literal">null</span>) &#123;</span><br><span class="line">    flutterVersionName = <span class="string">'1.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，引入 <code>flutter.gradle</code> 脚本并通过 <code>flutter</code> 插件指定 <strong>Flutter Project</strong> 源码位置。<code>flutter</code> 插件来自 <code>flutter.gradle</code> 脚本中的 <code>FlutterPlugin</code>。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">from:</span> <span class="string">"$flutterRoot/packages/flutter_tools/gradle/flutter.gradle"</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定的 Flutter 源码路径</span></span><br><span class="line">flutter &#123;</span><br><span class="line">    source <span class="string">'../..'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="flutter-gradle"><a href="#flutter-gradle" class="headerlink" title="flutter.gradle"></a><a href="https://github.com/flutter/flutter/blob/master/packages/flutter_tools/gradle/flutter.gradle" target="_blank" rel="noopener">flutter.gradle</a></h1><p>再来看 <code>&lt;Flutter SDK&gt;/packages/flutter_tools/gradle/flutter.gradle</code>。<code>flutter</code> 插件的具体实现在 <code>apply()</code> 方法。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用 FlutterPlugin</span></span><br><span class="line">apply <span class="string">plugin:</span> FlutterPlugin</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义名为 flutter 的 FlutterPlugin 插件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line">    <span class="keyword">private</span> Project project</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        <span class="keyword">this</span>.project = project</span><br><span class="line">        <span class="comment">// 创建名为 flutter 的 FlutterExtension</span></span><br><span class="line">        project.extensions.create(<span class="string">"flutter"</span>, FlutterExtension) </span><br><span class="line">        <span class="comment">// 添加 Flutter Task</span></span><br><span class="line">        project.afterEvaluate <span class="keyword">this</span>.&amp;addFlutterTasks</span><br><span class="line">        <span class="comment">// 配置 APK。修改 project.android (android插件)的配置</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 获取 Flutter 相关信息</span></span><br><span class="line">        <span class="comment">// 添加 Flutter Dependency</span></span><br><span class="line">        project.android.buildTypes.each <span class="keyword">this</span>.&amp;addFlutterDependencies</span><br><span class="line">        project.android.buildTypes.whenObjectAdded <span class="keyword">this</span>.&amp;addFlutterDependencies</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>apply()</code> 主要流程概括如下：</p><ul><li>创建 FlutterExtension。这个插件很简单，只包括<ul><li><code>source</code>(源码路径)</li><li><code>target</code>(Dart入口，通常是 <code>lib/main.dart</code>)</li></ul></li><li><strong>添加 Flutter Task</strong></li><li>配置 APK<ul><li>针对 Target Platform 生成 multiple APK 或 fat APK</li><li>配置 build type，例如是否压缩资源</li></ul></li><li>获取 Flutter 相关信息<ul><li>本地 Flutter SDK 路径</li><li><code>flutter</code> 命令</li><li>引擎版本</li><li>引擎路径 (来自 <code>gradle.properties</code> 文件的 <code>local-engine-out</code> 属性 )</li></ul></li><li><strong>添加 Flutter Dependency</strong></li></ul><p>接下来我们挑重点说，</p><ul><li>添加 Flutter Task</li><li>添加 Flutter Dependency</li></ul><p>简单来说，添加 Flutter Task 是<font color="red">添加一些 Task 用于处理三类 Flutter 相关的资源，库、资源、插件</font>：</p><ul><li>库 - 库是编译过程中生成jar文件和so文件。库文件应正确地打包到 AAR 或 APK</li><li>资源 - 资源是 <code>pubspec.yaml</code> 文件添加指定的各类资源，如图片、字体等。资源文件应正确地打包到 AAR 或 APK</li><li>插件 - 插件是 <code>pubspec.yaml</code> 文件添加的各种 Dart 库。插件的处理比较麻烦，一是某些插件包含原生Java或OC代码，二是插件之间有依赖关系</li></ul><p>而<font color="red">添加 Flutter Dependency 则是将 Flutter 框架(包括引擎)添加为 Android 工程的依赖</font>，具体包括：</p><ul><li><code>flutter_embedding.jar</code> - Flutter Framework，即 <code>io.flutter.embedding.android.FlutterActivity</code> 所在的 Java 库</li><li><code>libflutter.so</code> - Flutter 引擎</li></ul><hr><p>跟以上流程相关的几个辅助方法：</p><ul><li><code>useLocalEngine()</code> - 判断是否使用本地 Flutter 引擎，来自 <code>gradle.properties</code> 文件的 <code>local-engine-repo</code> 属性</li><li><code>getTargetPlatforms</code> - 获取 Target Platform，来自 <code>gradle.properties</code> 文件的 <code>target-platform</code> 属性</li><li><code>shouldSplitPerAbi()</code> - 判断是否生成 multiple APK (即针对每种架构生成一个 APK，与之对应的是 fat APK)，来自 <code>gradle.properties</code> 文件的 <code>split-per-abi</code> 属性，缺省为 <code>false</code></li><li><code>getPluginList()</code> - 解析 <code>.flutter-plugins</code> 文件获取插件列表</li><li><code>getPluginDependencies()</code> - 解析 <code>.flutter-plugins-dependencies</code> 文件获取插件依赖</li></ul><hr><h2 id="添加-Flutter-Task"><a href="#添加-Flutter-Task" class="headerlink" title="添加 Flutter Task"></a>添加 Flutter Task</h2><p><code>addFlutterTasks()</code> 是最复杂的方法。精简后的代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> addFlutterTasks(Project project) &#123;</span><br><span class="line">    <span class="comment">// 1. 参数检查</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2. 从 `gradle.properties` 获取各种参数</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 3. 定义 addFlutterDeps 匿名方法</span></span><br><span class="line">    <span class="keyword">def</span> addFlutterDeps = &#123; variant -&gt; </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 4. 为所有 applicationVariants 或 libraryVariants 添加 Flutter 依赖</span></span><br><span class="line">    <span class="keyword">if</span> (project.android.hasProperty(<span class="string">"applicationVariants"</span>)) &#123;</span><br><span class="line">        project.android.applicationVariants.all addFlutterDeps</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        project.android.libraryVariants.all addFlutterDeps</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 配置插件依赖</span></span><br><span class="line">    configurePlugins()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第3步和第4步处理库和资源</li><li>第5步处理插件</li></ul><h3 id="addFlutterDeps"><a href="#addFlutterDeps" class="headerlink" title="addFlutterDeps"></a>addFlutterDeps</h3><p>首先看第3步 <code>addFlutterDeps</code> 的创建。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 compileTask。FlutterTask 实际是对 flutter build 命令的包装</span></span><br><span class="line">FlutterTask compileTask = project.tasks.create(<span class="string">name:</span> taskName, <span class="string">type:</span> FlutterTask) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建 packFlutterAppAotTask。将第1步中的编译结果打包成 libs.jar 文件</span></span><br><span class="line">Task packFlutterAppAotTask = project.tasks.create(<span class="string">name:</span> <span class="string">"packLibs$&#123;FLUTTER_BUILD_PREFIX&#125;$&#123;variant.name.capitalize()&#125;"</span>, <span class="string">type:</span> Jar) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将第2步生成的 libs.jar 文件添加为依赖 </span></span><br><span class="line">addApiDependencies(project, variant.name, project.files &#123;</span><br><span class="line">    packFlutterAppAotTask</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建 copyFlutterAssetsTask。</span></span><br><span class="line">Task copyFlutterAssetsTask = project.tasks.create(</span><br><span class="line"><span class="symbol">    name:</span> <span class="string">"copyFlutterAssets$&#123;variant.name.capitalize()&#125;"</span>,</span><br><span class="line"><span class="symbol">    type:</span> Copy,</span><br><span class="line">) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flutter 项目可能作为插件编译或子项目编译(分别对应AAR产物集成和源码集成)</span></span><br><span class="line"><span class="comment">//  a) 当作为插件编译时，编译产物为 AAR</span></span><br><span class="line"><span class="comment">//  b) 当作为子项目编译时，编译产物为 APK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为插件编译和作为子项目编译时对 assets 的处理是不一样的</span></span><br><span class="line"><span class="comment">// 第5步和第6步分别对这两种情况进行处理</span></span><br><span class="line"><span class="keyword">boolean</span> isUsedAsSubproject = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 处理作为插件编译时的 assets 拷贝</span></span><br><span class="line"><span class="keyword">if</span> (!isUsedAsSubproject) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 处理作为子项目编译时的 assets 拷贝</span></span><br><span class="line"><span class="comment">// Flutter module included as a subproject in add to app.</span></span><br><span class="line">Project appProject = project.rootProject.findProject(<span class="string">':app'</span>)</span><br><span class="line">appProject.afterEvaluate &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><code>FlutterTask</code> 继承自 <code>BaseFlutterTask</code>。<code>BaseFlutterTask</code> 实际是对 <code>flutter build</code> 命令的包装，具体包装过程可以参数 <a href="https://github.com/flutter/flutter/blob/master/packages/flutter_tools/gradle/flutter.gradle#L819" target="_blank" rel="noopener">BaseFlutterTask.buildBundle()</a>。</p><h3 id="configurePlugins"><a href="#configurePlugins" class="headerlink" title="configurePlugins"></a>configurePlugins</h3><p>再来看 <code>configurePlugins()</code> 如何配置插件依赖。仍然分两种情况处理：源码集成和产物集成。代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configures the Flutter plugin dependencies.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The plugins are added to pubspec.yaml. Then, upon running `flutter pub get`,</span></span><br><span class="line"><span class="comment"> * the tool generates a `.flutter-plugins` file, which contains a 1:1 map to each plugin location.</span></span><br><span class="line"><span class="comment"> * Finally, the project's `settings.gradle` loads each plugin's android directory as a subproject.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> configurePlugins() &#123;</span><br><span class="line">    <span class="comment">// 第1种情况，源码集成</span></span><br><span class="line">    <span class="comment">// 配置源码集成时的插件</span></span><br><span class="line">    <span class="keyword">if</span> (!buildPluginAsAar()) &#123;</span><br><span class="line">        <span class="comment">// 1. 将 plugin 工程添加为 Android 工程的依赖</span></span><br><span class="line">        getPluginList().each <span class="keyword">this</span>.&amp;configurePluginProject</span><br><span class="line">        <span class="comment">// 2. 将 plugin 工程的依赖添加为 Android 工程的依赖</span></span><br><span class="line">        getPluginDependencies().each <span class="keyword">this</span>.&amp;configurePluginDependencies</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第2种情况，产物集成</span></span><br><span class="line">    <span class="comment">// 配置产物集成时的插件</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 将 plugin 工程的编译输出目录添加为 Android 工程的 maven 库</span></span><br><span class="line">    project.repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">"$&#123;getPluginBuildDir()&#125;/outputs/repo"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 将 plugin AAR 产物添加为 Android 工程的依赖</span></span><br><span class="line">    getPluginList().each &#123; pluginName, pluginPath -&gt;</span><br><span class="line">        configurePluginAar(pluginName, pluginPath, project)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，注释中提到了几个很重要的信息：</p><blockquote><p>插件在 pubspec.yaml 中添加。当运行 <code>flutter pub get</code> 命令时，工具会生成 <code>.flutter-plugins</code> 和 <code>.flutter-plugins-dependencies</code> 文件。<code>.flutter-plugins</code> 包含每个插件的位置，<code>.flutter-plugins-dependencies</code> 包含每个插件的依赖项</p><p>Android 项目的 <code>settings.gradle</code> 文件会加载每个插件为子工程</p></blockquote><p>以我们的项目为例。<code>.flutter-plugins</code> 文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># This is a generated file; do not edit or check into version control.</span><br><span class="line">flutter_integration=/Users/abc/flutter/.pub-cache/hosted/pub.dartlang.org/flutter_integration-0.0.1/</span><br><span class="line">flutter_mmkv_cache=/Users/abc/flutter/.pub-cache/hosted/pub.dartlang.org/flutter_mmkv_cache-0.0.2/</span><br><span class="line">path_provider=/Users/abc/flutter/.pub-cache/hosted/pub.dartlang.org/path_provider-1.3.0/</span><br><span class="line">sensors=/Users/abc/flutter/.pub-cache/hosted/pub.dartlang.org/sensors-0.4.1+8/</span><br><span class="line">sqflite=/Users/abc/flutter/.pub-cache/hosted/pub.dartlang.org/sqflite-1.1.7+1/</span><br></pre></td></tr></table></figure><p>该项目在 Android Studio 中看到的工程结构如下：</p><p><img src="/images/15839842720995.jpg" alt="-w249"></p><h2 id="添加-Flutter-Dependency"><a href="#添加-Flutter-Dependency" class="headerlink" title="添加 Flutter Dependency"></a>添加 Flutter Dependency</h2><p><font color="red"><code>apply()</code> 的另一个要点是添加 Flutter 依赖，由 <code>addFlutterDependencies()</code> 实现</font>。相比添加 Flutter Task，添加 Flutter 依赖则简单得多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        ...   </span><br><span class="line">        project.android.buildTypes.each <span class="keyword">this</span>.&amp;addFlutterDependencies</span><br><span class="line">        project.android.buildTypes.whenObjectAdded <span class="keyword">this</span>.&amp;addFlutterDependencies</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * addFlutterDependencies() 方法为 Flutter 工程添加 embedding 和 libflutter.so 依赖 </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Adds the dependencies required by the Flutter project.</span></span><br><span class="line"><span class="comment">     * This includes:</span></span><br><span class="line"><span class="comment">     *    1. The embedding</span></span><br><span class="line"><span class="comment">     *    2. libflutter.so</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFlutterDependencies</span><span class="params">(buildType)</span> </span>&#123;</span><br><span class="line">        String flutterBuildMode = buildModeFor(buildType)</span><br><span class="line">        <span class="keyword">if</span> (!supportsBuildMode(flutterBuildMode)) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 添加 Flutter 引擎仓库，默认使用 MAVEN_REPO </span></span><br><span class="line">        <span class="comment">// MAVEN_REPO 仓库地址 http://download.flutter.io</span></span><br><span class="line">        String repository = useLocalEngine()</span><br><span class="line">            ? project.property(<span class="string">'local-engine-repo'</span>)</span><br><span class="line">            : MAVEN_REPO</span><br><span class="line"></span><br><span class="line">        project.rootProject.allprojects &#123;</span><br><span class="line">            repositories &#123;</span><br><span class="line">                maven &#123;</span><br><span class="line">                    url repository</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 添加 embedding 依赖</span></span><br><span class="line">        <span class="comment">// Add the embedding dependency.</span></span><br><span class="line">        addApiDependencies(project, buildType.name,</span><br><span class="line">                <span class="string">"io.flutter:flutter_embedding_$flutterBuildMode:$engineVersion"</span>)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        platforms.each &#123; platform -&gt;</span><br><span class="line">            String arch = PLATFORM_ARCH_MAP[platform].replace(<span class="string">"-"</span>, <span class="string">"_"</span>)</span><br><span class="line">            <span class="comment">// 3. 添加 libflutter.so 依赖</span></span><br><span class="line">            <span class="comment">// Add the `libflutter.so` dependency.</span></span><br><span class="line">            addApiDependencies(project, buildType.name,</span><br><span class="line">                    <span class="string">"io.flutter:$&#123;arch&#125;_$flutterBuildMode:$engineVersion"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>通过看 <code>buid.gradle</code> 和 <code>flutter.gradle</code> 源码，我们对 Flutter 如何集成到 Android 项目中有一定的了解了。现在结合两个实例来加深理解，这里以一个编译失败问题和 so 加载失败问题为例。</p><h2 id="编译失败-Cause-assert-appProject-null"><a href="#编译失败-Cause-assert-appProject-null" class="headerlink" title="编译失败 Cause: assert appProject != null"></a>编译失败 Cause: assert appProject != null</h2><p>Flutter 1.12.13+hotfix.5 有一个编译失败的 <a href="https://github.com/flutter/flutter/issues/42214" target="_blank" rel="noopener">Issue #42214</a>，错误日志如下：</p><p><img src="/images/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_d5221a9a-5eea-4c5d-9c8b-8f99449e06c6.png" alt="企业微信截图_d5221a9a-5eea-4c5d-9c8b-8f99449e06"></p><p>问题来源：这个问题实际上来自 <code>flutter.gradle</code> 脚本中的一处 bug， 见<a href="https://github.com/flutter/flutter/pull/41333/files" target="_blank" rel="noopener">Pull #41333</a><br>问题分析：<code>addFlutterTasks()</code> 方法中第4步存在硬编码问题，<a href="https://github.com/flutter/flutter/blob/master/packages/flutter_tools/gradle/flutter.gradle#L724" target="_blank" rel="noopener">默认所有的 app module 名为 <code>app</code></a>。实际项目中 app module 名很可能不是 <code>app</code>，所以断言失败，导致集成 Flutter 后编译出错</p><p>解决办法：要么将 app module 改名为 <code>app</code>，要么给本地的 <code>flutter.gradle</code> 打上如下补丁。注意要将 <code>IGame</code> 替换成实际项目名。</p><p><img src="/images/15839996052765.jpg" alt="-w824"></p><h2 id="找不到-libflutter-so-或-libapp-so"><a href="#找不到-libflutter-so-或-libapp-so" class="headerlink" title="找不到  libflutter.so 或 libapp.so"></a>找不到  <code>libflutter.so</code> 或 <code>libapp.so</code></h2><p>一些年代比较久远的 Android 项目中，so 往往放在 <code>lib/armeabi</code> 目录。</p><p><img src="/images/15840141266883.jpg" alt="-w322"></p><p>而 Flutter 的 AOT 产物只支持 <code>x86_64</code>、 <code>armeabi-v7a</code> 和 <code>arm64-v8a</code> 三种架构。另外，<strong>Flutter 的构建流程默认将会将 so 文件打包到对应的目录中</strong>，</p><p><img src="/images/15840143123117.jpg" alt="-w323"><br>所以会出现找不到 <code>libflutter.so</code> 的问题。一种简单而粗暴的解决方案见 <a href="https://tech.meituan.com/2018/08/09/waimai-flutter-practice.html" target="_blank" rel="noopener">Flutter原理与实践 - 美团技术团队</a>。</p><p>Flutter 构建流程中 <code>packFlutterAppAotTask</code> 会将生成的 <code>app.so</code> 移动并重命名为 <code>lib/&lt;abi&gt;/libapp.so</code>。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Task packFlutterAppAotTask = project.tasks.create(</span><br><span class="line"><span class="symbol">  name:</span> <span class="string">"packLibs$&#123;FLUTTER_BUILD_PREFIX&#125;$&#123;variant.name.capitalize()&#125;"</span>, <span class="string">type:</span> Jar) &#123;</span><br><span class="line">    destinationDir libJar.parentFile</span><br><span class="line">    archiveName libJar.name</span><br><span class="line">    dependsOn compileTask</span><br><span class="line">    targetPlatforms.each &#123; targetPlatform -&gt;</span><br><span class="line">        String abi = PLATFORM_ARCH_MAP[targetPlatform]</span><br><span class="line">        from(<span class="string">"$&#123;compileTask.intermediateDir&#125;/$&#123;abi&#125;"</span>) &#123;</span><br><span class="line">            include <span class="string">"*.so"</span></span><br><span class="line">            <span class="comment">// Move `app.so` to `lib/&lt;abi&gt;/libapp.so`</span></span><br><span class="line">            rename &#123; String filename -&gt;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"lib/$&#123;abi&#125;/lib$&#123;filename&#125;"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改一：注意这里的 <code>&lt;abi&gt;</code> 只支持上述提到的三种架构，并不包括 <code>armeabi</code>。我们可以修改 <code>packFlutterAppAotTask</code>，修改后将 <code>app.so</code> 移动并重命名为 <code>lib/armeabi/libapp.so</code> 的目的。</p><p>修改二：修改原始的 embedding jar 包(<code>libflutter.so</code> 从原始的 <code>lib/armeabi-v7a</code> 移到 <code>lib/armeabi</code> 目录)，并在 <code>gradle.properties</code> 中提供 <code>local-engine-repo</code>，将其指向修改后的 embedding jar 包。具体见 <a href="https://github.com/flutter/flutter/blob/master/packages/flutter_tools/gradle/flutter.gradle#L198" target="_blank" rel="noopener">addFlutterDependencies()</a></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the dependencies required by the Flutter project.</span></span><br><span class="line"><span class="comment"> * This includes:</span></span><br><span class="line"><span class="comment"> *    1. The embedding</span></span><br><span class="line"><span class="comment"> *    2. libflutter.so</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> addFlutterDependencies(buildType) &#123;</span><br><span class="line">    String flutterBuildMode = buildModeFor(buildType)</span><br><span class="line">    <span class="keyword">if</span> (!supportsBuildMode(flutterBuildMode)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    String repository = useLocalEngine()</span><br><span class="line">        ? project.property('local-engine-repo')</span><br><span class="line">        : MAVEN_REPO</span><br><span class="line"></span><br><span class="line">    project.rootProject.allprojects &#123;</span><br><span class="line">        repositories &#123;</span><br><span class="line">            maven &#123;</span><br><span class="line">                url repository</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://flutter.dev/docs/development/add-to-app/android/project-setup" target="_blank" rel="noopener">Integrate a Flutter module into your Android project - Flutter</a></p><p><a href="https://tech.youzan.com/you-zan-flutter-hun-bian-fang-an/" target="_blank" rel="noopener">有赞 Flutter 混编方案</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter Dialog 详解</title>
      <link href="2020/03/09/flutter-dialog/"/>
      <url>2020/03/09/flutter-dialog/</url>
      
        <content type="html"><![CDATA[<p>对话框很干扰用户，却是移动应用中绕不开的话题之一。一起来详细了解 Flutter Dialog 吧。</p><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul><li>AlertDialog</li><li>SimpleDialog</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>要点：</p><ul><li>类和接口之间的关系</li><li>常用API</li></ul><p>疑问：</p><ul><li>如何实现 dim 效果</li><li>如何设置大小</li><li>多 navigator</li><li>返回值</li><li>继承关系</li></ul><p>坑：</p><p>结论：几乎没有 AlertDialog 实现不了的效果。如果有，请使用 Dialog</p><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><ul><li>样式<ul><li>背景</li><li>大小</li><li>位置</li></ul></li><li>特殊<ul><li>全局</li><li>底部</li></ul></li></ul><h1 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h1><ul><li>功能<ul><li>时间选择</li><li>日期选择</li><li>颜色选择</li><li>自定义功能</li></ul></li><li>动画</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter SizedOverflowBox 简介及案例</title>
      <link href="2020/02/18/flutter-sized-overflow-box/"/>
      <url>2020/02/18/flutter-sized-overflow-box/</url>
      
        <content type="html"><![CDATA[<p>OverflowBox 和 SizedOverflowBox 允许子控件超出父控件的边界。这个特性可以用来实现一些比较棘手的视觉效果。</p><a id="more"></a><p>设计给出如下视觉图：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/18/15820301730961.jpg" alt="-w393"></p><p>初看觉得没有什么特别的，不过是7个控件平均水平分布。但仔细观察之后发现并非如此：其中一个控件(表示当天，称之A控件)的背景比较特别，超出边框范围带一点光晕效果。这个光晕背景其实比其他控件(表示非当天，称之B控件)的背景占据的空间要大。</p><h2 id="方案一-“理想的背景图”"><a href="#方案一-“理想的背景图”" class="headerlink" title="方案一 - “理想的背景图”"></a>方案一 - “理想的背景图”</h2><p>控件A和控件B的背景大小不一致，且要求水平方向平均分布。一种可行的方式是使用实际上大小相同、但视觉上有差异的背景图，比如控件A使用 100x100带光晕效果的背景图，控件B使用 100x100的透明背景图。可惜我们视觉未给出这种<strong>理想的背景图</strong></p><h2 id="方案二-“聪明的边距”"><a href="#方案二-“聪明的边距”" class="headerlink" title="方案二 - “聪明的边距”"></a>方案二 - “聪明的边距”</h2><p>既然控件A和控件B的背景大小不一致，又要求水平方向平均分布。如果没有”理想的背景图”，我们还可以想办法：</p><ul><li>让控件A和控件B大小不一致(以达到视觉上”看起来”大小一致的效果)</li><li>添加不同大小的边距(padding 或 margin)让它们”看起来”水平平均分布</li></ul><p>不过添加”聪明的边距”的代码会惨不忍睹，几乎没有可维护性。</p><h2 id="方案三-OverflowBox-和-SizedOverflowBox"><a href="#方案三-OverflowBox-和-SizedOverflowBox" class="headerlink" title="方案三 - OverflowBox 和 SizedOverflowBox"></a>方案三 - OverflowBox 和 SizedOverflowBox</h2><p>看如何使用 SizedOverflowBox 来解决这个问题。</p><h3 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h3><p>优化前，光晕背景图无法占满控件A，视觉效果不佳。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/18/15820344976572.jpg" alt></p><p>控件A代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Container(</span><br><span class="line">    width: <span class="number">36</span>,</span><br><span class="line">    height: <span class="number">36</span>,</span><br><span class="line">    decoration: BoxDecoration(</span><br><span class="line">        border: Border.all(</span><br><span class="line">          width: <span class="number">1</span>,</span><br><span class="line">          color: c_FFFFE1A6,</span><br><span class="line">        ),</span><br><span class="line">        borderRadius: BorderRadius.all(Radius.circular(<span class="number">3</span>)),</span><br><span class="line">        image: DecorationImage(</span><br><span class="line">            image: AssetImage(_bgAwardToday), fit: BoxFit.fitHeight)),</span><br><span class="line">    child: child,</span><br><span class="line">    alignment: Alignment.center,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h3><p>优化后，光晕背景图可以占满控件A，<font color="red">完美还原视觉图</font>。<br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/18/15820345882075.jpg" alt></p><p>此外，控件A的大小为 (width=36.0, height=36.0)，与控件B的大小完全一致。由于控件A和控件B的大小一致，所以让它们<font color="red">水平方向平均分布的代码非常简单优雅</font>，<code>spaceBetween</code> 即可。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Row(mainAxisAlignment: MainAxisAlignment.spaceBetween,</span><br><span class="line">  children: []</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>控件A代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> SizedOverflowBox(</span><br><span class="line">    size: <span class="keyword">const</span> Size(<span class="number">36.0</span>, <span class="number">36.0</span>),</span><br><span class="line">    child: Stack(alignment: Alignment.center, children: [</span><br><span class="line">      Image.asset(</span><br><span class="line">        _bgAwardToday,</span><br><span class="line">        width: <span class="number">56</span>,</span><br><span class="line">      ),</span><br><span class="line">      SizedBox(</span><br><span class="line">        child: child,</span><br><span class="line">        width: <span class="number">36</span>,</span><br><span class="line">        height: <span class="number">36</span>,</span><br><span class="line">      ),</span><br><span class="line">    ]),</span><br><span class="line">    alignment: Alignment.center,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以下是控件B的代码。用于对照参考。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Container(</span><br><span class="line">    width: <span class="number">36</span>,</span><br><span class="line">    height: <span class="number">36</span>,</span><br><span class="line">    decoration: BoxDecoration(</span><br><span class="line">        border: Border.all(</span><br><span class="line">          width: <span class="number">1</span>,</span><br><span class="line">          color: Color(<span class="number">0X62FFFFFF</span>),</span><br><span class="line">        ),</span><br><span class="line">        borderRadius: BorderRadius.all(Radius.circular(<span class="number">3</span>)),</span><br><span class="line">        image: DecorationImage(image: AssetImage(_bgAwardOthers))),</span><br><span class="line">    child: child,</span><br><span class="line">    alignment: Alignment.center,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SliceSizedOverflowBox-介绍"><a href="#SliceSizedOverflowBox-介绍" class="headerlink" title="SliceSizedOverflowBox 介绍"></a>SliceSizedOverflowBox 介绍</h1><p>TODO</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>如下，蓝色矩形子控件超出了浅蓝色矩形父控件的区域。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/18/15820350888457.jpg" alt="-w225"></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SliceSizedOverflowBox</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> <span class="keyword">implements</span> <span class="title">SliceExample</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> name =&gt; <span class="string">'SliceSizedOverflowBox'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      color: Colors.blue[<span class="number">50</span>],</span><br><span class="line">      child: SizedOverflowBox(</span><br><span class="line">        size: <span class="keyword">const</span> Size(<span class="number">100.0</span>, <span class="number">100.0</span>),</span><br><span class="line">        alignment: AlignmentDirectional.bottomStart,</span><br><span class="line">        child: Container(height: <span class="number">50.0</span>, width: <span class="number">150.0</span>, color: Colors.blue,),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://api.flutter.dev/flutter/widgets/SizedOverflowBox-class.html" target="_blank" rel="noopener">SizedOverflowBox class - widgets library - Dart API</a></li><li><a href="https://github.com/blankapp/flutter-widget-livebook/blob/master/uiexplorer/lib/views/slice_sized_overflow_box/slice_sized_overflow_box.dart" target="_blank" rel="noopener">flutter-widget-livebook/slice_sized_overflow_box.dart at master · blankapp/flutter-widget-livebook</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Flutter Stack 用法小结</title>
      <link href="2020/02/15/flutter-stack-usage/"/>
      <url>2020/02/15/flutter-stack-usage/</url>
      
        <content type="html"><![CDATA[<p> 记录一下如何使用 Flutter Stack Widget 来将文本跟图片中的某个特定点对齐。</p><a id="more"></a><p>某个产品需求要求显示本月累计签到天数，于是设计给了开发如下一张图。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/15/15817377604093.jpg" alt="-w420"></p><p>设计姐姐”好心”地将文案也写好了，只留了个格让开发填，够简单吧。但其实开发很头疼：”累计签到”那一行文案是特殊字体，所以并不能吐槽设计的切图方式完全不合理。但问题是对背景图”填空”容易引起适配问题，稍有不慎就如下图一样没对齐。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/15/15817384649043.jpg" alt="-w314"></p><p>接下来看如何在 Flutter 中解决上述对齐问题。涉及到的几个要点：</p><ul><li>图片缩放 - 我们知道图片适配不同大小屏幕大小</li><li>了解 <code>Image.fit</code> 属性 - 这个属性控制着图片如何缩放</li><li>了解 <code>Stack</code> + <code>Positioned</code> 的基本用法</li><li>了解 <code>Stack</code> + <code>Align</code> 的基本用法</li></ul><h1 id="图片缩放"><a href="#图片缩放" class="headerlink" title="图片缩放"></a>图片缩放</h1><p>我们知道图片适配不同大小屏幕时必然出现不同程度的缩放。Flutter 中使用 <code>Image</code> 控件显示图片，<code>Image.fit</code> 属性则用于控制图片缩放方式。<code>fit</code> 属性为枚举类型 <code>BoxFit</code>，最常用值的包括如下几种：</p><ul><li><code>fill</code> - Fill the target box by distorting the source’s aspect ratio.</li><li><code>contain</code> - As large as possible while still containing the source entirely within the target box.</li><li><code>cover</code> - As small as possible while still covering the entire target box.</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/15/15817395834810.jpg" alt="box_fit_fill.png (300×90)"></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/15/15817396100662.jpg" alt="box_fit_contain.png (300×90)"></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/15/15817396361784.jpg" alt="box_fit_cover.png (300×90)"></p><p>先来看如何将背景图铺满 <code>Stack</code>。代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack(</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    Image.asset(</span><br><span class="line">      <span class="string">'images/sign_in/sign_in_head.webp'</span>,</span><br><span class="line">    ),</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>不同参数时效果分别如下：</p><p><code>Image.asset(width: null, fit: null)</code><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/15/15817527373819.jpg" alt="-w595"></p><p><code>Image.asset(width: double.infinity, fit: null)</code><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/15/15817530863297.jpg" alt="-w579"></p><p><code>Image.asset(width: double.infinity, fit: BoxFit.fill)</code><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/15/15817531751686.jpg" alt="-w576"></p><p><code>Image.asset(width: double.infinity, fit: BoxFit.cover)</code><br><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/15/15817532756950.jpg" alt="-w571"></p><p>就这里的场景而言(图片高度无限制)，<code>BoxFit.cover</code> 和 <code>BoxFit.fill</code> 效果无区别。不过 <code>BoxFit.cover</code> 保证图片不会变形，是个更好的选择。</p><h1 id="控件定位"><a href="#控件定位" class="headerlink" title="控件定位"></a>控件定位</h1><p><a href="https://api.flutter.dev/flutter/widgets/Stack-class.html" target="_blank" rel="noopener">Stack 类</a>用于对若干个控件以层叠方式布局。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Stack(</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    Container(</span><br><span class="line">      width: <span class="number">100</span>,</span><br><span class="line">      height: <span class="number">100</span>,</span><br><span class="line">      color: Colors.red,</span><br><span class="line">    ),</span><br><span class="line">    Container(</span><br><span class="line">      width: <span class="number">90</span>,</span><br><span class="line">      height: <span class="number">90</span>,</span><br><span class="line">      color: Colors.green,</span><br><span class="line">    ),</span><br><span class="line">    Container(</span><br><span class="line">      width: <span class="number">80</span>,</span><br><span class="line">      height: <span class="number">80</span>,</span><br><span class="line">      color: Colors.blue,</span><br><span class="line">    ),</span><br><span class="line">  ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/15/15817536932540.jpg" alt></p><p><code>Stack</code> 控件的子节点要么是 <code>positioned</code> (<code>Positioned</code> 或 <code>Align</code> 控件) 要么是 <code>non-positioned</code>。<code>Stack</code> 控件的大小刚好包含所有的 <code>non-positioned</code> 子控件(这些控件默认位于 Stack 的左上角)。而 <code>positioned</code> 子节点的位置，则由其 top, right, bottom, left 属性来决定。</p><p><code>Positioned</code> 和 <code>Align</code> 控件都能用于 <code>Stack</code> 控件定位和对齐。<code>Positioned</code> 以 top, right, bottom, left 属性来定位，这些属性分别用于指定控件到 Stack 各边框的距离；<code>Align</code> 以 <code>Alignment(x, y)</code> 属性来定位，这些属性分别用于指定控件水平方向和垂直方向的距离范围。</p><p><code>Alignment</code> 的 x, y 属性规定如下：</p><ul><li><code>Alignment(0.0, 0.0)</code> - 表示矩形中点</li><li><code>Alignment(-1.0, -1.0)</code> - 表示矩形左上角</li><li><code>Alignment(1.0, 1.0)</code> - 表示矩形右下角</li></ul><p>关于 <code>Stack</code> 有一个小细节要注意。通过如下两个例子说明：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Scaffold(</span><br><span class="line">  appBar: AppBar(title: Text(<span class="string">'hello'</span>)),</span><br><span class="line"></span><br><span class="line">  body: Stack(</span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      Align(</span><br><span class="line">        alignment: Alignment(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        child: Text(<span class="string">'hello, stack'</span>),</span><br><span class="line">      )</span><br><span class="line">    ],</span><br><span class="line">  ),</span><br></pre></td></tr></table></figure><p>这个例子中，<code>Text</code> 按预期居显示：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/15/15817549810555.jpg" alt="-w337"></p><p>然而，<font color="red">当 Stack 外面嵌套一个 Column 或 ListView 之后，Align 似乎在垂直方向失去了定位的作用</font>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Scaffold(</span><br><span class="line">  appBar: AppBar(title: Text(<span class="string">'hello'</span>)),</span><br><span class="line"></span><br><span class="line">  body: Column(</span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      Stack(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Align(</span><br><span class="line">            alignment: Alignment(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">            child: Text(<span class="string">'hello, stack'</span>),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    ],</span><br><span class="line">  ),</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/15/15817551181468.jpg" alt="-w324"></p><p>我们观察 Stack 外面嵌套一个 Column 或 ListView 之后控件树，截图如下：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/15/15817553643641.jpg" alt="-w549"></p><p>所以这个现象不难理解：</p><ul><li>Stack 外面无嵌套时，它占满了父控件，所以 <code>Align</code> 生效</li><li>Stack 外面嵌套 <code>Column</code> 或 <code>ListView</code> 时，Stack 大小未指定(最终以 <code>Text</code> 大小为准)，所以 <code>Align</code> 从视觉效果上看在垂直方向不起作用。</li></ul><p>给 Stack 指定大小就能解决这个问题。这里使用 <code>SizedBox</code> 指定 Stack 高度为 300。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/15/15817557227844.jpg" alt="-w551"></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>方案一使用 <code>Stack</code> + <code>Positioned</code> 定位，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 计算屏幕宽度</span></span><br><span class="line">    <span class="built_in">double</span> width = MediaQuery.of(context).size.width;</span><br><span class="line">    <span class="comment">// 计算图片缩放比</span></span><br><span class="line">    <span class="keyword">final</span> scale = width / <span class="number">375.0</span>;</span><br><span class="line">    <span class="keyword">return</span> Stack(children: &lt;Widget&gt;[</span><br><span class="line">      Image.asset(</span><br><span class="line">        _signInHeadBg,</span><br><span class="line">        width: <span class="built_in">double</span>.infinity,</span><br><span class="line">        fit: BoxFit.cover,</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// 使用 Positioned 定位，指定 top 和 right 边距</span></span><br><span class="line">      Positioned(</span><br><span class="line">        top: <span class="number">113</span> * scale,</span><br><span class="line">        right: <span class="number">108</span> * scale,</span><br><span class="line">        child: Text(</span><br><span class="line">          <span class="string">'2'</span>,</span><br><span class="line">          style: TextStyle(color: c_FFFFFFFF, fontSize: <span class="number">12</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的实现细节，即按图片缩放比 scale 来调整 top 和 right，保证不同大小屏幕上都能完美适配。</p><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>方案二使用 <code>Stack</code> + <code>Align</code> 定位，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="built_in">double</span> width = MediaQuery.of(context).size.width;</span><br><span class="line">  <span class="keyword">return</span> SizedBox(</span><br><span class="line">    width: width,</span><br><span class="line">    height: <span class="number">798.0</span> / <span class="number">634</span> * width,</span><br><span class="line">    child: Stack(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Image.asset(</span><br><span class="line">          _signInHeadBg,</span><br><span class="line">          width: <span class="built_in">double</span>.infinity,</span><br><span class="line">          fit: BoxFit.cover,</span><br><span class="line">        ),</span><br><span class="line">        Align(</span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">'2'</span>,</span><br><span class="line">            style: TextStyle(color: c_FFFFFFFF, fontSize: <span class="number">12</span>),</span><br><span class="line">          ),</span><br><span class="line">          alignment: Alignment(<span class="number">0.42</span>, <span class="number">-0.51</span>),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    ),</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>注意这里的实现细节，即为 <code>Stack</code> 添加一个指定大小的 <code>SizeBox</code>(大小与图片显示的大小相同)，保证不同大小屏幕上都能完美适配。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/15/15817565491620.jpg" alt="-w547"></p><p>如果不为 <code>Stack</code> 指定大小，则 <code>Align</code> 在垂直方向不生效。如下图：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/15/15817566311909.jpg" alt="-w547"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 之 precacheImage() 浅析</title>
      <link href="2020/02/11/flutter-precache-image/"/>
      <url>2020/02/11/flutter-precache-image/</url>
      
        <content type="html"><![CDATA[<p>Flutter 中 <code>precacheImage()</code> 方法是如何提高图片加载速度的？</p><a id="more"></a><p>Flutter 文档中提到调用 <a href="https://api.flutter.dev/flutter/widgets/precacheImage.html" target="_blank" rel="noopener">precacheImage()</a> 预先加载图片加载到缓存，后续如果这张图片被 <code>Image</code> 控件用到的话，加载起来会更快。</p><blockquote><p>Prefetches an image into the image cache.</p><p>If the image is later used by an [Image] or [BoxDecoration] or [FadeInImage], it will probably be loaded faster.</p></blockquote><p><code>precacheImage()</code> 代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="keyword">void</span>&gt; precacheImage(</span><br><span class="line">  ImageProvider provider,</span><br><span class="line">  BuildContext context, &#123;</span><br><span class="line">  Size size,</span><br><span class="line">  ImageErrorListener onError,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="keyword">final</span> ImageConfiguration config = ...;</span><br><span class="line">  <span class="keyword">final</span> Completer&lt;<span class="keyword">void</span>&gt; completer = Completer&lt;<span class="keyword">void</span>&gt;();</span><br><span class="line">  <span class="keyword">final</span> ImageStream stream = provider.resolve(config);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> completer.future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>precacheImage()</code> 是如何加快图片加载速度的？我们可以从如下两个角度来考虑这个问题：</p><ul><li>写缓存 - 如何将图片加入缓存</li><li>读缓存 - 如何从缓存取出图片</li></ul><h1 id="写缓存"><a href="#写缓存" class="headerlink" title="写缓存"></a>写缓存</h1><p>先上结论：<strong><code>precacheImage()</code> 调用 <code>ImageProvider.resolve()</code> 从缓存中取出图片</strong>。</p><p><code>precacheImage()</code> 主要的调用关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">precacheImage() -&gt;</span><br><span class="line"> ImageProvider.resolve() -&gt;</span><br><span class="line">  ImageCache.putIfAbsent() -&gt;</span><br><span class="line">   ImageProvider.load() -&gt;</span><br></pre></td></tr></table></figure><h2 id="ImageProvider-resolve"><a href="#ImageProvider-resolve" class="headerlink" title="ImageProvider.resolve()"></a><code>ImageProvider.resolve()</code></h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> ImageStream resolve(ImageConfiguration configuration) &#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">final</span> ImageStream stream = ImageStream();</span><br><span class="line">    T obtainedKey;</span><br><span class="line"></span><br><span class="line">    key = obtainKey(configuration);</span><br><span class="line">    key.then&lt;<span class="keyword">void</span>&gt;((T key) &#123;</span><br><span class="line">      obtainedKey = key;</span><br><span class="line">      <span class="keyword">final</span> ImageStreamCompleter completer = PaintingBinding.instance.imageCache.putIfAbsent(</span><br><span class="line">        key,</span><br><span class="line">        () =&gt; load(key, PaintingBinding.instance.instantiateImageCodec),</span><br><span class="line">        onError: handleError,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (completer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stream.setCompleter(completer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).catchError(handleError);</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>imageCache.putIfAbsent()</code> 第二个参数形式如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ImageStreamCompleter putIfAbsent(</span><br><span class="line">  <span class="built_in">Object</span> key,</span><br><span class="line">  ImageStreamCompleter loader(), </span><br><span class="line">  &#123; ImageErrorListener onError &#125;)</span><br></pre></td></tr></table></figure><p>所以这里的 <code>loader</code> 参数实际上是对 <code>load()</code> 方法的封装。</p><h2 id="ImageCache-putIfAbsent"><a href="#ImageCache-putIfAbsent" class="headerlink" title="ImageCache.putIfAbsent()"></a><code>ImageCache.putIfAbsent()</code></h2><p><code>ImageCache</code> 用于缓存图片的类。这个类实现了 LRU 算法，最多可以保存1000个图片或者100MB。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageCache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">Object</span>, _PendingImage&gt; _pendingImages = &lt;<span class="built_in">Object</span>, _PendingImage&gt;&#123;&#125;;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">Object</span>, _CachedImage&gt; _cache = &lt;<span class="built_in">Object</span>, _CachedImage&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>_pendingImages</code> - 保存正在加载中的图片</li><li><code>_cache</code> - 保存已加载到缓存的图片</li></ul><p><code>putIfAbsent()</code> 方法是 <code>ImageCache</code> 主要的入口方法，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ImageStreamCompleter putIfAbsent(<span class="built_in">Object</span> key, ImageStreamCompleter loader()) &#123;</span><br><span class="line">  ImageStreamCompleter result = _pendingImages[key]?.completer;</span><br><span class="line">  <span class="comment">// Nothing needs to be done because the image hasn't loaded yet.</span></span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  <span class="comment">// Remove the provider from the list so that we can move it to the</span></span><br><span class="line">  <span class="comment">// recently used position below.</span></span><br><span class="line">  <span class="keyword">final</span> _CachedImage image = _cache.remove(key);</span><br><span class="line">  <span class="keyword">if</span> (image != <span class="keyword">null</span>) &#123;</span><br><span class="line">    _cache[key] = image;</span><br><span class="line">    <span class="keyword">return</span> image.completer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    result = loader();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error, stackTrace) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> listener(ImageInfo info, <span class="built_in">bool</span> syncCall) &#123;</span><br><span class="line">    <span class="comment">// Images that fail to load don't contribute to cache size.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> imageSize = info?.image == <span class="keyword">null</span> ? <span class="number">0</span> : info.image.height * info.image.width * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">final</span> _CachedImage image = _CachedImage(result, imageSize);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> _PendingImage pendingImage = _pendingImages.remove(key);</span><br><span class="line">    <span class="keyword">if</span> (pendingImage != <span class="keyword">null</span>) &#123;</span><br><span class="line">      pendingImage.removeListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _cache[key] = image;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (maximumSize &gt; <span class="number">0</span> &amp;&amp; maximumSizeBytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> ImageStreamListener streamListener = ImageStreamListener(listener);</span><br><span class="line">    _pendingImages[key] = _PendingImage(result, streamListener);</span><br><span class="line">    <span class="comment">// Listener is removed in [_PendingImage.removeListener].</span></span><br><span class="line">    result.addListener(streamListener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其过程总结如下：</p><ul><li>如果 <code>_pendingImages</code> 存在对应的 key，说明正在加载该图片，此时什么也不用做所以直接返回</li><li>如果 <code>_cache</code> 存在对应的 key，说明已经加载过该图片，此时将图片调整到 LRU 位置并返回</li><li>否则，调用 <code>loader()</code> 来加载图片。<code>loader()</code> 的返回值为 <code>result</code><ul><li>为 <code>result</code> 创建新对象并保存到 <code>_pendingImages</code> 中</li><li>监听图片加载过程。加载成功后从 <code>_pendingImages</code> 移除对应的 key，并在 <code>_cache</code> 中保存加载结果</li></ul></li></ul><h2 id="ImageProvider-load"><a href="#ImageProvider-load" class="headerlink" title="ImageProvider.load()"></a><code>ImageProvider.load()</code></h2><p><code>ImageProvider</code> 是一个抽象类，它的 <code>load()</code> 和 <code>obtainKey()</code> 是抽象方法，需要 <code>ImageProvider</code> 的子类实现。</p><p>以 <code>AssetBundleImageProvider</code> 为例，<code>load()</code> 方法如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AssetBundleImageProvider</span> <span class="keyword">extends</span> <span class="title">ImageProvider</span>&lt;<span class="title">AssetBundleImageKey</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ImageStreamCompleter load(AssetBundleImageKey key, DecoderCallback decode) &#123;</span><br><span class="line">    <span class="keyword">return</span> MultiFrameImageStreamCompleter(</span><br><span class="line">      codec: _loadAsync(key, decode),</span><br><span class="line">      scale: key.scale,</span><br><span class="line">      informationCollector: () <span class="keyword">sync</span>* &#123;</span><br><span class="line">        <span class="keyword">yield</span> DiagnosticsProperty&lt;ImageProvider&gt;(<span class="string">'Image provider'</span>, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">yield</span> DiagnosticsProperty&lt;AssetBundleImageKey&gt;(<span class="string">'Image key'</span>, key);</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  Future&lt;ui.Codec&gt; _loadAsync(AssetBundleImageKey key, DecoderCallback decode) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> ByteData data = <span class="keyword">await</span> key.bundle.load(key.name);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">'Unable to read data'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> decode(data.buffer.asUint8List());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码不难看出这里的 <code>_loadAsync()</code> 即底层的 asset 图片加载过程，它由 <code>load()</code> 方法调用。而 <code>load()</code> 是前面 <code>result = loader();</code> 的具体执行过程。</p><p>至此可知，调用 <code>precache()</code> 可将指定 key 对应的 <code>_CachedImage</code> 保存到 <code>ImageCache</code> 中。</p><h1 id="读缓存"><a href="#读缓存" class="headerlink" title="读缓存"></a>读缓存</h1><p>先上结论：<strong><code>Image</code> 调用 <code>ImageProvider.resolve()</code> 从缓存中取出图片</strong>。</p><p><code>Image</code> 控件用于显示图片。有多种方式显示图片：</p><ul><li><code>Image.asset</code> - 使用 key 从 <code>AssetBundle</code> 图片</li><li><code>Image.network()</code> - 使用 url 从网络加载图片</li><li><code>Image.file</code> - 从文件加载图片</li><li><code>Image.memory</code> - 从内存加载图片</li></ul><p>这些显示方式都有各自的 <code>ImageProvider</code>：</p><ul><li><code>AssetImage</code></li><li><code>NetworkImage</code></li><li><code>FileImage</code></li><li><code>MemoryImage</code></li></ul><p>上述这些 Image 都继承自 <code>ImageProvider</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageProvider</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  ImageStream resolve(ImageConfiguration configuration) &#123;&#125;</span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; evict(&#123; ImageCache cache, ImageConfiguration configuration = ImageConfiguration.empty &#125;) <span class="keyword">async</span> &#123;&#125;</span><br><span class="line">  Future&lt;T&gt; obtainKey(ImageConfiguration configuration);</span><br><span class="line">  ImageStreamCompleter load(T key, DecoderCallback decode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AssetBundleImageProvider</span> <span class="keyword">extends</span> <span class="title">ImageProvider</span>&lt;<span class="title">AssetBundleImageKey</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkImage</span> <span class="keyword">extends</span> <span class="title">ImageProvider</span>&lt;<span class="title">NetworkImage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileImage</span> <span class="keyword">extends</span> <span class="title">ImageProvider</span>&lt;<span class="title">FileImage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryImage</span> <span class="keyword">extends</span> <span class="title">ImageProvider</span>&lt;<span class="title">MemoryImage</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>Image</code> 它是一个 <code>StatefulWidget</code>，它依赖于其 <code>ImageProvider</code> 成员，主要代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> ImageProvider image;</span><br><span class="line">  _ImageState createState() =&gt; _ImageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ImageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Image</span>&gt; <span class="title">with</span> <span class="title">WidgetsBindingObserver</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    ...</span><br><span class="line">    _resolveImage();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didUpdateWidget(Image oldWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.didUpdateWidget(oldWidget);</span><br><span class="line">    <span class="keyword">if</span> (widget.image != oldWidget.image)</span><br><span class="line">      _resolveImage();    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> _resolveImage() &#123;</span><br><span class="line">    <span class="keyword">final</span> ImageStream newStream =</span><br><span class="line">      widget.image.resolve(createLocalImageConfiguration(</span><br><span class="line">        context,</span><br><span class="line">        size: widget.width != <span class="keyword">null</span> &amp;&amp; widget.height != <span class="keyword">null</span> ? Size(widget.width, widget.height) : <span class="keyword">null</span>,</span><br><span class="line">      ));</span><br><span class="line">    _updateSourceStream(newStream);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的 <code>_resolveImage()</code> 方法，它调用 <code>ImageProvider.resolve()</code>。所以可以认为是由 <code>ImageProvider.resolve()</code> 从缓存中取出图片(前面分析过 <code>ImageProvider.resolve()</code> 与图片缓存的关系)。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>precacheImage()</code> 提升图片加载速度的关键其实在于主动调用 <code>ImageProvider.resolve()</code> 来提前将图片加载到 <code>ImageCache</code>，示意图如下(这里假设从本地读取图片)：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2020/02/11/15814253180199.jpg" alt="-w850"></p><p>如果后续有 <code>Image</code> 显示同一个 key 对应的图片，再次调用 <code>ImageProvider.resolve()</code> 的速度将大为提升(网络图片会尤其明显)，当然前提是该图片仍然在图片缓存中。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://api.flutter.dev/flutter/widgets/precacheImage.html" target="_blank" rel="noopener">precacheImage function - widgets library - Dart API</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter drawFrame()</title>
      <link href="2020/01/20/flutter-draw-frame/"/>
      <url>2020/01/20/flutter-draw-frame/</url>
      
        <content type="html"><![CDATA[<p><code>RendererBinding.drawFrame()</code> 负责生成帧。这个方法对于理解 Flutter 渲染过程非常重要。简单了解下。</p><a id="more"></a><p><code>RendererBinding.drawFrame()</code> 由 <code>SchedulerBinding.handleDrawFrame()</code> 方法调用，而后者又自动被引擎调用(如果引擎需要布局和绘制一帧的话)。</p><p><code>RendererBinding.drawFrame()</code> 的源码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 布局</span></span><br><span class="line">    pipelineOwner.flushLayout();</span><br><span class="line">    <span class="comment">// 检查是否需要重绘</span></span><br><span class="line">    pipelineOwner.flushCompositingBits();</span><br><span class="line">    <span class="comment">// 重绘</span></span><br><span class="line">    pipelineOwner.flushPaint();</span><br><span class="line">    renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></span><br><span class="line">    pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>flushPaint()</code> 调用 <code>PaintingContext.repaintCompositedChild(node)</code> 方法，后者是真正的绘制逻辑。</p><p>每帧由以下几个阶段组成：</p><ol><li>动画阶段 - <code>SchedulerBinding.handleBeginFrame</code> (由 <code>Window.onBeginFrame</code> 注册)，按注册顺序调用所有的临时帧回调 (由 <code>scheduleFrameCallback</code> 注册)。这些回调包括所有用于驱动 <code>AnimationController</code> 对象的 <code>Ticker</code> 实例，即该时间点的所有活跃 <code>Animation</code> 对象。</li><li>Microtasks  - <code>handleBeginFrame</code> 返回后，由临时帧回调注册的方法调度的 microtasks 开始运行。之后，由 <code>Window.onDrawFrame</code> 注册的 <code>handleDrawFrame</code> 回调开始执行，它调用所有的持久帧回调。其中最重要的是 <code>drawFrame</code> 方法，它的处理过程如下</li><li>布局阶段 - 对系统中的所有标记为脏的 <code>RenderObject</code> (如何将对象标脏以便布局，可参考 <code>RenderObject.markNeedsLayout</code>) 进行布局</li><li>compositing bits 阶段 - 更新所有标脏 <code>RenderObject</code> 中的 compositing bits。具体参考 <code>RenderObject.markNeedsCompositingBitsUpdate</code></li><li>绘制阶段 - 系统中的所有标脏 <code>RenderObject</code> 被重绘。这个过程生成 <code>Layer</code> 树。如何将对象标脏以便绘制，可参考 <code>RenderObject.markNeedsPaint</code></li><li>合成阶段 - 将 layer tree 转换成 <code>Scene</code> 并发送到 GPU</li><li>semantics 阶段 - 系统中的所有标脏 <code>RenderObject</code> 的 semantics 被更新。具体见 <code>RenderObject.semanticsAnnotator</code>。这个过程生成 <code>SemanticsNode</code> 树。如何将对象标脏以用于 semantics，可参考 <code>RenderObject.markNeedsSemanticsUpdate</code></li><li>步骤 3-7 的细节请参考 <code>PipelineOwner</code></li><li>结束阶段 - <code>drawFrame</code> 返回后，<code>handleDrawFrame</code> 调用 post-frame 回调。(由 <code>addPostFrameCallback</code> 注册)</li></ol><p>注意：某些绑定会向上述过程添加额外步骤，比如，<code>WidgetsBinding</code> 会添加 <code>WidgetsBinding.drawFrame</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter Performance 分析工具简介</title>
      <link href="2020/01/10/flutter-performance-tools/"/>
      <url>2020/01/10/flutter-performance-tools/</url>
      
        <content type="html"><![CDATA[<p>Flutter 提供了不少性能分析工具，但感觉相关文档不咋的，散落在官方的各个地方，对开发者不太友好。另外，有的工具目前只在 Android Studio 中有，比如 Flutter Performance；甚至有的工具只在 debug 模式下可用。本文对这些工具简单整理一下，便于做性能优化时查找和参考。</p><a id="more"></a><h1 id="Performance-Overlay"><a href="#Performance-Overlay" class="headerlink" title="Performance Overlay"></a>Performance Overlay</h1><p>开启 Performance Overlay 有多种方式，最简单的几种包括：</p><ul><li>Android Studio &gt; Flutter Inspector &gt; Performance Overlay</li><li>Android Studio &gt; Flutter Performance &gt; Performance Overlay</li><li>DevTools &gt; Timeline &gt; Performance Overlay</li></ul><p><img src="/images/15786503018684.jpg" alt="-w477"></p><p>性能图层用两张图表显示应用的耗时信息。每一张图表都代表当前线程的最近 300 帧表现。</p><p><img src="/images/15786490815418.jpg" alt></p><ul><li>顶部的图形表示 GPU 线程所花费的时间</li><li>底部的图表显示了 UI 线程所花费的时间</li><li>竖轴表示耗时，沿竖轴的黑线是时间线 (间隔单位为 16ms)</li><li>横轴则表示帧，垂直的绿色条代表的是当前帧</li><li>卡顿时绿色条会变成红色条<ul><li>如果是在 UI 图表出现了红色竖条，则表明 Dart 代码消耗了大量资源</li><li>而如果红色竖条是在 GPU 图表出现的，意味着场景太复杂导致无法快速渲染</li></ul></li></ul><p>更多信息请参考 <a href="https://flutter.dev/docs/perf/rendering/ui-performance#flutters-threads" target="_blank" rel="noopener">Flutter 线程</a></p><p>使用 Performance Overlay 可以对 UI 性能问题进行<strong>定性分析</strong>，大致判断到底是 Dart 代码执行过慢(布局慢)还是场景复杂无法快速渲染(渲染慢)。</p><p>Performance Overlay 可用于 profile 模式。</p><h1 id="PerformanceOverlay控件"><a href="#PerformanceOverlay控件" class="headerlink" title="PerformanceOverlay控件"></a><a href="https://api.flutter.dev/flutter/widgets/PerformanceOverlay-class.html" target="_blank" rel="noopener">PerformanceOverlay控件</a></h1><p><a href="https://api.flutter.dev/flutter/widgets/PerformanceOverlay-class.html" target="_blank" rel="noopener">PerformanceOverlay</a> 可以视为 Performance Overlay 的高级版本(Performance Overlay 正是基于 PerformanceOverlay 控件来实现的)。</p><p>通过如下方式在代码中开启 <code>PerformanceOverlay</code> 控件。<a href="https://flutter.dev/docs/testing/code-debugging#performance-overlay" target="_blank" rel="noopener">参考</a>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      showPerformanceOverlay: <span class="keyword">true</span>,</span><br><span class="line">      title: <span class="string">'My Awesome App'</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: MyHomePage(title: <span class="string">'My Awesome App'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有使用 <code>MaterialApp</code> 等控件，可以自己调用  <code>PerformanceOverlay.allEnabled(checkerboardOffscreenLayers: true,);</code> 来实现类似效果。</p><h1 id="Observatory-之-Timeline"><a href="#Observatory-之-Timeline" class="headerlink" title="Observatory 之 Timeline"></a><a href="https://dart-lang.github.io/observatory/" target="_blank" rel="noopener">Observatory</a> 之 Timeline</h1><p>Observatory 是 Dart SDK 提供的用于分析和调试 Dart 程序的工具。可以使用 Observatory 来观察 Dart VM 内部状态，获取应用的实时数据。主要功能包括：</p><ul><li>检查应用的耗时情况</li><li>检查已分配内存</li><li>检查哪些代码已执行</li><li>调试内存泄漏问题</li><li>调试内存碎片问题</li></ul><p>虽然 Observatory 正在被 DevTools 慢慢取代，但某些情况下它提供的性能数据更为详细。</p><p>Observatory 的使用步骤：</p><ol><li>VS Code 或命令行下打开 Observatory</li><li>点击 timeline</li><li>点击 Flutter Developer</li><li>操作应用</li><li>点击 Refresh 加载数据</li><li>w/s 放大， a/d (点?号可以看到全部的快捷键)</li></ol><p><img src="/images/15813940478063.jpg" alt></p><p>刷新后可以在事件面板中检查和分析UI线程和GPU的耗时，以定位性能瓶颈。</p><ul><li>将 <code>debugProfileBuildsEnabled</code> 设置为 <code>true</code> 可以在 Observatory 中看到 构建 Widget 的耗时</li><li>Save 后导出的 json 文件可以重新导入 Chrome 进行分析。Chrome 中输入 <code>chrome://tracing</code> 然后将 json 文件拖进去</li></ul><h1 id="DevTools-之-Timeline"><a href="#DevTools-之-Timeline" class="headerlink" title="DevTools 之 Timeline"></a>DevTools 之 Timeline</h1><p><a href="https://flutter.dev/docs/development/tools/devtools/timeline#frame-rendering-chart" target="_blank" rel="noopener">时间线视图</a>用于显示 Flutter 帧信息。它由三个部分组成。</p><ul><li>帧渲染图表</li><li>帧事件图表</li><li>CPU 分析器</li></ul><p>使用 Timeline 可以对 UI 性能问题进行<strong>定量分析</strong>，通过观察布局阶段和渲染阶段的耗时，进一步定位问题原因。</p><p>Performance Overlay 可用于 profile 模式。</p><h2 id="帧渲染图表"><a href="#帧渲染图表" class="headerlink" title="帧渲染图表"></a>帧渲染图表</h2><p>帧渲染图表跟 Performance Overlay 很类似。</p><p><img src="/images/15786578717563.jpg" alt></p><p>图表中的每个条形框都代表一帧，每帧中不同线程的执行情况以不同颜色表示。</p><ul><li>UI 线程执行 Dart VM 中的 Dart 代码。构建过于复杂的图层树可能导致这个线程变慢</li><li>GPU 线程执行 Flutter 引擎中图形相关的代码。某些图层树易于构建却难于渲染，也可能导致这个线程变慢</li></ul><h2 id="帧事件图表"><a href="#帧事件图表" class="headerlink" title="帧事件图表"></a>帧事件图表</h2><p>在帧渲染图表中选中一帧后，帧事件图表中将显示具体事件及其耗时。</p><p><img src="/images/15786583559211.jpg" alt="-w1274"></p><ul><li><a href="https://api.flutter.dev/flutter/widgets/debugProfileBuildsEnabled.html" target="_blank" rel="noopener">debugProfileBuildsEnabled</a> - 向 Timeline 事件中添加 build 信息</li><li><a href="https://api.flutter.dev/flutter/rendering/debugProfilePaintsEnabled.html" target="_blank" rel="noopener">debugProfilePaintsEnabled</a> - 向 timeline 事件中添加 paint 信息</li><li><a href="https://api.flutter.dev/flutter/widgets/debugPrintRebuildDirtyWidgets.html" target="_blank" rel="noopener">debugPrintRebuildDirtyWidgets</a> - 记录每帧重建的 widget</li></ul><h2 id="CPU-分析器"><a href="#CPU-分析器" class="headerlink" title="CPU 分析器"></a>CPU 分析器</h2><ul><li>采样率<ul><li>高采样率 - 单元时间内采集的 CPU 信息会更加详细且采集样例更多。但应用性能可能下降，采样存储空间可能溢出</li><li>单元时间内采集的 CPU 信息会比较粗略且采集样例较少。对应用性能影响小，可以采集更长时间</li></ul></li><li>图表<ul><li>火焰图 - 展示的是自上而下的调用堆栈信息，即上面的堆栈帧调用下面的堆栈帧。每一个堆<strong>栈帧的宽度代表 CPU 执行的时长</strong>。调用堆栈栈帧消耗 CPU 的时间越长，就越洽有可能是我们进行性能改进的好地方</li><li>调用树 - 展示的是自上而下展示 CPU 中的调用堆栈信息</li><li>Bottom up 视图 - 用于显示方法调用堆栈，是一个自下而上的表示方式。表格中的每个最上方的方法实际上是给定 CPU 样本的调用堆栈中的最后一个方法</li></ul></li></ul><h1 id="Chrome-Tracing"><a href="#Chrome-Tracing" class="headerlink" title="Chrome Tracing"></a>Chrome Tracing</h1><p>我们可以从 DevTools Timeline 中导出 timeline 文件。</p><p><img src="/images/15786557953993.jpg" alt="-w1000"></p><p>导出的 timeline 文件可以重新导入到 chrome tracing 进行分析。</p><p><img src="/images/15786559387247.jpg" alt="-w1000"></p><p>chrome tracing 几个常用的操作键包括：</p><ul><li>W - 放大</li><li>S - 缩小</li><li>A - 左移</li><li>D - 右移</li></ul><p>chrome tracing 工具展示如下两个阶段的耗时：</p><ul><li>VSYNC</li><li>GPURasterizer:Draw </li></ul><p><img src="/images/15786563521810.jpg" alt="-w1147"></p><p>(TODO 如何解读这些数据? 比 CPU 分析器更容易观察数据?)</p><p><a href="https://api.flutter.dev/flutter/dart-developer/Timeline-class.html" target="_blank" rel="noopener">Timeline</a> 用于向时间线添加同步事件。使用方法很简单：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Timeline.startSync(<span class="string">"Doing Something"</span>);</span><br><span class="line">doSomething();</span><br><span class="line">Timeline.finishSync();</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Timeline.timeSync(<span class="string">"Doing Something"</span>, () &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们在代码中添加 “Doing Something”，</p><p><img src="/images/15790537579215.jpg" alt="-w519"></p><p>然后将 DevTools Timeline 导出的 timeline 文件重新导入到 Chrome Tracing 工具。从中我们可以找到 “Doing Something” 对应的事件，如下图：</p><p><img src="/images/15790539789634.jpg" alt="-w900"></p><h1 id="Widget-rebuild-profiler"><a href="#Widget-rebuild-profiler" class="headerlink" title="Widget rebuild profiler"></a><a href="https://flutter.cn/docs/development/tools/android-studio#show-performance-data" target="_blank" rel="noopener">Widget rebuild profiler</a></h1><p>Android Studio 中 View &gt; Tool Windows &gt; Flutter Performance 打开性能工具窗口，在 Widget rebuild stats 中勾选 Track widget rebuilds 来查看 widget 的重建信息。重建信息包括 Widget 名字、源码位置、上一帧中重建次数、当前页面中重建次数。此外，Widget 名字前面还会显示一个小图标。</p><p><img src="/images/15788975395660.jpg" alt="-w697"></p><ul><li>黄色旋转圆圈 - 重建次数过多</li><li>灰色圆圈 - 未重建</li><li>灰色旋转圆圈 其他情况</li></ul><p>这个功能的目的是让你了解 widget 是何时重建的，如果发生不符合预期的重建，就需要优化代码了。优化方法请参考 <a href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html#performance-considerations" target="_blank" rel="noopener">StatefulWidget 与性能</a> (译文见<a href="https://www.sunmoonblog.com/2020/01/10/stateful-widget-performance-considerations/">这里</a>)</p><p>Widget rebuild profiler 只能用于 debug 模式。</p><h1 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h1><p>Performance Overlay 使用两张图来表示 UI线程 和 GPU线程的最近 300 帧表现。</p><p><img src="/images/15786490815418.jpg" alt></p><p>不过 FPS 对我们来说更直接。Android Studio Flutter Performance 中可以看到 FPS 值：</p><p><img src="/images/15788855830332.jpg" alt="-w703"></p><p>我们也可以使用 <code>WidgetsBinding.addTimingsCallback</code> 方法来自行统计 FPS。这里提供两个参考实现：</p><ul><li><a href="https://gist.github.com/yrom/ac4f30b26ee02ce3bd3a1d260bb9ffb4" target="_blank" rel="noopener">统计FPS</a></li><li><a href="https://gist.github.com/410063005/3293c1faa78a01a3d0e7b4e2ce12d1af" target="_blank" rel="noopener">FpsWidget</a></li></ul><h1 id="测试参数"><a href="#测试参数" class="headerlink" title="测试参数"></a><a href="https://flutter.dev/docs/testing/code-debugging" target="_blank" rel="noopener">测试参数</a></h1><p>刚入门 Flutter 开发时，你肯定会如何右上角那个刺眼的 debug 标志苦恼过。</p><p><img src="/images/15789021349152.jpg" alt="Debug logo -w320"></p><p>方法很简单。将 <code>debugShowCheckedModeBanner</code> 参数设置为 <code>false</code> 即可。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line"> debugShowCheckedModeBanner: <span class="keyword">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Flutter 提供性能测试/调试参数，这些参数通常是布尔类型，只要在代码中打开相应的参数就可以开始进行性能测试。</p><ul><li><a href="https://api.flutter-io.cn/flutter/rendering/PerformanceOverlayLayer/checkerboardOffscreenLayers.html" target="_blank" rel="noopener">PerformanceOverlayLayer.checkerboardOffscreenLayers</a> 用于检查是否使用 <code>saveLayer</code>，详情请参考 <a href="https://flutter.dev/docs/perf/rendering/ui-performance#checking-for-offscreen-layers" target="_blank" rel="noopener">Checking for offscreen layers</a></li><li><a href="https://api.flutter-io.cn/flutter/rendering/PerformanceOverlayLayer/checkerboardRasterCacheImages.html" target="_blank" rel="noopener">PerformanceOverlayLayer.checkerboardRasterCacheImages</a> 用于检查哪些图片被缓存，请情请参考 <a href="https://flutter.dev/docs/perf/rendering/ui-performance#checking-for-non-cached-images" target="_blank" rel="noopener">Checking for non-cached images</a></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  checkerboardOffscreenLayers: <span class="keyword">true</span>,</span><br><span class="line">  checkerboardRasterCacheImages: <span class="keyword">true</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Debug-flags"><a href="#Debug-flags" class="headerlink" title="Debug flags"></a>Debug flags</h1><h2 id="layers"><a href="#layers" class="headerlink" title="layers"></a>layers</h2><p>Flutter framework 的每一层都提供了函数来输出当前状态或事件到控制台(这些函数调用 <code>debugPrint</code>)。</p><p>调用 <a href="https://api.flutter-io.cn/flutter/widgets/debugDumpApp.html" target="_blank" rel="noopener">debugDumpApp()</a> 输出 the state of the Widgets library。不应在 <code>build()</code> 方法中调用 <code>debugDumpApp()</code>，可以在调用 <code>runApp()</code> 后的任何时候调用 <code>debugDumpApp()</code>。调用 <a href="https://api.flutter-io.cn/flutter/widgets/Widget/debugFillProperties.html" target="_blank" rel="noopener">debugFillProperties()</a> 方法向 <code>debugDumpApp()</code> 的输出添加自定义信息。</p><p>调用 <a href="https://api.flutter-io.cn/flutter/rendering/debugDumpRenderTree.html" target="_blank" rel="noopener">debugDumpRenderTree()</a> 方法来输出 rendering tree，用于分析布局问题。建议在 <a href="https://api.flutter-io.cn/flutter/scheduler/SchedulerBinding/addPersistentFrameCallback.html" target="_blank" rel="noopener">frame callback</a> 或 event handler 中调用 <code>debugDumpRenderTree()</code> 方法。分析布局问题时，关注的关键字段是 <code>size</code> 和 <code>constraints</code>。调用 <a href="https://api.flutter-io.cn/flutter/rendering/Layer/debugFillProperties.html" target="_blank" rel="noopener">debugFillProperties()</a> 方法向 <code>debugDumpRenderTree()</code> 的输出添加自定义信息。</p><p>调用 <a href="https://api.flutter-io.cn/flutter/rendering/debugDumpLayerTree.html" target="_blank" rel="noopener">debugDumpLayerTree()</a> 方法来输出 layer tree，用于分析 compositing 问题。</p><blockquote><p>The RepaintBoundary widget, which creates a RenderRepaintBoundary in the render tree, creates a new layer in the layer tree. This is used to reduce how much needs to be repainted.</p></blockquote><p>可以使用 <code>RepaintBoundary</code> 来在 render tree 中创建 <code>RenderRepaintBoundary</code> ，即，在 layer tree 中创建新的 layer。这种方法可以减少重绘工作。详细可参考 <a href="https://juejin.im/post/5deda528f265da339f7ce93c" target="_blank" rel="noopener">说说Flutter中的RepaintBoundary - 掘金</a>。</p><p>调用 <a href="https://api.flutter.dev/flutter/rendering/debugDumpSemanticsTree.html" target="_blank" rel="noopener">debugDumpSemanticsTree()</a> 方法来输出 semantics tree (这棵树表示 system accessibility APIs)。暂时用不上，略过。</p><p>调用 <a href="https://api.flutter.dev/flutter/scheduler/debugPrintBeginFrameBanner.html" target="_blank" rel="noopener">debugPrintBeginFrameBanner</a> 和 <a href="https://api.flutter.dev/flutter/scheduler/debugPrintEndFrameBanner.html" target="_blank" rel="noopener">debugPrintEndFrameBanner</a> 方法来输出一帧的开始和结束。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(DemoApp());</span><br><span class="line">  debugPrintBeginFrameBanner = <span class="keyword">true</span>;</span><br><span class="line">  debugPrintEndFrameBanner = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><p><a href="https://api.flutter.dev/flutter/rendering/debugPaintSizeEnabled.html" target="_blank" rel="noopener">debugPaintSizeEnabled</a> 用于调试布局问题。其用法如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    debugPaintSizeEnabled = <span class="keyword">true</span>;</span><br><span class="line">    runApp(DemoApp());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>box - 所有的 box 外都显示一个亮蓝绿色边界</li><li>padding - 以浅蓝色显示 <code>Padding</code> 等控件 (带一个深蓝色 box)</li><li>alignment - 包括 <code>Center</code> 和 <code>Align</code> 等控件，以黄色箭头显示</li><li>spacer - 以灰色显示，比如没有子节点的 <code>Container</code> 就属于这一类</li></ul><p><a href="https://api.flutter.dev/flutter/rendering/debugPaintBaselinesEnabled.html" target="_blank" rel="noopener">debugPaintBaselinesEnabled</a> 的作用类似，它显示的是对象的基线。</p><p><a href="https://api.flutter.dev/flutter/rendering/debugPaintPointersEnabled.html" target="_blank" rel="noopener">debugPaintPointersEnabled</a> 用于开启一个特殊的模式：该模式下被点击的对象以蓝绿色显示。这个功能用于检查 hit test 是否正确。</p><p>还有几个用于调试 compositor layer 的 flag，</p><ul><li><a href="https://api.flutter.dev/flutter/rendering/debugPaintLayerBordersEnabled.html" target="_blank" rel="noopener">debugPaintLayerBordersEnabled</a> - 以橙色显示每个 layer 的边界，用于检查是否需要使用 <code>RepaintBoundary</code> 控件</li><li><a href="https://api.flutter.dev/flutter/rendering/debugRepaintRainbowEnabled.html" target="_blank" rel="noopener">debugRepaintRainbowEnabled</a> - 每个 layer 重绘时会叠加上不同的颜色。使用技巧：如果一个静态的 widget 颜色出现变化，可以考虑给它加上 <code>RepaintBoundary</code></li><li>debugPrintScheduleBuildForStacks - 为什么被构建</li><li>debugPrintRebuildDirtyWidgets - 什么组件被重新构建了</li><li>debugProfileBuildsEnabled - 在观测台里显示构建树</li><li><a href="https://api.flutter.dev/flutter/rendering/debugPaintLayerBordersEnabled.html" target="_blank" rel="noopener">debugPaintLayerBordersEnabled</a> - 查看 layer 界线</li><li><a href="https://api.flutter.dev/flutter/widgets/debugProfileBuildsEnabled.html" target="_blank" rel="noopener">debugProfileBuildsEnabled</a> - Adds Timeline events for every Widget built.</li><li><a href="https://api.flutter.dev/flutter/rendering/debugProfilePaintsEnabled.html" target="_blank" rel="noopener">debugProfilePaintsEnabled</a></li><li><a href="https://api.flutter.dev/flutter/widgets/debugPrintRebuildDirtyWidgets.html" target="_blank" rel="noopener">debugPrintRebuildDirtyWidgets</a><ul><li>结合 <a href="https://api.flutter.dev/flutter/widgets/debugPrintScheduleBuildForStacks.html" target="_blank" rel="noopener">debugPrintScheduleBuildForStacks</a>，可以观察 widget 的 dirty/clean 生命周期</li><li>结合 <a href="https://api.flutter.dev/flutter/widgets/debugProfileBuildsEnabled.html" target="_blank" rel="noopener">debugProfileBuildsEnabled</a>，可以在 DevTools Timeline 中观察到详细事件信息</li></ul></li></ul><p>注意：所有这些以 debug 开头的 flag 均只能工作于 debug 模式。</p><h2 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h2><p>调试动画的最有效方式是减慢其速度。可以使用 DevTool 中 <a href="https://flutter.dev/docs/development/tools/devtools/inspector" target="_blank" rel="noopener">Inspector view</a> 的 Slow Animations 按钮来减慢。可以使用 <a href="https://api.flutter.dev/flutter/scheduler/timeDilation.html" target="_blank" rel="noopener">timeDilation</a> 来更精确地控制动画速度。</p><h2 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h2><p><a href="https://api.flutter.dev/flutter/rendering/debugPrintMarkNeedsLayoutStacks.html" target="_blank" rel="noopener">debugPrintMarkNeedsLayoutStacks</a> - 如果 layout 次数比预期中的要多，可以通过这个 flag 来观察 render box 被置为 dirty 的原因。</p><h1 id="Flutter-Driver"><a href="#Flutter-Driver" class="headerlink" title="Flutter Driver"></a>Flutter Driver</h1><p>TODO</p><ul><li><a href="https://flutter.cn/docs/perf/rendering/ui-performance#benchmarking" target="_blank" rel="noopener">https://flutter.cn/docs/perf/rendering/ui-performance#benchmarking</a></li></ul><h1 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h1><ul><li>检查 Performance Overlay</li><li>检查 FPS (自行计算 FPS)</li><li>检查屏幕之外的视图 (使用 <code>checkerboardOffscreenLayers</code>)</li><li>检查没有缓存的图像 (使用 <code>checkerboardRasterCacheImages</code>)</li><li>检查 widget 重建性能 (使用 Widget rebuild stats)</li></ul><p>优化点：</p><ul><li>想办法减少 widget 重建</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://flutter.dev/docs/testing/code-debugging" target="_blank" rel="noopener">code-debugging</a></li><li><a href="https://flutter.dev/docs/testing/debugging" target="_blank" rel="noopener">debugging</a></li><li><a href="https://flutter.dev/docs/perf/rendering/ui-performance" target="_blank" rel="noopener">ui-performance</a></li><li><a href="https://medium.com/flutter/performance-testing-of-flutter-apps-df7669bb7df7" target="_blank" rel="noopener">Performance testing of Flutter apps - Flutter - Medium</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译) StatefulWidget 与性能</title>
      <link href="2020/01/10/stateful-widget-performance-considerations/"/>
      <url>2020/01/10/stateful-widget-performance-considerations/</url>
      
        <content type="html"><![CDATA[<p>Flutter StatefulWidget 与应用性能其实有些微妙的联系。</p><a id="more"></a><p>Flutter 官方文档提到 widget 只是一个配置数据结构，创建是非常轻量的，加上 Flutter 团队对 widget 的创建/销毁做了优化，不用担心整个 widget 树重新创建所带来的性能问题。但实际上并非这么简单。看看这篇文章怎么说吧。</p><p>本文翻译自 <a href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html#performance-considerations" target="_blank" rel="noopener">Performance considerations</a>。</p><p>有两大类 <a href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html" target="_blank" rel="noopener">StatefulWidget</a>。</p><!--There are two primary categories of StatefulWidgets.--><p>一类 StatefulWidget 在 <a href="https://api.flutter.dev/flutter/widgets/State/initState.html" target="_blank" rel="noopener">State.initState</a> 方法中分配资源，并且在 <a href="https://api.flutter.dev/flutter/widgets/State/dispose.html" target="_blank" rel="noopener">State.dispose</a> 方法中释放资源，但并不依赖 <a href="https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html" target="_blank" rel="noopener">InheritedWidget</a> 或调用 <a href="https://api.flutter.dev/flutter/widgets/State/setState.html" target="_blank" rel="noopener">State.setState</a> 方法。这类 Widget 通常用于应用或页面的根节点，并且使用 <a href="https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html" target="_blank" rel="noopener">ChangeNotifier</a>、<a href="https://api.flutter.dev/flutter/dart-async/Stream-class.html" target="_blank" rel="noopener">Stream</a> 或其他对象来跟子节点通信。遵守这种模式的 StatefulWidget 在 CPU 和 GPU 上的开销相对较低，因为它们只被创建一次且不再更新。所以这种 StatefulWidget 可以有相对复杂和较深层级的 build 方法。</p><p>另一类 StatefulWidget 使用 <a href="https://api.flutter.dev/flutter/widgets/State/setState.html" target="_blank" rel="noopener">State.setState</a> 方法或依赖 <a href="https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html" target="_blank" rel="noopener">InheritedWidget</a>。这类 widget 通常在应用的生命周期中重建很多次，因此最小化其重建过程非常重要。(它们可能也会在 <a href="https://api.flutter.dev/flutter/widgets/State/initState.html" target="_blank" rel="noopener">State.initState</a> 或 <a href="https://api.flutter.dev/flutter/widgets/State/didChangeDependencies.html" target="_blank" rel="noopener">State.didChangeDependencies</a> 方法中分配资源，但重点在于<strong>重建</strong>)</p><!--The first is one which allocates resources in State.initState and disposes of them in State.dispose, but which does not depend on InheritedWidgets or call State.setState. Such widgets are commonly used at the root of an application or page, and communicate with subwidgets via ChangeNotifiers, Streams, or other such objects. Stateful widgets following such a pattern are relatively cheap (in terms of CPU and GPU cycles), because they are built once then never update. They can, therefore, have somewhat complicated and deep build methods.The second category is widgets that use State.setState or depend on InheritedWidgets. These will typically rebuild many times during the application's lifetime, and it is therefore important to minimize the impact of rebuilding such a widget. (They may also use State.initState or State.didChangeDependencies and allocate resources, but the important part is that they rebuild.)--><p>有若干技巧用来减小重建 StatefulWidget 对性能的影响：</p><ul><li>将状态下沉到叶子节点。比如，页面上有个时钟，与其将时间状态放在上层页面中(每次时间更新时重建整个页面)，不如创建一个专用的 clock widget (每次时间更新时仅仅只需更新这个 widget)</li><li>最小化 build 方法创建的 widget 的数量以及相对应的 node 数量。理想状态下，一个 StatefulWidget 只用创建唯一一个 widget (类型为 <a href="https://api.flutter.dev/flutter/widgets/RenderObjectWidget-class.html" target="_blank" rel="noopener">RenderObjectWidget</a>)。(显然这并不总是可行，但 widget 越接近这个理想状态则越高效)</li><li>如果一棵子树并不变化，缓存对应的 widget 并尽可能复用。复用一个 widget 比新生成一个 widget 要高效。一种常用的改进方式是，重构有状态的部分到一个接收 child 参数的 widget 中</li><li>尽可能使用 <code>const</code> widget (这等同于缓存和复用 widget)</li><li>避免改变已创建的子树的深度或修改子树中 widget 的类型。比如，与其直接返回子节点或将其包裹在 <a href="https://api.flutter.dev/flutter/widgets/IgnorePointer-class.html" target="_blank" rel="noopener">IgnorePointer</a>，不如总是将子节点包裹在 <a href="https://api.flutter.dev/flutter/widgets/IgnorePointer-class.html" target="_blank" rel="noopener">IgnorePointer</a> 并且操作 <a href="https://api.flutter.dev/flutter/widgets/IgnorePointer/ignoring.html" target="_blank" rel="noopener">IgnorePointer.ignoring</a> 属性值。原因是改变子树深度会导致重新 build/layout/paint 整个子树，而修改属性值只会对渲染树进行尽可能少的修改 (在 <a href="https://api.flutter.dev/flutter/widgets/IgnorePointer-class.html" target="_blank" rel="noopener">IgnorePointer</a> 这个例子中，根本不必重新 layout 和 paint)</li><li>如果出于某些原因必须要改变深度，可以考虑将子树的通用部分包裹在一个带 <a href="https://api.flutter.dev/flutter/widgets/GlobalKey-class.html" target="_blank" rel="noopener">GlobalKey</a> 的 widget 中 (该 GlobalKey 在 widget 生命周期中不变。如果其他 widget 不能很方便地设置 key，可考虑使用 <a href="https://api.flutter.dev/flutter/widgets/KeyedSubtree-class.html" target="_blank" rel="noopener">KeyedSubtree</a>)</li></ul><!--There are several techniques one can use to minimize the impact of rebuilding a stateful widget:Push the state to the leaves. For example, if your page has a ticking clock, rather than putting the state at the top of the page and rebuilding the entire page each time the clock ticks, create a dedicated clock widget that only updates itself.Minimize the number of nodes transitively created by the build method and any widgets it creates. Ideally, a stateful widget would only create a single widget, and that widget would be a RenderObjectWidget. (Obviously this isn't always practical, but the closer a widget gets to this ideal, the more efficient it will be.)If a subtree does not change, cache the widget that represents that subtree and re-use it each time it can be used. It is massively more efficient for a widget to be re-used than for a new (but identically-configured) widget to be created. Factoring out the stateful part into a widget that takes a child argument is a common way of doing this.Use const widgets where possible. (This is equivalent to caching a widget and re-using it.)Avoid changing the depth of any created subtrees or changing the type of any widgets in the subtree. For example, rather than returning either the child or the child wrapped in an IgnorePointer, always wrap the child widget in an IgnorePointer and control the IgnorePointer.ignoring property. This is because changing the depth of the subtree requires rebuilding, laying out, and painting the entire subtree, whereas just changing the property will require the least possible change to the render tree (in the case of IgnorePointer, for example, no layout or repaint is necessary at all).If the depth must be changed for some reason, consider wrapping the common parts of the subtrees in widgets that have a GlobalKey that remains consistent for the life of the stateful widget. (The KeyedSubtree widget may be useful for this purpose if no other widget can conveniently be assigned the key.)--><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>减少 widget 重建 (可借助 Android Studio &gt; Flutter Performance &gt; Widget rebuild stats 来<a href="https://flutter.cn/docs/development/tools/android-studio#show-performance-data" target="_blank" rel="noopener">统计重建次数</a>)</li><li>缓存不变的子树</li><li>尽可能使用 <code>const</code> widget</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter RenderObject 浅析</title>
      <link href="2019/12/26/flutter-render-object/"/>
      <url>2019/12/26/flutter-render-object/</url>
      
        <content type="html"><![CDATA[<p>Flutter 开发指南中提到 Widget 是 Android View 的对等物。虽然形象，但不准确。Flutter 文档说一切皆 Widget，同时又说 Widget 只是 UI 配置/蓝图，到底该如何理解？本文带你揭开 Widget 的神秘面纱，探寻背后藏着的 RenderObject。</p><a id="more"></a><p>[TOC]</p><p>本文转自<a href="https://www.sunmoonblog.com/2019/12/26/flutter-render-object/">我的博客</a>，内容整理自我的一份<a href="https://docs.google.com/presentation/d/1yfBqORVrDXmSSCMWei_29WaccaCL5B2qaFPMayQk-18/edit?usp=sharing" target="_blank" rel="noopener">PPT</a>。</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote><p>in Flutter, the rough equivalent to a View is a Widget。Flutter Widget 是 Android View 的对等物<br><a href="https://flutter.dev/docs/get-started/flutter-for/android-devs#what-is-the-equivalent-of-a-view-in-flutter" target="_blank" rel="noopener">参考</a></p></blockquote><p>当你使用 Flutter 一段时间后你会发现两者并不完全对等。比如，Android 中这些我们熟悉的用于操作 View 的方法，在 Flutter Widget 中并不存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">View.getWidth();</span><br><span class="line">View.getHeight();</span><br><span class="line">View.getLocationInWindow();</span><br><span class="line">ViewGroup.addView();</span><br><span class="line">ViewGroup.removeView();</span><br></pre></td></tr></table></figure><blockquote><p>Flutter 中 一切 UI 皆 Widget。不过，Widget 生而不同<br><a href="https://flutter.dev/docs/resources/technical-overview#everythings-a-widget" target="_blank" rel="noopener">参考</a></p></blockquote><p>不同种类的 Widget 存在着非常大的差异，包括：</p><ul><li>功能差异</li><li>类结构差异</li><li>树结构差异</li></ul><h2 id="功能差异"><a href="#功能差异" class="headerlink" title="功能差异"></a>功能差异</h2><p>以 Flutter 生成的缺省工程为例，UI 截图 和 Widget Outline 分别如下：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/27/15773323688839.jpg" alt="StatelessWidget w600"></p><p>从上图看 Widget 相当强大，可以通过 StatelessWidget 和 StatefulWidget 将已有的各种 Widget <strong>组合</strong>成复杂的界面，但即便如此，StatelessWidget 和 StatefulWidget 等 Widget 实际上并没有任何<strong>自定义绘制</strong> 能力(它们似乎充当了 Android ViewGroup 的角色)。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/27/15773505764400.jpg" alt="ErrorWidget -w300"></p><p>相反，Opacity、ErrorWidget 等 Widget 没有强大的组合能力，却有<strong>自定义绘制能力</strong>(它们更像是 Android View)。</p><p>所以我们可以根据自定义绘制能力将它们粗略分成两大类：<strong>只支持组合</strong>与<strong>可自定义绘制</strong>。追根溯源我们将发现这种不同其实来自于 RenderObject。</p><h2 id="类结构差异"><a href="#类结构差异" class="headerlink" title="类结构差异"></a>类结构差异</h2><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/27/15773503347545.jpg" alt="Widget的类结构 -w800"></p><p>观察不同 Widget 的类结构，不难发现 Opacity 和 ErrorWidget 这些可自定义绘制的控件与 StatelessWidget 和 StatefulWidget 这些不支持自定义绘制的控件不同，前两者并非直接继承自 <code>Widget</code>，而是继承自 <code>RenderObjectWidget</code>。</p><p>看名字，不难发现 <code>RenderObjectWidget</code> 跟 RenderObject 存在某种关联。</p><h2 id="树结构差异"><a href="#树结构差异" class="headerlink" title="树结构差异"></a>树结构差异</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    runApp(Container(child: ErrorWidget(<span class="string">'hello, world'</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/27/15773516364547.jpg" alt="渲染树与RenderObject -w600"></p><p>同样是 Widget，渲染树中可以看到 ErrorWidget 有一个关联的 renderObject 对象，而 Container 并没有关联的 renderObject 对象。产生这种差异的原因是什么？</p><h1 id="RenderObject-介绍"><a href="#RenderObject-介绍" class="headerlink" title="RenderObject 介绍"></a>RenderObject 介绍</h1><h2 id="Widget，Element-与-RenderObject"><a href="#Widget，Element-与-RenderObject" class="headerlink" title="Widget，Element 与 RenderObject"></a>Widget，Element 与 RenderObject</h2><p>Element 是联系 Widget 和 RenderObject 的纽带。</p><ul><li>Widget - 存放渲染内容、视图布局信息</li><li>Element - 存放上下文信息，通过 Element 遍历视图树，Element 同时持有Widget和RenderObject</li><li>RenderObject - 根据 Widget 的布局属性进行 layout，对 widget 传入的内容进行渲染绘制</li></ul><p>先来快速地了解一下。</p><p>首先通过一张图来看 Element 是如何发挥其纽带作用的：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/27/15773523142153.jpg" alt="Widget,Element与RenderObject -w800"></p><ul><li>每个 Widget 会创建一个对应的 Element 对象 (通过 <code>Widget.createElement()</code>)</li><li>每个 Element 会持有对应 Widget 对象的引用 (注意 <code>createElement()</code> 方法第一个参数)</li><li>RenderObjectElement 是 Element 的子类，这种 Element 持有一个 RenderObject 对象的引用</li></ul><p>其次，Element 也是树形结构。我们常说 Widget 是配置/蓝图，其实更具体来说 Widget 是 Element 的配置/蓝图。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/27/15774111904123.jpg" alt="Element数据结构 -w800"></p><p>配置(Widget)的变更导致 Element 树进行相应地更新。<code>Element.updateChild()</code> 是 Widget 系统的核心方法，它负责处理这个更新。</p><p><code>Element.updateChild()</code> 的更新策略见下图：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/27/15774121792952.jpg" alt="Element.updateChild() -w800"></p><p>注意区分 Widget 的更新和 Element 的更新有着非常重大的差别：</p><ul><li>Widget 是配置数据，是轻量级对象。Widget 的更新对应着 <code>Stateless.build()</code> 和 <code>StatefulWidget.build()</code>，<strong>重新创建整个 Widget 树</strong>，是个全量过程</li><li>Element 是重量级对象。Element 的更新对应着 <code>Element.updateChild()</code>，<strong>更新整个 Element 树</strong>，是个增量过程</li></ul><p>最后，如果非要找一段代码来体现三者之间的联系，非 <code>Element.inflateWidget()</code> 方法莫属。该方法简化后的代码如下，完整代码见 <a href="https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/framework.dart#L3247" target="_blank" rel="noopener">Github</a>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Element</span> inflateWidget(Widget newWidget, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Element</span> newChild = newWidget.createElement();</span><br><span class="line">  newChild.mount(<span class="keyword">this</span>, newSlot);</span><br><span class="line">  <span class="keyword">return</span> newChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述代码中的 Element 和 Widget 实际类型分别是 <code>RenderObjectElement</code> 和 <code>RenderObjectWidget</code>，则 <code>mount()</code> 方法会创建 <code>renderObject</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/27/15773529078805.jpg" alt="RenderObject创建流程 -w600"></p><p>注意：只有 RenderObjectElement/RednerObjectWidget 的子类才能创建 RenderObject 对象。</p><p>了解 Widget，Element 与 RenderObject 三者之间关系后我们再来重点看 RenderObject。</p><h2 id="初识-RenderObject"><a href="#初识-RenderObject" class="headerlink" title="初识 RenderObject"></a>初识 RenderObject</h2><blockquote><p>The Flutter render tree is a low-level layout and painting system based on a retained tree of objects that inherit from RenderObject. Most developers using Flutter won’t need to interact directly with the rendering tree. Instead, most developers should use widgets, which are built using the render tree.<br>The base class for every node in the render tree is RenderObject , which defines the base layout model<br><a href="https://flutter.dev/docs/resources/rendering#introduction" target="_blank" rel="noopener">参考</a></p></blockquote><blockquote><p>The RenderObject class hierarchy is the core of the rendering library’s reason for being.<br>The RenderObject class also implements the layout and paint protocols.<br><a href="https://api.flutter.dev/flutter/rendering/RenderObject-class.html" target="_blank" rel="noopener">参考</a></p></blockquote><p>翻译过来就是：</p><ul><li>RenderObject 类层级是渲染库的核心，定义了基本的布局模型</li><li>RenderObject 类实现了布局和绘制协议</li><li>RenderObject 及其子类是渲染树(低层布局和绘制系统)的基础</li><li>开发者应当使用 Widget 来构建渲染树，而不是直接操作渲染树</li></ul><h2 id="RenderObject-结构"><a href="#RenderObject-结构" class="headerlink" title="RenderObject 结构"></a>RenderObject 结构</h2><p>RenderObject 的结构如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> <span class="keyword">extends</span> <span class="title">AbstractNode</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// The parent of this node in the tree.</span></span><br><span class="line">  AbstractNode _parent;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// Data for use by the parent render object.</span></span><br><span class="line">  ParentData parentData;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// The layout constraints most recently supplied by the parent.</span></span><br><span class="line">  Constraints _constraints;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// The owner for this node (null if unattached).</span></span><br><span class="line">  <span class="built_in">Object</span> _owner;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/// Whether this node is in a tree whose root is attached to something.</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> attached =&gt; _owner != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意: 这个方法需要子类正确重写</span></span><br><span class="line">  <span class="comment">/// Override to setup parent data correctly for your children.</span></span><br><span class="line">  <span class="keyword">void</span> setupParentData(<span class="keyword">covariant</span> RenderObject child) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Called by subclasses when they decide a render object is a child.  </span></span><br><span class="line">  <span class="keyword">void</span> adoptChild(RenderObject child) &#123;&#125;</span><br><span class="line">  <span class="comment">/// Called by subclasses when they decide a render object is no longer a child.  </span></span><br><span class="line">  <span class="keyword">void</span> dropChild(RenderObject child) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// Mark this node as attached to the given owner.  </span></span><br><span class="line">  <span class="keyword">void</span> attach(PipelineOwner owner) &#123;&#125;</span><br><span class="line">  <span class="comment">/// Mark this node as detached.</span></span><br><span class="line">  <span class="keyword">void</span> detach() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将 RenderObject 的属性及相关方法分成三类：</p><table><thead><tr><th></th><th>属性</th><th>方法</th></tr></thead><tbody><tr><td>与 parent 交互</td><td><strong>_parent</strong>, <strong>parentData</strong>, _constraints</td><td>setupParentData()</td></tr><tr><td>与 owner 交互</td><td>_owner</td><td>attach(), detach(), attached</td></tr><tr><td>与 child 交互</td><td>-</td><td>adoptChild(), dropChild()</td></tr></tbody></table><p>RenderObject 中两个重要的属性是 <code>_parent</code> 和 <code>parentData</code>。</p><ul><li><code>_parent</code> 用于将各 RenderObject 组合成一棵树</li><li><code>parentData</code> 是个比较神奇的存在。(不过，回想一样 <code>View.mLayoutParams</code> 字段就不觉得神奇了)。逻辑上讲，这个字段的所有者是当前 RenderObject 的 parent；物理上讲，这个字段被保存在当前 RenderObject。这个字段通常保存类似于子节点位置这样的信息。</li></ul><p>简单来说，RenderObject 定义了<strong>布局/绘制协议</strong>，但并没定义具体<strong>布局/绘制模型</strong>。(RenderBox 是 RenderObject 的子类，它遵守 RenderObject 定义的布局/绘制协议，实现了一个具体的布局/绘制模型。)</p><p>什么是布局/绘制协议？举例来说，我们自己继承 RenderObject 实现一个新的子类时，必须遵守一系列的要求(完整协议见 <a href="https://api.flutter.dev/flutter/rendering/RenderBox-class.html" target="_blank" rel="noopener">文档</a>)：</p><ul><li>要实现 <code>performLayout()</code> 方法，该方法接受一个 <code>Constraints</code> 参数</li><li>要实现 <code>paint()</code> 方法</li><li>使用 <code>dropChild()</code> 方法添加子节点</li><li>使用 <code>adoptChild()</code> 方法移除子节点</li><li>…</li></ul><p>这些要求就是协议。Android 中也有类似”协议” (或称之为约定 Contract)，比如覆盖 <code>View.onMeasure()</code> 方法时要求必须调用 <code>setMeasuredDimension()</code> 保存相关值。</p><hr><p>什么是布局/绘制模型？可以看到协议中并没有指定该如何处理如下这些问题：</p><ul><li>是允许0个，1个还是多个子节点？ （子节点模型 children model)</li><li>使用什么坐标系，笛卡尔坐标系还是极坐标系或是别的？</li></ul><p>这些问题描述了模型。RenderBox (RenderObject 子类) 正是一个具体的模型，它要求使用笛卡尔坐标系，并提供定义了明确的子节点模型：</p><ul><li>如果子节点数量为0 (例如 RenderImage, RenderParagraph, RenderErrorBox)，不必处理</li><li>如果子节点数量为1 (例如 RenderOpacity)，通常继承 RenderProxyBox 即可</li><li>…</li></ul><h2 id="RenderObject-的方法"><a href="#RenderObject-的方法" class="headerlink" title="RenderObject 的方法"></a>RenderObject 的方法</h2><p>或许你已经发现 RenderObject 更像 Android View 的对应物。的确如此，两者不仅从概念上类似，很多方法也几乎一一对应。</p><table><thead><tr><th></th><th>Flutter RenderObject</th><th>Android View</th></tr></thead><tbody><tr><td>绘制</td><td><strong>paint()</strong></td><td>draw()/onDraw()</td></tr><tr><td>布局</td><td><strong>performLayout()</strong>/layout()</td><td>measure()/onMeasure(), layout()/onLayout()</td></tr><tr><td>布局约束</td><td>Constraints</td><td>MeasureSpec</td></tr><tr><td>布局协议1</td><td>performLayout() 的 Constraints 参数表示父节点对子节点的布局限制</td><td>measure() 的两个参数表示父节点对子节点的布局限制</td></tr><tr><td>布局协议2</td><td>performLayout() 应调用各子节点的 layout()</td><td>onLayout() 应调用各子节点的 layout()</td></tr><tr><td>布局参数</td><td>parentData</td><td>mLayoutParams</td></tr><tr><td>请求布局</td><td>markNeedsLayout()</td><td>requestLayout()</td></tr><tr><td>请求绘制</td><td>markNeedsPaint()</td><td>invalidate()</td></tr><tr><td>添加 child</td><td>adoptChild()</td><td>addView()</td></tr><tr><td>移除 child</td><td>dropChild()</td><td>removeView()</td></tr><tr><td>关联到窗口/树</td><td>attach()</td><td>onAttachedToWindow()</td></tr><tr><td>从窗口/树取消关联</td><td>detach()</td><td>onDetachedFromWindow()</td></tr><tr><td>获取 parent</td><td>parent</td><td>getParent()</td></tr><tr><td>触摸事件</td><td>hitTest()</td><td>onTouch()</td></tr><tr><td>用户输入事件</td><td>handleEvent()</td><td>onKey()</td></tr><tr><td>旋转事件</td><td>rotate()</td><td>onConfigurationChanged()</td></tr></tbody></table><p>此外，一些方法调用规则也类似。比如：</p><blockquote><p>The setter will typically finish with either a call to markNeedsLayout, if the layout uses this property, or markNeedsPaint, if only the painter function does. (No need to call both, markNeedsLayout implies markNeedsPaint.)</p></blockquote><ul><li>setter() 方法最后通常会调用 <code>markNeedsLayout()</code> 或 <code>markNeedsPaint()</code></li><li>调用 <code>markNeedsLayout()</code> 意味着也自动调用了 <code>markNeedsPaint()</code></li></ul><p>以这段 Android 代码为例，<code>ColorDrawable.setColor()</code> 方法修改颜色主动调用 <code>invalidateSelf()</code>，最终会调用到某个 View 的 <code>invalidate()</code> 导致重新绘制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorDrawable</span> <span class="keyword">extends</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(@ColorInt <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mColorState.mBaseColor != color || mColorState.mUseColor != color) &#123;</span><br><span class="line">            mColorState.mBaseColor = mColorState.mUseColor = color;</span><br><span class="line">            invalidateSelf();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RenderObject 的方法串起来大致是这样：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/27/15774456110882.jpg" alt="RenderObject lifecycle -w600"></p><h1 id="RenderBox-示例"><a href="#RenderBox-示例" class="headerlink" title="RenderBox 示例"></a>RenderBox 示例</h1><p>最后通过一个示例来加深前面提到一些知识点。</p><p>我实现了自定义的 <code>CircleTextWidget</code>，直接将其展示出来：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(Center(</span><br><span class="line">      child: SizedBox(</span><br><span class="line">          width: <span class="number">200</span>,</span><br><span class="line">          height: <span class="number">200</span>,</span><br><span class="line">          child: Center(</span><br><span class="line">            child: CircleTextWidget(</span><br><span class="line">              child: Text(</span><br><span class="line">                <span class="string">'hello, renderBox'</span>,</span><br><span class="line">                textDirection: TextDirection.ltr,</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Widget 树和渲染树如下图：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/27/15774366867668.jpg" alt="Widget树和渲染树 -w800"></p><p>CircleTextWidget 运行起来的效果图如下，</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/27/15774370864830.jpg" alt="CircleTextWidget -w800"></p><p>再来看 CircleTextWidget 的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleTextWidget</span> <span class="keyword">extends</span> <span class="title">SingleChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line">  CircleTextWidget(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderCircleText createRenderObject(BuildContext context) =&gt;</span><br><span class="line">      RenderCircleText();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderCircleText</span> <span class="keyword">extends</span> <span class="title">RenderProxyBox</span> </span>&#123;</span><br><span class="line">  RenderCircleText(&#123;RenderBox child&#125;) : <span class="keyword">super</span>(child);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">    <span class="keyword">super</span>.paint(context, offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父节点的宽高分别是 200, 200，由前面的 SizedBox 指定</span></span><br><span class="line">    <span class="comment">// dx, dy 分别是 100, 100</span></span><br><span class="line">    <span class="built_in">double</span> dx = constraints.constrainWidth() / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">double</span> dy = constraints.constrainHeight() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中心点坐标</span></span><br><span class="line">    Offset center = offset.translate(size.width / <span class="number">2</span>, size.height / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 左上角坐标</span></span><br><span class="line">    Offset topLeft = center.translate(-dx, -dy);</span><br><span class="line">    <span class="comment">// 右上角坐标</span></span><br><span class="line">    Offset topRight = center.translate(dx, -dy);</span><br><span class="line">    <span class="comment">// 左下角坐标</span></span><br><span class="line">    Offset bottomLeft = center.translate(-dx, dy);</span><br><span class="line">    <span class="comment">// 右下角坐标</span></span><br><span class="line">    Offset bottomRight = center.translate(dx, dy);</span><br><span class="line"></span><br><span class="line">    Paint paint = Paint()..color = Colors.amber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制蓝色矩形中心点</span></span><br><span class="line">    context.canvas.drawRect(</span><br><span class="line">        Rect.fromCenter(center: center, width: <span class="number">18</span>, height: <span class="number">18</span>),</span><br><span class="line">        paint..color = Colors.blue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制四角的圆形点</span></span><br><span class="line">    context.canvas.drawCircle(topLeft, <span class="number">10</span>, paint..color = Colors.red);</span><br><span class="line">    context.canvas.drawCircle(topRight, <span class="number">10</span>, paint..color = Colors.yellow);</span><br><span class="line">    context.canvas.drawCircle(bottomLeft, <span class="number">10</span>, paint..color = Colors.orange);</span><br><span class="line">    context.canvas.drawCircle(bottomRight, <span class="number">10</span>, paint..color = Colors.green);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制子节点</span></span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      context.paintChild(child, offset);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RenderCircleText-类"><a href="#RenderCircleText-类" class="headerlink" title="RenderCircleText 类"></a>RenderCircleText 类</h2><p>RenderCircleText 继承自 RenderProxyBox。RenderObject 定义了布局和绘制协议，但没有实现具体的布局模型。RenderBox 是 RenderObject 子类，实现了 box 布局模型。RenderProxyBox 是 RenderBox 的子类，它特别适合这种情形：父节点几乎跟子节点完全一样。</p><p>我们这里的 RenderCircleText 其实只是为其子节点绘制了自定义背景，所以继承自 RenderProxyBox 是个不错的选择。</p><h2 id="paint-方法"><a href="#paint-方法" class="headerlink" title="paint() 方法"></a>paint() 方法</h2><p>RenderCircleText 实现了 <a href="https://api.flutter.dev/flutter/rendering/RenderObject/paint.html" target="_blank" rel="noopener">paint()</a> 方法。它的原型如下：</p><p><code>void paint(PaintingContext context, Offset offset)</code></p><p><code>paint()</code> 方法涉及到的几个要点：</p><ul><li><code>PaintingContext</code> 参数 - PaintingContext 是一个高级画布，它的绘制对象是各种 RenderBox。PaintingContext 还持有一个 Canvas 对象(低级画布)，它的绘制对象各种形状、path、图像、文本等元素</li><li><code>Offset</code> 参数 - Offset 表示当前 RenderObject 的绘制起点(屏幕左上角是原点 Offset(0,0))。在本例当中这个绘制起点为 Offset(130.0, 350.3)</li><li><code>constraints</code> 成员 - 父节点给当前 RenderBox 设置的约束，见下图</li><li><code>size</code> 成员 -  当前 RenderBox 的大小，见下图</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/27/15774403469638.jpg" alt="paint()方法 -w800"></p><p>结合 <code>constraints</code> 和 <code>offset</code> 我们不难计算出这几个点的坐标：</p><ul><li>中心点</li><li>左上角</li><li>右上角</li><li>左下角</li><li>右下角</li></ul><p>先调用 Canvas 的方法给子节点绘制出背景：</p><ul><li>canvas.drawRect()</li><li>canvas.drawCircle()</li></ul><p>再调用 PaintingContext 的方法绘制出子节点：</p><ul><li>context.paintChild()</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文先从 Widget 是否具备自定义绘制能力出发，引出 RenderObject，然后梳理了 Widget、Element 和 RenderObject 三者之间的关系。接下来通过与 Android View 类比的方式介绍了 RenderObject。</p><p>理解 RenderObject 的几个关键在于：</p><ul><li>RenderObject 类层级是渲染库的核心</li><li>RenderObject 定义布局和绘制协议</li><li>RenderObject 是 Android View 的对应物</li><li>RenderBox 实现一种布局和绘制模型</li></ul><p>最后的示例中实现了一个可自定义绘制的 Widget，以加深对 RenderObject 的理解。 </p><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>2020-04-26 Update</p><p>补充一张 render tree 生命周期相关的图</p><p><img src="/images/15878833456674.jpg" alt></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/flutter/website/blob/master/src/docs/resources/rendering.md" target="_blank" rel="noopener">Flutter rendering</a></li><li><a href="https://medium.com/flutter-community/flutter-what-are-widgets-renderobjects-and-elements-630a57d05208" target="_blank" rel="noopener">Flutter, what are Widgets, RenderObjects and Elements?</a></li><li><a href="https://juejin.im/post/5c7cd2f4e51d4537b05b0974" target="_blank" rel="noopener">Flutter框架分析（一）– 总览和Window - 掘金</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart Mixin 介绍</title>
      <link href="2019/12/23/dart-mixin/"/>
      <url>2019/12/23/dart-mixin/</url>
      
        <content type="html"><![CDATA[<p>关于 Dart mixin 的一些理解。理解 mixin 概念的关键在于理解中间类。</p><a id="more"></a><blockquote><p>Mixins are a way of reusing code in multiple class hierarchies</p></blockquote><p>先来看一个简单例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Piloted</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> astronauts = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">void</span> describeCrew() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Number of astronauts: <span class="subst">$astronauts</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PilotedCraft</span> <span class="keyword">extends</span> <span class="title">Spacecraft</span> <span class="title">with</span> <span class="title">Piloted</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PilotedCraft</code> 拥有 <code>astronauts</code> 字段和 <code>describeCrew()</code> 方法。</p><h1 id="mixin-是什么？"><a href="#mixin-是什么？" class="headerlink" title="mixin 是什么？"></a>mixin 是什么？</h1><p>维基百科中这样定义 mixin：</p><blockquote><p>In object-oriented programming languages, a Mixin is a class that contains methods for use by other classes without having to be the parent class of those other classes.</p></blockquote><p>即，mixin 是另外一个普通类，我们可以在不继承这个类的情况下从这个类”借用”方法和变量。</p><blockquote><p>Support for the mixin keyword was introduced in Dart 2.1. Code in earlier releases usually used abstract class instead.</p></blockquote><p>从这个角度来讲，mixin 不过是 <code>abstract class</code>。</p><blockquote><p>Java tries to make up for this by using Interfaces, but that is not as useful or flexible as mixins.</p></blockquote><p>从这个角度来讲，可以认为 mixin 是带实现的接口。</p><h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><ul><li>mixin 有点类似 <code>abstract class</code></li><li>mixin 有点类似 <code>interface</code></li><li>不能继承 mixin</li><li>可以使用 <code>mixin</code>, <code>abstract class</code>, <code>class</code> 来作为 mixin</li></ul><h1 id="如何使用-mixin"><a href="#如何使用-mixin" class="headerlink" title="如何使用 mixin?"></a>如何使用 mixin?</h1><p>使用 mixin 的方法很简单：<code>with</code> 关键字后面跟上 mixin 的名字即可。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Musician</span> <span class="keyword">extends</span> <span class="title">Performer</span> <span class="title">with</span> <span class="title">Musical</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maestro</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">Musical</span>, <span class="title">Aggressive</span>, <span class="title">Demented</span> </span>&#123;</span><br><span class="line">  Maestro(<span class="built_in">String</span> maestroName) &#123;</span><br><span class="line">    name = maestroName;</span><br><span class="line">    canConduct = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 mixin 的方法同样也很简单：创建一个继承自 <code>Object</code> 的类并且不要声明构造方法。如果想让 mixin 作为普通类使用，使用 <code>class</code> 关键字；如果不想让 mixin 作为普通类使用，使用 <code>mixin</code> 关键字代替 <code>class</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> Musical &#123;</span><br><span class="line">  <span class="built_in">bool</span> canPlayPiano = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canCompose = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canConduct = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> entertainMe() &#123;</span><br><span class="line">    <span class="keyword">if</span> (canPlayPiano) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Playing piano'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (canConduct) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Waving hands'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Humming to self'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="on-的用法"><a href="#on-的用法" class="headerlink" title="on 的用法"></a>on 的用法</h1><blockquote><p>The keyword on is used to restrict our mixin’s use to only classes which either extends or implements the class it is declared on. In order to use the on keyword, you must declare your mixin using the mixin keyword</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">mixin</span> Y <span class="keyword">on</span> B &#123;</span><br><span class="line">  <span class="keyword">void</span> hi() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'hi'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Q</span> <span class="title">with</span> <span class="title">Y</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>则有如下错误提示：</p><p><code>Error: &#39;Object&#39; doesn&#39;t implement &#39;B&#39; so it can&#39;t be used with &#39;Y&#39;.</code></p><p><code>on</code> 关键字限制了 <code>Y</code> 的使用范围：<code>Y</code> 只能用于继承或实现了 <code>B</code> 的类。修复方式是让 <code>Q</code> 继承自 <code>B</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Q</span> <span class="keyword">extends</span> <span class="title">B</span> <span class="title">with</span> <span class="title">Y</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="mixin-解决了什么问题？"><a href="#mixin-解决了什么问题？" class="headerlink" title="mixin 解决了什么问题？"></a>mixin 解决了什么问题？</h1><p>mixin 解决了多重继承中的 <a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" target="_blank" rel="noopener">Deadly Diamond of Death(DDD)</a> 问题。</p><p>多重继承问题简单描述。各个类的继承关系如下：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/23/15768441684217.jpg" alt="mixin 与继承 -w500"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Performer</span> &#123;</span></span><br><span class="line">    <span class="function">abstract <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dancer</span> <span class="title">extends</span> <span class="title">Performer</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> <span class="title">extends</span> <span class="title">Performer</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Musician</span> <span class="title">extends</span> <span class="title">Dancer</span>, <span class="title">Singer</span> &#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题来了，当调用 <code>Musician.perform()</code> 时，到底会<strong>调用哪个 <code>perform()</code> 方法是模糊的</strong>。</p><p>来看 mixin 如何解决这个问题。见 <a href="https://medium.com/flutter-community/https-medium-com-shubhamhackzz-dart-for-flutter-mixins-in-dart-f8bb10a3d341" target="_blank" rel="noopener">Dart for Flutter : Mixins in Dart - Flutter Community - Medium</a></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Performer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> perform();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> Dancer &#123;</span><br><span class="line">    <span class="keyword">void</span> perform() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> Singer &#123;</span><br><span class="line">    <span class="keyword">void</span> perform() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Musician</span> <span class="keyword">extends</span> <span class="title">Performer</span> <span class="title">with</span> <span class="title">Dancer</span>, <span class="title">Singer</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当调用 <code>Musician.perform()</code> 时，到底会<strong>调用哪个 <code>perform()</code> 方法是确定的</strong>。在这里是调用 <code>Singer.perform()</code>。</p><p>mixin 有一套明确的机制来选择调用哪个方法。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/23/15768445983681.jpg" alt="minx 是线性的栈结构 -w500"></p><p>假设 <code>Musician</code> 类使用多个 mixin (<code>Dancer</code>, <code>Singer</code>)。该类有个方法名为 <code>perform()</code>，<code>Musician</code> 类继承自 <code>Performer</code> 类。</p><ul><li>首先，将 <code>Performer</code> 类置于栈顶</li><li>其次，后声明的 mixin 优先于后声明的 mixin。按顺序将 mixin 置于栈中，在这里分别是 <code>Dancer</code>, <code>Singer</code></li><li>最后，将 <code>Musician</code> 类自己置于栈中。<code>Musician</code> 类中的 <code>perform()</code> 被优先调用</li></ul><hr><p>Dart 使用的是单重继承 (Java 也是单重继承，C++ 是多重继承)。多重继承更为强大，但会引起 <a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" target="_blank" rel="noopener">Deadly Diamond of Death(DDD)</a> 问题。</p><p>Java 使用接口(interface)来部分实现多重继承。多重继承的问题是需要在每个类中实现接口(interface)，所以并不是一个好的方案。(实际上 Java 已经通过默认方法修复了这个问题)</p><p>所以 Dart 中就有了 mixin。</p><h1 id="理解-mixin"><a href="#理解-mixin" class="headerlink" title="理解 mixin"></a>理解 mixin</h1><blockquote><p>Mixins in Dart work by creating a new class that layers the implementation of the mixin on top of a superclass to create a new class — it is not “on the side” but “on top” of the superclass, so there is no ambiguity in how to resolve lookups.<br>Mixins is not a way to get multiple inheritance in the classical sense. Mixins is a way to abstract and reuse a family of operations and state. It is similar to the reuse you get from extending a class, but it is compatible with single-inheritance because it is linear.<br><a href="https://stackoverflow.com/a/45903671" target="_blank" rel="noopener">StackOverflow</a></p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> getMessage() =&gt; <span class="string">'A'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> getMessage() =&gt; <span class="string">'B'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> getMessage() =&gt; <span class="string">'P'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AB</span> <span class="keyword">extends</span> <span class="title">P</span> <span class="title">with</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BA</span> <span class="keyword">extends</span> <span class="title">P</span> <span class="title">with</span> <span class="title">B</span>, <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span> result = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  AB ab = AB();</span><br><span class="line">  result += ab.getMessage();</span><br><span class="line"></span><br><span class="line">  BA ba = BA();</span><br><span class="line">  result += ba.getMessage();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上这段代码输出 <code>BA</code>。</p><p>从语义上讲以上这段代码等同于：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PA</span> = <span class="title">P</span> <span class="title">with</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">PAB</span> = <span class="title">PA</span> <span class="title">with</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AB</span> <span class="keyword">extends</span> <span class="title">PAB</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PB</span> = <span class="title">P</span> <span class="title">with</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">PBA</span> = <span class="title">PB</span> <span class="title">with</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BA</span> <span class="keyword">extends</span> <span class="title">PBA</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>继承结构图是这样的：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/23/15770742264332.jpg" alt="mixin 的继承关系 -w400"></p><blockquote><p>Since each mixin application creates a new class, it also creates a new interface (because all Dart classes also define interfaces). As described, the new class extends the superclass and includes copies of the mixin class members, but it also implements the mixin class interface.<br>In most cases, there is no way to refer to that mixin-application class or its interface; the class for Super with Mixin is just an anonymous superclass of the class declared like class C extends Super with Mixin {}. If you name a mixin application like class CSuper = Super with Mixin {}, then you can refer to the mixin application class and its interface, and it will be a sub-type of both Super and Mixin.</p></blockquote><p>理解 mixin 的关键在于它是线性的。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul><li>在没有共同父类的各个类中共享代码时</li><li>在父类中实现某种方法无意义时</li></ul><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>(2020-7-22 更新：<a href="https://juejin.im/post/5efbf499e51d4534b979050c" target="_blank" rel="noopener">从mixin机制理解Flutter App启动 - 掘金</a> 也是分析 Flutter App 启动过程时无法理解 mixin，然后逐步了解 mixin 概念，再回过头来看 Flutter App 启动过程)</p><p><code>runApp()</code> 是我们运行应用的入口。这个方法的代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> runApp(Widget app) &#123;</span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized()</span><br><span class="line">    ..attachRootWidget(app)</span><br><span class="line">    ..scheduleWarmUpFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的的 <code>WidgetsFlutterBinding</code> 联系着 Flutter framework 和 Flutter engine。</p><blockquote><p>A concrete binding for applications based on the Widgets framework.</p><p>This is the glue that binds the framework to the Flutter engine.</p></blockquote><p><code>WidgetsFlutterBinding</code> 定义如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetsFlutterBinding</span> <span class="keyword">extends</span> <span class="title">BindingBase</span> <span class="title">with</span> <span class="title">GestureBinding</span>, <span class="title">ServicesBinding</span>, </span></span><br><span class="line"><span class="class"> <span class="title">SchedulerBinding</span>, <span class="title">PaintingBinding</span>, <span class="title">SemanticsBinding</span>,</span></span><br><span class="line"><span class="class"> <span class="title">RendererBinding</span>, <span class="title">WidgetsBinding</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingBase</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> GestureBinding <span class="keyword">on</span> BindingBase <span class="keyword">implements</span> HitTestable, HitTestDispatcher, HitTestTarget &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> ServicesBinding <span class="keyword">on</span> BindingBase &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> SchedulerBinding <span class="keyword">on</span> BindingBase, ServicesBinding &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> PaintingBinding <span class="keyword">on</span> BindingBase, ServicesBinding &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> SemanticsBinding <span class="keyword">on</span> BindingBase &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> RendererBinding <span class="keyword">on</span> BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HitTestable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>定义 mixin。<code>mixin RendererBinding</code> 定义了一个名为 <code>RendererBinding</code> 的 mixin</li><li>限制 mixin 的使用范围。<code>mixin RendererBinding on BindingBase, ServicesBinding</code> 限制 <code>RendererBinding</code> 只能用于继承或实现了 <code>BindingBase</code> 或 <code>ServicesBinding</code> 的类上</li><li>使用 mixin。<code>class WidgetsFlutterBinding extends BindingBase with RendererBinding</code></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetsFlutterBinding</span> <span class="keyword">extends</span> <span class="title">BindingBase</span></span></span><br><span class="line"><span class="class">    <span class="title">with</span></span></span><br><span class="line"><span class="class">        <span class="title">GestureBinding</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ServicesBinding</span>,</span></span><br><span class="line"><span class="class">        <span class="title">SchedulerBinding</span>,</span></span><br><span class="line"><span class="class">        <span class="title">PaintingBinding</span>,</span></span><br><span class="line"><span class="class">        <span class="title">SemanticsBinding</span>,</span></span><br><span class="line"><span class="class">        <span class="title">RendererBinding</span>,</span></span><br><span class="line"><span class="class">        <span class="title">WidgetsBinding</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingBase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"BindingBase.initInstances()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  BindingBase() &#123;</span><br><span class="line">    initInstances();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> WidgetsBinding</span><br><span class="line">    <span class="keyword">on</span></span><br><span class="line">        BindingBase,</span><br><span class="line">        SchedulerBinding,</span><br><span class="line">        GestureBinding,</span><br><span class="line">        RendererBinding,</span><br><span class="line">        SemanticsBinding &#123;</span><br><span class="line">  <span class="keyword">static</span> WidgetsBinding _instance;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'WidgetsBinding.initInstances() <span class="subst">$this</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> GestureBinding <span class="keyword">on</span> BindingBase <span class="keyword">implements</span> HitTestable &#123;</span><br><span class="line">  <span class="keyword">static</span> GestureBinding _instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'GestureBinding.initInstances() <span class="subst">$this</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> ServicesBinding <span class="keyword">on</span> BindingBase &#123;</span><br><span class="line">  <span class="keyword">static</span> ServicesBinding _instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'ServicesBinding.initInstances() <span class="subst">$this</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> SchedulerBinding <span class="keyword">on</span> BindingBase, ServicesBinding &#123;</span><br><span class="line">  <span class="keyword">static</span> SchedulerBinding _instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'SchedulerBinding.initInstances() <span class="subst">$this</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> PaintingBinding <span class="keyword">on</span> BindingBase, ServicesBinding &#123;</span><br><span class="line">  <span class="keyword">static</span> PaintingBinding _instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'PaintingBinding.initInstances() <span class="subst">$this</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> SemanticsBinding <span class="keyword">on</span> BindingBase &#123;</span><br><span class="line">  <span class="keyword">static</span> SemanticsBinding _instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'SemanticsBinding.initInstances() <span class="subst">$this</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> RendererBinding</span><br><span class="line">    <span class="keyword">on</span></span><br><span class="line">        BindingBase,</span><br><span class="line">        ServicesBinding,</span><br><span class="line">        SchedulerBinding,</span><br><span class="line">        GestureBinding,</span><br><span class="line">        SemanticsBinding,</span><br><span class="line">        HitTestable &#123;</span><br><span class="line">  <span class="keyword">static</span> RendererBinding _instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'RendererBinding.initInstances() <span class="subst">$this</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HitTestable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  WidgetsFlutterBinding b = WidgetsFlutterBinding();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'main(): <span class="subst">$b</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BindingBase.initInstances()</span><br><span class="line">GestureBinding.initInstances() Instance of &apos;WidgetsFlutterBinding&apos;</span><br><span class="line">ServicesBinding.initInstances() Instance of &apos;WidgetsFlutterBinding&apos;</span><br><span class="line">SchedulerBinding.initInstances() Instance of &apos;WidgetsFlutterBinding&apos;</span><br><span class="line">PaintingBinding.initInstances() Instance of &apos;WidgetsFlutterBinding&apos;</span><br><span class="line">SemanticsBinding.initInstances() Instance of &apos;WidgetsFlutterBinding&apos;</span><br><span class="line">RendererBinding.initInstances() Instance of &apos;WidgetsFlutterBinding&apos;</span><br><span class="line">WidgetsBinding.initInstances() Instance of &apos;WidgetsFlutterBinding&apos;</span><br><span class="line">main(): Instance of &apos;WidgetsFlutterBinding&apos;</span><br></pre></td></tr></table></figure><p>可以这样理解，<code>WidgetsFlutterBinding</code> 并不是继承自 <code>BindingBase</code>，而是继承自如下一个匿名类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindingBase</span> <span class="title">with</span></span></span><br><span class="line"><span class="class">        <span class="title">GestureBinding</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ServicesBinding</span>,</span></span><br><span class="line"><span class="class">        <span class="title">SchedulerBinding</span>,</span></span><br><span class="line"><span class="class">        <span class="title">PaintingBinding</span>,</span></span><br><span class="line"><span class="class">        <span class="title">SemanticsBinding</span>,</span></span><br><span class="line"><span class="class">        <span class="title">RendererBinding</span>,</span></span><br><span class="line"><span class="class">        <span class="title">WidgetsBinding</span></span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/5efbf499e51d4534b979050c" target="_blank" rel="noopener">从mixin机制理解Flutter App启动 - 掘金</a></li><li><a href="https://github.com/dart-lang/language/blob/master/accepted/2.1/super-mixins/feature-specification.md#dart-2-mixin-declarations" target="_blank" rel="noopener">mixin specification</a> - 最权威</li><li><a href="https://medium.com/flutter-community/dart-what-are-mixins-3a72344011f3" target="_blank" rel="noopener">Dart: What are mixins?</a> - 最详细</li><li><a href="https://dart.dev/samples#mixins" target="_blank" rel="noopener">参考</a></li><li><a href="https://dart.dev/guides/language/language-tour#adding-features-to-a-class-mixins" target="_blank" rel="noopener">参考2</a></li><li><a href="https://medium.com/flutter-community/https-medium-com-shubhamhackzz-dart-for-flutter-mixins-in-dart-f8bb10a3d341" target="_blank" rel="noopener">Dart for Flutter : Mixins in Dart</a></li><li><a href="https://alligator.io/dart/mixins/" target="_blank" rel="noopener">Introduction to Mixins in Dart ← Alligator.io</a> - 最浅显</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译) RenderObject 介绍</title>
      <link href="2019/12/19/what-is-renderobject/"/>
      <url>2019/12/19/what-is-renderobject/</url>
      
        <content type="html"><![CDATA[<p>什么是 RenderObject？</p><a id="more"></a><p>原文见 <a href="https://medium.com/flutter-community/flutter-what-are-widgets-renderobjects-and-elements-630a57d05208" target="_blank" rel="noopener">Flutter, what are Widgets, RenderObjects and Elements?</a></p><p>每个人都想知道 Flutter 是如何将 Widget 转换成屏幕上的像素的，对不对？</p><!--Ever wondered how Flutter takes those widgets and actually converts them to pixels on the screen? No?You should!--><p>理解底层技术原理是优秀开发者跟伟大开发者的差别。</p><!--Understanding how an underlying technology works makes the difference between a good developer and a great one.--><p>当你知道什么是可行，什么是不可行的话，就可以更轻松地创建自定义布局和特效，这能节省你很多的时间。</p><!--You can create custom layouts and special effects more easily when you know what works and what doesn’t; and knowing this will save you a few long nights at the keyboard.--><p>本文的目标是介绍 Flutter 背后的原理。我们从另一个不同的方面看 Flutter 并理解它是如何工作的。</p><!--The goal of this post is to introduce you to the world beyond the surface of flutter. We will take a look at different aspects of flutter and understand how it actually works.--><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>你很可能已经知道如何使用 StatelessWidget 和 StatefulWidget。但它们只能组合已有的 Widget。对 Widget 进行布局和绘制实际上发生在别的地方。</p><!--You probably already know how to use the StatelessWidget & StatefulWidget. But those widgets only compose the other widgets. Laying out the widgets and rendering them happens elsewhere.--><p>强烈建议你打开最喜欢的 IDE 并一步步按下面的步骤来操作，实际代码常常让你恍然大悟。Intellij 中双击 Shift 可以输出名称来打开任何类。</p><!--I highly recommend opening your favorite IDE and following along, seeing the structures in the actual code often creates those “aha” moments. In Intellij you can double tap shift and enter a class name to find it.--><h1 id="Opacity"><a href="#Opacity" class="headerlink" title="Opacity"></a>Opacity</h1><p>我们通过观察 <a href="https://github.com/flutter/flutter/blob/f38743593d00f13b21f49d8d8ee2d2206bf820d3/packages/flutter/lib/src/widgets/basic.dart#L150" target="_blank" rel="noopener">Opacity</a> Widget 来熟悉 Flutter 的基本概念。之所以选择 Opacity，因为它是一个非常基本的 Widget (特别简单)，可作为一个好例子来学习。</p><!--To get familiar with the basic concepts of how flutter works we will take a look at the Opacity widget and examine that. Because it’s a pretty basic widget, it makes a good example to follow along.--><p>Opacity 只接受一个子 Widget。你可以用 Opacity 来包装任何 Widget 并调整其显示方式。除了 <code>child</code> 参数，只有另外一个 <code>opacity</code> 参数，它是浮点类型，值介于 0.0 和 1.0。这个参数用于控制不透明度。</p><!--It only accepts one child. Therefore you can wrap any widget in an Opacity and change the way it’s displayed. Besides the child, there is only one parameter called opacity which is a value between 0.0 and 1.0. It controls the opacity (duh).--><h1 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h1><p><code>Opacity</code> 是一个 <code>SingleChildRenderObjectWidget</code>。它的继承结构如下：</p><p>Opacity → SingleChildRenderObjectWidget → RenderObjectWidget → Widget</p><p>StatelessWidget 和 StatefulWidget 继承结构则是这样的：</p><p>StatelessWidget/StatefulWidget → Widget</p><p><strong>StatelessWidget/StatefulWidget 与 Opacity 的不同在于：前者只能组合其他 Widget，而后者实际上改变了 Widget 的绘制方式</strong>。</p><p>但是你在这几个类当中找不到跟实际绘制不透明度相关的任何代码。原因在于 Widget 只持有配置信息。在本例中，Opacity 持有的是 <code>opacity</code> 值。</p><!--But if you look at any of those classes you won’t find any code related to actually painting the opacity.That’s because a widget only holds the configuration information. In this case, the opacity widget is only holding the opacity value.--><blockquote><p>每次都可以在 <code>build()</code> 函数中创建新的 Widget 的原因是创建的成本并不高，因为它们不过是配置信息的容器</p></blockquote><!--This is the reason why you can create new widget every time the build function is called. Because the widgets are not expensive to construct. They are merely containers for information.--><h1 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h1><p>渲染到底发生在哪里？实际上它们发生在 RenderObject 中。</p><p>你可以从名字猜到 RenderObject 负责的工作包括渲染。</p><!--As you might have guessed from the name, the RenderObject is responsible for a few things, including rendering.--><p>Opacity Widget 使用如下方法创建并更新 <a href="https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/basic.dart#L188" target="_blank" rel="noopener">RenderObject</a>：</p><!--The Opacity widget creates and updates a RenderObject with these methods.--><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">RenderOpacity createRenderObject(BuildContext context) =&gt; <span class="keyword">new</span> RenderOpacity(opacity: opacity);</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> updateRenderObject(BuildContext context, RenderOpacity renderObject) &#123;</span><br><span class="line">  renderObject.opacity = opacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="RenderOpacity"><a href="#RenderOpacity" class="headerlink" title="RenderOpacity"></a>RenderOpacity</h1><p><code>Opacity</code> Widget 大小跟其 child 完全一样。基本上它每个方面跟其 child 都一样，除了绘制。它会在绘制 child 前加上不透明度。</p><!--The Opacity widget sizes itself to be exactly the same size as its child. It basically mimics every aspect of the child but the painting. Before painting its child it is adding an opacity to it.--><p>本例中，RenderOpacity 需要实际所有方法(比如布局、点击测试、大小计算等等)并要求 child 完成实际工作。</p><!--In this case, the RenderOpacity needs to implement all the methods (for example performing layout/ hit testing/ computing sizes) and ask its child to do the actual work.--><p>而 <code>RenderOpacity</code> 继承自 <code>RenderProxyBox</code> (它混入了其他类)。这些类用于实际具体的方法，并将真正的计算工作推迟到 child 中进行。</p><!--The RenderOpacity extends the RenderProxyBox (which mixes in a few other classes). Those are exactly implementing those methods and deferring the actual calculation to the only child.--><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> opacity =&gt; _opacity;</span><br><span class="line"><span class="built_in">double</span> _opacity;</span><br><span class="line"><span class="keyword">set</span> opacity(<span class="built_in">double</span> value) &#123;</span><br><span class="line">  _opacity = value;</span><br><span class="line">  markNeedsPaint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(注：这里的代码去掉了优化和断言，只保留最关键部分。完整代码见<a href="https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/rendering/proxy_box.dart#L736" target="_blank" rel="noopener">这里</a>)</p><p>字段通常为私有变量暴露一个 getter。而 setter 用于设置字段，此外它还调用了 <code>markNeedsPaint()</code> 和 <code>markNeedsLayout()</code> 方法。正如名字所言，这个方法告诉系统 “我有变化啦，请重新绘制/重新布局”。</p><!--Fields usually expose a getter to the private variable. And a setter, which in addition to setting the field, also calls markNeedsPaint() or markNeedsLayout(). As the name suggests, it tells the system “Hey I have changed, please repaint/relayout me”.--><p>在 <code>RenderOpacity</code> 中可以找到这个方法：</p><!--Inside the RenderOpacity we find this method:--><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">    context.pushOpacity(offset, _alpha, <span class="keyword">super</span>.paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(注：这里同样只保留最关键代码，去掉了优化和断言，完整代码见<a href="https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/rendering/proxy_box.dart#L757" target="_blank" rel="noopener">这里</a>)</p><p><code>PaintingContext</code> 基本上是一个高级的 canvas。这个 canvas 上有一个 <code>pushOpacity()</code> 方法。而这行代码就是不透明度的实现。</p><!--The PaintingContext is basically a fancy canvas. And on this fancy canvas there is a method called pushOpacity.--><p>总结一下：</p><ul><li><code>Opacity</code> 并非 <code>StatelessWidget</code> 或 <code>StatefulWidget</code>，而是一个 <code>SingleChildRenderObjectWidget</code></li><li><code>Widget</code> 仅持有渲染器会用到的配置信息</li><li><code>Opacity</code> 持有一个 double 值用于表示不透明度</li><li>继承自 <code>RenderProxyBox</code> 的 <code>RenderOpacity</code> 完成实际布局/渲染工作</li><li><code>Opacity</code> 几乎跟 child 行为完全一致，所以它会将其方法代理到 child</li><li><code>RenderOpacity</code> 覆盖了 <code>paint</code> 方法。在这个方法中调用 <code>pushOpacity()</code> 来为 Widget 添加不透明度</li></ul><!--The Opacity is not a StatelessWidget or a StatefulWidget but instead a SingleChildRenderObjectWidget.The Widget only holds information which the renderer can use.In this case the Opacity is holding a double representing the opacity.The RenderOpacity, which extends the RenderProxyBox does the actual layouting/ rendering etc.Because the opacity behaves pretty much exactly as its child it delegates every method call to the child.It overrides the paint method and calls pushOpacity which adds the desired opacity to the widget.--><h1 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h1><p>记住，Widget 只是配置信息，<code>RenderObject</code> 只管理布局/渲染等工作。</p><!--Remember, the widget is only a configuration and the RenderObject only manages layout/rendering etc.--><p>在 Flutter 中你基本上不停地重新创建 Widget。<code>build()</code> 被调用时会创建一堆的 Widget。而每次发生变化时 <code>build()</code> 方法被调用。比如，有动画效果时 <code>build()</code> 方法不停地被调用。这意味着你并不能每次都重建子树。实际上，你想做的是更新它。</p><!--In Flutter you recreate widgets basically all the time. When your build() methods gets called you create a bunch of widgets. This build method is called every time something changes. When an animation happens for example, the build method gets called very often. This means you can’t rebuild the whole sub tree every time. Instead you want to update it.--><p>你无法获取 Widget 屏幕上的大小和位置，因为 Widget 只是一张蓝图，而不代表屏幕上的实际内容。它仅仅是对底层  RenderObject 会用到的变量的描述。 </p><!--You can’t get the size or location on the screen of a widget, because a widget is like a blueprint, it’s not actually on the screen. It’s only a description of what variables the underlying render object should use.--><p>Element 是实际的树中的具体的 Widget。</p><p>具体过程是这样的：首次创建 Widget 时，由它生成 <code>Element</code>。这个 Element 被插入到树中，后续如果 Wiget 发生变化，它会跟旧的 Widget 比较，并根据差异对 Element 进行相应地更新。最重要的一点是，Element 并未重新创建，而是更新！</p><!--The first time when a widget is created, it is inflated to an Element. The element then gets inserted it into the tree. If the widget later changes, it is compared to the old widget and the element updates accordingly. The important thing is, the element doesn’t get rebuilt, it only gets updated.--><p>Element 是核心框架的中心，我们应该对它进行更多讨论，不过现在了解这些就足够了。</p><!--Elements are a central part of the core framework and there is obviously more to them, but for now this is enough information.--><p>问题：在上面 Opacity 这个例子中 element 是在哪里创建的？</p><p>答案是 <code>SingleChildRenderObjectWidget</code> 创建了 Element。代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">SingleChildRenderObjectElement createElement() =&gt; <span class="keyword">new</span> SingleChildRenderObjectElement(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>具体见<a href="https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/framework.dart#L1631" target="_blank" rel="noopener">源码</a>。另外，<code>SingleChildRenderObjectElement</code> 只有一个 child。</p><p>问题：是Element 创建了 RenderObject 吗，但我们这个例子中看起来 Opacity Widget 创建了它自己的 RenderObject？</p><!--The element creates the RenderObject, but in our case the Opacity widget creates its own RenderObject?--><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Opacity</span> <span class="keyword">extends</span> <span class="title">SingleChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderOpacity createRenderObject(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RenderOpacity(</span><br><span class="line">      opacity: opacity,</span><br><span class="line">      alwaysIncludeSemantics: alwaysIncludeSemantics,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题说的应该是指 <code>Opacity.createRenderObject()</code> 方法创建了 <code>RenderObject</code>。</p><p>答案是这么做纯粹是为了更好用的 API。因为 Widget 通常需要一个 RenderObject 而不是自定义的 Element。实际上 RenderObject 是由 Element 创建的。</p><!--This is just for a smooth API. Because more often then not, the widget needs a RenderObject but no custom Element. The RenderObject is actually created by the Element, let’s take a look:--><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SingleChildRenderObjectElement(SingleChildRenderObjectWidget widget) : <span class="keyword">super</span>(widget);</span><br></pre></td></tr></table></figure><p>见<a href="https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/framework.dart#L4643" target="_blank" rel="noopener">源码</a>。<code>SingleChildRenderObjectElement</code> 持有 <code>RenderObjectWidget</code> 的引用，后者拥有创建 <code>RenderObject</code> 的方法。</p><p><code>mount()</code> 方法是 Element 被添加到 Element Tree 的地方。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">  attachRenderObject(newSlot);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦 <code>mount()</code> 方法被调用，Element 要求 Widget “请给我你想使用的 RenderObject，好让我保存下来”。</p><!--Only once (when it get’s mounted) it asks the widget “Please give me the renderobject you’d like to use so I can save it”.--><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>本文介绍了 Opacity Widget 内部工作机制。我的目标是介绍 Widget 背后的原理，仍然还有许多话题可以讨论，希望我能为你了解内部工作原理做一个好的指引。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>Widget 跟 View 类比是不准确的。</p><ul><li>View 并不会频繁重建，Widget 会频繁重建</li><li>View 有实际的大小和位置，Widget 没有具体的大小的位置</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译) Flutter Material Button 完全解析</title>
      <link href="2019/12/05/anatomy-of-material-buttons-in-flutter/"/>
      <url>2019/12/05/anatomy-of-material-buttons-in-flutter/</url>
      
        <content type="html"><![CDATA[<p>一文弄懂 Flutter Material Button。</p><a id="more"></a><p>原文见 <a href="https://medium.com/flutterpub/anatomy-of-material-buttons-in-flutter-first-part-40eb790979a6" target="_blank" rel="noopener">Anatomy of Material Buttons in Flutter (PART 1) - FlutterPub - Medium</a>。</p><p>关于 Material Button 及其属性，你需要知道的一切全在这里！</p><p>2019年似乎是 Google 这个用于在 iOS 和 Android 平台开发高品质移动应用的 UI 框架元年。谁能想象在一个代码库中同时为这两个平台快速开发漂亮又易于维护的应用？但 Google 做到了，它就是 Flutter。 </p><!--2019 seems to be the year of Google’s mobile UI framework for developing high-quality apps on iOS and Android. Who imagined possible to grow apps for both platforms in a beautifully, easy to maintain, with a single base code, in a very quick way? They did and delivered us this treasure named Flutter.--><p>在学习这个框架的过程中，我决定写一些关于那些最常使用的控件的系列文章。这个系列是面向那些需要寻求帮助来理解 Dart 语言和 Flutter 框架的初始者，但对所有想要知道如定制控件的开发者也有用。</p><!--During my progress through the learning curve of this framework, I decided to publish an extensive series reviewing the most commonly used widgets. This series is aimed at beginners who need extra help in understanding the Dart language and Flutter’s framework, but it is also useful to any programmer who wants a quick look at how to customize the widget.--><p>每篇文章先描述控件，基本功能以及用法。稍后，我们将讨论它最重要的属性以及如何自定义该控件。最后以几个示例来帮助你直观理解基本用法。</p><!--Each post will start describing the widget, its general purpose, its benefits and how to start using it. Later, we will discuss the most important properties to customize it. And finally, we will end the article with some examples with its code to help you visualize common uses.--><p>没别的了，欢迎阅读我的第一篇 Medium 文章。</p><!--With nothing else to add, feel welcome to my first Medium post.-->Ï<br><img src="/images/15755135667788.jpg" alt="Material Buttons -w500"><br><br># 关于 Material Button<br><br>如今我们都知道用户交互对应用有多重要，而一直以来按钮都是一种不错的交互方式。很难想象一个应用中没有任何按钮，所以我选择将它作为本系列中要讲的第一个控件。<br><br><!--About Material ButtonsWe all know how important user interaction is in nowadays apps. Buttons have been through all this time a very good old fellow. It is hard to imagine an app without buttons so here’s why it has been selected as the first honoree of this series.--><p>Flutter 框架中我们可以调整非常多的参数来适应我们的需求：colors、measures、 shape、elevation 和 inkwell animation。</p><!--In Flutter’s framework we can tweak a lot of parameters to fit our needs: purpose, colors, measures, shape, elevation and inkwell animation. We better get started!--><p><img src="/images/15755138697114.jpg" alt="Material Buttons -w500"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笨办法学 Dart: dartdoc.dart 源码分析</title>
      <link href="2019/11/28/dart-hard-way-1/"/>
      <url>2019/11/28/dart-hard-way-1/</url>
      
        <content type="html"><![CDATA[<p>Flutter SDK 的 <a href="https://github.com/flutter/flutter/blob/master/dev/tools/dartdoc.dart" target="_blank" rel="noopener">dartdoc.dart</a> 脚本不仅可以演示了 <code>dartdoc</code> 各参数的用法，它也是学习 Dart 编程语言的绝好参考资料。</p><a id="more"></a><p>Dart SDK 中的 <code>dartdoc</code> 命令用于从 Dart 源码生成文档。使用过程中遇到问题，一番搜索后发现 Flutter SDK 的 <code>dartdoc.dart</code> 脚本是对该命令的封装。这个脚本用于生成 Flutter 文档。我发现从 <code>dartdoc.dart</code> 中不仅能学习到 <code>dartdoc</code> 各参数的用法，它还是学习 Dart 编程语言的绝好参考资料。学习并记录一下。(看似挺笨的学习方法，但感觉有效)</p><p>一方面是 Dart 语言相关的知识：</p><ul><li>第三方简单用法<ul><li>argParser</li><li>path</li><li>process</li></ul></li><li>文件操作<ul><li>文件生成和读写</li><li>切换及遍历目录</li></ul></li><li>进程操作</li><li>Dart 语言特性<ul><li>Synchronous generator</li><li>扩展操作符</li><li>字符串操作</li></ul></li><li>正则表达式</li></ul><p>另一方面是 Dart dartdoc 的用法。</p><p>dartdoc.dart 脚本见 <a href="https://github.com/flutter/flutter/blob/master/dev/tools/dartdoc.dart" target="_blank" rel="noopener">Github</a>。另外注意区分 dartdoc.dart 和 Dart <code>dartdoc</code>，前者是 Flutter SDK 中用于生成文档的脚本，是对后者的封装；后者则是 Dart SDK 的内置命令。</p><h1 id="Dart-语言"><a href="#Dart-语言" class="headerlink" title="Dart 语言"></a>Dart 语言</h1><p><code>dartdoc.dart</code> 函数了以下内容。</p><h2 id="args-库"><a href="#args-库" class="headerlink" title="args 库"></a>args 库</h2><p>首先要引入 <a href="https://pub.dev/packages/args" target="_blank" rel="noopener">args库</a>，在 <code>pubspec.yaml</code> 中添加如下依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  args: 1.5.2</span><br></pre></td></tr></table></figure><p>arg 库的基本用法包括：</p><ul><li>创建 ArgParser - <code>ArgParser()</code> </li><li>添加 flag - <code>ArgParser.addFlag()</code> </li><li>生成 ArgResults - <code>ArgParser.parse()</code> </li><li>访问 <code>ArgResults</code><ul><li>显示当前程序的用法 - <code>ArgResults.usage</code> </li><li>访问传给当前程序的参数 - <code>[]</code></li></ul></li></ul><p>示例代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ArgParser _createArgsParser() &#123;</span><br><span class="line">  <span class="comment">// 1 - 创建 ArgParser</span></span><br><span class="line">  <span class="keyword">final</span> ArgParser parser = ArgParser();</span><br><span class="line">  parser.addFlag(<span class="string">'help'</span>, abbr: <span class="string">'h'</span>, negatable: <span class="keyword">false</span>,</span><br><span class="line">      help: <span class="string">'Show command help.'</span>);</span><br><span class="line">  <span class="comment">// 2 - 添加 flag</span></span><br><span class="line">  parser.addFlag(<span class="string">'verbose'</span>, negatable: <span class="keyword">true</span>, defaultsTo: <span class="keyword">true</span>,</span><br><span class="line">      help: <span class="string">'Whether to report all error messages (on) or attempt to '</span></span><br><span class="line">          <span class="string">'filter out some known false positives (off).  Shut this off '</span></span><br><span class="line">          <span class="string">'locally if you want to address Flutter-specific issues.'</span>);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="keyword">void</span>&gt; main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; arguments) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> ArgParser argParser = _createArgsParser();</span><br><span class="line">  <span class="comment">// 3 - 生成 ArgResults</span></span><br><span class="line">  <span class="keyword">final</span> ArgResults args = argParser.parse(arguments);</span><br><span class="line">  <span class="keyword">if</span> (args[<span class="string">'help'</span>]) &#123;</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">'Usage:'</span>);</span><br><span class="line">    <span class="comment">// 4 - 访问 `ArgResults`</span></span><br><span class="line">    <span class="built_in">print</span> (argParser.usage);</span><br><span class="line">    exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Flag 支持的选项包括：</p><ul><li><code>negatable</code> - 是否可忽略</li><li><code>abbr</code> - 缩写命令，比如 <code>--help</code> 的短命令是 <code>-h</code></li><li><code>defaultsTo</code> - 缺省值</li></ul><h2 id="path-库"><a href="#path-库" class="headerlink" title="path 库"></a>path 库</h2><p>首先要引入 <a href="https://pub.dev/packages/path" target="_blank" rel="noopener">path库</a>，在 <code>pubspec.yaml</code> 中添加如下依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  path: 1.6.4</span><br></pre></td></tr></table></figure><p>Dart 中使用 <code>Directory</code> 类可获取当前目录，通过 path 库可获取到目录名和文件名。示例代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前目录</span></span><br><span class="line">Directory.current.path; <span class="comment">// -&gt; /Users/cm/wd/flutter_web/lib/learn_dartdoc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换目录</span></span><br><span class="line"><span class="keyword">if</span> (path.basename(Directory.current.path) == <span class="string">'tools'</span>) &#123;</span><br><span class="line">  Directory.current = Directory.current.parent.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前目录名</span></span><br><span class="line">path.basename(<span class="string">'path/to/foo.dart'</span>); <span class="comment">// -&gt; 'foo.dart'</span></span><br><span class="line">path.basename(<span class="string">'path/to'</span>);          <span class="comment">// -&gt; 'to'</span></span><br><span class="line">path.basename(<span class="string">'path/to/'</span>); <span class="comment">// -&gt; 'to'</span></span><br></pre></td></tr></table></figure><h2 id="process-库"><a href="#process-库" class="headerlink" title="process 库"></a>process 库</h2><p><code>dartdoc.dart</code> 脚本中有这样一段代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ProcessResult flutter = Process.runSync(<span class="string">'flutter'</span>, &lt;<span class="built_in">String</span>&gt;[]);</span><br><span class="line"><span class="keyword">final</span> File versionFile = File(<span class="string">'version'</span>);</span><br><span class="line"><span class="keyword">if</span> (flutter.exitCode != <span class="number">0</span> || !versionFile.existsSync())</span><br><span class="line">  <span class="keyword">throw</span> Exception(<span class="string">'Failed to determine Flutter version.'</span>);</span><br></pre></td></tr></table></figure><p>这段代码的功能包括：</p><ul><li>使用 <code>Process.runSync()</code> 启动 <code>flutter</code> 命令并检查是否运行成功</li><li>使用 <code>File.existsSync()</code> 检查 <code>&lt;FLUTTER DIR&gt;/version</code> 文件是否存在</li></ul><p>引入 <a href="https://pub.dev/packages/process" target="_blank" rel="noopener">path库</a>，在 <code>pubspec.yaml</code> 中添加如下依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  process: 3.0.12</span><br></pre></td></tr></table></figure><p><a href="https://pub.dev/packages/process" target="_blank" rel="noopener">process 库</a> 的 <code>ProcessWrapper</code> 是对 Dart <code>Process</code> 的包装，以提供更方便的方法。其用法如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run pub.</span></span><br><span class="line">ProcessWrapper process = ProcessWrapper(<span class="keyword">await</span> Process.start(</span><br><span class="line">  pubExecutable,</span><br><span class="line">  &lt;<span class="built_in">String</span>&gt;[<span class="string">'get'</span>],</span><br><span class="line">  workingDirectory: kDocsRoot,</span><br><span class="line">  environment: pubEnvironment,</span><br><span class="line">));</span><br><span class="line">printStream(process.stdout, prefix: <span class="string">'pub:stdout: '</span>);</span><br><span class="line">printStream(process.stderr, prefix: <span class="string">'pub:stderr: '</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">int</span> code = <span class="keyword">await</span> process.done;</span><br></pre></td></tr></table></figure><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><code>dartdoc.dart</code> 脚本中用到几种基本的文件操作，</p><ul><li>写文件</li><li>读文件</li><li>创建目录</li><li>遍历目录</li></ul><p><code>File.writeAsStringSync(String)</code> 方法用于将字符串写入文件。用法如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the pubspec.yaml file.</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">StringBuffer</span> buf = <span class="built_in">StringBuffer</span>();</span><br><span class="line">buf.writeln(<span class="string">'name: Flutter'</span>);</span><br><span class="line">buf.writeln(<span class="string">'homepage: https://flutter.dev'</span>);</span><br><span class="line">...</span><br><span class="line">File(<span class="string">'<span class="subst">$kDocsRoot</span>/pubspec.yaml'</span>).writeAsStringSync(buf.toString());</span><br></pre></td></tr></table></figure><p><code>Directory.createSync()</code> 方法用于创建目录。用法如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the library file.</span></span><br><span class="line"><span class="keyword">final</span> Directory libDir = Directory(<span class="string">'<span class="subst">$kDocsRoot</span>/lib'</span>);</span><br><span class="line">libDir.createSync();</span><br></pre></td></tr></table></figure><p><code>dartdoc.dart</code> 包含的一个功能是遍历 Flutter SDK <code>packages</code> 目录来找到所有的库路径：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Returns import or on-disk paths for all libraries in the Flutter SDK.</span></span><br><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">String</span>&gt; libraryRefs() <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="keyword">for</span> (Directory dir <span class="keyword">in</span> findPackages()) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> dirName = path.basename(dir.path);</span><br><span class="line">    <span class="keyword">for</span> (FileSystemEntity file <span class="keyword">in</span> Directory(<span class="string">'<span class="subst">$&#123;dir.path&#125;</span>/lib'</span>).listSync()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (file <span class="keyword">is</span> File &amp;&amp; file.path.endsWith(<span class="string">'.dart'</span>)) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'<span class="subst">$dirName</span>/<span class="subst">$&#123;path.basename(file.path)&#125;</span>'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add a fake package for platform integration APIs.</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'platform_integration/android.dart'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'platform_integration/ios.dart'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Finds all packages in the Flutter SDK</span></span><br><span class="line"><span class="built_in">List</span>&lt;FileSystemEntity&gt; findPackages() &#123;</span><br><span class="line">  <span class="keyword">return</span> Directory(<span class="string">'&lt;FLUTTER SDK&gt;/packages'</span>)</span><br><span class="line">    .listSync()</span><br><span class="line">    .where((FileSystemEntity entity) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .cast&lt;Directory&gt;()</span><br><span class="line">    .toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码可以学到两个知识点：</p><ul><li>首先，注意 <code>libraryRefs()</code> 方法中用到的 <code>sync*</code> 和 <code>yield</code> 的用法。实际上这里返回的 <code>Iterable</code> 是 <a href="https://dart.dev/guides/language/language-tour#generators" target="_blank" rel="noopener">synchronous generator</a></li><li>其次，<code>Directory.listSync()</code> 返回当前目录中的所有文件和目录。该方法的参数 <code>recursive</code> 用于支持递归遍历</li></ul><h2 id="正则式"><a href="#正则式" class="headerlink" title="正则式"></a>正则式</h2><p><code>dartdoc.dart</code> 中用到了正则式。限于篇幅，这里不展开。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">printStream(process.stdout, prefix: args[<span class="string">'json'</span>] ? <span class="string">''</span> : <span class="string">'dartdoc:stdout: '</span>,</span><br><span class="line">  filter: args[<span class="string">'verbose'</span>] ? <span class="keyword">const</span> &lt;<span class="built_in">Pattern</span>&gt;[] : &lt;<span class="built_in">Pattern</span>&gt;[</span><br><span class="line">    <span class="built_in">RegExp</span>(<span class="string">r'^generating docs for library '</span>), <span class="comment">// unnecessary verbosity</span></span><br><span class="line">    <span class="built_in">RegExp</span>(<span class="string">r'^pars'</span>), <span class="comment">// unnecessary verbosity</span></span><br><span class="line">  ],</span><br><span class="line">);</span><br><span class="line">printStream(process.stderr, prefix: args[<span class="string">'json'</span>] ? <span class="string">''</span> : <span class="string">'dartdoc:stderr: '</span>,</span><br><span class="line">  filter: args[<span class="string">'verbose'</span>] ? <span class="keyword">const</span> &lt;<span class="built_in">Pattern</span>&gt;[] : &lt;<span class="built_in">Pattern</span>&gt;[</span><br><span class="line">    <span class="built_in">RegExp</span>(<span class="string">r'^ warning: .+: \(.+/\.pub-cache/hosted/pub.dartlang.org/.+\)'</span>), <span class="comment">// packages outside our control</span></span><br><span class="line">  ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>这里来看一些小的语言特性。小则小，用起来确实方便。</p><p>一，可以将 <code>if</code> 表达式用于 List 字面量的创建。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; dartdocBaseArgs = &lt;<span class="built_in">String</span>&gt;[</span><br><span class="line">  <span class="string">'global'</span>,</span><br><span class="line">  <span class="string">'run'</span>,</span><br><span class="line">  <span class="keyword">if</span> (args[<span class="string">'checked'</span>]) <span class="string">'-c'</span>,</span><br><span class="line">  <span class="string">'dartdoc'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>二，Dart 提供 <code>...</code> 扩展操作符。用法如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; dartdocBaseArgs = &lt;<span class="built_in">String</span>&gt;[</span><br><span class="line">  <span class="string">'global'</span>,</span><br><span class="line">  <span class="string">'run'</span>,</span><br><span class="line">  <span class="keyword">if</span> (args[<span class="string">'checked'</span>]) <span class="string">'-c'</span>,</span><br><span class="line">  <span class="string">'dartdoc'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify which version of dartdoc we're using.</span></span><br><span class="line"><span class="keyword">final</span> ProcessResult result = Process.runSync(</span><br><span class="line">  pubExecutable,</span><br><span class="line">  &lt;<span class="built_in">String</span>&gt;[...dartdocBaseArgs, <span class="string">'--version'</span>],</span><br><span class="line">  workingDirectory: kDocsRoot,</span><br><span class="line">  environment: pubEnvironment,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="Dart-dartdoc-命令"><a href="#Dart-dartdoc-命令" class="headerlink" title="Dart dartdoc 命令"></a><a href="https://github.com/dart-lang/dartdoc#dartdoc" target="_blank" rel="noopener">Dart dartdoc 命令</a></h1><blockquote><p>Use dartdoc to generate HTML documentaton for your Dart package.</p></blockquote><p>Dart dartdoc 是 Dart SDK 中用于为 Dart package 生成 HTML 文档的命令行工具。</p><p>要正确使用这个工具，建议先简单了解以下内容：</p><ul><li><a href="https://dart.dev/guides/libraries/create-library-packages" target="_blank" rel="noopener">Dart package 的组织方式</a></li><li><a href="https://dart.dev/guides/language/effective-dart/documentation#doc-comments" target="_blank" rel="noopener">Dart 注释文档最佳实践</a></li></ul><p>最简单的 Dart package 目录结构如下：</p><p><img src="/images/15749233895070.jpg" alt></p><ul><li>pubspec file</li><li>lib directory<ul><li>lib 目录下可以创建任意目录结构</li><li>lib/src 目录下的代码是私有的，通常是具体实现</li><li>lib 目录下的代码是公开的</li><li>可以通过 lib 目录下的文件导出 lib/src 为公开代码</li></ul></li></ul><p>更完整的代码结构可以参考 <a href="https://github.com/dart-lang/shelf" target="_blank" rel="noopener">shelf</a>。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Dart SDK 自带 dartdoc，不用另外安装。</p><ul><li>生成文档 - 在根目录下运行 <code>dartdoc</code></li><li>查看文档<ul><li><code>dhttpd --path doc/api</code> 启动服务</li><li><code>http://localhost:8080</code> 查看</li></ul></li></ul><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>Dart dartdoc 命令支持相当多的参数。以 Flutter 为例，生成文档时的参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dartdoc</span><br><span class="line">    --allow-tools</span><br><span class="line">    --no-validate-links</span><br><span class="line">    --link-to-source-excludes ../../bin/cache</span><br><span class="line">    --link-to-source-root ../.. </span><br><span class="line">    --link-to-source-uri-template https://github.com/flutter/flutter/blob/master/%f%#L%l%</span><br><span class="line">    --inject-html</span><br><span class="line">    --header styles.html</span><br><span class="line">    --header analytics.html </span><br><span class="line">    --header survey.html</span><br><span class="line">    --header snippets.html</span><br><span class="line">    --header opensearch.html</span><br><span class="line">    --footer-text lib/footer.html</span><br><span class="line">    --allow-warnings-in-packages Flutter,flutter,platform_integration,flutter_test,...</span><br><span class="line">    --exclude package:Flutter/temp_doc.dart,package:http/browser_client.dart,...</span><br><span class="line">    --favicon=favicon.ico</span><br><span class="line">    --package-order flutter,Dart,...</span><br><span class="line">    --auto-include-dependencies)</span><br></pre></td></tr></table></figure><p>实际使用时可以参考 <a href="https://github.com/dart-lang/dartdoc#dartdoc" target="_blank" rel="noopener">dart-lang/dartdoc: API documentation tool for Dart.</a>。</p><h2 id="dartdoc-options-yaml"><a href="#dartdoc-options-yaml" class="headerlink" title="dartdoc_options.yaml"></a>dartdoc_options.yaml</h2><p>可以通过在根目录下创建 <code>dartdoc_options.yaml</code> 来控制调整生成的文档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dartdoc:</span><br><span class="line">  exclude: []</span><br></pre></td></tr></table></figure><p>详细参数见 <a href="https://github.com/dart-lang/dartdoc#advanced-features" target="_blank" rel="noopener">Github</a></p><h2 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h2><p>这里用一个简单的例子演示 dartdoc 的用法。代码结构和 <code>dartdoc_options.yaml</code> 分别如下：</p><p><img src="/images/15749244487548.jpg" alt="-w885"></p><p>我们在 <code>exclude</code> 中排除了 <code>hello.dart</code> 和 <code>bar.dart</code> 两个文件，而 <code>lib/src</code> 下的代码为私有的，所以最终仅为 <code>hello2.dart</code> 生成了文档。</p><p><img src="/images/15749246280161.jpg" alt="-w773"></p><p>浏览器中看到了文档是这样的：</p><p><img src="/images/15749249251449.jpg" alt="-w723"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译) Dart 异步编程之 Isolate 和事件循环</title>
      <link href="2019/11/26/dart-async-isolate-eventloop/"/>
      <url>2019/11/26/dart-async-isolate-eventloop/</url>
      
        <content type="html"><![CDATA[<p>Dart 异步编程之 Isolate 和事件循环。编译自 <a href="https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a" target="_blank" rel="noopener">Dart asynchronous programming: Isolates and event loops</a>。</p><a id="more"></a><p>尽管 Dart 是个单线程任务，但它提供 Future、Stream、后台任务以及其他特性用于编写现代异步程序以及响应式程序(Flutter)。本文讲的是 Dart 后台任务的基础：Isolate 和事件循环。</p><p>如果你倾向于通过视频学习，可以在以下视频中找到本文讲解的内容。这个视频是 the Flutter in Focus 系列的一部分《Dart 中的异步编程》：</p><iframe width="666" height="382" src="https://www.youtube.com/embed/vl_AaCgudcY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>Still here? Let’s talk about isolates.</p><p>我们先从 Isolate 开始。</p><h1 id="Isolates"><a href="#Isolates" class="headerlink" title="Isolates"></a>Isolates</h1><hr><p>译者补充：</p><blockquote><p>大多数应用程序中，线程的数量都不止一个。多个线程可以互不干扰地并发执行，并共享进程的全局变量和堆的数据。<br>线程的访问非常自由，它可以访问进程内存里的所有数据，甚至包括其他线程的堆栈<br>《程序员的自我修养》</p></blockquote><hr><p>所有的 Dart 代码都运行在 Isolate 中。Isolate 有自己私有的内存空间和一个基于事件循环的线程。</p><p><img src="/images/15747423247738.jpg" alt="An isolate has its own memory and a single thread of execution that runs an event loop."></p><p>在其他很多语言中，比如 C++，多个线程可运行任何代码并共享内存。但 Dart 中每个线程在其自己的 Isolate 中，有自己的内存，线程只处理事件(后面很快会详细展开)。</p><p>大部分 Dart 应用在一个 Isolate 中运行全部代码，也可以根据需要创建更多 Isolate。如果某个操作计算量如此之大以至于它在主 Isolate 运行中会导致掉帧，可以使用 <a href="https://api.dartlang.org/stable/dart-isolate/Isolate/spawn.html" target="_blank" rel="noopener">Isolate.spawn()</a> 或<a href="https://flutter.dev/docs/cookbook/networking/background-parsing#4-move-this-work-to-a-separate-isolate" target="_blank" rel="noopener">Flutter’s compute() function</a> 方法。这些方法都会创建独立的 Isolate 来做密集计算，让主 Isolate 专注重建和渲染 Widget 树。</p><p><img src="/images/15747512192242.jpg" alt="Two isolates, each with its own memory and thread of execution."></p><p>新创建的 Isolate 有自己的事件循环和内存，原先的 Isolate (即创建新 Isolate 的那个 Isolate) 不能访问这些内存。这种机制正是 Isolate 名字的来源：内存块之间彼此<strong>隔离</strong>。</p><p>事实上，Isolate 之间能协作的唯一方式是消息传递。一个 Isolate 可以向另一个 Isolate 发送消息，接收方在其事件循环处理收到的消息。</p><p><img src="/images/15747512480045.jpg" alt="Isolates can send messages to other isolates."></p><p>缺少共享内存听起来过于严格，尤其是你之前用过 Java 或 C++，但它给 Dart 开发者带来一些重要的好处。</p><p>比如，Isolate 中内存分配和垃圾回收不需要锁定。Isolate 中只有一个线程，如果它不是很忙的话，内存并不会快速变化，所以不必锁定。这非常适合 Flutter 应用，它时常要迅速地构建和销毁 Widget 树。</p><h1 id="Event-loops"><a href="#Event-loops" class="headerlink" title="Event loops"></a>Event loops</h1><p>现在你已经了解 Isolate 了，再来看看事件循环是如何让异步代码变成可能的吧。</p><p>想像一下应用沿着时间线的运行过程。应用启动，应用停止，之间发生一串串事件：磁盘 IO，用户手势以及类似一些事件。</p><p>应用无法预测事件何时发生、以何种顺序发生，它必须在单个线程中处理所有事件并且保证不阻塞。所以应用会运行一个事件循环。它从事件队列中取出最老的事件进行处理，然后再取下一个事件，依次进行，直到事件队列为空。</p><p>应用一直在运行：你点击屏幕、下载数据、触发定时器。事件循环一直在运行，每次处理一个事件。</p><p><img src="/images/15747519662130.jpg" alt="The event loop processes one event at a time."></p><p>事件循环空闲时，线程会暂停并循环下一个事件。这时可能触发垃圾回收器等等。Dart 为异步编程提供的所有高级 API 和语言特性，如 Future、Stream、<code>async/await</code>，都是基于和围绕这个基本的循环。</p><p>比如，某个按钮用于发起网络请求，就像这样：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RaisedButton(</span><br><span class="line">  child: Text(<span class="string">'Click me'</span>),</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    <span class="keyword">final</span> myFuture = http.<span class="keyword">get</span>(<span class="string">'https://example.com'</span>);</span><br><span class="line">    myFuture.then((response) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'Success!'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>你运行应用时，Flutter 构建按钮并显示到屏幕，之后应用开始等待。</p><p>应用的事件循环处于空闲，等待下一个事件。当按钮等待点击时，跟按钮不相关的事件可能发生并进入到事件队列被处理。当点击事件发生时，最终会进入队列。</p><p>点击事件被取到，等待处理。Flutter 看到这个事件，它的渲染系统说 “事件坐标跟 RaisedButton 匹配”，所以 Flutter 执行 <code>onPressed</code> 函数。这个函数会发起网络请求(返回一个 Future)并使用 <code>then()</code> 方法注册 completion handler。</p><p>整个过程就是这样的。事件循环处理完点击事件后将其抛弃。</p><p><code>onPressed</code> 是 <a href="https://api.flutter.dev/flutter/material/RaisedButton-class.html" target="_blank" rel="noopener">RaisedButton</a> 的一个属性，而网络事件为 Future 添加了一个回调，但两者都是在相同的基本操作。它们都是在告诉 Flutter，”你好，一会儿将发生某个事件，你记得执行该事件的代码。”</p><p><code>onPressed</code> 在等待点击，而 Future 在等待网络数据，从 Dart 的视角，这些都是队列中的事件。</p><p>这也正是 Dart 中异步代码的工作方式。Future、Steam、以及 <code>async/await</code>，这些 API 都是你告诉 Dart 事件循环执行代码的一种方式。</p><p>如果再来回头看刚才的例子，你可以准确地看到它是如何为特定的事件被分解成一小块一小块的。</p><ol><li>初始的 UI 构建事件</li><li>点击事件</li><li>网络响应事件</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RaisedButton( <span class="comment">// (1)</span></span><br><span class="line">  child: Text(<span class="string">'Click me'</span>),</span><br><span class="line">  onPressed: () &#123; <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">final</span> myFuture = http.<span class="keyword">get</span>(<span class="string">'https://example.com'</span>);</span><br><span class="line">    myFuture.then((response) &#123; <span class="comment">// (3)</span></span><br><span class="line">      <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'Success!'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>你习惯异步代码之后，到处都可以看到这些模式。理解事件循环对你跟高级 API 打交道时同样有帮助。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们简单地了解了 Dart 中的 Isolate、事件循环以及异步编程基础。</p><p>如果你想了解更多，请看这个关于异步编程的视频。它讨论的是 Future API，这个 API 用于简化异步程序代码。</p><iframe width="671" height="382" src="https://www.youtube.com/embed/OTS-ap9_aXc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Tinker 用于 Flutter 热更新的思考</title>
      <link href="2019/11/21/how-tinker-update-so/"/>
      <url>2019/11/21/how-tinker-update-so/</url>
      
        <content type="html"><![CDATA[<p>最近一篇文章提到使用 Tinker 替换 so 来实现 Android 平台上 Flutter 热更新。为什么 Tinker 可以更新/替换 so，它是如何实现换的？这个方案用于 Flutter 可能会存在哪些限制，原因是什么？一起来研究下吧。篇幅较长，水平有限，如有疏漏欢迎指正。</p><a id="more"></a><p>[TOC]</p><p>本文围绕 Tinker so 替换技术用于 Flutter 更新来讨论以下几个问题：</p><ul><li>Tinker 如何实现 so 更新/替换？</li><li><code>System.load()</code> 的执行流程是怎样的？</li><li>Flutter 大致的编译流程是怎样的？</li><li>Flutter 编译产物是什么，有什么变更？</li><li>so 替换如何应用于 Flutter 热更新？</li><li>Flutter 及其编译产物的变更对上述方案有哪些潜在的影响？</li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="http://github.com/tencent/tinker" target="_blank" rel="noopener">Tinker</a> 是 Android 平台上一个流行的热更新框架，官网介绍如下：</p><blockquote><p>Tinker is a hot-fix solution library for Android, it supports dex, library and resources update without reinstalling apk.</p></blockquote><p>Tinker 更新 dex 的原理如下，</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/21/15737818623730.jpg" alt="Tinker 原理"></p><p>从介绍及原理图可以看出 <em>Tinker 的主打功能是通过差分包更新 dex 来实现热更新</em>，介绍中虽然简短地提到支持 library 热修复，但原理图中并没有给出相关内容。</p><p>Tinker 与其他主流热修复框架功能特性对比如下，</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/21/15737820549373.jpg" alt="Tinker 功能特性"></p><p>(图片来自 <a href="https://github.com/tencent/tinker/wiki" target="_blank" rel="noopener">Tinker wiki</a>)</p><p>只有 Tinker 支持 so 替换，是不是非常特别？我好奇它是如何实现的。</p><h1 id="Tinker-如何更新-so-库"><a href="#Tinker-如何更新-so-库" class="headerlink" title="Tinker 如何更新 so 库"></a>Tinker 如何更新 so 库</h1><p>这是 Tinker API 概览：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/21/15737861688694.jpg" alt="Tinker API 概览"></p><p><a href="https://github.com/Tencent/tinker/blob/master/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java" target="_blank" rel="noopener">TinkerLoadLibrary</a> 负责加载更新/替换后的 so，大致过程如下：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/21/15737860062659.jpg" alt="TinkerLoadLibrary"></p><p>实际上 Tinker 会根据一些条件来选择不同的加载过程，限于篇幅这里我们只讨论左边这种情况。涉及到的主要代码是：</p><ul><li><a href="https://github.com/Tencent/tinker/blob/master/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java#L137" target="_blank" rel="noopener">TinkerLoadLibrary.loadLibraryFromTinker()</a></li><li><a href="https://github.com/Tencent/tinker/blob/master/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java" target="_blank" rel="noopener">TinkerLoader.tryLoad()</a></li></ul><p><code>TinkerLoadLibrary.loadLibraryFromTinker(Context context, String relativePath, String libName)</code> 的流程如下：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/21/15737883238420.jpg" alt="TinkerLoadLibrary 加载 so"></p><ul><li><del>第一步是条件判断，检查是否支持加载 so、是否已构建 <code>Tinker</code>、<code>tinkerLoadResult</code> 是否存在，任一条件失败就直接结束</del> (忽略, 我们不关注)</li><li>第二步是遍历 <code>tinkerLoadResult.libs</code>，从中找到跟 <code>relativePath</code> 匹配的那一项并构建出 <code>patchLibraryPath</code></li><li>第三步，通过 MD5 校验则<strong>调用 System.load() 加载 so 文件</strong>(由 <code>patchLibraryPath</code> 指定)，否则结束</li></ul><p>单看这个流程的话，我们很快就能得出结论：Tinker 更新/替换 so，本质上不过是对 <code>System.load()</code> 的包装。</p><p>所以剩下的问题是梳理这里的 <code>tinkerLoadResult.libs</code> 到底指向了哪个文件？那个文件是如何来的？</p><!--TinkerInstaller.install() -> Tinker.install()  -> TinkerLoadResult.parseTinkerResult()   -> ApplicationLike.getTinkerResultIntent()    -> AnnotationProcessor 注解器     -> TinkerApplication--><p>继续分析之前先了解 Tinker 的几个背景知识：</p><ul><li>第一，Tinker 合并差分包后生成新的 so 保存在相应目录下。目录名类似于 <code>tinker/patch-641e634c/lib</code>。</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/21/15738059908501.jpg" alt="Tinker so 文件目录结构"></p><ul><li>第二，使用 Tinker 库的一种方式是继承 <a href="https://github.com/Tencent/tinker/blob/master/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/entry/DefaultApplicationLike.java" target="_blank" rel="noopener">DefaultApplicationLike</a>，而它本身继承自 <a href="https://github.com/Tencent/tinker/blob/master/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/entry/ApplicationLike.java" target="_blank" rel="noopener">ApplicationLike</a>。<a href="[tinker/SampleApplicationLike.java](https://github.com/Tencent/tinker/blob/master/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java">官方示例</a>) 的演示了 <code>DefaultApplicationLike</code> 的用法，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.tencent.tinker.anno.DefaultLifeCycle;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DefaultLifeCycle</span>(application = <span class="string">"tinker.sample.android.app.SampleApplication"</span>,</span><br><span class="line">                  flags = ShareConstants.TINKER_ENABLE_ALL,</span><br><span class="line">                  loadVerifyFlag = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplicationLike</span> <span class="keyword">extends</span> <span class="title">DefaultApplicationLike</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onCreate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第三，Tinker 的 <code>@DefaultLifeCycle</code> 注解器(源码见 <a href="https://github.com/Tencent/tinker/blob/master/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/AnnotationProcessor.java" target="_blank" rel="noopener">AnnotationProcessor</a>)从 <code>SampleApplicationLike</code> 生成如下形式的 <a href="https://github.com/Tencent/tinker/blob/master/tinker-android/tinker-android-anno/src/main/resources/TinkerAnnoApplication.tmpl" target="_blank" rel="noopener">Application</a>。具体用法可以参考<a href="[tinker/SampleApplicationLike.java](https://github.com/Tencent/tinker/blob/master/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java">官方示例</a>)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Generated application for tinker life cycle</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> %<span class="title">APPLICATION</span>% <span class="keyword">extends</span> <span class="title">TinkerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> %APPLICATION%() &#123;</span><br><span class="line">        <span class="keyword">super</span>(%TINKER_FLAGS%, <span class="string">"%APPLICATION_LIFE_CYCLE%"</span>, <span class="string">"%TINKER_LOADER_CLASS%"</span>, %TINKER_LOAD_VERIFY_FLAG%);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单总结一下：</p><ul><li><code>@DefaultLifeCycle</code> 注解器从 <code>SampleApplicationLike</code> 生成 <code>SampleApplication</code></li><li>生成的 <code>SampleApplication</code> 继承自 <code>TinkerApplication</code></li><li><code>SampleApplicationLike</code> 是 <code>SampleApplication</code> 的代理 (理解这个关系需要留意模板文件中的 <code>%APPLICATION_LIFE_CYCLE%</code> 以及 <a href="https://github.com/Tencent/tinker/blob/master/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java" target="_blank" rel="noopener">TinkerApplication</a> 构造方法第二个参数)</li></ul><p>有了这些背景知识，再回头看 <code>tinkerLoadResult.libs</code>。</p><p>第一步，应用启动时调用 <code>TinkerApplication.loadTinker()</code>，这个方法反射调用 <code>TinkerLoader.tryLoad()</code>。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TinkerApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Intent tinkerResultIntent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onBaseContextAttached</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        loadTinker();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadTinker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//reflect tinker loader, because loaderClass may be define by user!</span></span><br><span class="line">            Class&lt;?&gt; tinkerLoadClass = Class.forName(loaderClassName, <span class="keyword">false</span>, TinkerApplication<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">            Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            Constructor&lt;?&gt; constructor = tinkerLoadClass.getConstructor();</span><br><span class="line">            tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">//has exception, put exception error code</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，<code>TinkerLoader.tryLoad()</code> 最终调用 <code>TinkerSoLoader</code> 来加载 so 文件。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TinkerLoader</span> <span class="keyword">extends</span> <span class="title">AbstractTinkerLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Intent <span class="title">tryLoad</span><span class="params">(TinkerApplication app)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"tryLoad test test"</span>);</span><br><span class="line">        Intent resultIntent = <span class="keyword">new</span> Intent();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> begin = SystemClock.elapsedRealtime();</span><br><span class="line">        tryLoadPatchFilesInternal(app, resultIntent);</span><br><span class="line">        <span class="keyword">long</span> cost = SystemClock.elapsedRealtime() - begin;</span><br><span class="line">        ShareIntentUtil.setIntentPatchCostTime(resultIntent, cost);</span><br><span class="line">        <span class="keyword">return</span> resultIntent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryLoadPatchFilesInternal</span><span class="params">(TinkerApplication app, Intent resultIntent)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForNativeLib = ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEnabledForNativeLib) &#123;</span><br><span class="line">            <span class="comment">//tinker/patch.info/patch-641e634c/lib</span></span><br><span class="line">            <span class="keyword">boolean</span> libCheck = TinkerSoLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);</span><br><span class="line">            <span class="keyword">if</span> (!libCheck) &#123;</span><br><span class="line">                <span class="comment">//file not found, do not load patch</span></span><br><span class="line">                Log.w(TAG, <span class="string">"tryLoadPatchFiles:native lib check fail"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，<code>TinkerSoLoader.checkComplete()</code> 生成一个 HashMap 对象用于保存 so 文件相关的信息。而 HashMap 本身又保存在 Intent 中，字段名为 <code>intent_patch_libs_path</code>。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TinkerSoLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkComplete</span><span class="params">(String directory, </span></span></span><br><span class="line"><span class="function"><span class="params">      ShareSecurityCheck securityCheck, Intent intentResult)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//tinker//patch-641e634c/lib</span></span><br><span class="line">        String libraryPath = directory + <span class="string">"/"</span> + SO_PATH + <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, String&gt; libs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (ShareBsDiffPatchInfo info : libraryList) &#123;</span><br><span class="line">            ...</span><br><span class="line">            String middle = info.path + <span class="string">"/"</span> + info.name;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//unlike dex, keep the original structure</span></span><br><span class="line">            libs.put(middle, info.md5);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if is ok, add to result intent</span></span><br><span class="line">        intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_LIBS_PATH, libs);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这里的 so 文件为例，</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/21/15738059908501.jpg" alt="Tinker so 文件目录结构"></p><p>HashMap 中包含如下数据：</p><ul><li>key - <code>tinker/patch-3a9eeb8d/lib/lib/armeabi/libapp.so</code></li><li>value - 该 so 文件的 MD5</li></ul><p>注意，第三步中用于保存 HashMap 的 Intent 即第一步中的  <code>TinkerApplication.tinkerResultIntent</code>。</p><hr><p>第四步，这一步涉及到的内容较多，是第三步和第五步之间的衔接，整理如下供参考。</p><p>两个关键点：</p><ul><li><code>TinkerApplication.createInlineFence()</code> 反射方式创建 <code>TinkerApplicationInlineFence</code></li><li><code>TinkerApplicationInlineFence.createDelegate()</code> 反射方式创建 <code>ApplicationLike</code> (<code>ApplicationLike</code> 是 <code>TinkerApplication</code> 的代理)</li></ul><p>主要流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TinkerApplication.attachBaseContext()</span><br><span class="line"> -&gt; TinkerApplication.onBaseContextAttached()</span><br><span class="line">  -&gt; ITinkerInlineFenceBridge.attachBaseContext()</span><br><span class="line">   -&gt; TinkerApplicationInlineFence.attachBaseContext()</span><br><span class="line">    -&gt; TinkerApplicationInlineFence.attachBaseContextImpl_$noinline$()</span><br><span class="line">     -&gt; ApplicationLike.onBaseContextAttached()</span><br></pre></td></tr></table></figure><p>从这个流程可以看出 <code>TinkerApplication</code> 和 <code>ApplicationLike</code> 之间的关联。</p><p>再来结合 demo 来看 <code>ApplicationLike.onBaseContextAttached()</code> 这个回调，观察 <code>ApplicationLike</code> 是如何跟 <code>TinkerInstaller</code> 关联起来的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DefaultLifeCycle</span>(application = <span class="string">"tinker.sample.android.app.SampleApplication"</span>,</span><br><span class="line">                  flags = ShareConstants.TINKER_ENABLE_ALL,</span><br><span class="line">                  loadVerifyFlag = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplicationLike</span> <span class="keyword">extends</span> <span class="title">DefaultApplicationLike</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBaseContextAttached</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onBaseContextAttached(base);</span><br><span class="line">        ...</span><br><span class="line">        TinkerManager.installTinker(<span class="keyword">this</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TinkerManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installTinker</span><span class="params">(ApplicationLike appLike)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        TinkerInstaller.install(appLike,</span><br><span class="line">            loadReporter, patchReporter, patchListener,</span><br><span class="line">            SampleResultService<span class="class">.<span class="keyword">class</span>, <span class="title">upgradePatchProcessor</span>)</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>第五步，调用 <code>TinkerInstaller.install()</code> 方法，一系列调用后将生成 <code>TinkerLoadResult</code> 对象。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TinkerInstaller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Tinker <span class="title">install</span><span class="params">(ApplicationLike applicationLike)</span> </span>&#123;</span><br><span class="line">        Tinker tinker = <span class="keyword">new</span> Tinker.Builder(applicationLike.getApplication()).build();</span><br><span class="line">        Tinker.create(tinker);</span><br><span class="line">        tinker.install(applicationLike.getTinkerResultIntent());</span><br><span class="line">        <span class="keyword">return</span> tinker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tinker</span> </span>&#123;</span><br><span class="line">    TinkerLoadResult tinkerLoadResult;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(Intent intentResult, Class&lt;? extends AbstractResultService&gt; serviceClass, AbstractPatch upgradePatch)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        tinkerLoadResult = <span class="keyword">new</span> TinkerLoadResult();</span><br><span class="line">        tinkerLoadResult.parseTinkerResult(getContext(), intentResult);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TinkerLoadResult</span> </span>&#123;</span><br><span class="line">   <span class="comment">//@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;String, String&gt; libs;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">parseTinkerResult</span><span class="params">(Context context, Intent intentResult)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> (loadCode) &#123;</span><br><span class="line">            <span class="keyword">case</span> ShareConstants.ERROR_LOAD_OK:</span><br><span class="line">                TinkerLog.i(TAG, <span class="string">"oh yeah, tinker load all success"</span>);</span><br><span class="line">                tinker.setTinkerLoaded(<span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// get load dex</span></span><br><span class="line">                dexes = ShareIntentUtil.getIntentPatchDexPaths(intentResult);</span><br><span class="line">                libs = ShareIntentUtil.getIntentPatchLibsPaths(intentResult);</span><br><span class="line">                ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码可以看到，<code>TinkerLoadResult.libs</code> 来自于 <code>ApplicationLike.getTinkerResultIntent()</code> 返回的 Intent 中保存 HashMap 对象，其字段名为 <code>intent_patch_libs_path</code>。</p><p>前面提到过 <code>ApplicationLike</code> 是 <code>TinkerApplication</code> 的代理。<code>ApplicationLike.getTinkerResultIntent()</code> 返回的 Intent 其实就是 <code>TinkerApplication.tinkerResultIntent</code>，具体可参考 <a href="https://github.com/Tencent/tinker/blob/master/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/entry/TinkerApplicationInlineFence.java#L68" target="_blank" rel="noopener">tinker/TinkerApplicationInlineFence.java</a>。</p><p><code>TinkerLoadResult</code> 代表加载结果，其 <code>libs</code> 字段保存了 so 文件地址。如果以 <code>TinkerLoadResult</code> 作为关注点，整个过程总结如下：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/03/15752896732123.jpg" alt="TinkerLoadResult"></p><ol><li><code>TinkerApplication</code> 及相关类是生产者，负责生产 <code>TinkerLoadResult</code></li><li><code>Tinker</code> 是管理者，负责管理 <code>TinkerLoadResult</code></li><li><code>TnikerLoadLibrary</code> 是消费者，负责消费 <code>TinkerLoadResult</code></li></ol><p>可见，无论这个过程多复杂，Tinker 最终仍然是调用 <code>System.load()</code> 加载 so 库。</p><h1 id="System-load-简介"><a href="#System-load-简介" class="headerlink" title="System.load() 简介"></a>System.load() 简介</h1><p>前面提到 Tinker 更新/替换 so 库其实不过是对 <code>System.load()</code> 方法的包装。<a href="https://github.com/flutter/engine/blob/v1.9.1-hotfixes/shell/platform/android/io/flutter/view/FlutterMain.java" target="_blank" rel="noopener">Flutter 引擎初始化</a> 时也调用了 <code>System.load()</code> 方法。所以我们有必要了解这个方法。</p><p>考虑到已经有很多优秀的文章很好地总结了相关知识，我这里直接搬一些上来。</p><ul><li><a href="http://gityuan.com/2017/03/26/load_library/" target="_blank" rel="noopener">loadLibrary动态库加载过程分析</a></li><li><a href="https://pqpo.me/2017/05/31/system-loadlibrary/" target="_blank" rel="noopener">深入理解 System.loadLibrary - Pqpo’s Notes</a></li></ul><p><a href="http://gityuan.com/2017/03/26/load_library/" target="_blank" rel="noopener">loadLibrary动态库加载过程分析</a> 提到加载动态库的调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.loadLibrary()</span><br><span class="line"> -&gt; Runtime.loadLibrary()</span><br><span class="line">  -&gt; Runtime.doLoad()</span><br><span class="line">   -&gt; Runtime_nativeLoad() //1</span><br><span class="line">    -&gt; LoadNativeLibrary() //2</span><br><span class="line">     -&gt; dlopen()</span><br><span class="line">       -&gt; dlsym()</span><br><span class="line">         -&gt; JNI_OnLoad()</span><br></pre></td></tr></table></figure><p>(注：无论 <code>System.loadLibrary()</code> 还是 <code>System.load()</code> 最后都会调用到 <a href="https://android.googlesource.com/platform/art/+/e34fa1d/runtime/java_vm_ext.cc#577" target="_blank" rel="noopener">LoadNativeLibrary()</a> 方法，所以这里对二者未加区分)</p><p>调用栈中最主要代码是：</p><ul><li>代码1 - <a href="https://android.googlesource.com/platform/art/+/906846f/runtime/native/java_lang_Runtime.cc#70" target="_blank" rel="noopener">java_lang_Runtime.Runtime_nativeLoad()</a></li><li>代码2 - <a href="https://android.googlesource.com/platform/art/+/e34fa1d/runtime/java_vm_ext.cc#577" target="_blank" rel="noopener">java_vm_ext.LoadNativeLibrary()</a></li></ul><p><a href="https://android.googlesource.com/platform/art/+/e34fa1d/runtime/java_vm_ext.cc#577" target="_blank" rel="noopener">LoadNativeLibrary()</a> 方法执行如下几个操作：</p><ul><li>通过 <code>dlopen()</code> 打开动态共享库;</li><li>通过 <code>dlsym</code> 获取 <code>JNI_OnLoad</code> 符号所对应的方法；</li><li>调用该加载库中的 <code>JNI_OnLoad()</code> 方法</li></ul><p><code>dlopen()</code> 和 <code>dlsym()</code> 是 Linux 系统为动态链接器提供的接口，允许应用程序在运行时加载和链接动态库。这个 demo 演示了这些接口的用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.c</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*SIMPLE_FUNC)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *handle = dlopen(<span class="string">"libworld.so"</span>, RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span> (!handle) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: %s\n"</span>, dlerror());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> *symSayWorld = dlsym(handle, <span class="string">"sayWorld"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!symSayWorld) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: %s\n"</span>, dlerror());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SIMPLE_FUNC sayWorld = symSayWorld;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="string">"hello"</span>);</span><br><span class="line">    sayWorld();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// world.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">",world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/03/15753450972729.jpg" alt="dlopen 的用法"></p><h1 id="从-so-库到-Flutter-热更新"><a href="#从-so-库到-Flutter-热更新" class="headerlink" title="从 so 库到 Flutter 热更新"></a>从 so 库到 Flutter 热更新</h1><p>将 so 更新/替换应用于 Flutter 热更新技术上完全是可行的。《深入理解计算机系统》第七章第 7.11 节（P468）中讨论了应用程序如何加载和链接共享库。</p><blockquote><p>应用程序还可以在它运行时要求动态链接器加载和链接任意共享库，而无需在编译时链接那些库到应用中。</p></blockquote><p>书中还举了微软 Windows 应用更新的例子：</p><blockquote><p>分发软件。微软 Windows 应用的开发者常常利用共享库来分发软件更新。他们生成一个共享库的新版本。然后用户可以下载，并用它替换当前的版本。下一次他们运行应用程序时，应用将自动链接和加载新的共享库</p></blockquote><p>所以理论上只要 Flutter 不出于系统安全等原因阻止应用动态链接和加载<strong>更新后的共享库</strong>，动态链接技术同样可以用于热更新。但实践中可能遇到以下几个问题：</p><ul><li>首先你得要有 so ！</li></ul><p>我们知道 Dart 有 JIT 和 AOT 两种不同的编译模式，而 Flutter 是使用 Dart 作为开发语言，其编译产物在 debug 模式和 release 模式下并不相同。Dart 和 Flutter 都在快速演进，编译产物常常随版本发生变化。所以并不是所有编译模式或 Flutter 版本都有 so。没有 so，也就无法替换 so 文件来热更新。好在 Flutter v1.7 版本开始 release 模式下编译产物输出为 so 文件，所以 so 更新/替换方案变得可行</p><ul><li>其次是加载 so 的过程要可控</li></ul><p>我们很容易控制如何加载自己开发的 so 库文件。但第三方库通常会主动加载自带的 so 库文件，典型的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class FooSdk &#123;</span><br><span class="line"></span><br><span class="line">    // 在 static 初始化语句块中加载 libfoo.so</span><br><span class="line">    static &#123;</span><br><span class="line">        System.loadLibrary(&apos;foo&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // libfoo.so 实现 bar() 方法</span><br><span class="line">    public native void bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三方库通常会主动加载 so 的好处是对开发者透明和友好，坏处是不灵活不可控。Flutter 会不会也使用这种写死的加载方式呢？</p><p>我们会一步步详细展开，看看实践中是否存在这些问题。如果有，要如何克服？主要话题包括：</p><ul><li>Flutter 编译流程及产物简介</li><li>Flutter 引擎初始化简介</li></ul><h2 id="Flutter-编译流程及产物"><a href="#Flutter-编译流程及产物" class="headerlink" title="Flutter 编译流程及产物"></a>Flutter 编译流程及产物</h2><p>Dart 支持 JIT 和 AOT 两种编译模式。Flutter 在 debug 模式和 release 模式分别使用 JIT 和 AOT，前者开发调试速度快，后者运行效率高。</p><p>使用 Android Studio 或 VS code 来打包 Flutter 应用时，实际都会调用 <code>flutter run</code> 来构建 APK 包。关于 <code>flutter run</code> 命令<a href="https://juejin.im/post/5d68fb1af265da03d063b69e#heading-1" target="_blank" rel="noopener">浅谈Flutter构建</a>中有比较详细的讨论。</p><p>忽略一些不必要的细节，我们可以简单地认为：</p><ul><li>编译 debug 包对应于 <code>flutter build bundle</code> 这条命令</li><li>编译 release 包对应于 <code>flutter build aot; flutter build bundle --precompiled</code> 这两条命令</li></ul><p>现在来动手实践一下，观察这些命令的编译产物。我的 Flutter 版本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flutter 1.10.15-pre.234 • channel master • https://github.com/flutter/flutter.git</span><br><span class="line">Framework • revision e7236796bd (6 weeks ago) • 2019-10-24 03:21:06 -0400</span><br><span class="line">Engine • revision 5ded729f6a</span><br><span class="line">Tools • Dart 2.6.0 (build 2.6.0-dev.8.1 d43cd7e909)</span><br></pre></td></tr></table></figure><p><code>flutter create flutter_empty_demo</code> 创建一个新的项目，不对代码作任何改动，利用这个项目进行验证。</p><h3 id="编译-debug-包"><a href="#编译-debug-包" class="headerlink" title="编译 debug 包"></a>编译 debug 包</h3><p>运行 <code>flutter build bundle</code> 并观察建产物。这条命令本质是通过以下代码构造出一条类似于 <code>dart &lt;参数1&gt; &lt;参数2&gt; ... &lt;参数n&gt;</code> 带复杂参数的命令。主要代码包括：</p><ul><li><a href="https://github.com/flutter/flutter/blob/v1.9.1-hotfixes/packages/flutter_tools/lib/src/compile.dart" target="_blank" rel="noopener">compile.dart</a> - 对 Flutter SDK 中 <code>dart</code> 命令的包装，提供 <code>KernelCompiler</code> </li><li><a href="https://github.com/flutter/flutter/blob/v1.9.1-hotfixes/packages/flutter_tools/lib/src/bundle.dart" target="_blank" rel="noopener">bundle.dart</a> - 基于 <code>KernelCompiler</code> 提供 <code>BundleBuilder</code></li><li><a href="https://github.com/flutter/flutter/blob/v1.9.1-hotfixes/packages/flutter_tools/lib/src/commands/build_bundle.dart" target="_blank" rel="noopener">build_bundle.dart</a> - 基于 <code>BundleBuilder</code> 来实现 <code>flutter build bundle</code> 命令</li></ul><p>这条命令没有任何提示，等待约2秒后项目根目录下多出 <code>build/flutter_assets</code> 文件夹。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/03/15753607615004.jpg" alt="debug 模式编译产物"></p><ul><li><a href="https://github.com/dart-lang/sdk/tree/master/pkg/kernel" target="_blank" rel="noopener">kernel</a> - kernel 是从 Dart 本身衍生出来的语言，用于 Dart 程序的中间格式。这里的 <code>kernel_blob.bin</code> 即我们应用中编写的 Dart 代码</li><li>snapshots - Dart 虚拟机的状态</li><li>assets - 图片、字体等资源</li></ul><h3 id="编译-release-包"><a href="#编译-release-包" class="headerlink" title="编译 release 包"></a>编译 release 包</h3><p>运行 <code>flutter build aot</code> 并观察建产物。同样地，这条命令本质是通过以下代码构造出一条类似于 <code>dart &lt;参数1&gt; &lt;参数2&gt; ... &lt;参数n&gt;</code> 的带复杂参数的命令。主要代码包括：</p><ul><li><a href="https://github.com/flutter/flutter/blob/v1.9.1-hotfixes/packages/flutter_tools/lib/src/base/build.dart" target="_blank" rel="noopener">build.dart</a> - 对 Flutter SDK 中 <code>dart</code> 命令的包装，提供 <code>AOTSnapshotter</code>，可以将 Dart 代码编译成 so</li><li><a href="https://github.com/flutter/flutter/blob/v1.9.1-hotfixes/packages/flutter_tools/lib/src/commands/build_aot.dart" target="_blank" rel="noopener">build_aot.dart</a> - 基于 <code>BundleAOTSnapshotterBuilder</code> 来实现 <code>flutter build aot</code> 命令</li></ul><p>这条命令耗时比编译 debug 包稍长，输出如下：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/03/15753621578674.jpg" alt="flutter build aot"><br>执行成功后项目根目录下多出 <code>build/aot</code> 目录，我们的 Dart 代码被编译成这里的 <code>app.so</code>。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/03/15753622582470.jpg" alt="build /aot 目录"><br><code>app.so</code> 是可以将 Tinker so 替换用于 Flutter 更新的关键之一。实际上， Flutter 一开始并不是编译成 <code>app.so</code>，而是多次调整直到 1.7 版本开始输出为 <code>app.so</code>，直到目前最新版本 (V1.9)。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/12/03/15753633845265.jpg" alt="Flutter 编译产物演进"></p><p>(注：图片来自 <a href="https://juejin.im/post/5d68fb1af265da03d063b69e" target="_blank" rel="noopener">浅谈Flutter构建</a>)</p><p>通过对比相关代码可以看到，编译产物的变更其实只不过是 <code>snapshot_kind</code> 参数的调整：从 V1.7 的 <code>app-aot-blobs</code> 调整到 V1.9 的 <code>app-aot-elf</code></p><p><a href="https://github.com/flutter/flutter/blob/v1.9.1-hotfixes/packages/flutter_tools/lib/src/base/build.dart#L138" target="_blank" rel="noopener">Flutter V1.9 AOTSnapshotter 代码片断</a></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> assembly = fs.path.join(outputDir.path, <span class="string">'snapshot_assembly.S'</span>);</span><br><span class="line"><span class="keyword">if</span> (platform == TargetPlatform.ios || platform == TargetPlatform.darwin_x64) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> aotSharedLibrary = fs.path.join(outputDir.path, <span class="string">'app.so'</span>);</span><br><span class="line">  outputPaths.add(aotSharedLibrary);</span><br><span class="line">  genSnapshotArgs.add(<span class="string">'--snapshot_kind=app-aot-elf'</span>);</span><br><span class="line">  genSnapshotArgs.add(<span class="string">'--elf=<span class="subst">$aotSharedLibrary</span>'</span>);</span><br><span class="line">  genSnapshotArgs.add(<span class="string">'--strip'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/flutter/flutter/blob/v1.5.4-hotfixes/packages/flutter_tools/lib/src/base/build.dart#L152" target="_blank" rel="noopener">Flutter V1.5 AOTSnapshotter 代码片断</a></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> assembly = fs.path.join(outputDir.path, <span class="string">'snapshot_assembly.S'</span>);</span><br><span class="line"><span class="keyword">if</span> (buildSharedLibrary || platform == TargetPlatform.ios) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Blob AOT snapshot.</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> vmSnapshotData = fs.path.join(outputDir.path, <span class="string">'vm_snapshot_data'</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> isolateSnapshotData = fs.path.join(outputDir.path, <span class="string">'isolate_snapshot_data'</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> vmSnapshotInstructions = fs.path.join(outputDir.path, <span class="string">'vm_snapshot_instr'</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> isolateSnapshotInstructions = fs.path.join(outputDir.path, <span class="string">'isolate_snapshot_instr'</span>);</span><br><span class="line">  outputPaths.addAll(&lt;<span class="built_in">String</span>&gt;[vmSnapshotData, isolateSnapshotData, vmSnapshotInstructions, isolateSnapshotInstructions]);</span><br><span class="line">  genSnapshotArgs.addAll(&lt;<span class="built_in">String</span>&gt;[</span><br><span class="line">    <span class="string">'--snapshot_kind=app-aot-blobs'</span>,</span><br><span class="line">    <span class="string">'--vm_snapshot_data=<span class="subst">$vmSnapshotData</span>'</span>,</span><br><span class="line">    <span class="string">'--isolate_snapshot_data=<span class="subst">$isolateSnapshotData</span>'</span>,</span><br><span class="line">    <span class="string">'--vm_snapshot_instructions=<span class="subst">$vmSnapshotInstructions</span>'</span>,</span><br><span class="line">    <span class="string">'--isolate_snapshot_instructions=<span class="subst">$isolateSnapshotInstructions</span>'</span>,</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Flutter-引擎初始化"><a href="#Flutter-引擎初始化" class="headerlink" title="Flutter 引擎初始化"></a>Flutter 引擎初始化</h2><p><a href="https://github.com/flutter/engine/blob/v1.9.1-hotfixes/shell/platform/android/io/flutter/view/FlutterMain.java" target="_blank" rel="noopener">FlutterMain</a> 用于初始化 Flutter 引擎。这里只讨论跟 <code>libapp.so</code> 加载相关的部分 (<code>libapp.so</code> 即上文的 <code>app.so</code>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A class to intialize the Flutter engine.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterMain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"FlutterMain"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_AOT_SHARED_LIBRARY_NAME = <span class="string">"libapp.so"</span>;</span><br><span class="line">    <span class="comment">// Mutable because default values can be overridden via config properties</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String sAotSharedLibraryName = DEFAULT_AOT_SHARED_LIBRARY_NAME;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize our Flutter config values by obtaining them from the</span></span><br><span class="line"><span class="comment">     * manifest XML file, falling back to default values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initConfig</span><span class="params">(@NonNull Context applicationContext)</span> </span>&#123;</span><br><span class="line">        Bundle metadata = getApplicationInfo(applicationContext).metaData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// There isn't a `&lt;meta-data&gt;` tag as a direct child of `&lt;application&gt;` in</span></span><br><span class="line">        <span class="comment">// `AndroidManifest.xml`.</span></span><br><span class="line">        <span class="keyword">if</span> (metadata == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sAotSharedLibraryName = metadata.getString(PUBLIC_AOT_SHARED_LIBRARY_NAME, DEFAULT_AOT_SHARED_LIBRARY_NAME);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Blocks until initialization of the native system has completed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationContext The Android application context.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args Flags sent to the Flutter runtime.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensureInitializationComplete</span><span class="params">(@NonNull Context applicationContext, @Nullable String[] args)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      List&lt;String&gt; shellArgs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      String kernelPath = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</span><br><span class="line">          String snapshotAssetPath = PathUtils.getDataDirectory(applicationContext) + File.separator + sFlutterAssetsDir;</span><br><span class="line">          kernelPath = snapshotAssetPath + File.separator + DEFAULT_KERNEL_BLOB;</span><br><span class="line">          shellArgs.add(<span class="string">"--"</span> + SNAPSHOT_ASSET_PATH_KEY + <span class="string">"="</span> + snapshotAssetPath);</span><br><span class="line">          shellArgs.add(<span class="string">"--"</span> + VM_SNAPSHOT_DATA_KEY + <span class="string">"="</span> + sVmSnapshotData);</span><br><span class="line">          shellArgs.add(<span class="string">"--"</span> + ISOLATE_SNAPSHOT_DATA_KEY + <span class="string">"="</span> + sIsolateSnapshotData);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          shellArgs.add(<span class="string">"--"</span> + AOT_SHARED_LIBRARY_NAME + <span class="string">"="</span> + sAotSharedLibraryName);</span><br><span class="line">    </span><br><span class="line">          <span class="comment">// Most devices can load the AOT shared library based on the library name</span></span><br><span class="line">          <span class="comment">// with no directory path.  Provide a fully qualified path to the library</span></span><br><span class="line">          <span class="comment">// as a workaround for devices where that fails.</span></span><br><span class="line">          shellArgs.add(<span class="string">"--"</span> + AOT_SHARED_LIBRARY_NAME + <span class="string">"="</span> + applicationInfo.nativeLibraryDir + File.separator + sAotSharedLibraryName);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#">带你不到80行代码搞定Flutter热更新</a> 使用反射强行修改 <code>FlutterMain.sAotSharedLibraryName</code>，使其指向由 Tinker 管理的 so，从而实现热更新。不过从 V1.9 代码看似乎有更优雅的方案：</p><ul><li>首先 <code>sAotSharedLibraryName</code> 并非 <code>final</code> 字段，为的就是能从文件中读取配置</li><li>其次，<code>initConfig()</code> 方法的注释提到在 <code>AndroidManifest.xml</code> 中添加一个名为 <code>FlutterMain.aot-shared-library-name</code> 的 <code>&lt;meta-data&gt;</code> 可以为 <code>sAotSharedLibraryName</code> 指定值</li><li>最后，<code>FlutterMain.ensureInitializationComplete()</code> 方法的第二个参数 <code>args</code> 也会被添加到 <code>shellArgs</code> 变量中。所以可以按照格式添加额外的参数 <code>--AOT_SHARED_LIBRARY_NAME=&lt;so文件&gt;</code> 让 Flutter 引擎加载指定的 so 库。</li></ul><p>so 替换应用于 Flutter 热更新是可行的，原因包括：</p><ul><li>Flutter 1.7 之后编译产物输出为 <code>libapp.so</code> 文件，完全可以直接复用 Tinker 作为热更新框架</li><li>能使用反射等方式将 Flutter 加载 so 库的过程变得可控，比如从指定的路径加载更新/替换后的 so 库</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后来简单回答下前面提出的几个问题，作为总结。</p><ul><li>Tinker 如何实现 so 更新/替换？</li></ul><p>Tinker 实际上是调用 <code>System.load()</code> 来 so 实现更新/替换。 虽然 so 更新/替换并不是 Tinker 独有的，我们完全可以直接调用 <code>System.load()</code> 来实现 so 更新，但考虑 Tinker 的 patch 包生成和合并非常完善(可以生成很小的差分包)，工程实际中是个不错的选择。</p><ul><li><code>System.load()</code> 的执行流程是怎样的？</li></ul><p><code>System.load()</code> 调用 <code>Runtime</code> 相关方法，最终进入到 Java 虚拟机中的 <a href="https://android.googlesource.com/platform/art/+/e34fa1d/runtime/java_vm_ext.cc#577" target="_blank" rel="noopener">java_vm_ext.LoadNativeLibrary()</a> 方法。该方法调用 <code>dlopen()</code> 和 <code>dlsysm()</code> 加载 so 文件</p><ul><li>Flutter 大致的编译流程是怎样的？</li></ul><p>调用 <code>dart</code> 命令将应用中的 Dart 代码编译成某种类型的 snapshot 文件，常用的 snapshot-kind 包括 <code>kernel</code>、<code>app-aot-elf</code> 和 <code>app-aot-blobs</code>。 (这里仍然有个疑问，为什么 Dart 官网并没有提到 <code>app-aot-elf</code> 和 <code>app-aot-blobs</code> 这两种类型的 snapshot-kind？)</p><ul><li>Flutter 编译产物是什么，有什么变更？</li></ul><p>编译产物包括 1. 资源 (assets) 2. 代码 (kernel/so库 和 snapshots)</p><ul><li>so 替换如何应用于 Flutter 热更新？</li></ul><p>通过反射等方式修改 <code>FlutterMain.sAotSharedLibraryName</code> 字段，将缺省的 <code>libapp.so</code> 替换为指定的 so</p><ul><li>Flutter 及其编译产物的变更对上述方案有哪些潜在的影响？</li></ul><p>Fluter 1.7 版本之前编译产物并非 so 文件，所以不能直接利用 so 替换来实现热更新。1.7 版本之后编译产物输出为 so 文件，可以利用 so 替换来实现热更新。</p><p>但是要注意，so 替换方案虽然可行，Flutter 的代码仍在频繁变更中，所以使用反射等手段时要尤其注意 Flutter 版本带来的影响。比方说，Flutter 1.9 中反射方式修改 <code>FlutterMain.sAotSharedLibraryName</code> 是可行的，但 Flutter 1.12 中则会失败。原因很简单：1.12 新版本中 <code>FlutterMain</code> 被重构成 <code>FlutterMain</code> 和 <code>FlutterLoader</code>，原先用于加载 <code>libapp.so</code> 的代码现移到 <code>FlutterLoader</code> 中了，包括 <code>sAotSharedLibraryName</code> 字段。具体可参考源码。</p><ul><li>Flutter 1.9 - <a href="https://github.com/flutter/engine/blob/v1.9.1-hotfixes/shell/platform/android/io/flutter/view/FlutterMain.java" target="_blank" rel="noopener">engine/FlutterMain.java</a></li><li>Flutter 1.12 - <a href="https://github.com/flutter/engine/blob/v1.12.13-hotfixes/shell/platform/android/io/flutter/view/FlutterMain.java" target="_blank" rel="noopener">engine/FlutterMain.java</a> 和 <a href="https://github.com/flutter/engine/blob/v1.12.13-hotfixes/shell/platform/android/io/flutter/embedding/engine/loader/FlutterLoader.java" target="_blank" rel="noopener">engine/FlutterLoader.java</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="#">带你不到80行代码搞定Flutter热更新</a></li><li><a href="https://github.com/410063005/so-loader-demo/blob/master/README.md" target="_blank" rel="noopener">dlopen demo 完整源码</a></li><li><a href="https://www.sunmoonblog.com/2019/06/04/fake-dlopen/">Android dlopen 方法的使用限制及解决方案</a></li><li><a href="https://pqpo.me/2017/05/31/system-loadlibrary/" target="_blank" rel="noopener">深入理解 System.loadLibrary - Pqpo’s Notes</a></li><li><a href="http://gityuan.com/2017/03/26/load_library/" target="_blank" rel="noopener">loadLibrary动态库加载过程分析 - Gityuan博客 | 袁辉辉的技术博客</a></li><li><a href="https://juejin.im/post/5d68fb1af265da03d063b69e#heading-1" target="_blank" rel="noopener">浅谈Flutter构建 - 掘金</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart JIT 与 AOT</title>
      <link href="2019/11/13/dart-jit-aot/"/>
      <url>2019/11/13/dart-jit-aot/</url>
      
        <content type="html"><![CDATA[<p>简单聊聊 Dart 的 JIT 和 AOT 模式。</p><a id="more"></a><p>Dart 官方有如下介绍：</p><blockquote><p>Dart Native includes both a Dart VM with JIT (just-in-time) compilation and an AOT (ahead-of-time) compiler for producing machine code</p></blockquote><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/13/15734544331781.jpg" alt="-w725"></p><blockquote><p>Dart Native enables running Dart code compiled to native ARM or X64 machine code for mobile, desktop, and server apps.</p></blockquote><p>简单来说，Dart Native 同时支持 JIT 和 AOT。Dart 这种设计好处如下：</p><ul><li>Dart VM JIT 便于轻量快速开发，它既支持纯解释执行，也可对代码进行运行时优化</li><li>Dart AOT 编译器将代码编译成原生的 ARM 或 X64 代码，提升发布的代码运行效率</li></ul><h1 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h1><p>Dart SDK 分别为 JIT 和 AOT 提供不同的工具。</p><h2 id="dart-VM-tool"><a href="#dart-VM-tool" class="headerlink" title="dart VM tool"></a>dart VM tool</h2><p><a href="https://dart.dev/tools/dart-vm" target="_blank" rel="noopener">dart | Dart</a>。</p><blockquote><p>You can use the dart tool (bin/dart) to run Dart command-line apps such as server-side scripts, programs, and servers.</p></blockquote><p><code>dart</code> 命令支持如下的常用选项：</p><ul><li><code>--enable-asserts</code> - 开启断言</li><li><code>--version</code> - 查看 Dart VM 版本</li></ul><p>另外它还支持 Observatory 选项，用于分析和调试 Dart 程序。常用选项包括：</p><ul><li><code>--enable-vm-service</code> - 在本地 8181 端口开启 Observatory 服务</li><li><code>--observe</code> - 相当于同时指定 <code>--enable-vm-service</code> 和 <code>--pause-isolates-on-exit</code></li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/13/15734559193856.jpg" alt="-w794"></p><p>(小技巧：如果你是使用的是 iTerm，按住 Command 键后将光标放在)</p><p>关于 Observatory 的更多用法见 <a href="https://dart-lang.github.io/observatory/" target="_blank" rel="noopener">Observatory</a>。</p><h2 id="dart2native"><a href="#dart2native" class="headerlink" title="dart2native"></a><a href="https://dart.dev/tools/dart2native" target="_blank" rel="noopener">dart2native</a></h2><blockquote><p>Releases before Dart 2.6 contained a tool named dart2aot that produced AOT snapshots. The dart2native command replaces dart2aot and has a superset of the dart2aot functionality.</p></blockquote><blockquote><p>Dart 2.6 is now available, with support for compiling to self-contained, native executables.</p></blockquote><p>Dart 语言本身还在快速演化中。所以要注意以下变化：</p><ul><li>在 Dart 2.6 以及之前版本，<code>dart2aot</code> 用于生成 AOT 镜像</li><li>Dart 2.6 之后，<code>dart2native</code> 命令取代了 <code>dart2aot</code> (前者是后者的超集)。</li></ul><p>Dart 2.6 近期刚刚发布，这个版本开始才支持将 Dart 代码编译成自包含、独立的原生可执行程序。(当然，这只是形式上的改进，并不是 Dart 中的新技术，因为相关技术很早用于 Flutter 平台了)。</p><p>使用 <code>dart2native</code> 命令将对 Dart 程序进行 AOT (ahead-of-time) 编译，生成原生 ARM 或 X64 机器码。</p><p><code>dart2native</code> 命令的产物分成两种。一种是 <strong>独立的可执行程序</strong> (缺省是这种)，它是原生的机器码，由 Dart 代码及其依赖编译而来，再加上一个很小用于类型检查和垃圾回收的 Dart 运行时。</p><p><code>dart2native</code> 命令用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dart2native bin/main.dart -o bin/my_app</span><br><span class="line">cp bin/my_app .</span><br><span class="line">./my_app</span><br></pre></td></tr></table></figure><p>另一种是 <strong>AOT snapshot</strong>，它不包含 Dart 运行时，所以需要使用 <code>dartaotruntime</code> 来运行。</p><h2 id="dartaotruntime"><a href="#dartaotruntime" class="headerlink" title="dartaotruntime"></a><a href="https://dart.dev/tools/dartaotruntime" target="_blank" rel="noopener">dartaotruntime</a></h2><p><code>dartaotruntime</code> 命令用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dart2native bin/main.dart -k aot</span><br><span class="line">dartaotruntime bin/main.aot</span><br></pre></td></tr></table></figure><p>Flutter 采用 AOT snapshot 这种形式。讲 Flutter 架构时会看到这张图，</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/14/15737038527917.jpg" alt></p><p>图中 Flutter Engine 层中的 Dart 即 Dart 运行时，也正是这里提到的 <code>dartaotruntime</code>。</p><p>不过 Flutter 自带的 Dart SDK 中似乎找不到 <code>dart2aot</code> 或 <code>dart2native</code> 命令，以下两个 issue 提到了这个问题。</p><ul><li><a href="https://github.com/flutter/flutter/issues/32633" target="_blank" rel="noopener">dart2aot does not exist on the Dart SDK · Issue #32633 · flutter/flutter</a></li><li><a href="https://github.com/dart-lang/sdk/issues/36892" target="_blank" rel="noopener">The ‘dart2aot’ tool is missing from the Dart SDK debian package · Issue #36892 · dart-lang/sdk</a></li></ul><p><a href="https://medium.com/dartlang/dart2native-a76c815e6baf" target="_blank" rel="noopener">Announcing Dart 2.6 with dart2native: Compile Dart to self-contained, native executables</a> 对 Flutter 中不包含 <code>dart2aot</code> 或 <code>dart2native</code> 有如下解释：</p><blockquote><p>If you’re getting the Dart SDK via Flutter, note that current Flutter builds have incomplete dart2native support. Until Dart 2.6 reaches Flutter stable, we recommend you install the Dart 2.6 SDK from dart.dev/get-dart.</p></blockquote><p>可以从 <a href="https://dart.dev/tools/sdk/archive" target="_blank" rel="noopener">Dart 官网</a> 下载安装 Dart SDK，它包含 <code>dart2native</code> 命令。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/13/15735268131869.jpg" alt="Dart SDK 中的 dart2native 命令"></p><h1 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h1><p>写一个简单的 Dart 程序分别测试下 JIT 和 AOT 模式的性能。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo.dart</span></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">double</span> area;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000000</span>; i++) &#123;</span><br><span class="line">    area = i * <span class="number">3.14</span> * <span class="number">3.14</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/13/15735258635004.jpg" alt="-w779"></p><p>从测试数据可以看到，AOT 下的执行效率确实比 JIT 高多了。</p><p>Update: 2019-11-23 16:48</p><p><a href="https://renato.athaydes.com/posts/interesting-dart-features.html#quick-dart-overview" target="_blank" rel="noopener">这篇文章</a> 中 “Dart is as slow as Python” 这一节提到了 Dart 的性能问题，这里可以找到很多参考数据</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://dart.dev/platforms#dart-native-vm-jit-and-aot" target="_blank" rel="noopener">Platforms | Dart</a></li><li><a href="https://medium.com/dartlang/dart2native-a76c815e6baf" target="_blank" rel="noopener">Announcing Dart 2.6 with dart2native: Compile Dart to self-contained, native executables</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 入门之开篇</title>
      <link href="2019/11/13/flutter-series-1-begin/"/>
      <url>2019/11/13/flutter-series-1-begin/</url>
      
        <content type="html"><![CDATA[<p>开篇。这是 Flutter 入门系列的第一篇，列出了最近收集的学习资料。Flutter 和 Dart 都在快速更新中，所以学习资料尽可能以官方为准，以保证权威和及时更新。</p><a id="more"></a><p>[TOC]</p><p>俗话说，兵欲善其事必先利其器。学习 Dart 前如何”利器”呢？我认为无非这几个方面：</p><ul><li>优秀的学习资料</li><li>称手的开发工具</li><li>反复实践和练习</li></ul><p>具体见下图：</p><p><img src="/images/15736145796553.jpg" alt="-w724"></p><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><h2 id="网站和公众号"><a href="#网站和公众号" class="headerlink" title="网站和公众号"></a>网站和公众号</h2><p>官网通常是最权威的学习资料来源，所以强烈推荐优先看 Flutter 官网。Flutter 基于 Dart 平台，所以了解和熟悉 Dart 是非常必要的。官方还会不定期在 <a href="https://medium.com/flutter" target="_blank" rel="noopener">medium</a> 发一些技术文章，介绍 Flutter 的新特性，建议也关注。</p><ul><li><a href="https://dart.dev/" target="_blank" rel="noopener">Dart 官网</a></li><li><a href="https://flutter.dev/" target="_blank" rel="noopener">Flutter 官网</a></li><li><a href="https://medium.com/flutter" target="_blank" rel="noopener">medium</a></li><li>谷歌开发者公众号</li></ul><p>考虑到 Flutter 官网内容是英文，英文不好的话浏览起来会比较吃力的，也可退而求其次看中文网站：</p><ul><li><a href="https://flutter.cn" target="_blank" rel="noopener">Flutter 中文</a></li><li><a href="https://dart.cn" target="_blank" rel="noopener">Dart 中文</a> </li></ul><!--more[Dart 中文](http://s0dart0dev.icopy.site/) (非官方，大量内容由机器翻译)--><p>中文内容的好处，</p><ul><li>消除了语言障碍，方便快速浏览学习</li><li>中文网站通常在国内，打开速度可能快得多</li></ul><p>但也要注意其不足：</p><ul><li>访问可能不稳定 (通常不由官方支持，说不定哪天就没了)</li><li>某些内容相当不准确<ul><li>一些新术语很难翻译</li><li>大量内容由机器翻译，不靠谱</li></ul></li><li>内容更新不及时 (Flutter 和 Dart 都在快速更新中)</li></ul><p>谷歌开发者公众号是 Google 中国官方账号，汇集 Android、Flutter、Chrome OS 以及 AI 等开发技术。2019 年以及随着 Flutter 的爆发，这个公众号上关于 Flutter 的内容明显增多，建议关注。</p><p><img src="/images/15736157127923.jpg" alt="-w187"></p><p>谷歌开发者公众号上曾推出过几期 《Flutter 您需要知道的知识点》，这里整理如下：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652048481&amp;idx=1&amp;sn=3775bb6e61b9b4d7d7c5a48871a13807&amp;chksm=808cac24b7fb2532858b94dc45f1ec4f8ec83f28f186e0cbc53a40034b3398feddea553e3054&amp;mpshare=1&amp;scene=1&amp;srcid=1113sj4rrsidBwb6ecBCdZ86&amp;sharer_sharetime=1573616038315&amp;sharer_shareid=b5535657e3516bd6d7252ce5f5ed09f4&amp;rd2werd=1#wechat_redirect" target="_blank" rel="noopener">Flutter 您需要知道的知识点 | FAQ・第一期</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652048715&amp;idx=1&amp;sn=c8346d2603f311301d719d5374cc77ea&amp;chksm=808cad0eb7fb241864557d2bc08cacc2efeb76a27d3a6b849d2df44ccbddfa13c3e1b1db0f85&amp;mpshare=1&amp;scene=1&amp;srcid=1113h6WpLLfSkAf6rNSO5Yc5&amp;sharer_sharetime=1573616056926&amp;sharer_shareid=b5535657e3516bd6d7252ce5f5ed09f4&amp;rd2werd=1#wechat_redirect" target="_blank" rel="noopener">Flutter 您需要知道的知识点 | FAQ・第二期</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652049096&amp;idx=1&amp;sn=dc9d0a408d07d78d487974354fd5dee7&amp;chksm=808cae8db7fb279b3b2d183246a6759ccbc3d1d51420c7a7a5640f89206a1a20985d8d3f1b07&amp;mpshare=1&amp;scene=1&amp;srcid=1113f7jM3rxmuXGnN5NFNgzQ&amp;sharer_sharetime=1573616077912&amp;sharer_shareid=b5535657e3516bd6d7252ce5f5ed09f4&amp;rd2werd=1#wechat_redirect" target="_blank" rel="noopener">Flutter 您需要知道的知识点 | FAQ・第三期</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652049594&amp;idx=1&amp;sn=26434fd1aa93efb4aff12018365607cf&amp;chksm=808cb0ffb7fb39e9c4ccc010dd5dacd02faf326e22a70dae95783898e32b80c9102e94f9ec84&amp;mpshare=1&amp;scene=1&amp;srcid=11130i26qvOXs6rDzq7uSpdx&amp;sharer_sharetime=1573616095494&amp;sharer_shareid=b5535657e3516bd6d7252ce5f5ed09f4&amp;rd2werd=1#wechat_redirect" target="_blank" rel="noopener">Flutter 您需要知道的知识点 | FAQ・第四期</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652049986&amp;idx=1&amp;sn=adcb4fd598f8f37a83c98b3ae5fb478c&amp;chksm=808cb207b7fb3b11b969337386db9295f58c41f82131ad72de927ca3da80a31d4b0422234b4a&amp;mpshare=1&amp;scene=1&amp;srcid=1113cwoJv70OIw09MTgbsUFi&amp;sharer_sharetime=1573616122448&amp;sharer_shareid=b5535657e3516bd6d7252ce5f5ed09f4&amp;rd2werd=1#wechat_redirect" target="_blank" rel="noopener">Flutter 您需要知道的知识点 | FAQ・第五期</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652050376&amp;idx=1&amp;sn=2034b412bb113de7b208e18c3f74508f&amp;chksm=808cb38db7fb3a9b0c9c5d1fcb2d8a746d365c8eeb9ae5d2d4ad9f2ff1496c17c0851ecb26df&amp;mpshare=1&amp;scene=1&amp;srcid=1113xZMxrEdhsqDfbyi6edBg&amp;sharer_sharetime=1573616160182&amp;sharer_shareid=b5535657e3516bd6d7252ce5f5ed09f4&amp;rd2werd=1#wechat_redirect" target="_blank" rel="noopener">Flutter 您需要知道的知识点 | FAQ・第六期</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652050932&amp;idx=1&amp;sn=4284ce654f5ba9365845583cfc674bed&amp;chksm=808cb5b1b7fb3ca7a074b16b027bd3a4c8a79f190cf7b046adcd17e028568fbe5cce59e8ce2e&amp;mpshare=1&amp;scene=1&amp;srcid=1113upVjIoYooOEWY0gf8KPO&amp;sharer_sharetime=1573616174633&amp;sharer_shareid=b5535657e3516bd6d7252ce5f5ed09f4&amp;rd2werd=1#wechat_redirect" target="_blank" rel="noopener">Flutter 您需要知道的知识点 | FAQ・第七期</a></li></ul><p>(谷歌知道大家学不过来，所以将 Flutter 重点知识做成了卡片，让大家好时不时复习巩固一下，早日写出优秀的 Flutter 应用)</p><p>另外，谷歌开发者公众号上的 Flutter 相关的内容汇总在 <code>开发专栏 &gt; 重点知识巩固 &gt; UI框架</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="官方代码"><a href="#官方代码" class="headerlink" title="官方代码"></a>官方代码</h3><blockquote><p>Talk is cheap, show me the code</p></blockquote><p>如果你的学习习惯是多看代码，那么首推官方示例。官方示例分布在不同的仓库中：</p><ul><li><a href="https://github.com/flutter/flutter/tree/master/examples" target="_blank" rel="noopener">官方 examples</a> - 包含若干入门的简单示例</li><li><a href="https://github.com/flutter/samples" target="_blank" rel="noopener">官方 samples</a> - Flutter 最佳实践</li><li><a href="https://github.com/flutter/samples/blob/master/INDEX.md" target="_blank" rel="noopener">A curated list of samples</a> - 嫌上面的例子还不够的话，这个列表中的项目够你看的</li></ul><p>不要小看 <a href="https://github.com/flutter/flutter/tree/master/examples" target="_blank" rel="noopener">官方 examples</a>，它使用最简短的代码演示了最丰富的基础功能，包括：</p><ul><li><strong>Hello, world</strong> 最经典的 “hello, world”，以及一个阿拉伯文版本的 “hello, world” (国际化？Flutter 能行！)</li><li><strong>Image List</strong> 流行的网络图片列表界面 (这个 demo 还顺手写了个简单的 HTTP Sever)</li><li><strong>Flutter gallery</strong> 演示了各种 Widget 的用法</li><li><strong>Platform Channel</strong> 演示了 Flutter 如何跟 Android/iOS 交互 </li></ul><p><a href="https://github.com/flutter/samples" target="_blank" rel="noopener">官方 samples</a> 则演示了 Flutter 高级功能和最佳实践：</p><ul><li><strong>Animations</strong></li><li><strong>Isolate Example</strong></li><li><strong>Provider 状态管理</strong></li></ul><p>官方例子的优势是权威、内容丰富，更新及时，是我们学习的好资料。它的不足则在于往往非常理想化、代码过于”干净”，实际应用常遇到机型兼容问题、产品需求等情况导致”恶心”的代码，例子可以参考，遇到的坑还是要自己一点点填。</p><h3 id="第三方代码"><a href="#第三方代码" class="headerlink" title="第三方代码"></a>第三方代码</h3><blockquote><p>我们的大脑理解抽象内容很吃力，我们喜欢有形的事物。当事物是直接的而且是有形的时候，就显得容易理解。<br>乌尔里希·伯泽尔《有效学习》</p></blockquote><p>很多第三方代码有类似这样的功能，能边看代码边看效果，有助于快速理解 Flutter UI。</p><h2 id="视频和书籍"><a href="#视频和书籍" class="headerlink" title="视频和书籍"></a>视频和书籍</h2><p>如果你的学习习惯是看视频，推荐如下几个视频：</p><ul><li><a href="https://www.youtube.com/watch?v=lkF0TQJO0bA&amp;list=PLjxrf2q8roU23XGwz3Km7sQZFTdB996iG&amp;index=2" target="_blank" rel="noopener">Flutter Widget of the Week</a> - 每个视频在一两分钟内生动形象地演示一个 Widget 的主要功能和用法，适合快速入门 Flutter Widget</li><li><a href="https://www.youtube.com/watch?v=rfagvy5xCW0&amp;list=PLOU2XLYxmsIK0r_D-zWcmJ1plIcDNnRkK&amp;index=4" target="_blank" rel="noopener">The Boring Flutter Dev Show</a></li></ul><p>个人感觉通过视频来学习的缺点是比较费时间，时不时得快进，也很难快速抓住重点，当然 <a href="https://www.youtube.com/watch?v=lkF0TQJO0bA&amp;list=PLjxrf2q8roU23XGwz3Km7sQZFTdB996iG&amp;index=2" target="_blank" rel="noopener">Flutter Widget of the Week</a> 除外 (它已经帮你划好重点)</p><p>如果你的学习习惯是看书，推荐如下几本书：</p><ul><li><a href="https://book.flutterchina.club/" target="_blank" rel="noopener">Flutter 实战</a> 由浅入深的介绍了 Flutter 技术和开发流程。该书包含不仅包含大量示例、图片，还有配套的示例源码，可帮助读者循序渐进的掌握 Flutter 开发技术。<ul><li>入门篇（第1章~第7章）- 常用的组件以及布局</li><li>进阶篇（第8章~第14章）- 事件机制、动画、自定义组件、文件和网络、插件、国际化以及Flutter核心原理</li><li>实例篇 (第15章）- 实现一个简版的 Github APP</li></ul></li></ul><p>如果你还知道其他不错的视频或书籍资源，欢迎在评论中分享出来。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>这里是几篇不错的文章：</p><ul><li><a href="https://renato.athaydes.com/posts/interesting-dart-features.html" target="_blank" rel="noopener">Interesting Features of the Dart Programming Language</a></li><li><a href="https://github.com/yissachar/awesome-dart" target="_blank" rel="noopener">Awesome Dart</a></li><li><a href="https://tech.meituan.com/2018/08/09/waimai-flutter-practice.html" target="_blank" rel="noopener">Flutter原理与实践 - 美团技术团队</a></li><li><a href="https://fucknmb.com/2019/02/26/Flutter-Engine-%E7%BC%96%E8%AF%91%E6%8C%87%E5%8C%97/" target="_blank" rel="noopener">Flutter Engine 编译指北 | 区长</a></li><li><a href="https://www.ccarea.cn/archives/category/flutter" target="_blank" rel="noopener">Flutter – cc’s blog</a></li></ul><h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><p><a href="https://dartpad.dartlang.org/" target="_blank" rel="noopener">DartPad</a> 是学习 Dart 语法和尝试 Dart 语言特性的最佳方式，还可以体验 Dart 核心库（除了 dart:io 库和依赖 dart:io 的库）。</p><p>VS Code 是一个<strong>轻量级</strong>编辑器。我使用它没别的原因，Android Studio 强虽强，笔记本性能有限，资源能省则省！</p><p><a href="https://dartcode.org/" target="_blank" rel="noopener">https://dartcode.org/</a> dart 和 flutter 插件</p><p>Android Studio</p><p>[TODO]</p><h1 id="练习与实践"><a href="#练习与实践" class="headerlink" title="练习与实践"></a>练习与实践</h1><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><blockquote><p>纸上得来终觉浅，绝知此事要…</p></blockquote><p><a href="https://dart.dev/codelabs/dart-cheatsheet" target="_blank" rel="noopener">Dart cheatsheet codelab | Dart</a> - 这个练习用于快速掌握 Dart 语言特性</p><ul><li>默写 demo</li><li>实现 freecodecamp 上的练习</li></ul><p>除了看例子，还可以跟着 Codelabs 动手</p><ul><li><a href="https://dart.dev/codelabs" target="_blank" rel="noopener">Dart Codelabs</a></li><li><a href="https://flutter.dev/docs/codelabs" target="_blank" rel="noopener">Flutter Codelabs</a></li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ul><li>[TODO] 集成和构建。关键问题：so 兼容问题</li><li>从简单页面入手 </li></ul><p>为什么要从简单页面入手？</p><p><a href="https://medium.com/flutter-community/add-flutter-to-existing-android-ios-app-ae8c4fb1582e" target="_blank" rel="noopener">https://medium.com/flutter-community/add-flutter-to-existing-android-ios-app-ae8c4fb1582e</a></p><p><a href="https://tech.meituan.com/2018/08/09/waimai-flutter-practice.html" target="_blank" rel="noopener">Flutter原理与实践 - 美团技术团队</a></p><h1 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h1><p><a href="https://book.flutterchina.club/chapter1/flutter_intro.html" target="_blank" rel="noopener">https://book.flutterchina.club/chapter1/flutter_intro.html</a></p><ul><li>学习 <a href="https://github.com/flutter/flutter/blob/master/dev/tools/dartdoc.dart" target="_blank" rel="noopener">dartdoc.dart 源码</a></li><li>翻译 <a href="#">dart.cn 文档</a> </li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart 的类型系统</title>
      <link href="2019/11/13/dart-type-system/"/>
      <url>2019/11/13/dart-type-system/</url>
      
        <content type="html"><![CDATA[<p>Dart 语法跟 Java 比较类似，类型系统也非常相近，但仍然有一些细节需要注意。</p><a id="more"></a><p>[TOC]</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>以上是一段合法的 Dart 代码。你会误以为 Dart 是动态语言，实际上并非如此。Dart 是强类型的静态语言，它结合使用了静态类型检查和运行时检查。Dart 的聪明之处在于类型推断，所以上述代码中 <code>i</code> 的类型被推断成 <code>int</code>。</p><h1 id="一些-Tips"><a href="#一些-Tips" class="headerlink" title="一些 Tips"></a>一些 Tips</h1><p>静态类型的大多数规则很容易理解，但仍然有些不明显的规则。</p><h2 id="规则一"><a href="#规则一" class="headerlink" title="规则一"></a>规则一</h2><p>覆盖方法时，使用稳定的返回类型。(原文：Use sound return types when overriding methods.) 换句话说，子类方法的返回类型必须与父类中方法的返回类型相同或是其子类。</p><p>考虑 <code>Animal</code> 类中的 <code>getter</code> 方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> chase(Animal a) &#123; ... &#125;</span><br><span class="line">  Animal <span class="keyword">get</span> parent =&gt; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HoneyBadger</code> 继承自 <code>Animal</code>，所以可以用 <code>HoneyBadger</code> 作为 <code>getter</code> 方法的返回类型，但是不能使用一个跟 <code>Animal</code> 不相关的类型作为 <code>getter</code> 方法的返回类型。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoneyBadger</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> chase(Animal a) &#123; ... &#125;</span><br><span class="line">  HoneyBadger <span class="keyword">get</span> parent =&gt; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="规则二"><a href="#规则二" class="headerlink" title="规则二"></a>规则二</h2><p>第二条规则跟前一条规则类似。覆盖方法时，使用稳定的参数类型。(原文：Use sound parameter types when overriding methods)。换句话说，子类方法的返回类型必须与父类中方法的返回类型相同或是其超类。注意，这里是不是”收紧”类型，而是”放宽”类型。</p><p>以 <code>Animal</code> 类的 <code>chase(Animal)</code> 方法为例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> chase(Animal a) &#123; ... &#125;</span><br><span class="line">  Animal <span class="keyword">get</span> parent =&gt; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HoneyBadger</code> 继承自 <code>Animal</code>，它的 <code>chase()</code> 方法可以接受 <code>Animal</code>、<code>HoneyBadger</code> 甚至是 <code>Object</code> 作为参数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoneyBadger</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> chase(<span class="built_in">Object</span> a) &#123; ... &#125;</span><br><span class="line">  Animal <span class="keyword">get</span> parent =&gt; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(官网中对这条规则有解释，但似乎含糊不清。或者是我自己没有弄懂)</p><p>如果不遵守这条规则，会报错：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> chase(Animal a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Error: The parameter 'x' of the method 'Cat.chase' has type 'Mouse', </span></span><br><span class="line">  <span class="comment">// which does not match the corresponding type, 'Animal', </span></span><br><span class="line">  <span class="comment">// in the overridden method, 'Animal.chase'</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Change to a supertype of 'Animal', </span></span><br><span class="line">  <span class="comment">// or, for a covariant parameter, a subtype.</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> chase(Mouse x) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="规则三"><a href="#规则三" class="headerlink" title="规则三"></a>规则三</h2><p>动态列表(dynamic list)可以包含不同种类的内容。但是将动态列表作为一个有类型的列表是错误的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;Cat&gt; foo = &lt;<span class="built_in">dynamic</span>&gt;[Cat()]; <span class="comment">// Error</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Cat&gt; foo2 = &lt;<span class="built_in">dynamic</span>&gt;[Dog)()]; <span class="comment">// Error</span></span><br><span class="line">  <span class="comment">//List&lt;dynamic&gt; bar = &lt;dynamic&gt;[Dog(), Cat()]; // OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h1><p>Dart 的类型推断可以让代码更简洁。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; arguments = &#123;<span class="string">'argA'</span>: <span class="string">'hello'</span>, <span class="string">'argB'</span>: <span class="number">42</span>&#125;;</span><br></pre></td></tr></table></figure><p>使用 <code>var</code> 并让 Dart 推断类型：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arguments = &#123;<span class="string">'argA'</span>: <span class="string">'hello'</span>, <span class="string">'argB'</span>: <span class="number">42</span>&#125;; <span class="comment">// Map&lt;String, Object&gt;</span></span><br></pre></td></tr></table></figure><p>这里给出几个类型推断的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inferred as if you wrote &lt;int&gt;[].</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; listOfInt = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inferred as if you wrote &lt;double&gt;[3.0].</span></span><br><span class="line"><span class="keyword">var</span> listOfDouble = [<span class="number">3.0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inferred as Iterable&lt;int&gt;</span></span><br><span class="line"><span class="keyword">var</span> ints = listOfDouble.map(</span><br><span class="line">  <span class="comment">// 使用向下信息将x推断为double, 使用向上信息将闭包的返回类型推断为int</span></span><br><span class="line">  (x) =&gt; x.toInt());</span><br></pre></td></tr></table></figure><h1 id="类型替换"><a href="#类型替换" class="headerlink" title="类型替换"></a>类型替换</h1><p>覆盖方法时，可能会使用新类型替换旧类型。比如在上述规则一和规则二中，分别替换方法的返回值类型和参数类型。什么时候可以用子类型或超类型替换当前类型？</p><p>从 <strong>生产者</strong> 和 <strong>消费者</strong> 角度进行思考，有助于回答这个问题。</p><ul><li>消费者吸收类型，生产者产生类型 (A consumer absorbs a type and a producer generates a type)</li><li>可以将消费者的类型替换为超类型，将生产者的类型替换为子类型 (You can replace a consumer’s type with a supertype and a producer’s type with a subtype)</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/13/15736105816107.jpg" alt="生产者与消费者"></p><p>上图中 <code>chase()</code> 方法是消费者，所以可以将参数类型替换成超类型。<code>get parent</code> 是生产者，所以可以将返回类型替换成子类型。</p><p>在以下这个例子中，<code>Cat c</code> 是消费者，<code>Cat()</code> 是生产者。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat c = Cat();</span><br></pre></td></tr></table></figure><p>所以可以将消费者类型替换为超类型：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal c = Cat();</span><br></pre></td></tr></table></figure><p>所以也可以将生产者类型替换为子类型：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MaineCoon 是 Cat 的子类</span></span><br><span class="line">Cat c = MaineCoon();</span><br></pre></td></tr></table></figure><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>Dart 在运行时保留了泛型的类型信息。Java 与此不同，它在运行时已擦除类型信息。</p><p>在 Java 中，你可以判断一个对象是否 <code>List</code>，但无法判断一个对象是否 <code>List&lt;String&gt;</code>。Java 中，即便 <code>Cat</code> 是 <code>Animal</code> 的子类，但 <code>List&lt;Cat&gt;</code> 并不是 <code>List&lt;Animal&gt;</code> 的子类型。所以如下 Java 代码是错误的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误: 不兼容的类型: ArrayList&lt;Cat&gt;无法转换为List&lt;Animal&gt;</span></span><br><span class="line">List&lt;Animal&gt; list = <span class="keyword">new</span> ArrayList&lt;Cat&gt;();</span><br></pre></td></tr></table></figure><p>但在 Dart 中，上述限制不存在。<code>List&lt;Cat&gt;</code> 是 <code>List&lt;Animal&gt;</code> 的子类型。<code>List</code> 之间甚至也可以有下图中这样的子类关系。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/13/15736112893532.jpg" alt="List 类型之间的关系"></p><p>在 Dart 中，如下代码可以正常工作：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="built_in">List</span>&lt;Animal&gt; foo = <span class="built_in">List</span>&lt;Cat&gt;();</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>原文见 <a href="https://dart.dev/guides/language/sound-dart" target="_blank" rel="noopener">The Dart type system | Dart</a></li><li>译文见 <a href="http://s0dart0dev.icopy.site/guides/language/sound-dart" target="_blank" rel="noopener">The Dart type system | Dart 中文文档教程</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译) Flutter：不要担心垃圾收集器</title>
      <link href="2019/11/11/flutter-dont-fear-the-garbage-collector/"/>
      <url>2019/11/11/flutter-dont-fear-the-garbage-collector/</url>
      
        <content type="html"><![CDATA[<p>翻译自 <a href="https://medium.com/flutter/flutter-dont-fear-the-garbage-collector-d69b3ff1ca30" target="_blank" rel="noopener">Flutter: Don’t Fear the Garbage Collector - Flutter - Medium</a>。这篇文章简要地说明了 Flutter 垃圾收集器的工作原理，以及它对 Flutter 应用的影响。</p><a id="more"></a><p>本文要点总结如下：</p><ul><li>Dart 运行时支持 JIT 和 AOT 两种不同模式，分别用于 debug 和 release</li><li>Dart 垃圾收集器支持分代回收</li><li>Dart 垃圾收集器新生代清理阶段是阻塞的，但速度比并行标记/并发清理阶段速度要快</li><li>Flutter 引擎通知 Dart 垃圾收集器新生代清理阶段在应用空闲或没有用户交互时工作，减少到 UI 性能影响</li><li>开发者通常不应通过持有对象引用来干预 Dart 垃圾回收</li></ul><p>Flutter 使用 <a href="https://www.dartlang.org/" target="_blank" rel="noopener">Dart</a> 作为开发语言和运行时。Dart 的运行时一开始就支持 debug 模式和 release 模式，但两者之间有很大差异。</p><p>在 debug 模式下，Dart 的大部分模块被加载到设备：包括 Dart 运行时、JIT 编译器/解释器 (Android 下是 JIT 编译器，iOS 下是解释器)、调试服务以及分析服务。而在 release 模式下，JIT/解释器和调试服务被移除，只保留 Dart 运行时，它的体积在 Flutter 应用体积中占大头。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/12/15734765481070.jpg" alt="Debug 模式与 Release 模式"></p><p>Dart 的运行时中包含一个垃圾收集器，它是实例化对象以及对象变得不可达过程中分配和回收内存的必要组件。</p><p>Flutter 应用中会产生大量对象。这些对象在 Stateless Widget 渲染到屏幕时被创建，当应用状态改变或 Widget 不可见时被销毁或重建，大部分 Wiget 对象都是短生命周期。对 UI 复杂的应用来说，可能有数几千个 Widget。</p><p>那么 Flutter 开发者需要担心垃圾收集器吗？Flutter 会非常频繁创建和销毁对象，开发者需要限制这种行为吗？新手 Flutter 开发者创建为一段时间内不会变化的 Widget 创建引用，并且在状态数据保留这些引用以避免 Widget 重建的做法很常见。</p><p><strong>但不要这样做！</strong></p><p>担心 Dart 的垃圾收集器是毫无根据的，因为它有分代回收架构，并且其实现为快速创建和销毁对象优化过。大部分场景下，你应当让 Flutter 引擎自行创建和销毁所有的 Widget。</p><h1 id="Dart-垃圾收集器"><a href="#Dart-垃圾收集器" class="headerlink" title="Dart 垃圾收集器"></a>Dart 垃圾收集器</h1><p>Dart 的垃圾收集器支持分代回收 (<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Generational_GC_(ephemeral_GC" target="_blank" rel="noopener">generational</a>))，垃圾回收由两个阶段组成：新生代清理阶段以及并行标记收集阶段。</p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>为最小化垃圾收集对应用和 UI 性能的影响，垃圾收集器为 Flutter 引擎提供勾子，当引擎检查到应用空闲并且没有用户交互时会通知垃圾收集器开始工作。这可以让垃圾收集器有机会在不影响性能的情况下进行收集。垃圾收集器还可以在空闲期运行滑动压缩(sliding compaction)，减少内存碎片以降低内存占用。</p><h2 id="新生代清理器"><a href="#新生代清理器" class="headerlink" title="新生代清理器"></a>新生代清理器</h2><p>新生代清理器 (Young Space Scavenger)。这个阶段用于清理那短生命周期的临时对象，比如无状态的 Widget。尽管它是阻塞式，但仍然比第二阶段的标记/清理过程快得多，再加上上述的调度策略，实际上消除掉了应用运行期间可感知的暂停。</p><p>分配对象实质上是分配一块连续的内存，对象被创建时会分配到下一块可用的已分配内存空间，直到已分配内存耗尽。Dart 使用 bump pointer allocation 算法在新的空间中快速分配 (原文：Dart uses bump pointer allocation to rapidly allocate in new space, making the process very fast)</p><p>新的内存空间 (或称之为 nursery) 是新对象分配的地方，由两部分组成(也就是 semi spaces)。任何时刻只使用这两部分中的一部分：一部分活跃，则另一部分不活跃。新对象分配在活跃的那部分中，当这一部分被占满时，将仍然存活的对象从活跃部分拷贝到不活跃部分，忽略已死亡的对象。之后不活跃的部分变成活跃部分，如此往复。</p><p>垃圾收集器从根对象开始判断哪些对象存活，哪些对象死亡，比如栈变量 (stack variables) 是一种根对象。垃圾收集器会检查栈变量引用了谁，然后移动这些被引用的对象，之后垃圾收集器又检查被移动的对象指向什么地方，并且继续移动被引用的对象。这个过程一直继续直到所有存活对象被移动。已死亡的对象不被引用，因此被直接丢弃。未来某次垃圾收集过程中存活的对象被拷贝并覆盖掉这些已死亡的对象。</p><p>更多信息请参考 <a href="https://en.wikipedia.org/wiki/Cheney%27s_algorithm" target="_blank" rel="noopener">Cheney’s algorithm</a>。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/12/15734792877537.jpg" alt></p><h2 id="并行标记和并发清理"><a href="#并行标记和并发清理" class="headerlink" title="并行标记和并发清理"></a>并行标记和并发清理</h2><p>当对象到达某个寿命，它们被提升到另一块新的内存空间，该空间由第二代收集器管理：标记清理。</p><p>这个垃圾收集技术有两个阶段：首先遍历对象图并标记仍在使用的对象。在第二个阶段扫描整个内存，回收所有没被标记的对象。之后所有的标记都被清理。</p><p>这种形式的垃圾收集会在标记阶段阻塞；不能进行任何内存操作，UI 线程也被阻塞。这种形式的垃圾收集不像新生代清理器处理短暂对象那样频繁，但 Dart 运行时有时会暂停以执行垃圾收集。考虑到 Flutter 垃圾收集的调度策略 (见上一节)，暂停的影响会被最小化。</p><p>但是要注意如果应用并不遵守弱代假设(原文：the weak generational hypothesis， 这个假设认为大部分对象是短生命周期的)，那么这种形式的垃圾收集会运行得更多。考虑到 Flutter Widget 的工作原理，虽然这种情况的可能性并不大，但要牢记。</p><h1 id="Isolates"><a href="#Isolates" class="headerlink" title="Isolates"></a>Isolates</h1><p>值得注意的是，Dart isolates 拥有自己私有的堆，每个 isolate 堆跟其他 isolate 完全独立。每个 isolate 在独立线程中运行，一个 isolate 上的垃圾收集事件并不影响另外 isolate 的性能。使用 isolate 是避免阻塞 UI 和密集计算压力的好方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此你应该知道：Dart 使用一个强大的分代垃圾收集器来最小化 Flutter 应用中的垃圾收集时的阻塞影响。不要担心垃圾收集器，它已经考虑到应用的最大利益。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter UI 问题分析小结</title>
      <link href="2019/11/01/flutter-customappbar-safearea/"/>
      <url>2019/11/01/flutter-customappbar-safearea/</url>
      
        <content type="html"><![CDATA[<p>我们的 Flutter 项目中自定义 AppBar 时 SafeArea 误用导致出现一个奇怪的 UI 问题。本文从这个问题出发，简单梳理了 Android 和 iOS 平台在 AppBar 视觉规范上的差异，然后使用 Dart DevTools 分析并成功解决问题。</p><a id="more"></a><p>[TOC]</p><h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>最近我们项目接入 Flutter 并重写一些简单页面。项目中很多 Native 页面的 AppBar (为简单起见，本文将 Android 的 ActionBar/Toolbar 以及 iOS 的 Navigation Bar 统称为 AppBar)有类似这样的交互效果，</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/06/ezgif1e54ad03a7341.gif" alt="组队排行榜"></p><p>Flutter 页面也需要实现这种交互。一种做法是 Flutter 页面中保留原有的 Native AppBar，在 Flutter 列表滚动时通过 <code>MethodChannel</code> 通知 Native AppBar 更新其背景。不妨称这个方案为 Native 方案。另外一种做法是隐藏原有 Native AppBar，直接在 Flutter 层实现相同交互。这个方案称为 Flutter 方案。</p><p>显然，Native 方案实现起来较为繁琐，且似乎偏离了 <code>MethodChannel</code> 的合理使用场景。而 Flutter 方案可以避免跟 Native 层不必要的通信，所以我们选择了该方案。</p><h2 id="Flutter-方案"><a href="#Flutter-方案" class="headerlink" title="Flutter 方案"></a>Flutter 方案</h2><p><a href="https://github.com/flutter/flutter/tree/master/examples/flutter_gallery/lib/demo/fortnightly" target="_blank" rel="noopener">FortnightlyDemo</a> (Flutter 官方 example)实现了自定义的 <code>ShortAppBar</code>：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/06/15725848702985.jpg" alt="ShortAppBar -w396"></p><p><code>ShortAppBar</code> 简化后的代码如下。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FortnightlyDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> routeName = <span class="string">'/fortnightly'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Fortnightly Demo'</span>,</span><br><span class="line">      theme: _fortnightlyTheme,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        body: Stack(</span><br><span class="line">          children: &lt;Widget&gt;[ FruitPage(), SafeArea(child: ShortAppBar()),],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortAppBar</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ShortAppBar(&#123; <span class="keyword">this</span>.onBackPressed &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> VoidCallback onBackPressed;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> SizedBox(</span><br><span class="line">      height: <span class="number">56</span>,</span><br><span class="line">      ...</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里一个细节，从视觉效果上来看这里的 <code>ShortAppBar</code> 并没有延伸到 Status Bar 下方，</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/06/15726104959036.jpg" alt="ShortAppBar 没有延伸到 Status Bar 下方"></p><p>参考 <code>ShortAppBar</code> 的代码并加上必要的交互，我很快就实现了 <code>CustomAppBar</code>。<br>而我们项目中要求 <code>CustomAppBar</code> 能延伸 Status Bar 下方。给 <code>SafeArea</code> 套上一个 <code>Container</code> 就可以实现这种效果。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">  color: appBarColor,</span><br><span class="line">  child: SafeArea(child: CustomAppBar())</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/06/15726105059869.jpg" alt="ShortAppBar 延伸到 Status Bar 下方"></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p><code>CustomAppBar</code> 在 Android 上的效果还不错，在 iPhone 7 上也能接受(高度偏大一点点)，但在 iPhone 11 上的实际效果显得很违和了：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/06/15725908638519.jpg" alt="CustomAppBar 在 iPhone 11 上偏高 -w301"></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/06/15725911634410.jpg" alt="CustomAppBar 比原生应用的 AppBar 要高 -w331"></p><p>如上图，<code>CustomAppBar</code> 在 iPhone 11 上比原生应用的 AppBar 严重偏高。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>为什么 <code>CustomAppBar</code> 在 Android 机器上看起来很好，在 iOS (尤其是 iPhone 11)上却严重偏高？</p><p>Flutter 可以在 Android 平台和 iOS 平台上在像素级别无差别地进行绘制，这是它的强大之处。但不容忽视的是，Android 视觉规范天生跟 iOS 有差异，如果不考虑并尊重这些差异而强行无差别绘制，肯定会导致某一端看起来怪怪的。</p><p>所以很显然问题的一个原因是 <code>CustomAppBar</code> 的实现没有考虑平台差异。另一个原因则是 <code>SafeArea</code> 的误用导致 <code>CustomAppBar</code> 进一步偏高。接下来就这两个原因分别展开。</p><h2 id="视觉规范的差异"><a href="#视觉规范的差异" class="headerlink" title="视觉规范的差异"></a>视觉规范的差异</h2><p>首先得承认 Android 和 iOS 视觉上天生存在某些不一致。 (这也是 Flutter 分别提供 material 和 cupertino 风格控件的原因)</p><p>根据 <a href="https://developer.apple.com/design/human-interface-guidelines/ios/bars/navigation-bars/" target="_blank" rel="noopener">iOS Navigation Bar 设计规范</a>，标准的 AppBar 高度是 44pt (不包括 Status Bar)。</p><p>根据 <a href="https://material.io/develop/android/" target="_blank" rel="noopener">Android Material Design 设计规范</a>，Status Bar 高度是 24dp，标准的 AppBar(Action Bar) 高度是 56dp。</p><p><a href="https://github.com/flutterchina/gitme" target="_blank" rel="noopener">Gitme</a> 是用 Flutter 实现的应用，不过它是 Material Design 风格的，在 iOS 上看起来是这样：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/06/15725930597849.jpg" alt="Gitme -w359"></p><p>总觉得哪里怪是不是？没错，这里的 AppBar 太高！</p><p>所以第一个改进就是根据当前系统为 <code>CustomAppBar</code> 选择合适的高度。修改后的示意代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomAppBar</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> CustomAppBar(&#123; <span class="keyword">this</span>.onBackPressed &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> VoidCallback onBackPressed;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> SizedBox(</span><br><span class="line">      height: isAndroid ? <span class="number">56</span> : <span class="number">44</span>,</span><br><span class="line">      ...</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>事实上，Flutter 分别为 material 和 cupertino 提供了符合各自设计规范的 <a href="https://flutter.dev/docs/catalog/samples/basic-app-bar" target="_blank" rel="noopener">AppBar</a> 和 <a href="https://api.flutter.dev/flutter/cupertino/CupertinoNavigationBar-class.html" target="_blank" rel="noopener">CupertinoNavigationBar</a>，以简化应用开发。</p><p>你可能会问，既然有了 AppBar 和 CupertinoNavigationBar，能不能这样处理？</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherCustomAppBar</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isAndroid) &#123;</span><br><span class="line">        <span class="keyword">return</span> AppBar();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isIOS) &#123;</span><br><span class="line">        <span class="keyword">return</span> CupertinoNavigationBar();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AnotherCustomAppBar</code> 理论上更简单优雅，但实践发现有以下问题：</p><ul><li><code>AppBar</code> 的高度是 56dp，而我们Android端应用的规范是 50dp，所以需要调整 <code>AppBar</code> 高度</li><li><code>AppBar</code> 在 Android 端缺并不是沉浸式风格(status bar 和 AppBar 背景色不同)，所以需要对其进行适配</li><li><code>CupertinoNavigationBar</code> 背景色设置成透明仍然会遮挡背景图片 (why?)</li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/06/15730062923455.jpg" alt="Android 上 status bar 有不同背景色 -w295"></p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/06/15725942471237.jpg" alt="iOS 上背景图被 AppBar 遮挡 -w770"></p><p>再考虑到后期可能还会给自定义的 AppBar 添加更多功能，直接使用 Flutter SDK 提供的 <code>AppBar</code> 和 <code>CupertinoNavigationBar</code> 相对不可控，所以放弃了 <code>AnotherCustomAppBar</code> 方案。</p><hr><h2 id="SafeArea-的误用"><a href="#SafeArea-的误用" class="headerlink" title="SafeArea 的误用"></a>SafeArea 的误用</h2><p>视觉规范差异能在一定程度解释 <code>CustomAppBar</code> 在 iOS 上高度过大的问题。但考虑到其实这个差异不太大 (56-44=12，应该只相差12个逻辑单位)，跟视觉上看到的高度偏差有所不符，所以仍然让人疑惑是否存在其他问题。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/06/15725908638519.jpg" alt="AppBar 过高 -w301"></p><p>肉眼感觉这里的 AppBar 怕不止 56pt 吧? 不过肉眼不靠谱，还是上工具实测。</p><h3 id="UI-分析"><a href="#UI-分析" class="headerlink" title="UI 分析"></a>UI 分析</h3><p><a href="https://flutter.dev/docs/development/tools/devtools/overview" target="_blank" rel="noopener">DevTools</a> 是 Dart 和 Flutter 下的性能测试与 bug 调试的工具。它的功能包括：</p><ul><li>检查 Flutter UI 布局</li><li>检查 Flutter app 性能问题</li><li>源码调试</li><li>内存诊断</li></ul><p>我们这里重点关注检查 Flutter UI 布局的功能。用法如下：</p><p>第一步，通过 <code>flutter attach</code> 连上 App 后，从 IDE 打开 DevTools。VS Code 使用 ⇧⌘P 调出如下窗口然后选择 “Open DevTools”</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/06/15725956009978.jpg" alt="Dart DevTools -w629"></p><p>第二步，在打开的浏览器窗口中按以下步骤操作就可以检查目标 Widget。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/06/15725954425771.jpg" alt="Select Widget Mode -w1421"></p><p>我们感兴趣的 Widget 是 <code>CustomAppBar</code>。以下三张图从不同角度近距离观察它。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/06/safeareacustomappbarisok.jpg" alt="CustomAppBar 真实高度"></p><p>图一，从图中可以看出 <code>CustomAppBar</code> 的高度其实没有问题，正是预期中的 44pt (<code>CustomAppBar</code> 高度由 <code>CustomAppBarSize</code> 限制)</p><hr><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/06/15725961591573.jpg" alt="CustomAppBar 可见高度 -w1117"></p><p>图二，从图中可以看出 <code>CustomAppBar</code> 的高度看似偏高很多。</p><ul><li>可以看到红色框中的 <code>SafeArea</code> 为 <code>CustomAppBar</code> 添加了一个不正常的 <code>Padding</code>，bottom padding 为 34</li><li><code>Padding</code> 本身是不可见的，所以通常不会有影响。不过 <code>SafeArea</code> 的父节点是一个可见的 <code>Container</code>，所以看起来 AppBar 偏高</li></ul><hr><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/06/15725963633326.jpg" alt="CustomAppBar 高度受 padding 影响 -w1096"></p><p>图三，图中的 <code>CustomAppBar</code> 的高度正常。</p><ul><li><code>SafeArea</code> 同样为 <code>CustomAppBar</code> 添加了 <code>Padding</code>。不过这一回，bottom padding 为0</li><li><code>SafeArea</code> 的父节点同样是一个可见的 <code>Container</code>，但由于 bottom padding 为0，所以看起来 AppBar 高度正常</li></ul><p>至此可以初步定位到问题跟 <code>SafeArea</code> 有关(我们使用 <code>SafeArea</code> 来适配刘海屏设备)。继续分析前先快速了解下 <a href="https://api.flutter.dev/flutter/widgets/SafeArea-class.html" target="_blank" rel="noopener">SafeArea</a>。如果你熟悉这个 Widget 建议直接略过下一节。</p><h3 id="SafeArea-介绍"><a href="#SafeArea-介绍" class="headerlink" title="SafeArea 介绍"></a>SafeArea 介绍</h3><p>再来说说 SafeArea。iPhone X 首次使用刘海屏，并且屏幕的可显示区域也不再是方方正正的了。这就带来如下一个问题：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/06/15730072986793.jpg" alt="异形屏导致内容显示不全 -w345"></p><p>所以也就有了 SafeArea。这个<a href="https://www.youtube.com/watch?v=lkF0TQJO0bA" target="_blank" rel="noopener">视频</a>简单生动地介绍了  <a href="https://api.flutter.dev/flutter/widgets/SafeArea-class.html" target="_blank" rel="noopener">SafeArea</a>。</p><p><code>SafeArea</code> 的代码很少，所以这里就直接贴上来了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A widget that insets its child by sufficient padding to avoid intrusions by</span></span><br><span class="line"><span class="comment">/// the operating system.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeArea</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Whether to avoid system intrusions on the left.</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> left;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Whether to avoid system intrusions at the top of the screen, typically the</span></span><br><span class="line">  <span class="comment">/// system status bar.</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Whether to avoid system intrusions on the right.</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> right;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Whether to avoid system intrusions on the bottom side of the screen.</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> bottom;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(debugCheckHasMediaQuery(context));</span><br><span class="line">    <span class="keyword">final</span> MediaQueryData data = MediaQuery.of(context);</span><br><span class="line">    EdgeInsets padding = data.padding;</span><br><span class="line">    <span class="comment">// Bottom padding has been consumed - i.e. by the keyboard</span></span><br><span class="line">    <span class="keyword">if</span> (data.padding.bottom == <span class="number">0.0</span> &amp;&amp; data.viewInsets.bottom != <span class="number">0.0</span> &amp;&amp; maintainBottomViewPadding)</span><br><span class="line">      padding = padding.copyWith(bottom: data.viewPadding.bottom);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Padding(</span><br><span class="line">      padding: EdgeInsets.only(</span><br><span class="line">        left: math.max(left ? padding.left : <span class="number">0.0</span>, minimum.left),</span><br><span class="line">        top: math.max(top ? padding.top : <span class="number">0.0</span>, minimum.top),</span><br><span class="line">        right: math.max(right ? padding.right : <span class="number">0.0</span>, minimum.right),</span><br><span class="line">        bottom: math.max(bottom ? padding.bottom : <span class="number">0.0</span>, minimum.bottom),</span><br><span class="line">      ),</span><br><span class="line">      child: MediaQuery.removePadding(</span><br><span class="line">        context: context,</span><br><span class="line">        removeLeft: left,</span><br><span class="line">        removeTop: top,</span><br><span class="line">        removeRight: right,</span><br><span class="line">        removeBottom: bottom,</span><br><span class="line">        child: child,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上来说，<code>SafeArea</code> 会主动为其 child 加上 <code>Padding</code> 以避免 UI 超出屏幕。</p><ul><li><code>SafeArea</code> 的四个属性 <code>left</code>,<code>top</code>,<code>right</code>, <code>bottom</code> 分别用于控制是否对 child 的各个边界做 safe 处理</li><li>需要特别注意的是，<strong>这四个属性默认是 <code>true</code></strong>。</li></ul><h3 id="问题小节"><a href="#问题小节" class="headerlink" title="问题小节"></a>问题小节</h3><p>为了适配 iPhone X 等设备，我们会为 <code>CustomAppBar</code> 给添加 <code>SafeArea</code> 以避免内容显示不全。为了保证 <code>CustomAppBar</code> 能延伸到 Status Bar 下方，又在最外层加上了 <code>Container</code> 。适配代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">  child: SafeArea(</span><br><span class="line">    child: CustomAppBar())</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>SafeArea</code> 底层调用 <code>MediaQuery.of</code> 来构建合理的 <code>Padding</code> 对象。一开始我并没有注意到 <code>MediaQuery.of(context).padding.bottom</code> 的返回值在不同机型上有区别。比如，由于是带圆角的屏幕，在 iPhone 11 上 <code>MediaQuery.of(context).padding.bottom</code> 返回值为 <code>34pt</code>。而在方形屏幕上该值为 <code>0pt</code>。见下图：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/06/15725981523931.jpg" alt="iPhone 11 上 padding.bottom 的返回值 -w908"></p><p>另一方面，我没有注意到 <code>SafeArea.bottom</code> 值默认为 <code>true</code>。所以这里的 <code>padding.bottom</code> 返回的 <code>34pt</code> 被错误地用作 <code>CustomAppBar</code> 的 bottom padding，而最外层带红色背景的 <code>Container</code> 会让 <code>Padding</code> 占据的区域变得可见。</p><p>最终，各种因素的综合影响导致 <code>CustomAppBar</code> 高度看起来严重偏大，如下图：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/2019/11/06/15725908638519.jpg" alt="CustomAppBar 偏高 -w301"></p><p>找到原因后，对代码进行第二个改进：指定 <code>SafeArea.bottom</code> 为 <code>false</code>。至此，问题解决！</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SafeArea(</span><br><span class="line">  bottom: <span class="keyword">false</span>,  </span><br><span class="line">  child: CustomAppBar()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><p><strong>补充</strong>：为什么 <code>CupertinoNavigationBar</code> 不会有高度问题，它是怎么处理的？</p><p>我翻了下源码，果然也是将 <code>bottom</code> 设置为 <code>false</code>。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flutter/packages/flutter/lib/src/cupertino/nav_bar.dart</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> SizedBox(</span><br><span class="line">  height: _kNavBarPersistentHeight + MediaQuery.of(context).padding.top,</span><br><span class="line">  child: SafeArea(</span><br><span class="line">    bottom: <span class="keyword">false</span>,</span><br><span class="line">    child: paddedToolbar,</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>这从另一个角度印证了前面的分析以及解决方法是正确的。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文记录了 Flutter 项目中自定义 AppBar 时遇到的一个 UI 问题。问题主要原因在于：</p><ul><li>Android 和 iOS 视觉规范的差异</li><li><code>SafeArea</code> 的误用</li></ul><p>先从讨论了Android 和 iOS 视觉规范的差异对 Flutter UI 开发可能存在的影响，并使用 <a href="https://flutter.dev/docs/development/tools/devtools/overview" target="_blank" rel="noopener">Dart DevTools</a> 对 <code>SafeArea</code> 误用问题进行分析。</p><p>再梳理了 <code>SafeArea</code> 的误用是如何影响 <code>CustomAppBar</code> 的高度的。</p><ul><li>首先，<code>SafeArea</code> 缺省的 <code>bottom</code> 为 <code>true</code></li><li>第二，iPhone 11 上 <code>MediaQuery.of(context).padding.bottom</code> 返回值为 <code>34pt</code></li><li>最后，<code>Container</code> 导致由 <code>SafeArea</code> 添加的 <code>Padding</code> 占据的区域可见</li></ul><p>基于上述分析对 <code>CustomAppBar</code> 的进行两处改进，</p><ul><li>根据当前系统为 <code>CustomAppBar</code> 选择合适的高度</li><li>确保正确使用 <code>SafeArea</code>，避免产生不正确的可见区域。记住这两点，<ul><li><code>SafeArea</code> 会为内层的 child 添加 <code>Padding</code></li><li><code>SafeArea</code> 外层的 <code>Container</code> 会导致 <code>Padding</code> 占据的区域可见</li></ul></li></ul><p>通过这两处改进，成功解决自定义 AppBar 高度过大的问题，完美适配 iPhone 11。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)为什么我从 Java 迁移到 Dart</title>
      <link href="2019/10/28/why-i-moved-from-java-to-dart/"/>
      <url>2019/10/28/why-i-moved-from-java-to-dart/</url>
      
        <content type="html"><![CDATA[<p>翻译自 <a href="https://hackernoon.com/why-i-moved-from-java-to-dart-8f3802b1d652" target="_blank" rel="noopener">Why I moved from Java to Dart</a></p><a id="more"></a><p>听说有些人是 <a href="https://hackernoon.com/why-i-moved-from-javascript-to-dart-9ff55a108ff4#.ezyej7cdr" target="_blank" rel="noopener">从 Javascript 转到 Dart</a>，而我的经历有些不同：我是从 Java 转到 Dart。并且，我将<a href="http://adwords.google.com/" target="_blank" rel="noopener">adwords.google.com</a> 部分功能用<br>Dart 改写。</p><p>AdWords 是 <a href="https://en.wikipedia.org/wiki/AdWords" target="_blank" rel="noopener">Google 的现金流的核心</a> ，现在正在<a href="http://news.dartlang.org/2016/03/the-new-adwords-ui-uses-dart-we-asked.html" target="_blank" rel="noopener">用 Dart 重写</a>。但 AdWords 中由我负责的一部分，即在 YouTube 中出售可跳过广告，早在 2014 年就是运行在 Dart 上的。</p><p>最有意思的是我们并没有被要求使用 Dart，也没有主动要求使用 Dart。我们看到了 Dart 提供的能力，然后决定尝试一下。</p><p>重要的是，我们并不是完全重写。我们最初使用 <a href="http://www.gwtproject.org/" target="_blank" rel="noopener">Java/GWT</a>，可以在浏览器中将其跟 Dart 集成，以便渐近式地迁移到 Dart。随着我们起来越熟悉 Dart，我们爱上了这门语言。最终我们几乎重写了所有的浏览器代码，从 <a href="http://www.gwtproject.org/" target="_blank" rel="noopener">Java/GWT</a> 迁移到了 Dart。</p><p>以下是我觉得 Dart 优于 Java 的几个原因。</p><h1 id="Dart-SDK"><a href="#Dart-SDK" class="headerlink" title="Dart SDK"></a>Dart SDK</h1><p>你写过很多 Java 代码后最大的抱怨之一可能是 SDK 库。JDK 中一些关键决定发生在若干年前，无法做出改变。你只需要看看 Java 的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html" target="_blank" rel="noopener">Iterable</a> 和 Dart 的 <a href="https://api.dartlang.org/stable/1.21.0/dart-core/Iterable-class.html" target="_blank" rel="noopener">Iterable</a> 有多大不同。</p><p>最 Java 的最好方法是引入第三方库。Google 内部使用 <a href="https://github.com/google/guava" target="_blank" rel="noopener">Guava</a>。这个库非常棒，它提供 <a href="https://google.github.io/guava/releases/19.0/api/docs/com/google/common/collect/FluentIterable.html" target="_blank" rel="noopener">FutureIterable</a>。但这个类并不在 JDK 中，所以它仍然不过是二等公民。</p><p>而 Dart 则有机会重头开始。以下这段 Dart 代码在 Java 中需要借助 <code>FutureIterable</code> 才能实现。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].where((x) =&gt; x.isOdd).map((x) =&gt; x + <span class="number">10</span>));</span><br><span class="line">--&gt;</span><br><span class="line">(<span class="number">11</span>, <span class="number">13</span>)</span><br></pre></td></tr></table></figure><h1 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h1><p>你写了大量 Java/GWT 代码后很可能对 “callback” 有种不自觉的反应。The merest mention brings you out in a cold sweat.</p><p>我个人写过和维护过非常恐怖的嵌套回调代码，用于处理 RPC 链中的各种条件。</p><p>这是一个相对易懂的示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFoo</span><span class="params">(AsyncCallback&lt;List&lt;String&gt;&gt; callback)</span> </span>&#123;</span><br><span class="line">  getThenFilter(<span class="string">"foo"</span>, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getThenFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String parameter,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> AsyncCallback&lt;String&gt; callback)</span> </span>&#123;</span><br><span class="line">  makeRequest(<span class="keyword">new</span> AsyncCallback&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(List&lt;String&gt; values)</span> </span>&#123;</span><br><span class="line">      List&lt;String&gt; filtered = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.startsWith(parameter)) &#123;</span><br><span class="line">          filtered.add(value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      callback.handle(filtered);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dart 提供 <a href="https://api.dartlang.org/stable/1.21.0/dart-async/Future-class.html" target="_blank" rel="noopener">Future</a> 类，并且 SDK 的设计也是围绕这个类展开的，让异步回调变得简单。This is when it immediately became clear Dart was talking to me, personally. 它提供的东西让我的工作变得更轻松：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; getFoo() &#123;</span><br><span class="line">  <span class="keyword">return</span> _getThenFilter(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; _getThenFilter(<span class="built_in">String</span> parameter) &#123;</span><br><span class="line">  <span class="keyword">return</span> makeRequest().then((result) =&gt;</span><br><span class="line">      result.where((string) =&gt; string.startsWith(parameter))</span><br><span class="line">          .toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还不止于此。<code>await/async</code> 关键字让 Dart 中使用 Future 变得更简单。对于可能阻塞的异步代码块，你只要写上 <code>await</code> 关键字即可，剩下的 Dart 帮你处理好。</p><p>使用 <code>await/async</code> 关键字后的代码变得更干净：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; getFoo() &#123;</span><br><span class="line">  <span class="keyword">return</span> _getThenFilter(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; _getThenFilter(<span class="built_in">String</span> parameter) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> unfiltered = <span class="keyword">await</span> makeRequest();</span><br><span class="line">  <span class="keyword">return</span> unfiltered.where(</span><br><span class="line">      (string) =&gt; string.startsWith(parameter)).toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="去掉样本代码"><a href="#去掉样本代码" class="headerlink" title="去掉样本代码"></a>去掉样本代码</h1><p>从 Java 迁移到 Dart 后有如此多的特性让工作更简单：</p><ul><li>缺省的 <code>public</code> 访问修饰符，<code>_</code> 前缀表示 <code>private</code></li><li>集合字面量</li><li>一切皆对象，没有原型类型</li><li>属性。不再需要到处写 <code>get</code> 方法</li><li>级联。一切皆 <code>builder</code></li><li>强类型下的类型推断。局部变量只用写 <code>var</code></li><li>命名构造函数，自动给字段赋值</li><li>字符串操作。多种字符串字面量</li><li>dartfmt。<a href="http://journal.stuffwithstuff.com/2015/09/08/the-hardest-program-ive-ever-written/" target="_blank" rel="noopener"> worries about formatting</a> dartfmt 让你不必再担心代码格式问题</li></ul><h1 id="语言进步"><a href="#语言进步" class="headerlink" title="语言进步"></a>语言进步</h1><p>Dart 语言的进步并不只停留在添加 <code>await/async</code> 关键字。Dart 最近还新加了<a href="http://news.dartlang.org/2016/12/dart-121-generic-method-syntax.html" target="_blank" rel="noopener">泛型方法语法</a>以及非空类型尝试。Dart 的类型系统正在修改成强类型。</p><p>Dart 语言以实用主义方式演进，所有的新特性必须在实际代码中有用。</p><h1 id="面向-Web"><a href="#面向-Web" class="headerlink" title="面向 Web"></a>面向 Web</h1><p>Dart 提供面向 web 的 UI 框架。实际上我们使用过 <a href="https://pub.dartlang.org/packages/web_ui" target="_blank" rel="noopener">Web UI</a>，AngularDart 以及 <a href="https://webdev.dartlang.org/angular" target="_blank" rel="noopener">AngularDart2</a>。它们的相同点是：轻量、类似 HTML 模板。这被证明是构建 UI 的好方式。</p><h1 id="The-Search-for-Immutability"><a href="#The-Search-for-Immutability" class="headerlink" title="The Search for Immutability"></a>The Search for Immutability</h1><p>我个人认为 Dart 最大的问题是对不可变集合以及不可变值的支持。所以我自己花时间写了两个开源库 <a href="https://github.com/google/built_collection.dart" target="_blank" rel="noopener">built_collection</a> 和 <a href="https://github.com/google/built_value.dart" target="_blank" rel="noopener">built_value</a>。</p><p>Dart 可以用来构建大型的关键 web 应用，就像我们在 AdWords 中那样。也可以使用 Flutter 来为 Android 和 iOS 来构建移动应用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)改进 Android Studio 中的构建速度</title>
      <link href="2019/10/28/improving-build-speed-in-android-studio/"/>
      <url>2019/10/28/improving-build-speed-in-android-studio/</url>
      
        <content type="html"><![CDATA[<p>翻译自 <a href="https://medium.com/androiddevelopers/improving-build-speed-in-android-studio-3e1425274837" target="_blank" rel="noopener">Improving build speed in Android Studio - Android Developers - Medium</a>。</p><a id="more"></a><h1 id="改进构建速度"><a href="#改进构建速度" class="headerlink" title="改进构建速度"></a>改进构建速度</h1><p>我们想让你在 Android Studio 中的生产力尽可能高。从之前跟开发者的讨论和调查中我们得知等待构建会降低生产力。</p><p>本文将分享一些用于准确定位影响构建速度的新的分析，以及我们目前在做的工作和你可以怎样防止构建速度变慢。</p><p><em>可能要感谢那些在设置中打开 “data sharing” 以分享其使用过程中的统计数据的那些开发者</em></p><h1 id="度量构建速度的不同方式"><a href="#度量构建速度的不同方式" class="headerlink" title="度量构建速度的不同方式"></a>度量构建速度的不同方式</h1><p>The first thing we did was to create internal benchmarks* using open source projects (SignalAndroid, Tachiyomi, SantaTracker &amp; skeleton of Uber) to measure the build speed impact of various changes to the project (code, resources, manifest etc).</p><p>我们工作的第一步是使用开源项目(<a href="https://github.com/signalapp/Signal-Android/archive/v4.19.1.zip" target="_blank" rel="noopener">SignalAndroid</a>, <a href="https://github.com/inorichi/tachiyomi/archive/014bb2f42634765ae2fec487cf3b8dc779f23f7b.zip" target="_blank" rel="noopener">Tachiyomi</a>, <a href="https://github.com/google/santa-tracker-android" target="_blank" rel="noopener">SantaTracker</a>, <a href="https://github.com/kageiit/android-studio-gradle-test.git" target="_blank" rel="noopener">Uber</a>) 建立内部指标来度量对项目的不同修改对构建速度的影响 (比如修改代码，资源以及 manifest)</p><p>例如，这是修改代码对构建速度的影响指标，它表明过去一段时间构建速度有非常大的提高。</p><p><img src="/images/15722512736229.jpg" alt></p><p>我们也观察了真实世界中的数据，关注升级 Android Gradle 插件前后 debug 构建的速度变化。我们将这个数据作为新版本的实际改进。</p><p>下图显示新版本带来了极大提升，对比 2.3 版本构建时间下降了 50%。</p><p><img src="/images/15722514469463.jpg" alt></p><p>最后看看构建时间随着时间的推移，而不关心 Android Gradle 插件的版本。我们将这个数据作为实际的构建速度。</p><p>If builds are indeed getting faster with each release, and we can see it in our data, why are they still getting slower over time?<br>We dug a little deeper and realized that things happening in our ecosystem are causing build to slow down faster than we can improve.<br>While we knew that project growth — with more code, more resource usage, more language features — was making build slower over time, we also discovered that there are many additional factors beyond our immediate control:</p><p>（那么问题来了，）随着每次新版本发布，如果构建速度真的变快了的话，为什么看到的实际构建速度却逐渐变慢？</p><p>我们深挖了一下，认识到实际的问题在于整个生态中正在发生的情况导致构建速度变慢，这个过程超过了我们的改进速度。</p><p>我们知道随着项目增长，更多的代码、更多的资源以及更多的语言特性，让项目构建速度逐渐变慢。我们还发现有许多额外因素超出我们的直接控制。</p><ul><li>2017 年底 <strong><a href="https://meltdownattack.com/" target="_blank" rel="noopener">Spectre and Meltdown</a></strong> 补丁对新的进程和 I/O 性能有影响，导致 clean builds 变慢 50% 到 140%</li><li><strong>第三方以及自定义 Gradle 插件</strong>：96% 的 Android Studio 开发者使用其他的 Gradle 插件 (一些开发者并没有遵守 <a href="https://developer.android.com/studio/build/optimize-your-build" target="_blank" rel="noopener">新的最佳实践</a>)</li><li>大部分 <strong>注解处理器不是增量式的</strong>，每次修改代码都会全量编译。</li><li><strong>Java 8 的使用</strong>。Java 8 的语言特性会引起 desugaring 过程。我们使用 D8 编译器减少了 desugaring 的影响</li><li><strong>Kotlin 的使用</strong>。Kotlin 的注解处理器(KAPT)也会影响构建性能。我们正在跟 JetBrains 合作来最小化性能影响</li></ul><ul><li>之前列出的那些荐跟真实项目不同，它们不会随着时间增长。测试指标只是模拟变化并且事后撤销，仅仅度量我们插件随时间的变化<br>** 3.3 关注基础工作以便未来的改进 (例如, 命名资源、增量注解器元素、Gradle workers 等等)，所以几乎没有什么性能改进</li></ul><h1 id="我们能做什么"><a href="#我们能做什么" class="headerlink" title="我们能做什么"></a>我们能做什么</h1><h2 id="修复内部流程-amp-持续性能提升"><a href="#修复内部流程-amp-持续性能提升" class="headerlink" title="修复内部流程 &amp; 持续性能提升"></a>修复内部流程 &amp; 持续性能提升</h2><p>我们也承认许多内部来自 Google 提供的功能特性，所以我们改变内部流程以更好及时发现构建性能降低。</p><p>我们让 <a href="https://developer.android.com/studio/build/optimize-your-build#annotation_processors" target="_blank" rel="noopener">annotation processors 支持增量构建</a>。写这篇文章时，Glide、Dagger 以及 Auto Service 都是增量式的，我们正在让其他库也支持增量构建。</p><p>我们在新发布的版本中还引入了更轻量级的 R 类生成方案，以及 lazy task 和 worker API，并继续跟 Gradle inc. 以及 JetBrains 合作来继续从整体上改进构建性能。</p><h2 id="Attribution-tools"><a href="#Attribution-tools" class="headerlink" title="Attribution tools"></a>Attribution tools</h2><p>最近一个调查表明大约 60% 的开发者不会分析构建性能，也不知道如何分析构建性能。因此我们计划改进 Android Studio 中的工具来提升社区中关于项目构建时间的认识和透明度。</p><p>我们正在探索如何直接在 Android Studio 中更好地提供插件和 task 如何影响构建性能的相关信息。</p><h1 id="你能做什么"><a href="#你能做什么" class="headerlink" title="你能做什么"></a>你能做什么</h1><p>configuration 时间因 variant、模块以及其他因素变化，这里分享真实项目中的数据作为参考点。</p><p><img src="/images/15722614003578.jpg" alt></p><p>如果你发现你的项目中 configuration 时间比上图中要慢很多，很可能是某些自定义构建逻辑(或第三方 Gradle 插件)影响了 configuration 时间。</p><h2 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h2><p>Gradle 提供免费的<a href="https://guides.gradle.org/performance/" target="_blank" rel="noopener">工具集</a>用于分析构建。建议你使用 <a href="https://guides.gradle.org/performance/#build_scans" target="_blank" rel="noopener">Gradle scan</a>，它能提供关于构建的许多信息。如果你不能将自己的构建信息上传到 Gradle 服务器，则建议使用 <a href="https://guides.gradle.org/performance/#profile_report" target="_blank" rel="noopener">Gradle profiler</a>。Gradle profiler 能提供的信息要少一些，但不用担心它向服务器上传数据。</p><p>注意：构建扫描并不能用来有效分析 configuration 耗时，建议使用 JVM profiler 来分析 configuration 耗时。</p><h2 id="优化构建配置和任务"><a href="#优化构建配置和任务" class="headerlink" title="优化构建配置和任务"></a>优化构建配置和任务</h2><p>这里有些优化构建速度的最佳实践可供参考。也可以参考 <a href="https://developer.android.com/studio/build/optimize-your-build" target="_blank" rel="noopener">latest best practices</a>。</p><p>配置</p><ul><li>在 configuration 中只建立 task (通过 lazy API)，避免任何 I/O 或其他操作 ( Configuration 不是用于执行 git 操作、读取文件、查询连接设备以其其他计算的)</li><li>在 configuration 中建议所有 task。Configuration 并不知道实际会构建什么</li></ul><p>优化任务</p><ul><li>为每个 task 都声明 inputs/outputs (即使没有任何文件)，以保证任务可增量编译以及可缓存</li><li>将复杂步骤分解成多个任务，以便增量编译和可缓存 (这样可以让某些 task 保持 up-to-date 状态或者并行)</li><li>确保 task 不会写入或删除其他 task 的输出目录</li><li>在 plugin/buildSrc 中添加自己的 task，而不是在 <code>build.gradle</code> 中添加</li></ul><p>我们关心你作为开发者的生产力。我们将继续努力让构建更快速，也希望这些 tips 和 guidelines 能帮你减少构建时间，而你更加专注开发优秀的应用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一个 IllegalArgumentException</title>
      <link href="2019/09/27/kotlin-comparison-method-violates/"/>
      <url>2019/09/27/kotlin-comparison-method-violates/</url>
      
        <content type="html"><![CDATA[<p>记一个诡异的 <code>IllegalArgumentException: Comparison method violates its general contract!</code></p><a id="more"></a><h1 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h1><p>完整的异常日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">09-25 14:17:14.253 7992-8182/com.tencent.ibg.joox E/AndroidRuntime: FATAL EXCEPTION: BitmapProfilerRefQueue</span><br><span class="line">    Process: com.tencent.ibg.joox, PID: 7992</span><br><span class="line">    java.lang.IllegalArgumentException: Comparison method violates its general contract!</span><br><span class="line">        at java.util.TimSort.mergeHi(TimSort.java:882)</span><br><span class="line">        at java.util.TimSort.mergeAt(TimSort.java:499)</span><br><span class="line">        at java.util.TimSort.mergeForceCollapse(TimSort.java:440)</span><br><span class="line">        at java.util.TimSort.sort(TimSort.java:219)</span><br><span class="line">        at java.util.TimSort.sort(TimSort.java:169)</span><br><span class="line">        at java.util.Arrays.sort(Arrays.java:2010)</span><br><span class="line">        at kotlin.collections.ArraysKt___ArraysJvmKt.sortWith(_ArraysJvm.kt:1862)</span><br><span class="line">        at kotlin.collections.CollectionsKt___CollectionsKt.sortedWith(_Collections.kt:947)</span><br><span class="line">        at com.tencent.tip.bitmapprofiler.extension.BitmapTraceCollector.sortBySize(BitmapTraceCollector.kt:227)</span><br></pre></td></tr></table></figure><p><code>BitmapTraceCollector.sortBySize()</code> 的源码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sortBySize</span><span class="params">()</span></span>: List&lt;BitmapTrace&gt; = ArrayList&lt;BitmapTrace&gt;(traces)</span><br><span class="line">        .filter &#123; it.isBitmapAlive() &#125;</span><br><span class="line">        .sortedBy &#123; it.currentBitmapSize() &#125;</span><br><span class="line">        .reversed()</span><br></pre></td></tr></table></figure><p>而 <code>BitmapTrace</code> 类定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapTrace</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">        bitmap: Bitmap,</span><br><span class="line">        queue: ReferenceQueue&lt;Bitmap&gt;?,</span><br><span class="line">        <span class="keyword">val</span> threadName: String,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> exception: Exception,</span><br><span class="line">        <span class="keyword">val</span> createdTime: <span class="built_in">Long</span>,</span><br><span class="line">        <span class="keyword">var</span> destroyedTime: <span class="built_in">Long</span></span><br><span class="line">) : WeakReference&lt;Bitmap&gt;(bitmap, queue) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isBitmapAlive</span><span class="params">()</span></span> = <span class="keyword">get</span>() != <span class="literal">null</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">currentBitmapSize</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="keyword">get</span>()?.allocationByteCount ?: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写个测试来看一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContractTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testContract</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            runTest()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">runTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = <span class="number">500000</span></span><br><span class="line">        <span class="keyword">val</span> rand = Random()</span><br><span class="line">        <span class="keyword">val</span> list = ArrayList&lt;MockBitmapTrace&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..n) &#123;</span><br><span class="line">            list.add(MockBitmapTrace(Bmp(rand.nextInt())))</span><br><span class="line">        &#125;</span><br><span class="line">        list.filter &#123; it.isBitmapAlive() &#125;</span><br><span class="line">                .sortedBy &#123; it.currentBitmapSize() &#125;</span><br><span class="line">                .reversed()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MockBitmapTrace</span></span>(referent: Bmp) : WeakReference&lt;Bmp&gt;(referent) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> allocationByteCount: <span class="built_in">Int</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isBitmapAlive</span><span class="params">()</span></span> = <span class="keyword">get</span>() != <span class="literal">null</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">currentBitmapSize</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="keyword">get</span>()?.allocationByteCount ?: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Bmp</span></span>(<span class="keyword">var</span> allocationByteCount: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>这个测试在一个死循环中跑 <code>runTest()</code>，不过 10s 就出现 <code>Comparison method violates its general contract</code>。</p><p><img src="/images/15695691678423.jpg" alt="-w1035"></p><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>其实 Java 官方文档对这种行为有描述，见 </p><ul><li><a href="https://stackoverflow.com/questions/7849539/comparison-method-violates-its-general-contract-java-7-only" target="_blank" rel="noopener">compareto - Comparison method violates its general contract! Java 7 only - Stack Overflow</a></li><li><a href="https://www.oracle.com/technetwork/java/javase/compatibility-417013.html#source" target="_blank" rel="noopener">Java SE 7 and JDK 7 Compatibility</a></li></ul><p>描述如下：</p><blockquote><p>Area: API: Utilities<br>Synopsis: Updated sort behavior for Arrays and Collections may throw an IllegalArgumentException<br>Description: The sorting algorithm used by java.util.Arrays.sort and (indirectly) by java.util.Collections.sort has been replaced. The new sort implementation may throw an IllegalArgumentException if it detects a Comparable that violates the Comparable contract. The previous implementation silently ignored such a situation.<br>If the previous behavior is desired, you can use the new system property, java.util.Arrays.useLegacyMergeSort, to restore previous mergesort behavior.<br>Nature of Incompatibility: behavioral</p></blockquote><p>简单来说，<code>java.util.Arrays.sort()</code> 和 <code>java.util.Collections.sort()</code> 两个排序方法底层使用的算法有更新。使用这两个方法对数组或集合排序时，如果检查到 <code>Comparable</code> 没有遵守 Comparable contract 时会抛出 <code>IllegalArgumentException</code>。而以前版本中会忽略该异常。可以设置 <code>java.util.Arrays.useLegacyMergeSort</code> 系统属性来切换到以前的不会抛出异常的 <code>mergesort</code>。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>对于标准的 JVM，可以使用以下方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.util.Arrays.useLegacyMergeSort=true</span><br></pre></td></tr></table></figure><p>对于 Android，上述方法不可行。Android SDK <code>java.util.Arrays.sort()</code> 方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Android-changed: LegacyMergeSort is no longer supported</span></span><br><span class="line">    <span class="comment">// if (LegacyMergeSort.userRequested)</span></span><br><span class="line">    <span class="comment">//     legacyMergeSort(a);</span></span><br><span class="line">    <span class="comment">// else</span></span><br><span class="line">        ComparableTimSort.sort(a, <span class="number">0</span>, a.length, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接不支持 LegacyMergeSort !!</p><p>所以只能老老实实分析出问题的代码为什么没有正确的实现 <code>Comparable contract</code>。其实很容易缩小问题范围，是使用 <code>BitmapTrace.currentBimapSize()</code> 的返回值对 BitmapTrace 列表来排序的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sortedBy &#123; it.currentBitmapSize() &#125;</span><br></pre></td></tr></table></figure><p><code>BitmapTrace.currentBimapSize()</code> 方法会不会有问题？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun currentBitmapSize(): Int = get()?.allocationByteCount ?: 0</span><br></pre></td></tr></table></figure><p>不难理解，它的返回值是不稳定的。当前对象是个 <code>WeakReference</code>，这个对象未被回收时 <code>currentBitmapSize()</code> 返回 Bitmap 内存大小，这个对象被回收时返回 0。所以如果排序持续过程足够长，其中发生了 GC，很可能以下描述的这种局面。<a href="https://stackoverflow.com/questions/8327514/comparison-method-violates-its-general-contract" target="_blank" rel="noopener">参考来源</a></p><p>一开始时有三个对象 A, B, C，大小分别如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A: 100</span><br><span class="line">B: 50</span><br><span class="line">C: 20</span><br></pre></td></tr></table></figure><p>这时 <code>A &gt; B</code>, <code>B &gt; C</code>。所以可以断定 <code>A &gt; C</code> 必然成立。由于 GC 导致 A 对象被回收，所以 A, B, C 三个对象大小恰好变成了这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A: 0</span><br><span class="line">B: 50</span><br><span class="line">C: 20</span><br></pre></td></tr></table></figure><p>这里 <code>A &gt; C</code> 不成立了。JVM 一旦检测到这一点，就立即抛出 <code>java.lang.IllegalArgumentException: Comparison method violates its general contract!</code>。(要不要这么严肃???)</p><p>所以解决办法是保证 <code>currentBitmapSize()</code> 返回值是稳定的、不受 GC 影响的。</p><p>测试代码修改如下，使用 <code>oldBitmapSize()</code> 代替原来的 <code>currentBitmapSize()</code>。这个测试跑一下午也没有出现 <code>Comparison method violates its general contract!</code> 异常，问题完美修复！</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContractTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testContract</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            runTest()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">runTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = <span class="number">500000</span></span><br><span class="line">        <span class="keyword">val</span> rand = Random()</span><br><span class="line">        <span class="keyword">val</span> list = ArrayList&lt;MockBitmapTrace&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..n) &#123;</span><br><span class="line">            list.add(MockBitmapTrace(Bmp(rand.nextInt())))</span><br><span class="line">        &#125;</span><br><span class="line">        list.filter &#123; it.isBitmapAlive() &#125;</span><br><span class="line">                <span class="comment">//.sortedBy &#123; it.currentBitmapSize() &#125;</span></span><br><span class="line">                .sortedBy &#123; it.oldBitmapSize() &#125;</span><br><span class="line">                .reversed()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MockBitmapTrace</span></span>(referent: Bmp) : WeakReference&lt;Bmp&gt;(referent) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> allocationByteCount: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isBitmapAlive</span><span class="params">()</span></span> = <span class="keyword">get</span>() != <span class="literal">null</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">currentBitmapSize</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="keyword">get</span>()?.allocationByteCount ?: <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">oldBitmapSize</span><span class="params">()</span></span>: <span class="built_in">Int</span> = allocationByteCount</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Bmp</span></span>(<span class="keyword">var</span> allocationByteCount: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p><a href="https://gist.github.com/410063005/9c95e917eb8557f17621e6adb95d9de8" target="_blank" rel="noopener">测试用例 gist</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 之 RestTemplate</title>
      <link href="2019/08/28/spring-boot-rest-template/"/>
      <url>2019/08/28/spring-boot-rest-template/</url>
      
        <content type="html"><![CDATA[<p>总结 Spring Boot 中 RestTemplate 的用法。</p><a id="more"></a><p>[TOC]</p><h1 id="用法介绍"><a href="#用法介绍" class="headerlink" title="用法介绍"></a>用法介绍</h1><p>Spring Boot 中 RestTemplate 用法很简单。通过如下几行代码就可以很方便地调用 HTTP 服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestTemplateDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RestTemplate r = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        Person person = r.getForObject(</span><br><span class="line">                <span class="string">"http://localhost:3000/api/temp/person.json"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTTP 服务如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; res.send(<span class="string">'Hello World!'</span>))</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/api/temp/person.json'</span>, (req, res) =&gt; res.send(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'cm'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">))</span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 3000!'</span>))</span><br></pre></td></tr></table></figure><p>关于 RestTemplate 用法网上有不少参考文章，所以这里只列出几个要点，不对过多细节赘述。</p><ul><li>HTTP 源 - RestTemplate 默认使用 <code>HttpUrlConnection</code>。可以通过 <code>setRequestFactory()</code> 切换到 <code>Apache HttpComponents</code>、<code>Netty</code> 或 <code>OkHttp</code></li><li>Converter - RestTemplate 默认使用 <code>HttpMessageConverter</code> 将 HTTP 消息转换成 POJO 或者从 POJO转换成HTTP消息。可以通过 <code>setMessageConverters()</code> 注册其他转换器 </li></ul><h1 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h1><p>调试过程中常常需要查看 RestTemplate 请求参数和响应参数。(最近参与开发一个电影票务系统，其中有个功能是使用 RestTemplate 调用第三方票务接口，我不小心将参数传错了导致接口调用失败。排查问题时没有想到先观察 RestTemplate 的 HTTP 请求和响应参数，浪费了不少时间)</p><p>使用 <code>ClientHttpRequestInterceptor</code> 可以非常方便地打印出请求参数与响应参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">formatHeaders</span><span class="params">(MultiValueMap&lt;String, String&gt; headers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> headers.entrySet().stream()</span><br><span class="line">            .map(entry -&gt; &#123;</span><br><span class="line">                List&lt;String&gt; values = entry.getValue();</span><br><span class="line">                <span class="keyword">return</span> entry.getKey() + <span class="string">":"</span> + (values.size() == <span class="number">1</span> ?</span><br><span class="line">                        <span class="string">"\""</span> + values.get(<span class="number">0</span>) + <span class="string">"\""</span> :</span><br><span class="line">                        values.stream().map(s -&gt; <span class="string">"\""</span> + s + <span class="string">"\""</span>).collect(Collectors.joining(<span class="string">", "</span>)));</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect(Collectors.joining(<span class="string">"\n"</span>, <span class="string">"-----\n"</span>, <span class="string">"\n-----"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    RestTemplate r = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    r.setInterceptors(Collections.singletonList(</span><br><span class="line">            <span class="keyword">new</span> ClientHttpRequestInterceptor() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">intercept</span><span class="params">(HttpRequest request, <span class="keyword">byte</span>[] body,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(request.getURI().toString());</span><br><span class="line">                    System.out.println(formatHeaders(request.getHeaders()));</span><br><span class="line">                    ClientHttpResponse rsp = execution.execute(request, body);</span><br><span class="line">                    System.out.println(formatHeaders(rsp.getHeaders()));</span><br><span class="line">                    <span class="keyword">return</span> rsp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求参数和响应参数日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:3000/api/temp/person.json</span><br><span class="line">-----</span><br><span class="line">Accept:&quot;text/plain, application/json, application/*+json, */*&quot;</span><br><span class="line">Content-Length:&quot;0&quot;</span><br><span class="line">-----</span><br><span class="line">-----</span><br><span class="line">X-Powered-By:&quot;Express&quot;</span><br><span class="line">Content-Type:&quot;application/json; charset=utf-8&quot;</span><br><span class="line">Content-Length:&quot;22&quot;</span><br><span class="line">ETag:&quot;W/&quot;16-ThD5gkGvRvX3v6wW+dfzNjgw6VA&quot;&quot;</span><br><span class="line">Date:&quot;Wed, 28 Aug 2019 09:49:19 GMT&quot;</span><br><span class="line">Connection:&quot;keep-alive&quot;</span><br><span class="line">-----</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/27a82c494413" target="_blank" rel="noopener">Springboot – 用更优雅的方式发HTTP请求(RestTemplate详解) - 简书</a></li><li><a href="https://blog.csdn.net/yanchangyufan/article/details/82821029" target="_blank" rel="noopener">Spring RestTemplate 利用拦截器打印请求参数和返回状态 - yanchangyufan的专栏 - CSDN博客</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter Sample 解析</title>
      <link href="2019/08/20/flutter-examples/"/>
      <url>2019/08/20/flutter-examples/</url>
      
        <content type="html"><![CDATA[<p>简单看了下 Flutter 源码中的例子，flutter_gallery。<br><a id="more"></a><br><a href="https://github.com/flutter/flutter/tree/master/examples/flutter_gallery" target="_blank" rel="noopener">flutter_gallery</a> 是学习 Flutter 的好例子。</p><hr><h1 id="SizedBox"><a href="#SizedBox" class="headerlink" title="SizedBox"></a>SizedBox</h1><p>例子中多处用到 <a href="https://api.flutter.dev/flutter/widgets/SizedBox-class.html" target="_blank" rel="noopener">SizedBox</a>。</p><blockquote><p>A box with a specified size.</p></blockquote><blockquote><p>If given a child, this widget forces its child to have a specific width and/or height (assuming values are permitted by this widget’s parent). If either the width or height is null, this widget will size itself to match the child’s size in that dimension.</p></blockquote><blockquote><p>If not given a child, SizedBox will try to size itself as close to the specified height and width as possible given the parent’s constraints. If height or width is null or unspecified, it will be treated as zero.</p></blockquote><p>这个控件中如果不指定子控件，则类似于 android 中的 <a href="https://developer.android.com/reference/android/widget/Space" target="_blank" rel="noopener">android.view.Space</a> 用于占位。</p><p>这个控件中如果指定子控件，则强制子控件大小跟当前控件一致。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SizedBox(</span><br><span class="line">  width: <span class="number">200.0</span>,</span><br><span class="line">  height: <span class="number">300.0</span>,</span><br><span class="line">  child: <span class="keyword">const</span> Card(child: Text(<span class="string">'Hello World!'</span>)),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_33716154/article/details/88017225" target="_blank" rel="noopener">Flutter之SizedBox学习使用 - weixin_33716154的博客 - CSDN博客</a></p><h1 id="mainAxisAlignment-和-crossAxisAlignment"><a href="#mainAxisAlignment-和-crossAxisAlignment" class="headerlink" title="mainAxisAlignment 和 crossAxisAlignment"></a>mainAxisAlignment 和 crossAxisAlignment</h1><p>Row 和 Column 控件中经常会看到 <a href="https://flutter.dev/docs/development/ui/layout" target="_blank" rel="noopener">mainAxisAlignment</a> 和 <code>crossAxisAlignment</code> 两个属性。<code>mainAxisAlignment</code> 是主轴，<code>crossAxisAlignment</code> 是交叉轴。具体来说，</p><ul><li>对于 Row，<code>mainAxisAlignment</code> 是横轴，<code>crossAxisAlignment</code> 是纵轴</li><li>对于 Column，<code>mainAxisAlignment</code> 是纵轴，<code>crossAxisAlignment</code> 是横轴</li></ul><blockquote><p>You control how a row or column aligns its children using the mainAxisAlignment and crossAxisAlignment properties. For a row, the main axis runs horizontally and the cross axis runs vertically. For a column, the main axis runs vertically and the cross axis runs horizontally.</p></blockquote><p><img src="row-diagram.png" alt></p><ul><li><a href="https://blog.csdn.net/yuzhiqiang_1993/article/details/86496145" target="_blank" rel="noopener">Flutter中MainAxisAlignment和CrossAxisAlignment详解 - 喻志强的博客 - CSDN博客</a></li><li><a href="https://blog.csdn.net/hekaiyou/article/details/70849178" target="_blank" rel="noopener">Flutter进阶—垂直和水平布局 - 咖啡花园 - CSDN博客</a></li><li><a href="https://stackoverflow.com/questions/53850149/flutter-crossaxisalignment-vs-mainaxisalignment" target="_blank" rel="noopener">Flutter crossAxisAlignment vs mainAxisAlignment - Stack Overflow</a></li></ul><h1 id="图标居中的技巧"><a href="#图标居中的技巧" class="headerlink" title="图标居中的技巧"></a>图标居中的技巧</h1><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">  width: <span class="number">56.0</span>,</span><br><span class="line">  height: <span class="number">56.0</span>,</span><br><span class="line">  alignment: Alignment.center,</span><br><span class="line">  child: Icon(</span><br><span class="line">    demo.icon,</span><br><span class="line">    size: <span class="number">24.0</span>,</span><br><span class="line">    color: isDark ? Colors.white : _kFlutterBlue,</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 踩坑记之集成 Flutter 到 Android 工程</title>
      <link href="2019/08/15/add-flutter-to-existing-apps/"/>
      <url>2019/08/15/add-flutter-to-existing-apps/</url>
      
        <content type="html"><![CDATA[<p>不得不说 Flutter v1.7 仍然没有足够稳定，个人感觉玩玩 demo 还行，集成到已有工程项目仍然各种奇怪的坑。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>你可能会反驳我的观点，不是很产品都已经开始在发布产品中使用 Flutter 了吗，怎么到了你这里就不成熟稳定。</p><p>的确，已经不少产品使用 Flutter，我非常佩服这些将 Flutter 用于正式产品的团队，一是这得是踩过了多少坑，二是他们为后来人积累了不少宝贵经验。但我作为 Flutter 新手却仍然会轻易踩到一些坑，有些坑可能是 Flutter 代码 bug，有些坑仅仅只是 Flutter 文档更新不及时而已。这里举两个例子。</p><h2 id="不存在的-flutter-build-aar-命令"><a href="#不存在的-flutter-build-aar-命令" class="headerlink" title="不存在的 flutter build aar 命令"></a>不存在的 <code>flutter build aar</code> 命令</h2><p><a href="https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps" target="_blank" rel="noopener">Add Flutter to existing apps · flutter/flutter Wiki</a> 是关于如何向已有 Android 工程集成 Flutter 的官方文档。</p><p>截图显示该文档6天前更新。今天是 2019-08-15，所以文档最后编辑日期是 2019-08-09，可以认为它已经足够新了。</p><p><img src="/images/15658346775705.jpg" alt="-w949"></p><p>文档中提到两种集成 Flutter 至现有 Android 工程的方式。方式一是将 Flutter 模块编译成 aar 文件，作为 Android 工程的依赖。文档中给出的编译命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd some/path/my_flutter</span><br><span class="line">$ flutter build aar</span><br></pre></td></tr></table></figure><p>我的 Flutter 版本如下(已是目前最新)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  flutter git:(stable) flutter --version</span><br><span class="line">Flutter 1.7.8+hotfix.4 • channel stable • https://github.com/flutter/flutter.git</span><br><span class="line">Framework • revision 20e59316b8 (4 weeks ago) • 2019-07-18 20:04:33 -0700</span><br><span class="line">Engine • revision fee001c93f</span><br><span class="line">Tools • Dart 2.4.0</span><br></pre></td></tr></table></figure><p>但是我本地的 Flutter 运行 <code>flutter build aar</code> 后提示根本就不支持 aar 子命令！当前可支持的子命令如下：</p><p><img src="/images/15658350152128.jpg" alt="-w885"></p><p>推测这是一处文档错误。</p><h2 id="可笑的-libflutter-so-加载失败问题"><a href="#可笑的-libflutter-so-加载失败问题" class="headerlink" title="可笑的 libflutter.so 加载失败问题"></a>可笑的 <code>libflutter.so</code> 加载失败问题</h2><p>Flutter 另一个极坑的问题是由于某种原因加载不到 <code>libflutter.so</code> 导致应用崩溃。关于这个问题的 issue 超级多，随便就能搜出一大堆，比如 <a href="https://github.com/azihsoyn/flutter_mlkit/issues/36" target="_blank" rel="noopener">issue#36</a>。官方给出的理由不少理由说这个问题不是问题，但我认为它大大减少了 Flutter 的易用性。</p><p>加载 <code>libflutter.so</code> 失败的原因有很多种。这里只分析原工程中存在 <code>jniLibs/armeabi</code> 目录导致 <code>libflutter.so</code> 压根没有打包到的 APK 的情形，简单总结如下：</p><p>早期的安卓普通是 armeabi 架构，而目前普遍是 armeabi-v7a 架构，可简单理解为 <strong>armeabi 架构已废弃</strong>。所以 APK 推荐使用 <code>jniLibs/armeabi-v7a</code> 目录来放 so 库，而不是放在 <code>jniLibs/armeabi</code> 目录中 。不过由于 armeabi-v7a 是兼容 armeabi 的，所以虽然很多老旧项目将 so 放在 <code>jniLibs/armeabi</code> 运行时其实也不会有问题。</p><p>但是由于 Flutter 官方只提供了四种 CPU 架构的 so 库：armeabi-v7a、arm64-v8a、x86 和 x86-64，这就会导致旧的 Android 项目中集成 Flutter 时出问题。问题就是，很可能压根就没将 <code>libflutter.so</code> 打包到 APK！</p><h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><h2 id="坑一：找不到-include-flutter-groovy-脚本"><a href="#坑一：找不到-include-flutter-groovy-脚本" class="headerlink" title="坑一：找不到 include_flutter.groovy 脚本"></a>坑一：找不到 <code>include_flutter.groovy</code> 脚本</h2><p>严格来说这个坑是我自己的问题，没有注意到项目目录结构。</p><p><a href="https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps" target="_blank" rel="noopener">Add Flutter to existing apps · flutter/flutter Wiki</a> 使用如下命令在 <code>some/path/my_flutter</code> 中生成 Flutter 模块，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd some/path/</span><br><span class="line">$ flutter create -t module --org com.example my_flutter</span><br></pre></td></tr></table></figure><p>在原有 Android 项目的 app 模块中添加如下配置用于集成 Flutter：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// MyApp/settings.gradle</span><br><span class="line">include &apos;:app&apos;                                     // assumed existing content</span><br><span class="line">setBinding(new Binding([gradle: this]))                                 // new</span><br><span class="line">evaluate(new File(                                                      // new</span><br><span class="line">  settingsDir.parentFile,                                               // new</span><br><span class="line">  &apos;my_flutter/.android/include_flutter.groovy&apos;                          // new</span><br><span class="line">))                                                                      // new</span><br></pre></td></tr></table></figure><p>一开始的我的 <code>my_flutter</code> 模块目录结构是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">some/path/</span><br><span class="line">  |--- MyApp</span><br><span class="line">       |--- setting.gradle</span><br><span class="line">       |--- build.gradle</span><br><span class="line">       |--- my_flutter</span><br><span class="line">       |--- app</span><br><span class="line">             |--- build.gradle</span><br></pre></td></tr></table></figure><p>提示找不到 <code>include_flutter.groovy</code>，发现是目录不正确。</p><p><strong>建议将 <code>my_flutter</code> 跟 Android 根项目平级，而不是作为其子目录</strong>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">some/path/</span><br><span class="line">  |--- my_flutter</span><br><span class="line">  |--- MyApp</span><br><span class="line">       |--- setting.gradle</span><br><span class="line">       |--- build.gradle</span><br><span class="line">       |--- app</span><br><span class="line">             |--- build.gradle</span><br></pre></td></tr></table></figure><h2 id="坑二：-加载-libflutter-so-失败"><a href="#坑二：-加载-libflutter-so-失败" class="headerlink" title="坑二： 加载 libflutter.so 失败"></a>坑二： 加载 libflutter.so 失败</h2><p>前面说到我在老项目中集成 Flutter 时遇到没将 <code>libflutter.so</code> 打包到 APK 的问题，网上找到不少解决办法：</p><ul><li><a href="https://juejin.im/post/5c3444116fb9a049e6606bc4" target="_blank" rel="noopener">Flutter杂症</a>  </li><li><a href="https://tech.meituan.com/2018/08/09/waimai-flutter-practice.html" target="_blank" rel="noopener">Flutter原理与实践</a></li><li><a href="https://fucknmb.com/2019/02/26/Flutter-Engine-%E7%BC%96%E8%AF%91%E6%8C%87%E5%8C%97/" target="_blank" rel="noopener">Flutter Engine 编译指北 | 区长</a></li></ul><p>我嫌以上方法都太麻烦，就用了一种简单粗暴且有效的办法：找到 <code>libflutter.so</code> 放在项目的 <code>jniLibs/armeabi</code> 目录。(当然，开发中确实有效，但实际上 Flutter 为 debug, release 以及 profile 三种模式提供不同版本的 <code>libflutter.so</code>，所以这种做法在发布时是不可取的)</p><p>另外我尝试将 <code>armeabi</code> 目录重命名为 <code>armeabi-v7a</code> 并将 <code>abiFilters &quot;armeabi&quot;</code> 修改 <code>abiFilters &quot;armeabi-v7a&quot;</code>也能保证将 <code>libflutter.so</code> 打包到 APK 中。</p><h2 id="坑三-无法启动-Dart-VM"><a href="#坑三-无法启动-Dart-VM" class="headerlink" title="坑三 无法启动 Dart VM"></a>坑三 无法启动 Dart VM</h2><p>解决上面的坑之后，debug 包不再报找不到 <code>libflutter.so</code> 了。但是遇到类似如下的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-06-24 11:08:24.366 30834-30834/com.alarmnet.tc2 E/flutter: [ERROR:flutter/runtime/dart_vm_data.cc(19)] VM snapshot invalid and could not be inferred from settings.</span><br><span class="line">2019-06-24 11:08:24.366 30834-30834/com.alarmnet.tc2 E/flutter: [ERROR:flutter/runtime/dart_vm.cc(241)] Could not setup VM data to bootstrap the VM from.</span><br><span class="line">2019-06-24 11:08:24.366 30834-30834/com.alarmnet.tc2 E/flutter: [ERROR:flutter/runtime/dart_vm_lifecycle.cc(89)] Could not create Dart VM instance.</span><br><span class="line">2019-06-24 11:08:24.366 30834-30834/com.alarmnet.tc2 A/flutter: [FATAL:flutter/shell/common/shell.cc(218)] Check failed: vm. Must be able to initialize the VM.</span><br><span class="line">2019-06-24 11:08:24.368 30834-30834/com.alarmnet.tc2 A/libc: Fatal signal 6 (SIGABRT), code -6 in tid 30834 (om.alarmnet.tc2)</span><br></pre></td></tr></table></figure><p>一头雾水。通过对比 Android 项目中集成 Flutter 模块生成的 debug APK，以及纯 Flutter 项目生成的 debug APK，发现前者中缺少 <code>assets/flutter_assets</code>。</p><p>原来是因为打包时 <code>assets/flutter_assets</code> 丢失导致 dart 虚拟机无法启动。简单办法也简单，<code>my_flutter</code> 模块是可以直接编译的，它生成的中间文件中包含 <code>flutter_assets</code>，拷贝一份放在 <code>MyApp/app</code> 模块的 <code>assets</code> 中即可。</p><p>(注：<code>assets/flutter_assets</code> 丢失的根本原因是 <code>flutter:copyFlutterAssetsDebug</code> 任务没有正确运行，原因不详)</p><p>解决上面的坑之后，终于成功将 Flutter 集成到 debug APK 中并成功运行。</p><p>(注：虽然成功但很失望，因为 debug 模式下 Flutter 的性能明显太低。另外，手动拷贝 <code>flutter_assets</code> 目录在发布产品时是不可行的)</p><hr><p>试着编个 release APK 包玩一下，又遇到另一个无法启动 Dart VM 的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-08-16 18:22:46.093 32010-32010/? A/flutter: [FATAL:flutter/runtime/dart_vm.cc(380)] Error while initializing the Dart VM: Precompiled runtime requires a precompiled snapshot</span><br><span class="line">2019-08-16 18:22:46.179 32092-32092/? A/DEBUG: Abort message: &apos;[FATAL:flutter/runtime/dart_vm.cc(380)] Error while initializing the Dart VM: Precompiled runtime requires a precompiled snapshot</span><br></pre></td></tr></table></figure><p>欲哭无泪。</p><p>(未完待续。问题还没解决，但怕自己拖延，所以还是先发出来)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记 Java DataInputStream.readUTF() 的一个小坑</title>
      <link href="2019/07/18/java-datainputstream-readutf/"/>
      <url>2019/07/18/java-datainputstream-readutf/</url>
      
        <content type="html"><![CDATA[<p>记录今天遇到的 <code>DataInputStream.readUTF()</code> 的一个小坑。<br><a id="more"></a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>最近在看 Flutter 和 Dart。感觉 Dart 上手应该比较容易，所以准备动手写 Dart 代码 (Dart Socket) 访问我们 app 后台接口的。但考虑到实际后台接口是使用私有的协议，其中的数据变换和加解密会带来一些不必要的工作，不易快速实现，所以我自己写了个简单的 Java Server (Java 是我最熟悉的，写起来快) 来验证 Dart Client。说是 Server，其实就是简单地接收 Client 发来的字符串，转换成大写形式，然后发送给 Client。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ExecutorService e = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">        ss.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">6760</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Server started at port 6760"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            e.execute(<span class="keyword">new</span> ClientHandler(ss.accept()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> DataInputStream input;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> DataOutputStream output;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ClientHandler</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">            input = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line">            output = <span class="keyword">new</span> DataOutputStream((socket.getOutputStream()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"A client coming "</span> + socket.getInetAddress() + <span class="string">":"</span> + socket.getPort());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String echo = input.readUTF();</span><br><span class="line">                System.out.println(<span class="string">"Client said: "</span> + echo);</span><br><span class="line">                output.writeUTF(echo.toUpperCase());</span><br><span class="line">                output.flush();</span><br><span class="line">                System.out.println(<span class="string">"Server said: "</span> + echo.toUpperCase());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close(input);</span><br><span class="line">                close(output);</span><br><span class="line">                close(socket);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"This client has leave "</span> + socket.getInetAddress() + <span class="string">":"</span> + socket.getPort());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable closeable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                closeable.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再用 Dart 写一个 Client (参考自 <a href="https://stackoverflow.com/questions/54481818/how-to-connect-flutter-app-to-tcp-socket-server" target="_blank" rel="noopener">Stack Overflow</a>)。代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  Socket socket = <span class="keyword">await</span> Socket.connect(<span class="string">'127.0.0.1'</span>, <span class="number">6760</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'connected'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// listen to the received data event stream</span></span><br><span class="line">  socket.listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; event) &#123;</span><br><span class="line">    <span class="built_in">print</span>(event);</span><br><span class="line">    <span class="built_in">print</span>(utf8.decode(event));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send hello</span></span><br><span class="line">  socket.add(utf8.encode(<span class="string">'hello'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait 5 seconds</span></span><br><span class="line">  <span class="keyword">await</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .. and close the socket</span></span><br><span class="line">  socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来也不难，无奈调试发现一个奇怪的问题： Server 端可以看到 Client 端连上来，但死活收不到数据，阻塞在 <code>String echo = input.readUTF()</code> 这里。</p><p>毫无头绪，于用 Java 写个类似的 Client 验证， Server 和 Client 之间收发数据完全正常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket s = <span class="keyword">new</span> Socket();</span><br><span class="line"></span><br><span class="line">        s.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">6760</span>));</span><br><span class="line"></span><br><span class="line">        DataInputStream input = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(s.getInputStream()));</span><br><span class="line">        DataOutputStream output = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(s.getOutputStream()));</span><br><span class="line"></span><br><span class="line">        output.writeUTF(<span class="string">"hello"</span>);</span><br><span class="line">        output.flush();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"received: "</span> + input.readUTF());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        close(input);</span><br><span class="line">        close(output);</span><br><span class="line">        close(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable closeable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                closeable.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排查问题各种折腾偶然发现另一个现象：Dart Client 打印出 Java Server 发送的数据时有一个多出来的乱码。</p><p>Java Server 使用 <code>DataOutputStream.writeUTF()</code> 发送数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output.writeUTF(<span class="string">"HELLO"</span>);</span><br><span class="line">output.flush();</span><br></pre></td></tr></table></figure><p>Dart Client 使用 <code>socket.listen()</code> 接收数据并打印：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socket.listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; event) &#123;</span><br><span class="line">  <span class="built_in">print</span>(utf8.decode(event)); <span class="comment">// HELLO 前面有一个乱码</span></span><br><span class="line">  <span class="built_in">print</span>(event);              <span class="comment">// [0, 5, 72, 69, 76, 76, 79]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/15634533594124.jpg" alt="-w446"></p><p><code>event</code> 是 <code>List&lt;int&gt;</code>，其中后面几个数字容易理解，就是 “HELLO” 对应的 ASCII 码。<strong>那 <code>0</code> 和 <code>5</code> 又是什么？</strong></p><h1 id="readUTF-和-writeUTF"><a href="#readUTF-和-writeUTF" class="headerlink" title="readUTF() 和 writeUTF()"></a>readUTF() 和 writeUTF()</h1><p>基于这两个现象，</p><ul><li>Java Client 和 Java Server 可以正常通信，Dart Client 就不行</li><li><code>DataOutputStream.writeUTF()</code> 发送的数据会多出一些字节</li></ul><p>我看了下 <code>DataOutputStream.writeUTF()</code> 的文档和代码。(其实稍加仔细看下文档就能明白问题所在了)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes a string to the underlying output stream using</span></span><br><span class="line"><span class="comment"> * &lt;a href="DataInput.html#modified-utf-8"&gt;modified UTF-8&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * encoding in a machine-independent manner.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * First, two bytes are written to the output stream as if by the</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;writeShort&lt;/code&gt; method giving the number of bytes to</span></span><br><span class="line"><span class="comment"> * follow. This value is the number of bytes actually written out,</span></span><br><span class="line"><span class="comment"> * not the length of the string. Following the length, each character</span></span><br><span class="line"><span class="comment"> * of the string is output, in sequence, using the modified UTF-8 encoding</span></span><br><span class="line"><span class="comment"> * for the character. If no exception is thrown, the counter</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;written&lt;/code&gt; is incremented by the total number of</span></span><br><span class="line"><span class="comment"> * bytes written to the output stream. This will be at least two</span></span><br><span class="line"><span class="comment"> * plus the length of &lt;code&gt;str&lt;/code&gt;, and at most two plus</span></span><br><span class="line"><span class="comment"> * thrice the length of &lt;code&gt;str&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      str   a string to be written.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  IOException  if an I/O error occurs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeUTF</span><span class="params">(String str)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writeUTF(str, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">writeUTF</span><span class="params">(String str, DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> strlen = str.length();</span><br><span class="line">    <span class="keyword">int</span> utflen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c, count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    out.write(bytearr, <span class="number">0</span>, utflen+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> utflen + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * See the general contract of the &lt;code&gt;readUTF&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * method of &lt;code&gt;DataInput&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Bytes</span></span><br><span class="line"><span class="comment"> * for this operation are read from the contained</span></span><br><span class="line"><span class="comment"> * input stream.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>     a Unicode string.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  EOFException  if this input stream reaches the end before</span></span><br><span class="line"><span class="comment"> *               reading all the bytes.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  IOException   the stream has been closed and the contained</span></span><br><span class="line"><span class="comment"> *             input stream does not support reading after close, or</span></span><br><span class="line"><span class="comment"> *             another I/O error occurs.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  UTFDataFormatException if the bytes do not represent a valid</span></span><br><span class="line"><span class="comment"> *             modified UTF-8 encoding of a string.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        java.io.DataInputStream#readUTF(java.io.DataInput)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">readUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readUTF(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads from the</span></span><br><span class="line"><span class="comment"> * stream &lt;code&gt;in&lt;/code&gt; a representation</span></span><br><span class="line"><span class="comment"> * of a Unicode  character string encoded in</span></span><br><span class="line"><span class="comment"> * &lt;a href="DataInput.html#modified-utf-8"&gt;modified UTF-8&lt;/a&gt; format;</span></span><br><span class="line"><span class="comment"> * this string of characters is then returned as a &lt;code&gt;String&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> * The details of the modified UTF-8 representation</span></span><br><span class="line"><span class="comment"> * are  exactly the same as for the &lt;code&gt;readUTF&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * method of &lt;code&gt;DataInput&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      in   a data input stream.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>     a Unicode string.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  EOFException            if the input stream reaches the end</span></span><br><span class="line"><span class="comment"> *               before all the bytes.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  IOException   the stream has been closed and the contained</span></span><br><span class="line"><span class="comment"> *             input stream does not support reading after close, or</span></span><br><span class="line"><span class="comment"> *             another I/O error occurs.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  UTFDataFormatException  if the bytes do not represent a</span></span><br><span class="line"><span class="comment"> *               valid modified UTF-8 encoding of a Unicode string.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        java.io.DataInputStream#readUnsignedShort()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String <span class="title">readUTF</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> utflen = in.readUnsignedShort();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文档明确提到：</p><ul><li><code>DataOutputStream.writeUTF()</code> 和 <code>DataInputStream.readUTF()</code> 实际发送/接收的并不是 UTF-8 编码数据，而是一个修改过的 UTF-8 <a href="https://stackoverflow.com/questions/7921016/what-does-it-mean-to-say-java-modified-utf-8-encoding" target="_blank" rel="noopener">参考</a></li><li>更要命的是，<code>writeUTF()</code> 发送实际 UTF-8 前先会以 “UnsignedShort” 形式发送其长度，占两个字节</li></ul><p>第2点会导致几个问题：</p><ul><li><code>writeUTF(str)</code> 的返回值并不是 UTF-8 的长度，而是 UTF-8 的长度再加上 2</li><li><code>readUTF()</code> 跟 <code>writeUTF()</code> 配合使用不会有问题，因为 <code>readUTF()</code> 会先调用 <code>readUnsignedShort()</code> 读取 UTF-8 的长度 (不妨为 utflen)，然后再读取 utflen 个字节</li><li>如果不是使用 <code>readUTF()</code> 读取数据，而是其他方法，就要小心了。至于其他编程语言，就更要小心了！</li></ul><p>说到这里，就不难理解 <code>0</code> 和 <code>5</code> 是怎么来的了。简单描述一下。</p><ul><li>Java Server 调用 <code>DataOutputStream.writeUTF()</code> 发送 “HELLO”</li><li>“HELLO” 的 UTF-8 形式为 [72, 69, 76, 76, 79]</li><li>不过实际发送时还要考虑 UTF-8 的长度，所以发送的是 [0, 5, 72, 69, 76, 76, 79]</li><li>Dart Client 收到 [0, 5, 72, 69, 76, 76, 79]</li><li>Dart Client 解码时将 <code>0</code> 和 <code>5</code> 打印成乱码</li></ul><p>之前另一个问题是：Server 端可以看到 Client 端连上来，但死活收不到数据，阻塞在 <code>String echo = input.readUTF()</code>。问题原因描述如下：</p><ul><li>Dart Client 发送 “HELLO”</li><li>“HELLO” 的 UTF-8 形式为 [72, 69, 76, 76, 79]</li><li>Java Server 调用 <code>DataInputStream.readUTF()</code> 接收 “HELLO”</li><li>Java Server 会先调用 <code>readUnsignedShort()</code>，[72, 69] 作为 “UnsignedShort” 值为 18501</li><li><code>readUTF()</code> 会尝试读取 18501 个字节，但实际上只能读取 3 个字节，所以一直阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer bb = ByteBuffer.wrap(<span class="keyword">new</span> <span class="keyword">byte</span>[] &#123;<span class="number">72</span>, <span class="number">69</span>&#125;);</span><br><span class="line">    ShortBuffer sb = bb.asShortBuffer();</span><br><span class="line">    System.out.println(sb.get(<span class="number">0</span>)); <span class="comment">// [72, 69] 作为 short 值为 18501</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对 Java Server 进行修复，其代码避免调用 <code>writeUTF()</code> 和 <code>readUTF()</code>，而是分别使用 <code>write()</code> 和 <code>read()</code> 代替。 </p><p>修复后的 Java Server 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ExecutorService e = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">        ss.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">6760</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Server started at port 6760"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            e.execute(<span class="keyword">new</span> ClientHandler(ss.accept()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> DataInputStream input;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> DataOutputStream output;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] buf;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ClientHandler</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">            input = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line">            output = <span class="keyword">new</span> DataOutputStream((socket.getOutputStream()));</span><br><span class="line">            buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"A client coming "</span> + socket.getInetAddress() + <span class="string">":"</span> + socket.getPort());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> hasRead = input.read(buf);</span><br><span class="line">                <span class="keyword">if</span> (hasRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    String echo = <span class="keyword">new</span> String(buf, <span class="number">0</span>, hasRead);</span><br><span class="line">                    System.out.println(<span class="string">"Client said: "</span> + echo);</span><br><span class="line">                    output.write(echo.toUpperCase().getBytes());</span><br><span class="line">                    output.flush();</span><br><span class="line">                    System.out.println(<span class="string">"Server said: "</span> + echo.toUpperCase());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"len is "</span> + hasRead);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close(input);</span><br><span class="line">                close(output);</span><br><span class="line">                close(socket);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"This client has leave "</span> + socket.getInetAddress() + <span class="string">":"</span> + socket.getPort());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable closeable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                closeable.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复后的 Dart Client 如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  Socket socket = <span class="keyword">await</span> Socket.connect(<span class="string">'127.0.0.1'</span>, <span class="number">6760</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'connected'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// listen to the received data event stream</span></span><br><span class="line">  socket.listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; event) &#123;</span><br><span class="line">    <span class="built_in">print</span>(event);</span><br><span class="line">    <span class="built_in">print</span>(utf8.decode(event));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send hello</span></span><br><span class="line">  socket.add(utf8.encode(<span class="string">'hello'</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait 5 seconds</span></span><br><span class="line">  <span class="keyword">await</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .. and close the socket</span></span><br><span class="line">  socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Dart </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译) Dart 异步编程之 Stream</title>
      <link href="2019/07/16/dart-stream/"/>
      <url>2019/07/16/dart-stream/</url>
      
        <content type="html"><![CDATA[<p>翻译 Dart Stream 文档，了解 Stream 的用法。</p><a id="more"></a><p>原文见<a href="https://dart.dev/tutorials/language/streams" target="_blank" rel="noopener">这里</a>。</p><p>重点：</p><ul><li>Steams 提供异步的数据序列</li><li>数据序列可以用户生成的数据或者从文件读取的数据</li><li>可以使用 <strong>await for</strong> 或 Stream API 的 <code>listen()</code> 方法来处理 stream</li><li>Streams 提供错误处理机制</li><li>Streams 分为两类：单一的 subscription (single subscription) 或广播 (broadcast)</li></ul><p>Future 和 Stream 类用于 Dart 异步编程。 </p><p>Future 表示不能立即结束的计算。普通函数返回计算结果，而异步函数返回 Future，它包含最终的计算结果。Future 会在计算完成时告知结果。</p><p>Stream 是异步事件序列。它有点像一个异步的 Iterable，不同之处在于，你不是自己获取下一个事件，而是由 Stream 在下一个事件准备好后通知你。</p><h1 id="接收-stream-事件"><a href="#接收-stream-事件" class="headerlink" title="接收 stream 事件"></a>接收 stream 事件</h1><p>可以通过多种方式创建 streams，这个话题后面文章再讨论。无论哪种方式创建 stream，它们的用法都相同：用于 stream 事件上进行异步 for 循环迭代 (即 <strong>await for</strong>)，就像 Iterable 中进行普通 <strong>for 循环</strong> 迭代一样。比如，</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int</span>&gt; sumStream(Stream&lt;<span class="built_in">int</span>&gt; stream) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">in</span> stream) &#123;</span><br><span class="line">    sum += value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码只是接收整数事件 stream 的每个事件，然后返回它们的和 (一个 Future)。循环体结束后，函数暂停并等待下一个事件到来，直到 stream 结束。</p><p>使用 <strong>await for</strong> 循环时要求函数带 <code>async</code> 关键字。</p><h1 id="错误事件"><a href="#错误事件" class="headerlink" title="错误事件"></a>错误事件</h1><p>Streams 在没有更多事件时结束。使用 <strong>await for</strong> 循环读取事件时，循环在 stream 结束时停止。</p><p>某些情况下，stream 结束前出现错误，比如，从远程服务器获取文件时网络断开，或者创建事件的代码有 bug。</p><p>Streams 以发送数据事件的相同方式发送错误事件。大多数 streams 会在第一次错误时中止，但也有些 streams 可能多次发送错误事件，还有些 streams 在错误事件后继续发送数据事件。这个文档中我们只讨论最多发送一次错误事件的情况。</p><p>使用 <strong>await for</strong> 读取 stream 时，循环语句抛出错误同时结束循环。可以使用 <strong>try-catch</strong> 来捕获错误。</p><h1 id="使用-stream"><a href="#使用-stream" class="headerlink" title="使用 stream"></a>使用 stream</h1><p><code>Stream</code> 类有许多工具方法用于在 stream 上执行常用操作，跟 <code>Iterable</code> 的方法类似。比如，可以使用 Stream API 的 <code>lastWhere()</code> 方法查找 stream 中最后一个正整数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int</span>&gt; lastPositive(Stream&lt;<span class="built_in">int</span>&gt; stream) =&gt;</span><br><span class="line">    stream.lastWhere((x) =&gt; x &gt;= <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h1 id="两种-Stream"><a href="#两种-Stream" class="headerlink" title="两种 Stream"></a>两种 Stream</h1><p>有两种 stream。</p><h2 id="Single-subscription-streams"><a href="#Single-subscription-streams" class="headerlink" title="Single subscription streams"></a>Single subscription streams</h2><p>最常用的 stream 包含整个事件中的一个小序列。事件必须以正确的顺序分发。读取文件或接收网络响应时得到的正是这种 stream。</p><h2 id="Broadcast-streams"><a href="#Broadcast-streams" class="headerlink" title="Broadcast streams"></a>Broadcast streams</h2><p>另一种 stream 专门用于每次只能处理一条消息的场景。比如，用于浏览器中的鼠标事件。</p><p>可以在任何时候监听这个 stream，监听后会收到发送出来的事件。同一时刻可以监听多个 listener，取消前一个订阅后还能再次监听。</p><h1 id="处理-stream"><a href="#处理-stream" class="headerlink" title="处理 stream"></a>处理 stream</h1><p><code>Stream&lt;T&gt;</code> 上的以下方法用于处理 stream 并且返回结果：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;T&gt; <span class="keyword">get</span> first;</span><br><span class="line">Future&lt;<span class="built_in">bool</span>&gt; <span class="keyword">get</span> isEmpty;</span><br><span class="line">Future&lt;T&gt; <span class="keyword">get</span> last;</span><br><span class="line">Future&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> length;</span><br><span class="line">Future&lt;T&gt; <span class="keyword">get</span> single;</span><br><span class="line">Future&lt;<span class="built_in">bool</span>&gt; any(<span class="built_in">bool</span> <span class="built_in">Function</span>(T element) test);</span><br><span class="line">Future&lt;<span class="built_in">bool</span>&gt; contains(<span class="built_in">Object</span> needle);</span><br><span class="line">Future&lt;E&gt; drain&lt;E&gt;([E futureValue]);</span><br><span class="line">Future&lt;T&gt; elementAt(<span class="built_in">int</span> index);</span><br><span class="line">Future&lt;<span class="built_in">bool</span>&gt; every(<span class="built_in">bool</span> <span class="built_in">Function</span>(T element) test);</span><br><span class="line">Future&lt;T&gt; firstWhere(<span class="built_in">bool</span> <span class="built_in">Function</span>(T element) test, &#123;T <span class="built_in">Function</span>() orElse&#125;);</span><br><span class="line">Future&lt;S&gt; fold&lt;S&gt;(S initialValue, S <span class="built_in">Function</span>(S previous, T element) combine);</span><br><span class="line">Future forEach(<span class="keyword">void</span> <span class="built_in">Function</span>(T element) action);</span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; join([<span class="built_in">String</span> separator = <span class="string">""</span>]);</span><br><span class="line">Future&lt;T&gt; lastWhere(<span class="built_in">bool</span> <span class="built_in">Function</span>(T element) test, &#123;T <span class="built_in">Function</span>() orElse&#125;);</span><br><span class="line">Future pipe(StreamConsumer&lt;T&gt; streamConsumer);</span><br><span class="line">Future&lt;T&gt; reduce(T <span class="built_in">Function</span>(T previous, T element) combine);</span><br><span class="line">Future&lt;T&gt; singleWhere(<span class="built_in">bool</span> <span class="built_in">Function</span>(T element) test, &#123;T <span class="built_in">Function</span>() orElse&#125;);</span><br><span class="line">Future&lt;<span class="built_in">List</span>&lt;T&gt;&gt; toList();</span><br><span class="line">Future&lt;<span class="built_in">Set</span>&lt;T&gt;&gt; toSet();</span><br></pre></td></tr></table></figure><p>除了 <code>drain()</code> 和 <code>pipe()</code>，其他方法都能在 Iterable 中找到相应的方法。这些方法很容易写，在 async 方法使用 <strong>await for</strong> 循环。比如，以下是一些方法的实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">bool</span>&gt; contains(<span class="built_in">Object</span> needle) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> event <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event == needle) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future forEach(<span class="keyword">void</span> <span class="built_in">Function</span>(T element) action) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> event <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">    action(event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">List</span>&lt;T&gt;&gt; toList() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> result = &lt;T&gt;[];</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">this</span>.forEach(result.add);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; join([<span class="built_in">String</span> separator = <span class="string">""</span>]) <span class="keyword">async</span> =&gt;</span><br><span class="line">    (<span class="keyword">await</span> <span class="keyword">this</span>.toList()).join(separator);</span><br></pre></td></tr></table></figure><p>(注意，以上只是精简后的代码，由于历史原因实际实现可能更复杂。)</p><h1 id="修改-stream"><a href="#修改-stream" class="headerlink" title="修改 stream"></a>修改 stream</h1><p>Stream 类的以下方法基于原先的 stream 返回一个新的 stream。Each one waits until someone listens on the new stream before listening on the original.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;R&gt; cast&lt;R&gt;();</span><br><span class="line">Stream&lt;S&gt; expand&lt;S&gt;(<span class="built_in">Iterable</span>&lt;S&gt; <span class="built_in">Function</span>(T element) convert);</span><br><span class="line">Stream&lt;S&gt; map&lt;S&gt;(S <span class="built_in">Function</span>(T event) convert);</span><br><span class="line">Stream&lt;R&gt; retype&lt;R&gt;();</span><br><span class="line">Stream&lt;T&gt; skip(<span class="built_in">int</span> count);</span><br><span class="line">Stream&lt;T&gt; skipWhile(<span class="built_in">bool</span> <span class="built_in">Function</span>(T element) test);</span><br><span class="line">Stream&lt;T&gt; take(<span class="built_in">int</span> count);</span><br><span class="line">Stream&lt;T&gt; takeWhile(<span class="built_in">bool</span> <span class="built_in">Function</span>(T element) test);</span><br><span class="line">Stream&lt;T&gt; where(<span class="built_in">bool</span> <span class="built_in">Function</span>(T event) test);</span><br></pre></td></tr></table></figure><p>相应地，Iterable 中也有类似的方法用于将一个 iterable 转换成另外一个 iterable。这些方法很容易使用带 <strong>await for</strong> 循环的 async 方法编写。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;E&gt; asyncExpand&lt;E&gt;(Stream&lt;E&gt; <span class="built_in">Function</span>(T event) convert);</span><br><span class="line">Stream&lt;E&gt; asyncMap&lt;E&gt;(FutureOr&lt;E&gt; <span class="built_in">Function</span>(T event) convert);</span><br><span class="line">Stream&lt;T&gt; distinct([<span class="built_in">bool</span> <span class="built_in">Function</span>(T previous, T next) equals]);</span><br></pre></td></tr></table></figure><p><code>asyncExpand()</code> 和 <code>asyncMap()</code> 函数跟 <code>expand()</code> 和 <code>map()</code> 类似，但允许其函数参数为异步函数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; handleError(<span class="built_in">Function</span> onError, &#123;<span class="built_in">bool</span> test(error)&#125;);</span><br><span class="line">Stream&lt;T&gt; timeout(<span class="built_in">Duration</span> timeLimit,</span><br><span class="line">    &#123;<span class="keyword">void</span> <span class="built_in">Function</span>(EventSink&lt;T&gt; sink) onTimeout&#125;);</span><br><span class="line">Stream&lt;S&gt; transform&lt;S&gt;(StreamTransformer&lt;T, S&gt; streamTransformer);</span><br></pre></td></tr></table></figure><p>最后的三个方法更特别。它们用于处理 <strong>await for</strong> 循环不能处理的错误，循环中首次出现的错误会导致循环结束，对 stream 的订阅也被结束。没法从这种情况恢复。可以使用 <code>handleError()</code> 在错误事件到达 <strong>await for</strong> 循环之前从 stream 中移除错误。(原文：You can use handleError() to remove errors from a stream before using it in an await for loop.)</p><h2 id="transform-function"><a href="#transform-function" class="headerlink" title="transform() function"></a>transform() function</h2><p><code>transform()</code> 函数不仅仅用于错误处理，还能用于对 stream 进行更通用的 “map”。通常的 map 要求为每个收到的事件得到一个值。但是在 I/O 操作中，常常出现几个输入事件生成一个输出事件的情形。<code>StreamTransformer</code> 用于处理这种情况。比如，<code>Utf8Decoder</code> 等解码器也是 transformer。transformer 只需要实现 <code>bind()</code> 方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;S&gt; mapLogErrors&lt;S, T&gt;(</span><br><span class="line">  Stream&lt;T&gt; stream,</span><br><span class="line">  S <span class="built_in">Function</span>(T event) convert,</span><br><span class="line">) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="keyword">var</span> streamWithoutErrors = stream.handleError((e) =&gt; log(e));</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> event <span class="keyword">in</span> streamWithoutErrors) &#123;</span><br><span class="line">    <span class="keyword">yield</span> convert(event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reading-and-decoding-a-file"><a href="#Reading-and-decoding-a-file" class="headerlink" title="Reading and decoding a file"></a>Reading and decoding a file</h2><p>以下代码读文件并且对 stream 运用两个 transform。首先从 UTF8 转换数据，然后再使用 <code>LineSplitter</code>。最后打印所有行，除了以 <code>#</code> 开头的行。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="keyword">void</span>&gt; main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> file = File(args[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">var</span> lines = utf8.decoder</span><br><span class="line">      .bind(file.openRead())</span><br><span class="line">      .transform(LineSplitter());</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> line <span class="keyword">in</span> lines) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!line.startsWith(<span class="string">'#'</span>)) <span class="built_in">print</span>(line);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="The-listen-method"><a href="#The-listen-method" class="headerlink" title="The listen() method"></a>The listen() method</h1><p>最后要介绍的是 Stream 中的 <code>listen()</code> 方法。它是一个低级方法，所有的其他 stream 方法都是某种意义上的 <code>listen()</code> 方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StreamSubscription&lt;T&gt; listen(<span class="keyword">void</span> <span class="built_in">Function</span>(T event) onData,</span><br><span class="line">    &#123;<span class="built_in">Function</span> onError, <span class="keyword">void</span> <span class="built_in">Function</span>() onDone, <span class="built_in">bool</span> cancelOnError&#125;);</span><br></pre></td></tr></table></figure><p>要创建新的 <code>Stream</code> 类型，只需要继承 <code>Stream</code> 类并且实现 <code>listen()</code> 方法。<code>Stream</code> 上的其他方法都会调用 <code>listen()</code> 方法。</p><p><code>listen()</code> 方法允许监听 stream。直接被监听，否则 stream 就是静态的。开始监听后，将返回 <code>StreamSubscription</code> 对象，它代表活动的、可以产生事件的流。这跟 <code>Iterable</code> 类似，它只是对象集合，itertor 才会真正进行迭代。</p><p>stream subscription 允许暂停以及恢复，或者完全取消。还能设置回调，当产生数据事件、错误事件或者 stream 被关闭时都会收到回调。 </p><h1 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h1><p>阅读以下 stream 用法及 Dart 异步编程文档，了解更多内容。</p><ul><li><a href="https://dart.dev/articles/libraries/creating-streams" target="_blank" rel="noopener">Creating Streams in Dart</a>, an article about creating your own streams</li><li><a href="https://dart.dev/guides/libraries/futures-error-handling" target="_blank" rel="noopener">Futures and Error Handling</a>, an article that explains how to handle errors using the Future API</li><li><a href="https://dart.dev/guides/language/language-tour#asynchrony-support" target="_blank" rel="noopener">Asynchrony support</a>, a section in the <a href="https://dart.dev/guides/language/language-tour" target="_blank" rel="noopener">language tour</a></li><li><a href="https://api.dart.dev/stable/dart-async/Stream-class.html" target="_blank" rel="noopener">Stream API reference</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android inline hook 浅析</title>
      <link href="2019/07/15/inline-hook-basic/"/>
      <url>2019/07/15/inline-hook-basic/</url>
      
        <content type="html"><![CDATA[<p>简单了解一下 inline hook 技术。</p><a id="more"></a><p>inline hook 技术涉及到很多底层知识，所以我不太 hold 得住。幸好网上能找到很多不错的参考资料，就算不能完全弄懂，也可以了解个大概。先上参考资料：</p><ul><li><a href="https://www.malwaretech.com/2015/01/inline-hooking-for-programmers-part-1.html" target="_blank" rel="noopener">Inline Hooking for Programmers (Part 1: Introduction)</a>，这个文档中的示意图非常清晰，有助于理解 inline hook 的本质</li><li><a href="https://www.jianshu.com/p/76d789d9d4e1" target="_blank" rel="noopener">Android Inline Hook 详解</a>，这个文档是对下一个文档的整理和总结，有助于理解实现 inline hook 的关键步骤</li><li><a href="http://ele7enxxh.com/Android-Arm-Inline-Hook.html" target="_blank" rel="noopener">Android Arm Inline Hook</a>，这个文档介绍了实现 inline hook 的技术细节</li><li><a href="https://github.com/ele7enxxh/Android-Inline-Hook" target="_blank" rel="noopener">ele7enxxh/Android-Inline-Hook</a>，这个是 inline hook 的源码，建议结合着上一个文档来看</li><li>[]，上面的源码是使用旧的 NDK 编译方式，Android Studio 使用 CMake 编译。所以我动手将该源码改造成可以直接 Android Studio 中运行的 demo，方便动手实践</li></ul><h1 id="什么是-inline-hook"><a href="#什么是-inline-hook" class="headerlink" title="什么是 inline hook"></a>什么是 inline hook</h1><blockquote><p>Inline hooking is a method of intercepting calls to target functions. The general idea is to redirect a function to our own, so that we can perform processing before and/or after the function does its; this could include: checking parameters, shimming, logging, spoofing returned data, and filtering calls. </p><p>The hooks are placed by directly modifying code within the target function (inline modification), usually by overwriting the first few bytes with a jump; this allows execution to be redirected before the function does any processing</p></blockquote><p>inline hook 是拦截目标函数调用的一种手段。通常是将原始方法调用重定向到我们指定的新方法，以便在原始方法执行前后可以执行某些操作，包括检查参数、打印日志、过滤某些调用等等。</p><p>inline hook 的实现手段是直接修改目标函数的代码(即内联修改)，通常是用跳转指令替换目标函数代码的前几个字节。跳转指令让目标函数进行实际处理前被重定向。</p><p>inline hook 需要解决的问题：</p><ul><li>hook 成功后，如何调用原先的旧函数</li><li>无限递归问题</li><li>多线程场景时的 race conditions</li><li>指令修正</li></ul><h1 id="Inline-hook-的原理"><a href="#Inline-hook-的原理" class="headerlink" title="Inline hook 的原理"></a>Inline hook 的原理</h1><p>inline hook 由3部分组成：</p><ul><li>Hook - 为了 hook 目标函数(旧函数)，会向其代码中写入一个5个字节的跳转指令(实际跳转指令以及指令大小跟平台相关)</li><li>Proxy - 用于指定被 hook 的目标函数将要跳转到的函数(新函数)</li><li>Trampoline - 用于调用旧函数</li></ul><h1 id="为什么需要-trampoline"><a href="#为什么需要-trampoline" class="headerlink" title="为什么需要 trampoline"></a>为什么需要 trampoline</h1><p>前面提到的两个问题，可以通过 trampoline 来解决</p><ul><li>hook 成功后，如何调用原先的旧函数</li><li>无限递归问题</li></ul><p>假设有一个方法 <code>MessageBoxA()</code>，它可以显示一个对话框。假设我们 hook 了该方法，即，将其重定向到某个 Proxy。这个 Proxy 先打印出参数，再调用 <code>MessageBoxA()</code> 显示对话框。但是要注意，由于已经被 hook，所以正常调用 <code>MessageBoxA()</code> 时它又会重定向到 Proxy。这是一个无限递归调用，最后会导致程序因 stack overflow 而中止。</p><p>有一个直观的解决方案：在 Proxy 中先 unhook <code>MessageBoxA()</code> (即取消重定向)，然后调用 <code>MessageBoxA()</code>，然后再一次 hook <code>MessageBoxA()</code> (即打开重定向)。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/mweb/2019/07/09/CodeFlow.png" width="60%" height="60%"></p><p>上图中提供了另外一个更通用的解决方案：使用 trampoline。先将 <code>MesasgeBoxA()</code> 的头5个字节保存在 trampoline 中，再向 <code>MessageBoxA()</code> 的头5个字节写入 Proxy 的地址。这样一来，hook <code>MessageBoxA()</code> 之后，如果你想正常调用原来的 <code>MessageBoxA()</code>，你可以借助 trampoline 来完成。</p><h1 id="Android-Inline-Hook-源码分析"><a href="#Android-Inline-Hook-源码分析" class="headerlink" title="Android-Inline-Hook 源码分析"></a>Android-Inline-Hook 源码分析</h1><p><a href="https://github.com/ele7enxxh/Android-Inline-Hook" target="_blank" rel="noopener">ele7enxxh/Android-Inline-Hook</a> 是 Github 上的一个开源项目。它的几个要点包括：</p><ul><li>指令模式判断</li><li>跳转指令构造</li><li>跳转指令修正</li><li>多线程处理及其他细节</li></ul><p>这里只看跳转指令构造的大致原理(涉及到太多背景知识和技术细节，只能不求甚解)。</p><h2 id="inlineHookItem-结构体"><a href="#inlineHookItem-结构体" class="headerlink" title="inlineHookItem 结构体"></a><a href="https://github.com/ele7enxxh/Android-Inline-Hook/blob/master/inlineHook.c#L40" target="_blank" rel="noopener">inlineHookItem 结构体</a></h2><p>每个被 hook 的函数被记录在 <code>inlineHookItem</code> 结构体中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inlineHookItem</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> target_addr;          <span class="comment">// 目标函数地址</span></span><br><span class="line"><span class="keyword">uint32_t</span> new_addr;             <span class="comment">// 新函数地址</span></span><br><span class="line"><span class="keyword">uint32_t</span> **proto_addr;</span><br><span class="line"><span class="keyword">void</span> *orig_instructions;       <span class="comment">// 原始指令</span></span><br><span class="line"><span class="keyword">int</span> orig_boundaries[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> trampoline_boundaries[<span class="number">20</span>];</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">void</span> *trampoline_instructions; <span class="comment">// 跳转指令</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>inlineHookItem.trampoline_instructions</code> 字段正是上文中提到的 trampoline。</p><h2 id="registerInlineHook-方法"><a href="#registerInlineHook-方法" class="headerlink" title="registerInlineHook() 方法"></a><a href="https://github.com/ele7enxxh/Android-Inline-Hook/blob/master/inlineHook.c#L252" target="_blank" rel="noopener">registerInlineHook() 方法</a></h2><p>调用 <code>registerInlineHook()</code> 方法开始记录 <code>inlineHookItem</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">enum</span> ele7en_status <span class="title">registerInlineHook</span><span class="params">(<span class="keyword">uint32_t</span> target_addr, <span class="keyword">uint32_t</span> new_addr, <span class="keyword">uint32_t</span> **proto_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inlineHookItem</span> *<span class="title">item</span>;</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">item = findInlineHookItem(target_addr);</span><br><span class="line"><span class="keyword">if</span> (item != <span class="literal">NULL</span>) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">item = addInlineHookItem();</span><br><span class="line"></span><br><span class="line">item-&gt;target_addr = target_addr;</span><br><span class="line">item-&gt;new_addr = new_addr;</span><br><span class="line">item-&gt;proto_addr = proto_addr;</span><br><span class="line">item-&gt;length = TEST_BIT0(item-&gt;target_addr) ? <span class="number">12</span> : <span class="number">8</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ELE7EN_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法几个主要步骤是：</p><ul><li>调用 <code>findInlineHookItem()</code> 方法检查是否已有相关记录。有则直接返回，否则进入下一步</li><li>调用 <code>addInlineHookItem()</code> 方法为指定的 <code>target_addr</code> 来创建一个新的 <code>inlineHookItem</code></li><li>初始化创建的 <code>inlineHookItem</code> </li></ul><h2 id="doInlineHook-方法"><a href="#doInlineHook-方法" class="headerlink" title="doInlineHook() 方法"></a><a href="https://github.com/ele7enxxh/Android-Inline-Hook/blob/master/inlineHook.c#L342" target="_blank" rel="noopener">doInlineHook() 方法</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doInlineHook</span><span class="params">(struct inlineHookItem *item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">if</span> (item-&gt;proto_addr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">*(item-&gt;proto_addr) = TEST_BIT0(item-&gt;target_addr) ? (<span class="keyword">uint32_t</span> *) SET_BIT0((<span class="keyword">uint32_t</span>) item-&gt;trampoline_instructions) : item-&gt;trampoline_instructions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (TEST_BIT0(item-&gt;target_addr)) &#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (CLEAR_BIT0(item-&gt;target_addr) % <span class="number">4</span> != <span class="number">0</span>) &#123;</span><br><span class="line">((<span class="keyword">uint16_t</span> *) CLEAR_BIT0(item-&gt;target_addr))[i++] = <span class="number">0xBF00</span>;  <span class="comment">// NOP</span></span><br><span class="line">&#125;</span><br><span class="line">((<span class="keyword">uint16_t</span> *) CLEAR_BIT0(item-&gt;target_addr))[i++] = <span class="number">0xF8DF</span>;</span><br><span class="line">((<span class="keyword">uint16_t</span> *) CLEAR_BIT0(item-&gt;target_addr))[i++] = <span class="number">0xF000</span>;<span class="comment">// LDR.W PC, [PC]</span></span><br><span class="line">((<span class="keyword">uint16_t</span> *) CLEAR_BIT0(item-&gt;target_addr))[i++] = item-&gt;new_addr &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">((<span class="keyword">uint16_t</span> *) CLEAR_BIT0(item-&gt;target_addr))[i++] = item-&gt;new_addr &gt;&gt; <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">((<span class="keyword">uint32_t</span> *) (item-&gt;target_addr))[<span class="number">0</span>] = <span class="number">0xe51ff004</span>;<span class="comment">// LDR PC, [PC, #-4]</span></span><br><span class="line">((<span class="keyword">uint32_t</span> *) (item-&gt;target_addr))[<span class="number">1</span>] = item-&gt;new_addr;</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doInlineHook()</code> 方法是 inline hook 关键之一。其作用包括：</p><ul><li>处理对原始方法的访问 - 将 <code>trampoline_instructions</code> 强制转型为 <code>void *proto_addr</code>。如果想调用原始方法，调用 <code>proto_addr</code> 指向的方法即可</li><li>修改原始方法，写入跳转指令</li></ul><h2 id="relocateInstruction-方法"><a href="#relocateInstruction-方法" class="headerlink" title="relocateInstruction() 方法"></a><a href="https://github.com/ele7enxxh/Android-Inline-Hook/blob/master/relocate.c#L489" target="_blank" rel="noopener">relocateInstruction() 方法</a></h2><p><code>relocateInstruction()</code> 方法是 inline hook 的关键之一。其作用是将原始函数的被跳转指令替换的那几个指令拷贝到 <code>trampoline_instructions</code> 中，此时 PC 值已经变动，所以还需要对相关指令进行修正。 PC 值相关的指令由 <a href="https://github.com/ele7enxxh/Android-Inline-Hook/blob/master/relocate.c#L14" target="_blank" rel="noopener">INSTRUCTION_TYPE</a> 描述。</p><p><code>relocateInstruction()</code> 方法用于按不同的平台分为：</p><ul><li><code>relocateInstructionInThumb()</code><ul><li><code>relocateInstructionInThumb16()</code></li><li><code>relocateInstructionInThumb32()</code></li></ul></li><li><code>relocateInstructionInArm()</code></li></ul><p>这里只看 <code>relocateInstructionInArm()</code> 方法。它的参数包括：</p><ul><li><code>target_addr</code> - 待Hook的目标函数地址，即当前 PC 值，用于修正指令</li><li><code>orig_instructions</code> - 存放原有指令的首地址，用于修正指令和后续对原有指令的恢复</li><li><code>length</code> - 存放的原有指令的长度，Arm 指令为8字节；Thumb 指令为12字节</li><li><code>trampoline_instructions</code> - 存放修正后指令的首地址，用于调用原函数</li><li><code>orig_boundaries</code> - 存放原有指令的指令边界（所谓边界即为该条指令与起始地址的偏移量），用于后续线程处理中，对 PC 的迁移</li><li><code>trampoline_boundaries</code> - 存放修正后指令的指令边界，用途与上相同</li><li><code>count</code> - 处理的指令项数，用途与上相同</li></ul><p>精简后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">relocateInstructionInArm</span><span class="params">(<span class="keyword">uint32_t</span> target_addr, <span class="keyword">uint32_t</span> *orig_instructions, <span class="keyword">int</span> length, <span class="keyword">uint32_t</span> *trampoline_instructions, <span class="keyword">int</span> *orig_boundaries, <span class="keyword">int</span> *trampoline_boundaries, <span class="keyword">int</span> *count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (orig_pos = <span class="number">0</span>; orig_pos &lt; length / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>); ++orig_pos) &#123;</span><br><span class="line"><span class="keyword">uint32_t</span> instruction;</span><br><span class="line"><span class="keyword">int</span> type;</span><br><span class="line">instruction = orig_instructions[orig_pos];</span><br><span class="line">type = getTypeInArm(instruction);</span><br><span class="line"><span class="keyword">if</span> (type == BLX_ARM || type == BL_ARM || type == B_ARM || type == BX_ARM) &#123;</span><br><span class="line">...</span><br><span class="line">trampoline_instructions[trampoline_pos++] = value;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (type == ADD_ARM) &#123;</span><br><span class="line">    ...</span><br><span class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xE52D0004</span> | (r &lt;&lt; <span class="number">12</span>);<span class="comment">// PUSH &#123;Rr&#125;</span></span><br><span class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xE59F0008</span> | (r &lt;&lt; <span class="number">12</span>);<span class="comment">// LDR Rr, [PC, #8]</span></span><br><span class="line">trampoline_instructions[trampoline_pos++] = (instruction &amp; <span class="number">0xFFF0FFFF</span>) | (r &lt;&lt; <span class="number">16</span>);</span><br><span class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xE49D0004</span> | (r &lt;&lt; <span class="number">12</span>);<span class="comment">// POP &#123;Rr&#125;</span></span><br><span class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xE28FF000</span>;<span class="comment">// ADD PC, PC</span></span><br><span class="line">trampoline_instructions[trampoline_pos++] = pc;    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">trampoline_instructions[trampoline_pos++] = instruction;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xe51ff004</span>;<span class="comment">// LDR PC, [PC, #-4]</span></span><br><span class="line">trampoline_instructions[trampoline_pos++] = lr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的略去了技术细节，建议参考 <a href="http://ele7enxxh.com/Android-Arm-Inline-Hook.html" target="_blank" rel="noopener">Android Arm Inline Hook</a>。</p><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p><a href="https://github.com/ele7enxxh/Android-Inline-Hook" target="_blank" rel="noopener">ele7enxxh/Android-Inline-Hook: thumb16 thumb32 arm32 inlineHook in Android</a> 近期没有更新，它仍然使用 <code>ndk-build</code> 编译，且提供的 example 真机验证不便。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"inlineHook.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*old_puts)(<span class="keyword">const</span> <span class="keyword">char</span> *) = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    old_puts(<span class="string">"inlineHook success"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (registerInlineHook((<span class="keyword">uint32_t</span>) <span class="built_in">puts</span>, (<span class="keyword">uint32_t</span>) new_puts, (<span class="keyword">uint32_t</span> **) &amp;old_puts) != ELE7EN_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inlineHook((<span class="keyword">uint32_t</span>) <span class="built_in">puts</span>) != ELE7EN_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inlineUnHook((<span class="keyword">uint32_t</span>) <span class="built_in">puts</span>) != ELE7EN_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"test"</span>);</span><br><span class="line">    hook();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"test"</span>);</span><br><span class="line">    unHook();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我动手写了另一个 demo，完整代码见 <a href="https://github.com/410063005/android-ndk/tree/inline-hook" target="_blank" rel="noopener">Inline hook demo</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJni</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_hello_jni);</span><br><span class="line"></span><br><span class="line">        findViewById(R.id.btnCallOriginal).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                callHookTestCallOriginal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">                    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">callHookTestCallOriginal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"hello-jni"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码结构如下：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/mweb/2019/07/09/inline-example.png" width="40%" height="40%"></p><p>NDK 编译配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line">add_library(hello-jni SHARED</span><br><span class="line">            hello-jni.c inlinehook/inlineHook.c inlinehook/relocate.c inlinehook/hooktest.c)</span><br><span class="line"></span><br><span class="line"># Include libraries needed for hello-jni lib</span><br><span class="line">target_link_libraries(hello-jni</span><br><span class="line">                      android</span><br><span class="line">                      log)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Glide transform 问题分析</title>
      <link href="2019/07/09/glide-transform/"/>
      <url>2019/07/09/glide-transform/</url>
      
        <content type="html"><![CDATA[<p>Glide 很强大也很复杂。多数时候 Glide 可以提高我们的生产力，也有少数时候我们不小心会踩到坑里。本文来自一个真实案例：布局文件中一处不起眼的疏忽，导致 Glide 生成一个超大的 Bitmap。<br><a id="more"></a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/mweb/2019/07/09/15626421386129.jpg" width="40%" height="40%"></p><p>上图中的英雄头像上有一个小角标，角标大小为180x180像素。但我们通过 Bitmap Profiler 看到的这个角标对应的 Bitmap 大小超过 4MB，显然不合理。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/mweb/2019/07/09/15626422390998.jpg" width="40%" height="40%"></p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>为了容易定位问题，我写了一个 demo 来进行分析。demo 源码见 <a href="https://github.com/410063005/GlideDontTransformDemo" target="_blank" rel="noopener">Github</a>。</p><h2 id="图一"><a href="#图一" class="headerlink" title="图一"></a>图一</h2><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/201906/glide-dont-transform.gif" height="40%" width="40%"></p><p>上图中分别使用 Glide 和 Picasso 加载图片。结果，</p><ul><li>第一次使用 Glide 加载图片，这时生成了两个 Bitmap</li><li>第二次使用 Picasso 加载图片，这时只生成一个 Bitmap</li></ul><p>由此可以初步断定，Glide 加载图片会多生成一个 Bitmap。</p><h2 id="图二"><a href="#图二" class="headerlink" title="图二"></a>图二</h2><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/201906/glide-vs-picasso.gif" height="40%" width="40%"></p><p>上图中只使用 Glide 加载图片，两次加载稍有不同：</p><ul><li>第一次使用 Glide 加载图片时调用 <code>dontTransform()</code> 方法，这时只生一个 Bitmap</li><li>第二次使用 Glide 加载图片不调用 <code>dontTransform()</code>，这时生成了两个 Bitmap</li></ul><p>由此可以初步断定，Glide 加载图片时的 transform 处理导致多生成一个 Bitmap。</p><h2 id="为什么生成大的-Bitmap"><a href="#为什么生成大的-Bitmap" class="headerlink" title="为什么生成大的 Bitmap"></a>为什么生成大的 Bitmap</h2><p>Glide 对原始 Bitamp 进行 transform 处理导致生成新的 Bitmap 对象，这是可以理解的。但是问题是，原始图片只有180x180像素，为什么生成了4MB的 Bitmap？</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/mweb/2019/07/09/15626539754464.jpg" width="40%" height="40%"></p><h1 id="Transform-分析"><a href="#Transform-分析" class="headerlink" title="Transform 分析"></a>Transform 分析</h1><p>Glide 加载图片过程比较复杂，所以我们只挑相关步骤来说，忽略不相关细节。另外，简单起见这里的讨论暂不考虑图片缓存问题，认为所有的图片都是从服务器上拉取的。</p><p>下面从以下几个方面进行讨论：</p><ul><li>获取控件大小 - getSize()</li><li>Bitmap 变换 - transform()</li><li>transformation 的选择策略</li></ul><h2 id="getSize"><a href="#getSize" class="headerlink" title="getSize()"></a>getSize()</h2><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/mweb/2019/07/09/15626573011974.jpg" width="40%" height="40%"></p><p>Glide 实际发请求加载图片前有一个判断当前 <a href="https://github.com/bumptech/glide/blob/v3.7.0/library/src/main/java/com/bumptech/glide/request/target/Target.java" target="_blank" rel="noopener">Target</a> 大小的过程。这里 <a href="https://github.com/bumptech/glide/blob/v3.7.0/library/src/main/java/com/bumptech/glide/request/target/Target.java" target="_blank" rel="noopener">Target</a> 通常是指 <a href="https://github.com/bumptech/glide/blob/v3.7.0/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java" target="_blank" rel="noopener">ViewTarget</a>。</p><p>获取当前 <a href="https://github.com/bumptech/glide/blob/v3.7.0/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java" target="_blank" rel="noopener">ViewTarget</a> 大小的原因很简单：将一个大小超过控件实际大小的 Bitmap 显示在控件上显然是不合理的。所以 Glide 加载图片前会先获取控件实际大小，后面按这个实际大小 transform 成一个尺寸更小的 Bitmap。Glide 的磁盘缓存对象也是 transform 后的 Bitmap，这样通常可以更省存储空间，并且之后读取磁盘缓存性能也更好。不过其他一些图片加载库，比如 Picasso，并没有进行类似的处理。</p><p>获取当前 ViewTarget 大小是从 <a href="https://github.com/bumptech/glide/blob/v3.7.0/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java#L99" target="_blank" rel="noopener">ViewTarget.getSize(SizeReadyCallback cb)</a> 方法开始的。</p><ul><li>首先，检查 <code>View.getWidth()</code> 和 <code>View.getHeight()</code>。如果其中某一个为0，进入下一步。否则，结束</li><li>检查 view 的 <code>LayoutParams</code>。如果其中宽和高其中某一个小于等于0，进入下一步。否则，结束</li><li>创建 <code>SizeDeterminerLayoutListener</code>，等待 measure 过程结束。结束后回调 <code>SizeDeterminerLayoutListener</code></li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSize</span><span class="params">(SizeReadyCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> currentWidth = getViewWidthOrParam();</span><br><span class="line">    <span class="keyword">int</span> currentHeight = getViewHeightOrParam();</span><br><span class="line">    <span class="keyword">if</span> (isSizeValid(currentWidth) &amp;&amp; isSizeValid(currentHeight)) &#123;</span><br><span class="line">        cb.onSizeReady(currentWidth, currentHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getViewWidthOrParam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LayoutParams layoutParams = view.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (isSizeValid(view.getWidth())) &#123;</span><br><span class="line">        <span class="keyword">return</span> view.getWidth();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (layoutParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getSizeForParam(layoutParams.width, <span class="keyword">false</span> <span class="comment">/*isHeight*/</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PENDING_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSizeForParam</span><span class="params">(<span class="keyword">int</span> param, <span class="keyword">boolean</span> isHeight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (param == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">        Point displayDimens = getDisplayDimens();</span><br><span class="line">        <span class="keyword">return</span> isHeight ? displayDimens.y : displayDimens.x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 ViewTarget 大小一般不会有什么问题。但是，如果 ImageView 宽高为 <code>wrap_content</code> 时就要小心了。以下面布局为例，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"90dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"140dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">"center_horizontal"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/iv_bg"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"90dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"140dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">"center_horizontal"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"@color/colorAccent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:scaleType</span>=<span class="string">"fitXY"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:scaleType</span>=<span class="string">"fitStart"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/iv_tag"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_alignStart</span>=<span class="string">"@id/iv_bg"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_alignTop</span>=<span class="string">"@id/iv_bg"</span></span></span><br><span class="line"><span class="tag">             /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.constraint.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意 <code>iv_tag</code> 这个 ImageView 的宽高为 <code>wrap_content</code>。但是按照上述代码逻辑，Glide 认为 <code>iv_tag</code> 这个控件的大小是 1080x2150 (即当前屏幕大小)！</p><p>我打断点看了下，确认无误。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/mweb/2019/07/09/15626590721810.jpg" alt="-w1612"></p><h2 id="transform"><a href="#transform" class="headerlink" title="transform()"></a>transform()</h2><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/mweb/2019/07/09/15626539754464.jpg" width="40%" height="40%"></p><p>Glide 从后台拉取到图片后并解码为 Bitmap，即下面代码中的 <code>decoded</code>。但 Glide 并不是将 <code>decoded</code> 直接显示在控件上，而是先 <a href="https://github.com/bumptech/glide/blob/v3.7.0/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java#L231" target="_blank" rel="noopener">transform()</a> 得到一个新的 Bitmap <code>transformed</code>。具体的 transform 由 <a href="https://github.com/bumptech/glide/blob/v3.7.0/library/src/main/java/com/bumptech/glide/load/Transformation.java#L32" target="_blank" rel="noopener">transformation.transform()</a> 完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Z&gt; <span class="title">decodeFromSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Resource&lt;T&gt; decoded = decodeSource();</span><br><span class="line">    <span class="keyword">return</span> transformEncodeAndTranscode(decoded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;Z&gt; <span class="title">transformEncodeAndTranscode</span><span class="params">(Resource&lt;T&gt; decoded)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;T&gt; transformed = transform(decoded);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Transformed resource from source"</span>, startTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writeTransformedToCache(transformed);</span><br><span class="line"></span><br><span class="line">    startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Transcoded transformed from source"</span>, startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;T&gt; <span class="title">transform</span><span class="params">(Resource&lt;T&gt; decoded)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (decoded == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Resource&lt;T&gt; transformed = transformation.transform(decoded, width, height);</span><br><span class="line">    <span class="keyword">if</span> (!decoded.equals(transformed)) &#123;</span><br><span class="line">        decoded.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transformed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 transformation 为 <a href="https://github.com/bumptech/glide/blob/v3.7.0/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java" target="_blank" rel="noopener">FitCenter</a>。<code>FitCenter</code> 似乎与 <code>iv_tag</code> 的 <code>scaleType</code> 属性对应不上，稍后我们在讨论 transformation 选择策略时再来说这个问题。</p><p><code>FitCenter</code> 实际上是调用 <a href="https://github.com/bumptech/glide/blob/v3.7.0/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java#L85" target="_blank" rel="noopener">TransformationUtils.fitCenter()</a> 方法来处理原始的 Bitmap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scales the image uniformly (maintaining the image's aspect ratio) so that one of the dimensions of the image</span></span><br><span class="line"><span class="comment"> * will be equal to the given dimension and the other will be less than the given dimension.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FitCenter</span> <span class="keyword">extends</span> <span class="title">BitmapTransformation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">transform</span><span class="params">(BitmapPool pool, Bitmap toTransform, <span class="keyword">int</span> outWidth, <span class="keyword">int</span> outHeight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TransformationUtils.fitCenter(toTransform, pool, outWidth, outHeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformationUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An expensive operation to resize the given Bitmap down so that it fits within the given dimensions maintain</span></span><br><span class="line"><span class="comment">     * the original proportions.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toFit The Bitmap to shrink.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pool The BitmapPool to try to reuse a bitmap from.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> width The width in pixels the final image will fit within.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height The height in pixels the final image will fit within.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or height matches the</span></span><br><span class="line"><span class="comment">     * given dimensions and toFit fits within the given dimensions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">fitCenter</span><span class="params">(Bitmap toFit, BitmapPool pool, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (toFit.getWidth() == width &amp;&amp; toFit.getHeight() == height) &#123;</span><br><span class="line">            <span class="keyword">return</span> toFit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> widthPercentage = width / (<span class="keyword">float</span>) toFit.getWidth();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> heightPercentage = height / (<span class="keyword">float</span>) toFit.getHeight();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> minPercentage = Math.min(widthPercentage, heightPercentage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// take the floor of the target width/height, not round. If the matrix</span></span><br><span class="line">        <span class="comment">// passed into drawBitmap rounds differently, we want to slightly</span></span><br><span class="line">        <span class="comment">// overdraw, not underdraw, to avoid artifacts from bitmap reuse.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> targetWidth = (<span class="keyword">int</span>) (minPercentage * toFit.getWidth());</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> targetHeight = (<span class="keyword">int</span>) (minPercentage * toFit.getHeight());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (toFit.getWidth() == targetWidth &amp;&amp; toFit.getHeight() == targetHeight) &#123;</span><br><span class="line">            <span class="keyword">return</span> toFit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Bitmap.Config config = getSafeConfig(toFit);</span><br><span class="line">        Bitmap toReuse = pool.get(targetWidth, targetHeight, config);</span><br><span class="line">        <span class="keyword">if</span> (toReuse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            toReuse = Bitmap.createBitmap(targetWidth, targetHeight, config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.</span></span><br><span class="line">        TransformationUtils.setAlpha(toFit, toReuse);</span><br><span class="line"></span><br><span class="line">        Canvas canvas = <span class="keyword">new</span> Canvas(toReuse);</span><br><span class="line">        Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">        matrix.setScale(minPercentage, minPercentage);</span><br><span class="line">        Paint paint = <span class="keyword">new</span> Paint(PAINT_FLAGS);</span><br><span class="line">        canvas.drawBitmap(toFit, matrix, paint);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> toReuse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/bumptech/glide/blob/v3.7.0/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java#L85" target="_blank" rel="noopener">TransformationUtils.fitCenter()</a> 将传入的 <code>toFit</code> 转换成 <code>toReuse</code>。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/mweb/2019/07/09/15626615206181.jpg" alt="-w1278"></p><p>然而断点看一下发现 <code>toFit</code> 大小是 180x180，<code>toReuse</code> 大小是 1080x1080。简单算一下，可知之前看到的那个 4MB 的 Bitmap 正是这里的 <code>toReuse</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1080 * 1080 * 4 / 1024 = 4556.3 KB</span><br></pre></td></tr></table></figure><p>到这里，基本可以看出问题原因：</p><ul><li>Glide 认为 <code>wrap_content</code> 的 ImageView 大小为 1080x2150</li><li>Glide 先将大小为 180x180 的图片 <code>decode</code> 成 180x180 的 Bitmap，之后又该 Bitmap <code>transform</code> 成 1080x1080 的 Bitmap</li></ul><h2 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h2><h3 id="为什么有-transformation"><a href="#为什么有-transformation" class="headerlink" title="为什么有 transformation"></a>为什么有 transformation</h3><p>前文提到过，Glide 的磁盘缓存对象也是 transform 后的 Bitmap，这样通常可以更省存储空间，并且之后读取磁盘缓存性能也更好。</p><p><a href="https://github.com/bumptech/glide/blob/v3.7.0/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java#L127" target="_blank" rel="noopener">DecodeJob</a> 相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Z&gt; <span class="title">decodeFromSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Resource&lt;T&gt; decoded = decodeSource();</span><br><span class="line">    <span class="keyword">return</span> transformEncodeAndTranscode(decoded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;Z&gt; <span class="title">transformEncodeAndTranscode</span><span class="params">(Resource&lt;T&gt; decoded)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;T&gt; transformed = transform(decoded);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Transformed resource from source"</span>, startTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writeTransformedToCache(transformed);</span><br><span class="line"></span><br><span class="line">    startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Transcoded transformed from source"</span>, startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeTransformedToCache</span><span class="params">(Resource&lt;T&gt; transformed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (transformed == <span class="keyword">null</span> || !diskCacheStrategy.cacheResult()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    SourceWriter&lt;Resource&lt;T&gt;&gt; writer = <span class="keyword">new</span> SourceWriter&lt;Resource&lt;T&gt;&gt;(loadProvider.getEncoder(), transformed);</span><br><span class="line">    diskCacheProvider.getDiskCache().put(resultKey, writer);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Wrote transformed from source to cache"</span>, startTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Transformation-策略"><a href="#Transformation-策略" class="headerlink" title="Transformation 策略"></a>Transformation 策略</h3><p>Transformation 的选择策略见 <a href="https://github.com/bumptech/glide/blob/v3.7.0/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java" target="_blank" rel="noopener">GenericRequestBuilder</a>，源码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transform resources with the given &#123;<span class="doctag">@link</span> Transformation&#125;s. Replaces any existing transformation or</span></span><br><span class="line"><span class="comment"> * transformations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> transformations the transformations to apply in order.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> This request builder.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; <span class="title">transform</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Transformation&lt;ResourceType&gt;... transformations)</span> </span>&#123;</span><br><span class="line">    isTransformationSet = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (transformations.length == <span class="number">1</span>) &#123;</span><br><span class="line">        transformation = transformations[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        transformation = <span class="keyword">new</span> MultiTransformation&lt;ResourceType&gt;(transformations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the current &#123;<span class="doctag">@link</span> com.bumptech.glide.load.Transformation&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> This request builder.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; <span class="title">dontTransform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Transformation&lt;ResourceType&gt; transformation = UnitTransformation.get();</span><br><span class="line">    <span class="keyword">return</span> transform(transformation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Target&lt;TranscodeType&gt; <span class="title">into</span><span class="params">(ImageView view)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must pass in a non null View"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isTransformationSet &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">                applyCenterCrop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">            <span class="keyword">case</span> FIT_START:</span><br><span class="line">            <span class="keyword">case</span> FIT_END:</span><br><span class="line">                applyFitCenter();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//$CASES-OMITTED$</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// Do nothing.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> into(glide.buildImageViewTarget(view, transcodeClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>默认是基于 <code>ImageView</code> 的 <code>scaleType</code> 自动选择 transformation<ul><li>CENTER_CROP 时选择 <code>CenterCrop</code></li><li>FIT_CENTER, FIT_START, FIT_END 时选择 <code>FitCenter</code></li><li>其他情况使用默认的 <code>UnitTransformation</code></li></ul></li><li>如果 <code>GenericRequestBuilder.transform()</code> 方法指定了 transformation，则优先使用这个 transformation</li></ul><p>用户可以调用 <code>GenericRequestBuilder.dontTransform()</code> 方法来禁用 transform 操作。<code>dontTransform()</code> 实际上是调用 <code>transform()</code> 方法来指定 <code>UnitTransformation</code> 作为 transformation。<code>UnitTransformation</code> 并不进行任何操作，而是直接返回原始的 Bitmap。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于大小为 <code>wrap_content</code> 的 ImageView，Glide 会”误认为”其大小为屏幕大小，所以可能将一个原本较小地图片错误地 transform 成一个较大的 Bitmap，从而引起不必要的内存开销。</p><p>建议使用 Glide 时不要将 ImageView 的大小设置为 <code>wrap_content</code>。以这个布局中的 <code>iv_tag</code> 为例，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:scaleType</span>=<span class="string">"fitStart"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/iv_tag"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignStart</span>=<span class="string">"@id/iv_bg"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignTop</span>=<span class="string">"@id/iv_bg"</span></span></span><br><span class="line"><span class="tag">     /&gt;</span></span><br></pre></td></tr></table></figure><p>考虑到这个图片的实际大小为 180x180 像素，</p><p><img src="https://game.gtimg.cn/images/user/cp/wxsystemToC20170712/store_2/list0517/img-label/shangxin-f.png" width="90" height="90"></p><p>如果将 <code>iv_tag</code> 大小由 <code>wrap_content</code> 修改为 <code>60dp</code>：</p><ul><li>在华为 nova 2 (3倍屏) 上不再生成一个额外的大小为 4MB 的 Bitmap </li><li>其他非3倍屏的手机上仍然会有一个额外的 Bitmap，但大小仅几十KB到几百KB</li></ul><p>至此，应用内存轻松减少 4MB，问题解决！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译) 掌握 Kotlin 的 run, with, let, also 以及 apply 方法</title>
      <link href="2019/06/24/mastering-kotlin-standard-functions-run-with-let-also-and-apply/"/>
      <url>2019/06/24/mastering-kotlin-standard-functions-run-with-let-also-and-apply/</url>
      
        <content type="html"><![CDATA[<p>Kotlin 的 <code>run</code>, <code>with</code>, <code>let</code>, <code>also</code> 和 <code>apply</code> 方法经常傻傻分不清？翻译一篇不错的文章，教你掌握这些方法的简单技巧。<br><a id="more"></a><br>翻译自 <a href="https://medium.com/@elye.project/mastering-kotlin-standard-functions-run-with-let-also-and-apply-9cd334b0ef84" target="_blank" rel="noopener">Mastering Kotlin standard functions: run, with, let, also and apply</a></p><p>Kotlin 的一些<a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/util/Standard.kt" target="_blank" rel="noopener">标准函数</a>如此相似以至我们有时搞不清该用哪个。我在本文中介绍一种简单的方法来明确地区分它们。</p><h1 id="Scoping-functions"><a href="#Scoping-functions" class="headerlink" title="Scoping functions"></a>Scoping functions</h1><p>我重点关注的的函数是 <code>run</code>, <code>with</code>, <code>T.run</code>, <code>T.let</code>, <code>T.also</code> 以及 <code>T.apply</code>。我将这些函数称为 scoping functions，因为它们的主要功能是为调用函数提供一个 inner scope。</p><p>展示 scoping 的最简单方法是调用 <code>run</code> 函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mood = <span class="string">"I am sad"</span></span><br><span class="line"></span><br><span class="line">    run &#123;</span><br><span class="line">        <span class="keyword">val</span> mood = <span class="string">"I am happy"</span></span><br><span class="line">        println(mood) <span class="comment">// I am happy</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(mood)  <span class="comment">// I am sad</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 test 函数内部，可以使用了一个单独的 scope。在这个单独的 scope 中 <code>mood</code> 在打印前被重新定义为 <code>I am happy</code>，重定义和打印都在 <code>run</code> 指定的 scope 中。</p><p>仅仅使用 scoping 函数作用并不大。它还有另外一个好处：即，有返回值。<code>run</code> 函数返回当前 scope 中的最近的一个对象。</p><p>这让代码看起来很干净。下面代码中我们可以对两种 view 调用 <code>show()</code>，而不必将代码写两次：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run &#123;</span><br><span class="line">    <span class="keyword">if</span> (firstTimeView) introView <span class="keyword">else</span> normalView</span><br><span class="line">&#125;.show()</span><br></pre></td></tr></table></figure><h1 id="3-attributes-of-scoping-functions"><a href="#3-attributes-of-scoping-functions" class="headerlink" title="3 attributes of scoping functions"></a>3 attributes of scoping functions</h1><p>To make scoping functions more interesting, let me categorize their behavior with 3 attributes. I will use these attributes to distinguish them from each others.</p><h2 id="1-Normal-vs-extension-function"><a href="#1-Normal-vs-extension-function" class="headerlink" title="1. Normal vs. extension function"></a>1. Normal vs. extension function</h2><p><code>with</code> 函数和 <code>T.run</code> 函数非常相似。看如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">with(webview.settings) &#123;</span><br><span class="line">    javaScriptEnabled = <span class="literal">true</span></span><br><span class="line">    databaseEnabled = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// similarly</span></span><br><span class="line">webview.settings.run &#123;</span><br><span class="line">    javaScriptEnabled = <span class="literal">true</span></span><br><span class="line">    databaseEnabled = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但其实二者是有区别的。<code>with</code> 是一个普通函数，而 <code>T.run</code> 是扩展函数。</p><p>所以问题是，该优先使用哪一个呢？</p><p>假设 <code>webview.settings</code> 可能为 <code>null</code>，有如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Yack!</span></span><br><span class="line">with(webview.settings) &#123;</span><br><span class="line">      <span class="keyword">this</span>?.javaScriptEnabled = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">this</span>?.databaseEnabled = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Nice.</span></span><br><span class="line">webview.settings?.run &#123;</span><br><span class="line">    javaScriptEnabled = <span class="literal">true</span></span><br><span class="line">    databaseEnabled = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个案例中，显然 <code>T.run</code> 扩展方法更好，因为我们可以在使用前检查 <code>webview.settings</code> 是否为空。</p><h2 id="2-This-vs-it-argument"><a href="#2-This-vs-it-argument" class="headerlink" title="2. This vs. it argument"></a>2. This vs. it argument</h2><p><code>T.run</code> 和 <code>T.let</code> 也很相似，唯一不同是它们接收参数的方式。如下代码实现了相同的逻辑：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringVariable?.run &#123;</span><br><span class="line">      println(<span class="string">"The length of this String is <span class="variable">$length</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Similarly.</span></span><br><span class="line">stringVariable?.let &#123;</span><br><span class="line">      println(<span class="string">"The length of this String is <span class="subst">$&#123;it.length&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果看 <code>T.run</code> 函数签名，你会注意到 <code>T.run</code> 只是调用 <code>block: T.()</code> 的扩展函数。所以在其 scope 中，可以使用 <code>this</code> 来访问 <code>T</code> 对象本身。Kotlin 编程语言中，大部分时候可以忽略 <code>this</code>。所以这个例子中，可以在 <code>println</code> 语句中使用 <code>$length</code> 来代替 <code>${this.length}</code>。我将之称为将 this 作为参数。(原文 I call this as sending in this as argument.) </p><p>但是看 <code>T.let</code> 函数签名，你会注意到 <code>T.let</code> 将自身传到 <code>block: (T)</code> 函数中。这很像一个 lambda 参数。可以使用 <code>it</code> 在 scope 中访问这个参数。我将之称为将 it 作为参数。(原文 So I call this as sending in it as argument.)</p><p>所以看起来 <code>T.run</code> 比 <code>T.let</code> 更好，因为代码更简单。但 <code>T.let</code> 函数有如下好处：</p><ul><li><code>T.let</code> 提供使用指定的 <code>it</code> 变量来更明确地区分是访问 <code>it</code> 的函数/成员还是访问外部类的函数/成员</li><li>在 <code>this</code> 不能被省略的场景下，<code>it</code> 作为函数的参数，它比 <code>this</code> 更简短</li><li><code>T.let</code> 允许为参数指定更有意义更明确的名字，而非 <code>it</code> 或 <code>this</code></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stringVariable?.let &#123;</span><br><span class="line">      nonNullString -&gt;</span><br><span class="line">      println(<span class="string">"The non null string is <span class="variable">$nonNullString</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Return-this-vs-other-type"><a href="#3-Return-this-vs-other-type" class="headerlink" title="3. Return this vs. other type"></a>3. Return this vs. other type</h2><p>现在来看 <code>T.let</code> 和 <code>T.also</code>，如果我们从函数 scope 的角度来看它们的话，发现二者是一样的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringVariable?.let &#123;</span><br><span class="line">      println(<span class="string">"The length of this String is <span class="subst">$&#123;it.length&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Exactly the same as below</span></span><br><span class="line">stringVariable?.also &#123;</span><br><span class="line">      println(<span class="string">"The length of this String is <span class="subst">$&#123;it.length&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是它们的返回值有细微的不同之处。<code>T.let</code> 返回值的类型不同于 <code>T</code>，而 <code>T.also</code> 返回 <code>T</code> 对象本身。</p><p>二者在链式调用中都很有用。<code>T.let</code> 返回你 evolve the operation，而<code>T.also</code> 允许你对同一变量进行操作。</p><p>如下是简单示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">val original = &quot;abc&quot;</span><br><span class="line">// Evolve the value and send to the next chain</span><br><span class="line">original.let &#123;</span><br><span class="line">    println(&quot;The original String is $it&quot;) // &quot;abc&quot;</span><br><span class="line">    it.reversed() // evolve it as parameter to send to next let</span><br><span class="line">&#125;.let &#123;</span><br><span class="line">    println(&quot;The reverse String is $it&quot;) // &quot;cba&quot;</span><br><span class="line">    it.length  // can be evolve to other type</span><br><span class="line">&#125;.let &#123;</span><br><span class="line">    println(&quot;The length of the String is $it&quot;) // 3</span><br><span class="line">&#125;</span><br><span class="line">// Wrong</span><br><span class="line">// Same value is sent in the chain (printed answer is wrong)</span><br><span class="line">original.also &#123;</span><br><span class="line">    println(&quot;The original String is $it&quot;) // &quot;abc&quot;</span><br><span class="line">    it.reversed() // even if we evolve it, it is useless</span><br><span class="line">&#125;.also &#123;</span><br><span class="line">    println(&quot;The reverse String is $&#123;it&#125;&quot;) // &quot;abc&quot;</span><br><span class="line">    it.length  // even if we evolve it, it is useless</span><br><span class="line">&#125;.also &#123;</span><br><span class="line">    println(&quot;The length of the String is $&#123;it&#125;&quot;) // &quot;abc&quot;</span><br><span class="line">&#125;</span><br><span class="line">// Corrected for also (i.e. manipulate as original string</span><br><span class="line">// Same value is sent in the chain </span><br><span class="line">original.also &#123;</span><br><span class="line">    println(&quot;The original String is $it&quot;) // &quot;abc&quot;</span><br><span class="line">&#125;.also &#123;</span><br><span class="line">    println(&quot;The reverse String is $&#123;it.reversed()&#125;&quot;) // &quot;cba&quot;</span><br><span class="line">&#125;.also &#123;</span><br><span class="line">    println(&quot;The length of the String is $&#123;it.length&#125;&quot;) // 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中 <code>T.also</code> 看起来没有意义，因为可以很容易将其前后的语句封装成一个方法。但仔细思考会发现它有如下好处： </p><ul><li>它可清晰地分离对同一个对象的不同操作，从而有更小的方法</li><li>在使用前对自身进行自操作非常强大，可以进行链式 builder 操作</li></ul><p>当两者结合使用时，非常强大。如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Normal approach</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">makeDir</span><span class="params">(path: <span class="type">String</span>)</span></span>: File  &#123;</span><br><span class="line">    <span class="keyword">val</span> result = File(path)</span><br><span class="line">    result.mkdirs()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Improved approach</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">makeDir</span><span class="params">(path: <span class="type">String</span>)</span></span> = path.let&#123; File(it) &#125;.also&#123; it.mkdirs() &#125;</span><br></pre></td></tr></table></figure><p>(个人感觉这里没有必要使用 <code>let</code>，直接 <code>= File(path).also { it.mkdirs() }</code> 不是更好 )</p><h1 id="Looking-at-all-attributes"><a href="#Looking-at-all-attributes" class="headerlink" title="Looking at all attributes"></a>Looking at all attributes</h1><p>By looking at the 3 attributes, we could pretty much know the function behavior. Let me illustrate on the T.apply function, as it has not be mentioned above. The 3 attributes of T.apply is as below…</p><p>通过3个属性可以更好地了解函数行为。这里演示 <code>T.apply()</code> 的用法，因为上面没有提到这个函数。<code>T.apply()</code> 函数的3个属性如下：</p><ul><li>它是扩展函数</li><li>它将 <code>this</code> 作为参数</li><li>它返回 <code>this</code></li></ul><p>所以可以按如下方式使用该方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Normal approach</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createInstance</span><span class="params">(args: <span class="type">Bundle</span>)</span></span> : MyFragment &#123;</span><br><span class="line">    <span class="keyword">val</span> fragment = MyFragment()</span><br><span class="line">    fragment.arguments = args</span><br><span class="line">    <span class="keyword">return</span> fragment</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Improved approach</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createInstance</span><span class="params">(args: <span class="type">Bundle</span>)</span></span> </span><br><span class="line">              = MyFragment().apply &#123; arguments = args &#125;</span><br></pre></td></tr></table></figure><p>我们甚至可以将不支持链式调用的对象创建过程变成链式调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Normal approach</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createIntent</span><span class="params">(intentData: <span class="type">String</span>, intentAction: <span class="type">String</span>)</span></span>: Intent &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent()</span><br><span class="line">    intent.action = intentAction</span><br><span class="line">    intent.<span class="keyword">data</span>=Uri.parse(intentData)</span><br><span class="line">    <span class="keyword">return</span> intent</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Improved approach, chaining</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createIntent</span><span class="params">(intentData: <span class="type">String</span>, intentAction: <span class="type">String</span>)</span></span> =</span><br><span class="line">        Intent().apply &#123; action = intentAction &#125;</span><br><span class="line">                .apply &#123; <span class="keyword">data</span> = Uri.parse(intentData) &#125;</span><br></pre></td></tr></table></figure><h1 id="Function-selections"><a href="#Function-selections" class="headerlink" title="Function selections"></a>Function selections</h1><p>所以我们可以根据这3个属性将函数分类。并且基于这个分类，得到了下图中的决策树，它可以帮我们选择需要使用的方法：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/201906/1_pLNnrvgvmG6Mdi0Yw3mdPQ.png" alt></p><p>希望这个决策树可以让你更清晰地区分这几个函数，更容易做出选择，并且熟练掌握它们的用法。</p><p>你也可以在回复中给我提供一些实际项目中的好例子。希望听到你的回音。你将帮到别人。</p><p>希望你喜欢这篇文章，希望这篇文章对你有帮助。欢迎分享。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 小技巧之扩大点击区域</title>
      <link href="2019/06/20/extend-view-touchable-area/"/>
      <url>2019/06/20/extend-view-touchable-area/</url>
      
        <content type="html"><![CDATA[<p>这里介绍 Android 开发中的一个小技巧：扩大 View 的 touchable area。扩大 touchable area 后可以让 View 的可点击区域大于其自身显示区域，某些场景下很有用。<br><a id="more"></a></p><h1 id="TouchDelegate"><a href="#TouchDelegate" class="headerlink" title="TouchDelegate"></a>TouchDelegate</h1><p>以下是 <a href="https://developer.android.com/reference/android/view/TouchDelegate.html" target="_blank" rel="noopener">TouchDelegate</a> 的文档。</p><blockquote><p>Helper class to handle situations where you want a view to have a larger touch area than its actual view bounds. The view whose touch area is changed is called the delegate view. This class should be used by an ancestor of the delegate. To use a TouchDelegate, first create an instance that specifies the bounds that should be mapped to the delegate and the delegate view itself.</p></blockquote><blockquote><p>The ancestor should then forward all of its touch events received in its View.onTouchEvent(MotionEvent) to onTouchEvent(android.view.MotionEvent).</p></blockquote><p>看文档可知 TouchDelegate 就是专门为修改 view 的点击区域而生。</p><p>以下翻译至<a href="https://developer.android.com/training/gestures/viewgroup.html#delegate" target="_blank" rel="noopener">官方文档</a>。</p><p>Android 中的 <code>TouchDelegate</code> 类可用于扩展子节点的 touchable area，让子节点的 touchable area 可以超出其本身的边界。当子节点很小，需要更大 touch 区域时这个技巧很有用。当然，你也可以使用这个技巧来缩小 touch 区域。</p><p>以下例子中，<code>ImageButton</code> 是代理 view (即，父节点会扩展其 touch 区域)。布局文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:id</span>=<span class="string">"@+id/parent_layout"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">ImageButton</span> <span class="attr">android:id</span>=<span class="string">"@+id/button"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:background</span>=<span class="string">"@null"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:src</span>=<span class="string">"@drawable/icon"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以下的代码片断操作这几个操作：</p><ul><li>获取父节点，并且在主线程中发一个 <code>Runnable</code> 消息。这可以保证调用 <code>getHitRect()</code> 方法前父节点已完成子节点的布局工作。<code>getHitRect()</code> 方法用于获取子节点的点击区域(touchable area)</li><li>获取子节点(在这里是 <code>ImageButton</code>)，并且调用 <code>getHitRect()</code> 来获取其 touchable area 的边界</li><li>扩展 <code>ImageButton</code> 可点击区域的边界</li><li>实例化一个 <code>TouchDelegate</code>，传入的构造参数包括点击区域边界以及 <code>ImageButton</code> 对象本身</li><li>在父节点上设置 <code>TouchDelegate</code>，这样能让在 touch delegate 边界内发生的 touch event 被路由到 <code>ImageButton</code></li></ul><p>作为 <code>ImageButton</code> 这个子节点的 touch delegate，父节点将收到所有的 touch event。如果 touch event 发生在子节点的点击区域内，父节点会将这些 touch event 传递给子节点处理。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">Activity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Post in the parent's message queue to make sure the parent</span></span><br><span class="line">        <span class="comment">// lays out its children before you call getHitRect()</span></span><br><span class="line">        findViewById&lt;View&gt;(R.id.parent_layout).post &#123;</span><br><span class="line">            <span class="comment">// The bounds for the delegate view (an ImageButton</span></span><br><span class="line">            <span class="comment">// in this example)</span></span><br><span class="line">            <span class="keyword">val</span> delegateArea = Rect()</span><br><span class="line">            <span class="keyword">val</span> myButton = findViewById&lt;ImageButton&gt;(R.id.button).apply &#123;</span><br><span class="line">                isEnabled = <span class="literal">true</span></span><br><span class="line">                setOnClickListener &#123;</span><br><span class="line">                    Toast.makeText(</span><br><span class="line">                            <span class="keyword">this</span><span class="symbol">@MainActivity</span>,</span><br><span class="line">                            <span class="string">"Touch occurred within ImageButton touch region."</span>,</span><br><span class="line">                            Toast.LENGTH_SHORT</span><br><span class="line">                    ).show()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// The hit rectangle for the ImageButton</span></span><br><span class="line">                getHitRect(delegateArea)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Extend the touch area of the ImageButton beyond its bounds</span></span><br><span class="line">            <span class="comment">// on the right and bottom.</span></span><br><span class="line">            delegateArea.right += <span class="number">100</span></span><br><span class="line">            delegateArea.bottom += <span class="number">100</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Sets the TouchDelegate on the parent view, such that touches</span></span><br><span class="line">            <span class="comment">// within the touch delegate bounds are routed to the child.</span></span><br><span class="line">            (myButton.parent <span class="keyword">as</span>? View)?.apply &#123;</span><br><span class="line">                <span class="comment">// Instantiate a TouchDelegate.</span></span><br><span class="line">                <span class="comment">// "delegateArea" is the bounds in local coordinates of</span></span><br><span class="line">                <span class="comment">// the containing view to be mapped to the delegate view.</span></span><br><span class="line">                <span class="comment">// "myButton" is the child view that should receive motion</span></span><br><span class="line">                <span class="comment">// events.</span></span><br><span class="line">                touchDelegate = TouchDelegate(delegateArea, myButton)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>我自己动手将这个示例改了一下，代码见 <a href="https://github.com/410063005/cmdemo/blob/master/app/src/main/java/com/sunmoonblog/cmdemo/layout/TouchDelegateActivity.kt" target="_blank" rel="noopener">Github</a>。</p><p>截图如下：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/mweb/2019/06/19/touchdelegate.gif" width="40%" height="40%"></p><p>从截图可以看出，扩大 <code>ImageButton</code> 的 touchable area 后，其点击区域也随着变大。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://developer.android.com/training/gestures/viewgroup.html#delegate" target="_blank" rel="noopener">官方文档</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Hexo + MWeb 写博客</title>
      <link href="2019/06/19/hexo-and-mweb/"/>
      <url>2019/06/19/hexo-and-mweb/</url>
      
        <content type="html"><![CDATA[<p>上周开始试用了 MWeb，不得不说好用。感觉我写 Markdown 的工具可以升级了(原先使用的 LiteIDE)，效率就要提升了。不得不记录下来，以示庆祝！<br><a id="more"></a></p><h1 id="LiteIDE"><a href="#LiteIDE" class="headerlink" title="LiteIDE"></a>LiteIDE</h1><p>LiteIDE 写 Markdown 还不错。但仅仅是不错而已，还是有些地方用得不爽：</p><ul><li>预览不便</li><li>贴图不便</li></ul><p>(毕竟 LiteIDE 免费的，而且本身也不是专门为写 Markdown 而生，所以要求不能太高。还是要感谢作者开发出 LiteIDE 这个工具)</p><p>首先说预览问题。第一，hexo 写博客时，无法从 LiteIDE 中预览本地图片。第二，Alt + 4 在右下方打开预览窗口个人觉得操作不太舒服。</p><p>再说贴图问题。一图胜千言，所以写博客时免不了贴图。之前想了很多方法来简化这个过程，比如配置 Alfred 工具流之类的，自动将剪贴板的图片保存到 hexo 的目录下。然而不好用就是不好用，太繁琐，我只想简简单单写博客而已，不想扯什么高大上的 Alfred。</p><h1 id="MWeb"><a href="#MWeb" class="headerlink" title="MWeb"></a>MWeb</h1><p>2019年6月开始试用 MWeb。一开始是觉得有以下几个好处：</p><ul><li>MWeb 界面做得不错，性能跟宣称的一样好</li><li>很快就找到一个看起来很舒服的主题，Tommorrow 主题</li><li>贴图方便，Command + V 就完事，能直接看到图片效果</li><li>Command + R 进入预览模式。对全屏的！(这个是我想要的效果)</li></ul><p>随着几天的试用，又发现另外的一些好处。</p><h2 id="知识库与静态网站"><a href="#知识库与静态网站" class="headerlink" title="知识库与静态网站"></a>知识库与静态网站</h2><p>MWeb 的搜索功能很强大，所以完全可以使用 MWeb 建立知识库。</p><p>MWeb 支持生成静态网站。只是简单试了一下这个功能，可以生成类似 hexo 风格的博客。单纯一个本地知识库不便分享，MWeb 可以通过知识库生成静态网站。如果想将知识库托管到 GitHub 或腾讯云，生成静态网站功能无疑相当方便。</p><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>MWeb 支持配置各种图床。所以立马充钱买了腾讯云 COS 服务，配了个图床。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/mweb/2019/06/19/15609364692688.jpg" alt></p><p>最贴心的地方 MWeb 可以将 Markdown 中引用的本地图片上传到图床，然后将本地图片地址替换成网络图片地址。</p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>习惯使用 Hexo 写博客。博客源码托管在 Codeing，静态页面托管在 GitHub，Hexo 主题用的是 Next。</p><p>MWeb 中 Command + E 打开外部模式，然后导入 Hexo 的 source 目录，以前怎么写博客现在就还是怎么写博客。流程没变，但贴图简单，预览方便，所以结果是效率提高！</p><p>具体做法可以参考 <a href="https://zhuanlan.zhihu.com/p/30513914" target="_blank" rel="noopener">MWeb配合 Hexo 高效管理博客</a>。</p><h1 id="时间表"><a href="#时间表" class="headerlink" title="时间表"></a>时间表</h1><ul><li>2020-07-04 - 修复 tag 404 问题<ul><li><a href="https://hexo.io/docs/configuration.html#Site" target="_blank" rel="noopener">filename_case: 1</a></li><li><a href="https://github.com/hexojs/hexo/issues/70" target="_blank" rel="noopener">Issue #70 · hexojs/hexo</a></li><li><a href="https://joejztang.github.io/2018/03/21/hexo-categories-tags-404-issue-on-github/" target="_blank" rel="noopener">hexo categories/tags 404 issue on github | 130L blog</a></li></ul></li><li>2019-11-26 - 添加搜索功能。参考 <a href="https://qiuyiwu.github.io/2019/01/25/Hexo-LocalSearch/" target="_blank" rel="noopener">1</a> 和 <a href="https://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">2</a></li><li>2018-08-12 - 开启 HTTPS，图片压缩，添加评论</li><li>时间点待考证 - 博客源码托管在 git.coding.net</li><li>2017-02-09 - 新年，开始写博客</li><li>时间点待考证 - 购买 sunmoonblog.com 域名</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.mweb.im/how_to_use_tencent_cos.html" target="_blank" rel="noopener">如何使用腾讯云 COS 图床</a></li><li><a href="https://zhuanlan.zhihu.com/p/30513914" target="_blank" rel="noopener">MWeb配合 Hexo 高效管理博客</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 读写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bitmap 之从出生到死亡</title>
      <link href="2019/06/15/bitmap-creation/"/>
      <url>2019/06/15/bitmap-creation/</url>
      
        <content type="html"><![CDATA[<p>Bitmap 不像四大组件一样有明确定义的生命周期。但作为 Java 对象，Bitmap 仍然有一个从出生到死亡的过程，它是内存超级大户，所以了解内存在其生命周期中是如何被分配和销毁是必要的。本文试图理清创建和销毁 Bitmap 过程的主脉络，忽略一些细节，重点聚焦内存分配与回收。如有疏漏，欢迎批评指正。</p><a id="more"></a><p>Bitmap 占内存多是因为其像素数据(pixels)大。Bitmap 像素数据的存储在不同 Android 版本之间有所不同，具体来说：</p><ul><li>Android 2.3 (API Level 10) 以及之前 - 像素数据保存在 native heap</li><li>Android 3.0 到 Android 7.1 (API Level 11-26) - 像素数据保存在 java heap</li><li>Android 8.0 以及之后 - 像素数据保存在 native heap</li></ul><p>这种变化导致不同 Android 版本间 Bitmap 相关的代码可能有较大差异。本文基于 <a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/oreo-release/core/jni/android/graphics/Bitmap.cpp" target="_blank" rel="noopener">Android 8.0 源码</a>分析。</p><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>先从整体上看一下 Bitmap。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/201906/bitmap-creation-arch.png?imageView2/2/w/300" alt></p><ul><li>用户在手机屏幕上看到的是一张张图片</li><li>App 中这些图片实际上是 BitmapDrawable</li><li>BitmapDrawable 是对 Bitmap 的包装</li><li>Bitmap 是对 SkBitmap 的包装。具体说来， Bitmap 的实现包括 Java 层和 JNI 层，JNI 层依赖 <a href="https://github.com/google/skia" target="_blank" rel="noopener">Skia</a>。</li><li>SkBitmap 本质上可简单理解为内存中的一个字节数组</li></ul><p>所以说 Bitmap 其实是一个字节数组。创建 Bitmap 是在内存中分配一个字节数组，销毁 Bitmap 则是回收这个字节数组。</p><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><p>创建 Bitmap 的方式很多，</p><ul><li>可以通过 SDK 提供的 API 来创建 Bitmap</li><li>加载某些布局或资源时会创建 Bitmap</li><li><a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">Glide</a> 等第三方图片库会创建 Bitmap</li></ul><p>先说通过 API 创建 Bitmap。SDK 中创建 Bitmap 的 API 很多，分成三大类：</p><ul><li><strong>创建</strong> Bitmap - <code>Bitmap.createBitmap()</code> 方法在内存中从无到有地创建 Bitmap</li><li><strong>拷贝</strong> Bitmap - <code>Bitmap.copy()</code> 从已有的 Bitmap 拷贝出一个新的 Bitmap</li><li><strong>解码</strong> - 从文件或字节数组等资源解码得到 Bitmap，这是最常见的创建方式<ul><li>BitmapFactory.decodeResource()</li><li><a href="https://developer.android.com/reference/android/graphics/ImageDecoder" target="_blank" rel="noopener">ImageDecoder.decodeBitmap</a>。ImageDecoder 是 Android 9.0 新加的类</li></ul></li></ul><p>假设 <code>resId</code> 对应的是一张图片。加载如下布局文件时会创建一个 Bitmap：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span> <span class="attr">android:src</span>=<span class="string">"@drawable/resId"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码中加载资源也会创建出一个 Bitmap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Drawable drawable = Resources.getDrawable(resId)</span><br></pre></td></tr></table></figure><p>实际项目中往往不是直接调用 API 来创建 Bitmap，而是使用 <a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">Glide</a> 或 <a href="https://github.com/square/picasso" target="_blank" rel="noopener">Picosso</a> 等第三方图片库。这些库成熟稳定，接口易用，开发中处理 Bitmap 变得轻松。</p><p>以 Glide 为例，只要一行代码可以很方便地从网络上加载一张图片。但另一方面，Glide 也让 Bitmap 的创建更加多样和复杂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>).load(<span class="string">"http://goo.gl/gEgYUd"</span>).into(imageView);</span><br></pre></td></tr></table></figure><p>太多的创建 Bitmap 的方式，简直让人头大。但好在无论哪种创建方式，最终殊途同归。见下图：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/201906/bitmap-creation-overview.png" alt></p><p><strong>Java 层的创建 Bitmap 的所有 API 进入到 Native 层后，全都会走如下这四个步骤</strong>。</p><ul><li>资源转换 - 这一步将 Java 层传来的不同类型的资源转换成解码器可识别的数据类型</li><li>内存分配 - 分配内存时会考虑是否复用 Bitmap、是否缩放 Bitmap 等因素</li><li>图片解码 - 实际的解码工作由第三方库完成，解码结果填在上一步分配的内存中。注，<code>Bitmap.createBitmap()</code> 和 <code>Bitmap.copy()</code> 创建的 Bitmap 不需要进行图片解码</li><li>创建对象 - 这一步将包含解码数据的内存块包装成 Java 层的 <code>android.graphics.Bitmap</code> 对象，方便 App 使用</li></ul><p>内存分配和图片解码由 <a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/oreo-release/core/jni/android/graphics/BitmapFactory.cpp#233" target="_blank" rel="noopener">BitmapFactory.doDecode()</a> 函数完成。它是创建 Bitmap 的核心，主要负责内存分配和图片解码。其关键步骤包括：</p><ol><li>Update with options supplied by the client.</li><li>Create the codec.</li><li>Handle sampleSize. (跟 BitmapFactory.Options.inSampleSize 参数相关)</li><li>Set the decode colorType.</li><li>Handle scale.  (跟 BitmapFactory.Options.inScaled 参数相关)</li><li>Handle reuseBitmap (跟 BitmapFactory.Options.inBitmap 参数相关)</li><li>Choose decodeAllocator</li><li>Construct a color table</li><li>AllocPixels </li><li>Use SkAndroidCodec to perform the decode.</li><li>Create the java bitmap</li></ol><p>我们先简单说说资源转换，稍后详细讨论内存分配和图片解码(包括第7, 9, 10步)。</p><h2 id="资源转换"><a href="#资源转换" class="headerlink" title="资源转换"></a>资源转换</h2><p>解码前的第一项工作是资源转换。Java 层的待解码资源包括：</p><ul><li>File</li><li>Resource</li><li>ByteArray</li><li>Stream</li><li>FileDescriptor</li></ul><p>第一步，在 JNI 层将待解码的资源重新划分成四种，包括：</p><ul><li>FileDescriptor</li><li>Asset</li><li>ByteArray</li><li>DecodeAsset</li></ul><p>第二步，<code>BitmapFactory</code> 提供四个方法对资源进行转换，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nativeDecodeFileDescriptor()</span><br><span class="line">nativeDecodeAsset()</span><br><span class="line">nativeDecodeByteArray()</span><br><span class="line">nativeDecodeAsset()</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/201906/bitmap-creation-convert-resource.png" alt></p><p>所有的资源都会转换成与 <code>SkStreamRewindable</code> 兼容的数据。</p><p>最后，<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/oreo-release/core/jni/android/graphics/BitmapFactory.cpp#233" target="_blank" rel="noopener">BitmapFactory.doDecode()</a> 统一解码处理 <code>SkStreamRewindable</code>。 </p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>解码前的第二项工作是内存分配。</p><p>首先是选择 decodeAllocator (见上文提到的 <code>BitmapFactory.doDecode()</code> 的第7步)。有以下几种 Allocator 可供选择：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/201906/bitmap-createion-allocator-classes.png" alt></p><p>选择 Allocator 时考虑的因素包括：是否复用已有 Bitmap，是否会缩放 Bitmap，是否是 Hardware Bitmap。选择策略总结如下：</p><table><thead><tr><th>是否复用已有 Bitmap</th><th>是否会缩放 Bitmap</th><th>是否是 Hardware Bitmap</th><th>Allocator类型</th></tr></thead><tbody><tr><td>是</td><td>是</td><td>-</td><td><a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/oreo-release/core/jni/android/graphics/BitmapFactory.cpp#144" target="_blank" rel="noopener">ScaleCheckingAllocator</a></td></tr><tr><td>是</td><td>否</td><td>-</td><td><a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/oreo-release/core/jni/android/graphics/GraphicsJNI.h#171" target="_blank" rel="noopener">RecyclingPixelAllocator</a></td></tr><tr><td>否</td><td>是</td><td>是</td><td><a href="https://github.com/google/skia/blob/master/include/core/SkBitmap.h#L1119" target="_blank" rel="noopener">SkBitmap::HeapAllocator</a></td></tr><tr><td>-</td><td>-</td><td>-</td><td><a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/oreo-release/core/jni/android/graphics/GraphicsJNI.h#125" target="_blank" rel="noopener">HeapAllocator</a> (缺省的Allocator)</td></tr></tbody></table><p>接下来，使用选定的 Allocator 分配内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.doDecode() -&gt;</span><br><span class="line">SkBitmap.tryAllocPixels() -&gt;</span><br><span class="line">    Allocator.allocPixelRef()</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BitmapFactory.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">doDecode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    SkBitmap decodingBitmap;</span><br><span class="line">    <span class="keyword">if</span> (!decodingBitmap.setInfo(bitmapInfo) ||</span><br><span class="line">            !decodingBitmap.tryAllocPixels(decodeAllocator, colorTable.get())) &#123;</span><br><span class="line">        <span class="comment">// SkAndroidCodec should recommend a valid SkImageInfo, so setInfo()</span></span><br><span class="line">        <span class="comment">// should only only fail if the calculated value for rowBytes is too</span></span><br><span class="line">        <span class="comment">// large.</span></span><br><span class="line">        <span class="comment">// tryAllocPixels() can fail due to OOM on the Java heap, OOM on the</span></span><br><span class="line">        <span class="comment">// native heap, or the recycled javaBitmap being too small to reuse.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SkBitmap.cpp https://github.com/google/skia/blob/master/src/core/SkBitmap.cpp#L213</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SkBitmap::tryAllocPixels</span><span class="params">(Allocator* allocator)</span> </span>&#123;</span><br><span class="line">    HeapAllocator stdalloc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == allocator) &#123;</span><br><span class="line">        allocator = &amp;stdalloc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allocator-&gt;allocPixelRef(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Allocator 的类型有四种，我们只看其中的两种。</p><p>先看 <code>SkBitmap::HeapAllocator</code> 作为 decodeAllocator 进行内存分配的流程。</p><ol><li><a href="https://github.com/google/skia/blob/master/src/core/SkBitmap.cpp#L213" target="_blank" rel="noopener">SkBitmap::tryAllocPixels</a></li><li><a href="https://github.com/google/skia/blob/master/src/core/SkBitmap.cpp#L368" target="_blank" rel="noopener">SkBitmap::HeapAllocator::allocPixelRef</a></li><li><a href="https://github.com/google/skia/blob/master/src/core/SkMallocPixelRef.cpp#L57" target="_blank" rel="noopener">SkMallocPixelRef::MakeAllocate</a></li><li><a href="https://github.com/google/skia/blob/master/include/private/SkMalloc.h#L66" target="_blank" rel="noopener">sk_calloc_canfail</a></li><li><a href="https://github.com/google/skia/blob/master/src/ports/SkMemory_malloc.cpp#L66" target="_blank" rel="noopener">sk_malloc_flags</a></li></ol><p>对应的代码如下(可以看到最终会调用 <code>malloc()</code> 分配指定大小的内存)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** We explicitly use the same allocator for our pixels that SkMask does,</span></span><br><span class="line"><span class="comment"> so that we can freely assign memory allocated by one class to the other.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">bool</span> SkBitmap::HeapAllocator::allocPixelRef(SkBitmap* dst) &#123;</span><br><span class="line">    <span class="keyword">const</span> SkImageInfo info = dst-&gt;info();</span><br><span class="line">    <span class="keyword">if</span> (kUnknown_SkColorType == info.colorType()) &#123;</span><br><span class="line"><span class="comment">//        SkDebugf("unsupported config for info %d\n", dst-&gt;config());</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sk_sp&lt;SkPixelRef&gt; pr = SkMallocPixelRef::MakeAllocate(info, dst-&gt;rowBytes());</span><br><span class="line">    <span class="keyword">if</span> (!pr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dst-&gt;setPixelRef(<span class="built_in">std</span>::move(pr), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    SkDEBUGCODE(dst-&gt;validate();)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SkMallocPixelRef.cpp</span></span><br><span class="line"><span class="function">sk_sp&lt;SkPixelRef&gt; <span class="title">SkMallocPixelRef::MakeAllocate</span><span class="params">(<span class="keyword">const</span> SkImageInfo&amp; info, <span class="keyword">size_t</span> rowBytes)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">void</span>* addr = sk_calloc_canfail(size);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SkMalloc.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span>* <span class="title">sk_calloc_canfail</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(IS_FUZZING_WITH_LIBFUZZER)</span></span><br><span class="line">    <span class="comment">// The Libfuzzer environment is very susceptible to OOM, so to avoid those</span></span><br><span class="line">    <span class="comment">// just pretend we can't allocate more than 200kb.</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">200000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> sk_malloc_flags(size, SK_MALLOC_ZERO_INITIALIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SkMemory_malloc.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">sk_malloc_flags</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* p;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; SK_MALLOC_ZERO_INITIALIZE) &#123;</span><br><span class="line">        p = <span class="built_in">calloc</span>(size, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; SK_MALLOC_THROW) &#123;</span><br><span class="line">        <span class="keyword">return</span> throw_on_failure(size, p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkBitmap::setPixelRef</span><span class="params">(sk_sp&lt;SkPixelRef&gt; pr, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    fPixelRef = kUnknown_SkColorType != <span class="keyword">this</span>-&gt;colorType() ? <span class="built_in">std</span>::move(pr) : <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">void</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">size_t</span> rowBytes = <span class="keyword">this</span>-&gt;rowBytes();</span><br><span class="line">    <span class="comment">// ignore dx,dy if there is no pixelref</span></span><br><span class="line">    <span class="keyword">if</span> (fPixelRef) &#123;</span><br><span class="line">        rowBytes = fPixelRef-&gt;rowBytes();</span><br><span class="line">        <span class="comment">// TODO(reed):  Enforce that PixelRefs must have non-null pixels.</span></span><br><span class="line">        p = fPixelRef-&gt;pixels();</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            p = (<span class="keyword">char</span>*)p + dy * rowBytes + dx * <span class="keyword">this</span>-&gt;bytesPerPixel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SkPixmapPriv::ResetPixmapKeepInfo(&amp;fPixmap, p, rowBytes);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看 <code>HeapAllocator</code> 作为 decodeAllocator 进行内存分配的流程。</p><ol><li><a href="https://github.com/google/skia/blob/master/src/core/SkBitmap.cpp#L213" target="_blank" rel="noopener">SkBitmap::tryAllocPixels</a></li><li><a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/oreo-release/core/jni/android/graphics/Graphics.cpp#616" target="_blank" rel="noopener">HeapAllocator::allocPixelRef</a></li><li><a href="https://android.googlesource.com/platform/frameworks/base/+/master/libs/hwui/hwui/Bitmap.cpp#79" target="_blank" rel="noopener">android::Bitmap::allocateHeapBitmap</a></li></ol><p>对应的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Graphics.cpp https://android.googlesource.com/platform/frameworks/base/+/refs/heads/oreo-release/core/jni/android/graphics/Graphics.cpp#616</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HeapAllocator::allocPixelRef</span><span class="params">(SkBitmap* bitmap, SkColorTable* ctable)</span> </span>&#123;</span><br><span class="line">    mStorage = android::Bitmap::allocateHeapBitmap(bitmap, ctable);</span><br><span class="line">    <span class="keyword">return</span> !!mStorage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bitmap.cpp https://android.googlesource.com/platform/frameworks/base/+/refs/heads/oreo-release/libs/hwui/hwui/Bitmap.cpp#86</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> sk_sp&lt;Bitmap&gt; <span class="title">allocateHeapBitmap</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> SkImageInfo&amp; info, <span class="keyword">size_t</span> rowBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* addr = <span class="built_in">calloc</span>(size, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!addr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sk_sp&lt;Bitmap&gt;(<span class="keyword">new</span> Bitmap(addr, size, info, rowBytes));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GraphicsJNI.h https://android.googlesource.com/platform/frameworks/base/+/refs/heads/oreo-release/core/jni/android/graphics/GraphicsJNI.h#125</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapAllocator</span> :</span> <span class="keyword">public</span> SkBRDAllocator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   HeapAllocator() &#123; &#125;;</span><br><span class="line">    ~HeapAllocator() &#123; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">allocPixelRef</span><span class="params">(SkBitmap* bitmap, SkColorTable* ctable)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fetches the backing allocation object. Must be called!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">android::Bitmap* <span class="title">getStorageObjAndReset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mStorage.release();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">SkCodec::ZeroInitialized <span class="title">zeroInit</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> SkCodec::kYes_ZeroInitialized; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    sk_sp&lt;android::Bitmap&gt; mStorage;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于 <code>RecyclingPixelAllocator</code> 和 <code>ScaleCheckingAllocator</code> 的情况，读者可以自行分析。</p><p>无论哪种 Allocator，最终要么调用 <code>malloc()</code> 分配内存，要么复用之前分配的内存。分配/复用完成后，由 <code>SkBitmap</code> 来持有这块内存，供下一步中图片解码用。</p><p>注：</p><ul><li>准确来说，<code>SkBitmap::HeapAllocator</code> 分配内存由 <a href="https://github.com/google/skia/blob/master/src/core/SkPixmap.cpp" target="_blank" rel="noopener">SkBitmap 的 SkPixmap</a> 持有，而不是 SkBitmap 持有。忽略这个细节</li><li>准确来说，<code>HeapAllocator</code> 分配的内存是由 <code>android::Bitmap.mStorage</code> 持有，而不是 SkBitmap 持有。但 <code>android::Bitmap</code> 与 SkBitmap 有某种关联，所以可以忽略这个细节</li></ul><!--注：native 层的 Bitmap 类比较让人疑惑，一直找不到其具体代码，似乎是在 [hwui库](https://android.googlesource.com/platform/frameworks/base/+/refs/heads/oreo-release/libs/hwui/hwui/Bitmap.h#45)中定义的--><h2 id="图片解码"><a href="#图片解码" class="headerlink" title="图片解码"></a>图片解码</h2><p>在 Skia 中 <code>SkCodec</code> 代表解码器，解码器的类层次结构如下：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/201906/bitmap-creation-sk-codec-class.png" alt></p><p>Skia 将实际的解码工作交由第三方库，不同图片格式有各自对应的解码器。比如 PNG 图片由 <code>SkPngCodec</code> 解码，而 <code>SkPngCodec</code> 是封装和调用 libpng 库。</p><p>前面提到 <code>BitmapFactory.doDecode()</code> 的第2步是创建解码器，第10步是调用该解码器进行解码。</p><ul><li><a href="https://github.com/google/skia/blob/master/src/codec/SkCodec.cpp#L70" target="_blank" rel="noopener">SkCodec::MakeFromStream()</a> 根据图片格式选择一个合适的 <code>SkCodec</code>，比如为 PNG 图片选择 <code>SkPngCodec</code></li><li><a href="https://github.com/google/skia/blob/master/src/codec/SkAndroidCodec.cpp#L78" target="_blank" rel="noopener">SkAndroidCodec::MakeFromStream()</a> 创建 <code>SkAndroidCodec</code>， 它是上一步创建的 <code>SkCodec</code> 的代理。<code>SkAndroidCodec</code> 的具体类型跟图片格式有关。PNG，JPEG，GIF，BMP 等格式时其类型是 <code>SkSampledCodec</code>，WEBP 格式时是 <code>SkAndroidCodecAdapter</code></li><li>调用 <a href="https://github.com/google/skia/blob/master/src/codec/SkAndroidCodec.cpp#L357" target="_blank" rel="noopener">SkAndroidCodec.getAndroidPixels()</a> 解码</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">doDecode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    SkCodec::Result result = codec-&gt;getAndroidPixels(decodeInfo, decodingBitmap.getPixels(),</span><br><span class="line">            decodingBitmap.rowBytes(), &amp;codecOptions);</span><br><span class="line">                </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 PNG 图片为例来分析。 首先，对于 PNG 图片 </p><ul><li>以上代码中，<code>codec</code> 是 <code>SkSampledCodec</code></li><li><code>SkSampledCodec</code> 使用的解码器是 <code>SkPngCodec</code> (见 <code>SkAndroidCodec.fCodec</code> 字段)。</li></ul><p>解码流程如下图：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/201906/bitmap-creation-decode.png" alt></p><p>第一步是调用 <code>codec-&gt;getAndroidPixels()</code> 方法。注意第二个参数正是上一步分配的内存地址，即 <code>SkBitmap</code> 持有的内存。</p><p>接下来是一系列函数调用。注意传入的内存地址参数 <code>dst</code> 即可，其他细节忽略。</p><p>然后会执行到 <code>SkPngCodec.onGetPixels()</code> 方法。它使用 <a href="http://www.libpng.org/pub/png/libpng.html" target="_blank" rel="noopener">libpng 库</a>解码 PNG 图片。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SkCodec::Result <span class="title">SkPngCodec::onGetPixels</span><span class="params">(<span class="keyword">const</span> SkImageInfo&amp; dstInfo, <span class="keyword">void</span>* dst,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">size_t</span> rowBytes, <span class="keyword">const</span> Options&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span>* rowsDecoded)</span> </span>&#123;</span><br><span class="line">    Result result = <span class="keyword">this</span>-&gt;initializeXforms(dstInfo, options);</span><br><span class="line">    <span class="keyword">if</span> (kSuccess != result) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options.fSubset) &#123;</span><br><span class="line">        <span class="keyword">return</span> kUnimplemented;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;allocateStorage(dstInfo);</span><br><span class="line">    <span class="keyword">this</span>-&gt;initializeXformParams();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;decodeAllRows(dst, rowBytes, rowsDecoded);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，解码结果保存在 <code>dst</code> 指针指向的内存，即 <code>SkBitmap</code> 持有的内存。</p><h2 id="创建Java对象"><a href="#创建Java对象" class="headerlink" title="创建Java对象"></a>创建Java对象</h2><p>解码完成后得到 Native 层的 <code>SkBitmap</code> 对象，最后一步工作是将其封装成 Java 层可以使用的 <code>Bitmap</code> 对象。</p><p>这一步的过程相对简单，分为三步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.doDecode() -&gt;</span><br><span class="line">Bitmap.createBitmap() -&gt;</span><br><span class="line">    Java Bitmap 的构造方法中保存 `mNativePtr` (像素数据内存块的地址)</span><br></pre></td></tr></table></figure><p>对应的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BitmapFactory.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">doDecode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SkBitmap decodingBitmap;    </span><br><span class="line">    ...</span><br><span class="line">    SkCodec::Result result = ...</span><br><span class="line">    SkBitmap outputBitmap;</span><br><span class="line">    outputBitmap.swap(decodingBitmap);                </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// now create the java bitmap</span></span><br><span class="line">    <span class="keyword">return</span> bitmap::createBitmap(env, defaultAllocator.getStorageObjAndReset(),</span><br><span class="line">            bitmapCreateFlags, ninePatchChunk, ninePatchInsets, <span class="number">-1</span>);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bitmap.cpp</span></span><br><span class="line"><span class="function">jobject <span class="title">createBitmap</span><span class="params">(JNIEnv* env, Bitmap* bitmap,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> bitmapCreateFlags, jbyteArray ninePatchChunk, jobject ninePatchInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> density)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isMutable = bitmapCreateFlags &amp; kBitmapCreateFlag_Mutable;</span><br><span class="line">    <span class="keyword">bool</span> isPremultiplied = bitmapCreateFlags &amp; kBitmapCreateFlag_Premultiplied;</span><br><span class="line">    <span class="comment">// The caller needs to have already set the alpha type properly, so the</span></span><br><span class="line">    <span class="comment">// native SkBitmap stays in sync with the Java Bitmap.</span></span><br><span class="line">    assert_premultiplied(bitmap-&gt;info(), isPremultiplied);</span><br><span class="line">    BitmapWrapper* bitmapWrapper = <span class="keyword">new</span> BitmapWrapper(bitmap);</span><br><span class="line">    jobject obj = env-&gt;NewObject(gBitmap_class, gBitmap_constructorMethodID,</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(bitmapWrapper), bitmap-&gt;width(), bitmap-&gt;height(), density,</span><br><span class="line">            isMutable, isPremultiplied, ninePatchChunk, ninePatchInsets);</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck() != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"*** Uncaught exception returned from Java call!\n"</span>);</span><br><span class="line">        env-&gt;ExceptionDescribe();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bitmap.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Convenience for JNI access</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> mNativePtr;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Private constructor that must received an already allocated native bitmap</span></span><br><span class="line"><span class="comment">     * int (pointer).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// called from JNI</span></span><br><span class="line">    Bitmap(<span class="keyword">long</span> nativeBitmap, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> density,</span><br><span class="line">            <span class="keyword">boolean</span> isMutable, <span class="keyword">boolean</span> requestPremultiplied,</span><br><span class="line">            <span class="keyword">byte</span>[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nativeBitmap == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"internal error: native bitmap is 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        mNativePtr = nativeBitmap;</span><br><span class="line">        ...        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，Java 层的 <code>Bitmap</code> 对象创建完毕，它在内存中大致是这样的：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/201906/bitmap-creation-ref-relationship.png" alt></p><h1 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h1><p>上一节重点是讲如何为 Bitmap 分配内存，这一节重点讲如何在 Bitmap 销毁时回收内存。</p><p>Java 层的 Bitmap 对象有点特别，特别之处在于其像素数据保存在 native heap。我们知道， native heap 并不被 JVM 管理，那如何保证 Bitmap 对象本身被 GC 后 native heap 中的内存也能正确回收呢？</p><h2 id="recycle"><a href="#recycle" class="headerlink" title="recycle()"></a>recycle()</h2><p>首先想到的是在代码主动调用 <a href="https://developer.android.com/reference/android/graphics/Bitmap.html" target="_blank" rel="noopener">Bitmap.recycle()</a> 方法来释放 native 内存。</p><p><code>Bitmap.recycle()</code> 方法流程如下：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/201906/bitmap-creation-free-mem.png" alt></p><p>来看具体代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Free the native object associated with this bitmap, and clear the</span></span><br><span class="line"><span class="comment"> * reference to the pixel data. This will not free the pixel data synchronously;</span></span><br><span class="line"><span class="comment"> * it simply allows it to be garbage collected if there are no other references.</span></span><br><span class="line"><span class="comment"> * The bitmap is marked as "dead", meaning it will throw an exception if</span></span><br><span class="line"><span class="comment"> * getPixels() or setPixels() is called, and will draw nothing. This operation</span></span><br><span class="line"><span class="comment"> * cannot be reversed, so it should only be called if you are sure there are no</span></span><br><span class="line"><span class="comment"> * further uses for the bitmap. This is an advanced call, and normally need</span></span><br><span class="line"><span class="comment"> * not be called, since the normal GC process will free up this memory when</span></span><br><span class="line"><span class="comment"> * there are no more references to this bitmap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mRecycled &amp;&amp; mNativePtr != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nativeRecycle(mNativePtr)) &#123;</span><br><span class="line">            <span class="comment">// return value indicates whether native pixel object was actually recycled.</span></span><br><span class="line">            <span class="comment">// false indicates that it is still in use at the native level and these</span></span><br><span class="line">            <span class="comment">// objects should not be collected now. They will be collected later when the</span></span><br><span class="line">            <span class="comment">// Bitmap itself is collected.</span></span><br><span class="line">            mNinePatchChunk = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRecycled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bitmap.cpp https://android.googlesource.com/platform/frameworks/base/+/refs/heads/oreo-release/core/jni/android/graphics/Bitmap.cpp#872</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">Bitmap_recycle</span><span class="params">(JNIEnv* env, jobject, jlong bitmapHandle)</span> </span>&#123;</span><br><span class="line">    <span class="function">LocalScopedBitmap <span class="title">bitmap</span><span class="params">(bitmapHandle)</span></span>;</span><br><span class="line">    bitmap-&gt;freePixels();</span><br><span class="line">    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convenience class that does not take a global ref on the pixels, relying</span></span><br><span class="line"><span class="comment">// on the caller already having a local JNI ref</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalScopedBitmap</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">LocalScopedBitmap</span><span class="params">(jlong bitmapHandle)</span></span></span><br><span class="line"><span class="function">            : <span class="title">mBitmapWrapper</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;BitmapWrapper*&gt;(bitmapHandle))</span> </span>&#123;&#125;</span><br><span class="line">    BitmapWrapper* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> mBitmapWrapper;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">pixels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBitmapWrapper-&gt;bitmap().pixels();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBitmapWrapper &amp;&amp; mBitmapWrapper-&gt;valid();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BitmapWrapper* mBitmapWrapper;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapWrapper</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BitmapWrapper(Bitmap* bitmap)</span><br><span class="line">        : mBitmap(bitmap) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">freePixels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mInfo = mBitmap-&gt;info();</span><br><span class="line">        mHasHardwareMipMap = mBitmap-&gt;hasHardwareMipMap();</span><br><span class="line">        mAllocationSize = mBitmap-&gt;getAllocationByteCount();</span><br><span class="line">        mRowBytes = mBitmap-&gt;rowBytes();</span><br><span class="line">        mGenerationId = mBitmap-&gt;getGenerationID();</span><br><span class="line">        mIsHardware = mBitmap-&gt;isHardware();</span><br><span class="line">        mBitmap.reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Resets to its initial state; all fields are set to zero, as if SkBitmap had</span></span><br><span class="line"><span class="comment">    been initialized by SkBitmap().</span></span><br><span class="line"><span class="comment">    Sets width, height, row bytes to zero; pixel address to nullptr; SkColorType to</span></span><br><span class="line"><span class="comment">    kUnknown_SkColorType; and SkAlphaType to kUnknown_SkAlphaType.</span></span><br><span class="line"><span class="comment">    If SkPixelRef is allocated, its reference count is decreased by one, releasing</span></span><br><span class="line"><span class="comment">    its memory if SkBitmap is the sole owner.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fPixelRef = <span class="literal">nullptr</span>;  <span class="comment">// Free pixels.</span></span><br><span class="line">    fPixmap.reset();</span><br><span class="line">    fFlags = <span class="number">0</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先，App 主动调用 <code>Bitmap.recycle()</code> 方法</li><li>接下来，<code>Bitmap.recycle()</code> 调用对应的 native 方法 <code>Bitmap_recycle()</code></li><li>然后会进入到 <code>BitmapWrapper.freePixels()</code> 方法</li><li>最后，<a href="https://github.com/google/skia/blob/master/include/core/SkBitmap.h#L334" target="_blank" rel="noopener">SkBitmap.reset()</a> 将 <code>fPixelRef</code> 置空。注：之前分配内存过程中可以看到 <code>fPixelRef</code> 是如何被赋值的</li></ul><p><code>fPixelRef</code> 原本指向一个 <code>SkMallocPixelRef</code> 对象。将 <code>fPixelRef</code> 置空后，该对象引用数变成0时，<code>~SkMallocPixelRef()</code> 析构方法被调用，并触发 <a href="https://github.com/google/skia/blob/master/src/core/SkMallocPixelRef.cpp#L33" target="_blank" rel="noopener">sk_free_releaseproc()</a> 方法执行，回收内存。</p><p>提示：</p><ul><li>注意这里的 <code>SkMallocPixelRef::fReleaseProc</code> 成员变量，它是保存的是方法地址，这个方法将被用于回收内存</li><li>在之前分配内存时，<code>sk_free_releaseproc()</code> 方法地址作为 <code>SkMallocPixelRef()</code> 构造方法的参数 (参数类型 <code>SkMallocPixelRef::ReleaseProc</code>) 被传进来并保存在 <code>SkMallocPixelRef::fReleaseProc</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SkMemory_malloc.cpp https://github.com/google/skia/blob/master/src/ports/SkMemory_malloc.cpp#L66</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sk_free</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SkMallocPixelRef.cpp https://github.com/google/skia/blob/master/src/core/SkMallocPixelRef.cpp#L33</span></span><br><span class="line"><span class="comment">// assumes ptr was allocated via sk_malloc</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sk_free_releaseproc</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">void</span>*)</span> </span>&#123;</span><br><span class="line">    sk_free(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SkMallocPixelRef.cpp https://github.com/google/skia/blob/master/src/core/SkMallocPixelRef.cpp#L57</span></span><br><span class="line"><span class="function">sk_sp&lt;SkPixelRef&gt; <span class="title">SkMallocPixelRef::MakeAllocate</span><span class="params">(<span class="keyword">const</span> SkImageInfo&amp; info, <span class="keyword">size_t</span> rowBytes)</span> </span>&#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">void</span>* addr = sk_calloc_canfail(size);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == addr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sk_sp&lt;SkPixelRef&gt;(<span class="keyword">new</span> SkMallocPixelRef(info, addr, rowBytes,</span><br><span class="line">                                                  sk_free_releaseproc, <span class="literal">nullptr</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SkMallocPixelRef.cpp https://github.com/google/skia/blob/master/src/core/SkMallocPixelRef.cpp#L133</span></span><br><span class="line">SkMallocPixelRef::~SkMallocPixelRef() &#123;</span><br><span class="line">    <span class="keyword">if</span> (fReleaseProc != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        fReleaseProc(<span class="keyword">this</span>-&gt;pixels(), fReleaseProcContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动释放"><a href="#自动释放" class="headerlink" title="自动释放"></a>自动释放</h2><p>实际上现在的 Android 应用中多数场景代码不主动调用 <code>recycle()</code>， native 内存也能正确回收。这是为何？秘密在于 <a href="https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NativeAllocationRegistry.java" target="_blank" rel="noopener">NativeAllocationRegistry</a>。</p><blockquote><p>NativeAllocationRegistry 用于将 native 内存跟 Java 对象关联，并将它们注册到 Java 运行时。注册 Java 对象关联的 native 内存有几个好处：</p><ul><li>Java 运行时在 GC 调度时可考虑 native 内存状态</li><li>Java 运行时在 Java 对象变得不可达时可以使用用户提供的函数来自动清理 native 内存</li></ul></blockquote><p>来看代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Bitmap(<span class="keyword">long</span> nativeBitmap, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> density,</span><br><span class="line">        <span class="keyword">boolean</span> isMutable, <span class="keyword">boolean</span> requestPremultiplied,</span><br><span class="line">        <span class="keyword">byte</span>[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets) &#123;</span><br><span class="line">    ...</span><br><span class="line">    NativeAllocationRegistry registry = <span class="keyword">new</span> NativeAllocationRegistry(</span><br><span class="line">        Bitmap<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), <span class="title">nativeGetNativeFinalizer</span>(), <span class="title">nativeSize</span>)</span>;</span><br><span class="line">    registry.registerNativeAllocation(<span class="keyword">this</span>, nativeBitmap);</span><br><span class="line">    ...           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 Bitmap 构造方法有如下操作：</p><ul><li>向 <code>NativeAllocationRegistry</code> 提供 <code>nativeGetNativeFinalizer()</code> 方法地址</li><li>将当前 Java 对象本身注册到 <code>NativeAllocationRegistry</code></li><li>将当前 Java 对象关联的 native 内存地址注册到 <code>NativeAllocationRegistry</code></li></ul><p>当 Java 层 Bitmap 对象不可达后关联的 native 内存会由 <code>nativeGetNativeFinalizer()</code> 指定的方法来回收，流程如下：</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/201906/bitmap-creation-free-native-mem.png" alt></p><p>来看 <code>NativeAllocationRegistry</code> 的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeAllocationRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Runnable <span class="title">registerNativeAllocation</span><span class="params">(Object referent, <span class="keyword">long</span> nativePtr)</span> </span>&#123;</span><br><span class="line">        CleanerThunk thunk;</span><br><span class="line">        CleanerRunner result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thunk = <span class="keyword">new</span> CleanerThunk();</span><br><span class="line">            Cleaner cleaner = Cleaner.create(referent, thunk);</span><br><span class="line">            result = <span class="keyword">new</span> CleanerRunner(cleaner);</span><br><span class="line">            registerNativeAllocation(<span class="keyword">this</span>.size);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (VirtualMachineError vme <span class="comment">/* probably OutOfMemoryError */</span>) &#123;</span><br><span class="line">            applyFreeFunction(freeFunction, nativePtr);</span><br><span class="line">            <span class="keyword">throw</span> vme;</span><br><span class="line">        &#125; <span class="comment">// Other exceptions are impossible.</span></span><br><span class="line">        <span class="comment">// Enable the cleaner only after we can no longer throw anything, including OOME.</span></span><br><span class="line">        thunk.setNativePtr(nativePtr);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CleanerThunk</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> nativePtr;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CleanerThunk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.nativePtr = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (nativePtr != <span class="number">0</span>) &#123;</span><br><span class="line">                applyFreeFunction(freeFunction, nativePtr);</span><br><span class="line">                registerNativeFree(size);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNativePtr</span><span class="params">(<span class="keyword">long</span> nativePtr)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.nativePtr = nativePtr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CleanerRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Cleaner cleaner;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CleanerRunner</span><span class="params">(Cleaner cleaner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cleaner = cleaner;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cleaner.clean();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &lt;code&gt;freeFunction&lt;/code&gt;(&lt;code&gt;nativePtr&lt;/code&gt;).</span></span><br><span class="line"><span class="comment">     * Provided as a convenience in the case where you wish to manually free a</span></span><br><span class="line"><span class="comment">     * native allocation using a &lt;code&gt;freeFunction&lt;/code&gt; without using a</span></span><br><span class="line"><span class="comment">     * NativeAllocationRegistry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@libcore</span>.api.CorePlatformApi</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">applyFreeFunction</span><span class="params">(<span class="keyword">long</span> freeFunction, <span class="keyword">long</span> nativePtr)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 Bitmap 而言，<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/oreo-release/core/jni/android/graphics/Bitmap.cpp#864" target="_blank" rel="noopener">Bitmap_destruct()</a> 方法被指定用来回收 native 内存。这个方法超级简单，相信你一眼能看明白。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Bitmap_destruct</span><span class="params">(BitmapWrapper* bitmap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> bitmap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">Bitmap_getNativeFinalizer</span><span class="params">(JNIEnv*, jobject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;jlong&gt;(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(&amp;Bitmap_destruct));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/201906/bitmap-creation-free-native-mem2.png" alt></p><p>如果想了解更多细节，可以看 <a href="https://android.googlesource.com/platform/libcore/+/49965c1/ojluni/src/main/java/sun/misc/Cleaner.java" target="_blank" rel="noopener">Cleaner</a> 源码。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developer.android.com/topic/performance/graphics/manage-memory.html" target="_blank" rel="noopener">如何管理 Bitmap 内存</a></li><li><a href="https://skia.org/user/api/SkBitmap_Reference" target="_blank" rel="noopener">SkBitmap Reference</a></li><li><a href="https://www.jianshu.com/p/d5714e8987f3" target="_blank" rel="noopener">Android Bitmap变迁与原理解析（4.x-8.x）</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Kotlin 之 Nothing</title>
      <link href="2019/06/12/kotlin-nothing/"/>
      <url>2019/06/12/kotlin-nothing/</url>
      
        <content type="html"><![CDATA[<p>Kotlin 中的 <code>Nothing</code> 到底有什么作用？<br><a id="more"></a></p><p>原文见<a href="https://www.bignerdranch.com/blog/kotlins-nothing-its-usefulness-in-generics/" target="_blank" rel="noopener">Kotlin’s Nothing: Its Usefulness in Generics</a></p><p>本文介绍 Kotlin 中 <code>Nothing</code> 类型在泛型中的作用。先来看一个关于链表的具体例子。</p><p><img src="https://www.bignerdranch.com/assets/img/blog/2018/07/a-linked-list.png" alt></p><p>这个链表封装了某种类型，不妨称为 T。链表可以是以下任意一种:</p><ul><li>类型一 - <code>Node&lt;T&gt;</code>。它包含两个属性， <code>T</code> 类型的 payload 和 <code>LinkedList&lt;T&gt;</code> 类型的 next</li><li>类型二 - 一个空链表 <code>EmptyList</code></li></ul><p>使用 <code>sealed class</code> 用于保证链表要么是类型一要么是类型二。</p><p>所以可以写出如下代码:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="type">out T</span>&gt;  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> payload: T, <span class="keyword">var</span> next: LinkedList&lt;T&gt; ) : LinkedList&lt;T&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何写空链表有点挑战。考虑到所有的空链表都是一样的，所以空链表由 Kotlin 中的 <code>object</code> 表示。此外，空链表还必须是 <code>LinkedList&lt;T&gt;</code> 的子类。可以尝试如下写法:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="type">out T</span>&gt;  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> payload: T, <span class="keyword">var</span> next: LinkedList&lt;T&gt; ) : LinkedList&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">object</span> EmptyList&lt;T&gt; : LinkedList&lt;T&gt;() <span class="comment">// won't compile</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 中的 <code>object</code> 不能带类型参数，所以上面代码编译失败。再来尝试去掉空链表的类型参数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="type">out T</span>&gt;  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> payload: T, <span class="keyword">var</span> next: LinkedList&lt;T&gt; ) : LinkedList&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">object</span> EmptyList : LinkedList&lt;T&gt;() <span class="comment">// won't compile</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码仍然编译失败。第5行代码中的 <code>T</code> 无法解析。必须为这里的 <code>T</code> 规定一个具体的类型。</p><p>见文章开头的那张图，<code>T</code> 是 <code>Node.payload</code> 属性的类型。而空链表并不包含任何 <code>Node</code>。所以正确的代码如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="type">out T</span>&gt;  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> payload: T, <span class="keyword">var</span> next: LinkedList&lt;T&gt; = EmptyList) : LinkedList&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">object</span> EmptyList : LinkedList&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> nonEmptyList = LinkedList.Node(payload = <span class="string">"A"</span>, next = LinkedList.Node(payload = <span class="string">"B"</span>))</span><br></pre></td></tr></table></figure><p>Kotlin 中 <code>Nothing</code> 类型到底是什么？在 Kotlin REPL 中运行 <code>println(Nothing::class.java)</code> 命令输出结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(Nothing::class.java)</span><br><span class="line">class java.lang.Void</span><br></pre></td></tr></table></figure><p>Kotlin 的 <code>Nothing</code> 其实就是 Java 中的 <code>Void</code>。在 Kotlin 中，<code>Nothing</code> 表示缺少类型。</p><p>再来看看为什么不能让 Kotlin 中的函数返回 <code>Nothing?</code>。比如以下代码编译出错:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getNothing</span><span class="params">()</span></span> = <span class="built_in">Nothing</span>() <span class="comment">// won't compile</span></span><br></pre></td></tr></table></figure><p>Kotlin 不允许实例化 <code>Nothing</code>。<code>Nothing</code> 的构造方法是私有的。看看 Java 版本的 <code>getNothing()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetVoidExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">getVoid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Void(); <span class="comment">// won't compile</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 中 <code>Void</code> 的构造方法也是私有的。<code>Void</code> 同样不能被实例化。我们也不能返回 <code>Void</code>。所以这样看来 Kotlin 中不能返回 <code>Void</code> 是合理的。</p><p>总结一下: Kotlin 的 <code>Nothing</code> 其实就是 Java 中的 <code>Void</code>。Kotlin 中 <code>Nothing</code> 用于泛型，表示该泛型不包含任何类型信息，即该类型缺失。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重温 fitsSystemWindows</title>
      <link href="2019/06/06/fits-system-windows/"/>
      <url>2019/06/06/fits-system-windows/</url>
      
        <content type="html"><![CDATA[<p>感觉这个是特别令人困惑的属性，不仅我，网上也有很多人也类似感受。时间一久我常常容易忘记 fitsSystemWindows 的具体作用，所以今天复习一遍。<br><a id="more"></a></p><p>官方文档 <a href="https://developer.android.com/training/system-ui/status" target="_blank" rel="noopener">Hide the status bar  |  Android Developers</a> 中提到：</p><blockquote><p>Android 4.1 开始，可以将 app 的内容绘制在状态栏的下一层 (behind the status bar)，并且 app 的内容区域的大小不会随着状态栏的出现和消失而自动。使用 <a href="https://developer.android.com/reference/android/view/View.html#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN" target="_blank" rel="noopener">SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</a> 即可实现这种效果。<br>将 app 的内容绘制在状态栏的下一层时，app 自己负责保证 UI 中的重要内容不被状态栏遮挡(例如，地图应用中的控件不应被状态档遮挡)。否则可能导致应用不可用。大部分时候通过在 XML 文件中添加 <code>android:fitsSystemWindows=true</code> 可以解决这个被遮挡导致不可用的问题。这个属性用于告知父节点要为 system windows 保留一些 padding。</p></blockquote><p>关于 system window：</p><blockquote><p>System windows are the parts of the screen where the system is drawing either non-interactive (in the case of the status bar) or interactive (in the case of the navigation bar) content.</p></blockquote><p>文档中的内容并不难理解：这个属性用于告知父节点要为 system windows 保留一些 padding。通过截图说明一下使用 <code>fitsSystemWindows=true</code> 和使用 <code>fitsSystemWindows=false</code> 的区别。</p><p><img src="fitsystemwindows.png" alt></p><p><img src="no-fitsystemwindows.png" alt></p><p>显然第一张图是我们期望的效果。如果真实情况这么简单，就没有什么让人困惑的了。下面来看问题。</p><hr><p>补充知识</p><p><a href="https://developer.android.com/reference/android/view/View.html#setFitsSystemWindows(boolean" target="_blank" rel="noopener">setFitsSystemWindows</a>) 方法是跟 <code>fitsSystemWindows</code> 属性对应的方法。这个方法的作用描述如下：</p><blockquote><p>Sets whether or not this view should account for system screen decorations such as the status bar and inset its content; that is, controlling whether the default implementation of fitSystemWindows(android.graphics.Rect) will be executed. </p></blockquote><hr><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>测试机是华为 Nova 2 (Android 8.0)，Android 8.0。</p><p>Activity 使用的主题中将 <code>windowTranslucentStatus</code> 设置如 true。内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"BaseAppTheme"</span>&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowTranslucentStatus"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果 Activity 布局文件的根布局是 <code>DrawerLayout</code>，<code>fitsSystemWindows</code> 表现正常。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.drawerlayout.widget.DrawerLayout</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">"@+id/drawer_layout"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但如果 Activity 布局文件的根布局是 <code>LinearLayout</code>，<code>fitsSystemWindows</code> 表现就很诡异了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>怎么个诡异法呢。如果 <code>fitsSystemWindows=false</code>，效果如下，跟预期一致：</p><p><img src="no-fitsystemwindows.png" alt></p><p>如果 <code>fitsSystemWindows=true</code>，效果如下，状态栏变成白色的了：</p><p><img src="fitsystemwindows-bug.png" alt></p><ul><li>为什么 <code>DrawerLayout</code> 中使用 <code>fitsSystemWindows=true</code> 是正常，而 <code>LinearLayout</code> 中使用 <code>fitsSystemWindows=true</code> 不正常</li><li>为什么 <code>fitsSystemWindows=true</code> 似乎跟 <code>windowTranslucentStatus=true</code> 有冲突</li></ul><p><a href="https://stackoverflow.com/questions/31761046/what-exactly-does-fitssystemwindows-do" target="_blank" rel="noopener">android - What exactly does fitsSystemWindows do? - Stack Overflow</a> 这个帖子为上面第一个问题提供了一些线索。Material 包中的很多类，比如 <code>DrawerLayout</code>、<code>CoordinatorLayout</code>及<code>AppBarLayout</code>等等，并不是仅仅将 <code>fitsSystemWindows</code> 用于控制是否让父节点要为 system windows 保留一些 padding，还用来控制是否修改状态栏背景！</p><p>比如，<code>DrawerLayout.java</code> 源码中可以看到如下用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ViewCompat.getFitsSystemWindows(<span class="keyword">this</span>)) &#123;</span><br><span class="line">        IMPL.configureApplyInsets(<span class="keyword">this</span>);</span><br><span class="line">        mStatusBarBackground = IMPL.getDefaultStatusBarBackground(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以推测，<code>LinearLayout</code> 并没有类似处理，所以看起来状态栏变白了。可以断定第一个问题的原因正是这种对 <code>fitsSystemWindows</code> 处理上的不一致性。也正是这种不一致性导致 <code>fitsSystemWindows</code> 让人困惑。<a href="https://www.jianshu.com/p/5cc3bd23be7b" target="_blank" rel="noopener">令人困惑的fitsSystemWindows属性 - 简书</a> 也提到这种不一致问题，称这种不一致为个性化(似乎也有一定道理，官方并没有说只能用一种固定的方式处理 fitsSystemWindows)。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>知道了问题原因，解决办法就简单了。</p><ul><li>从主题中去掉 <code>windowTranslucentStatus=true</code></li><li>或者在使用 <code>LinearLayout</code> 等时主动设置状态栏颜色</li></ul><hr><p><a href="https://medium.com/androiddevelopers/why-would-i-want-to-fitssystemwindows-4e26d9ce1eec?linkId=19685562" target="_blank" rel="noopener">Why would I want to fitsSystemWindows? – Android Developers – Medium</a> 这篇文章讲得不错。翻译一下。</p><p>首先说说什么是 system window。system window 即 Android 系统本身进行绘制的区域，既可以是无交互的(状态栏)，也可以是有交互的(导航栏)。</p><p>大部分时候你的应用不需要在状态栏或导航栏的底部进行绘制，但如果一定要这样做的时候，你应该保证应用中的可交互元素不会被状态栏或导航栏遮挡。这就是 <code>android:fitsSystemWindows=true</code> 的缺省行为：它让 View 有足够的 padding， 保证内容不会被 system window 遮拦。</p><p>记住这几点：</p><ul><li><code>fitsSystemWindows</code> 是深度优先的。顺序很重要，it’s the first View that consumes the insets that makes a difference</li><li>Insets are always relative to the full window - 布局前就添加了 inset，所以在为父节点添加 padding 时其实并不知道 view 的位置</li><li>padding 会被 <code>fitsSystemWindows=true</code> 覆盖 - 同一个 view 上使用 <code>fitsSystemWindows=true</code> 后 padding 相关的属性无效</li></ul><p>以上所说的对多数应用场景是足够的，比如视频播放。</p><p>如果想让 <code>RecyclerView</code> 在透明的导航栏底部滚动，使用 <code>android:fitsSystemWindows=&quot;true&quot;</code> 和 <code>android:clipToPadding=&quot;false&quot;</code> 即可。</p><p>关于如何自定义 fitsSystemWindows。</p><p>在 KitKat 及以下，自定义 View 可以覆盖 <code>fitsSystemWindows()</code> 方法。如果消费了 inset，让 <code>fitsSystemWindows()</code> 返回 <code>true</code>，否则就返回 <code>false</code>。</p><p>在 Lollipop 及以上版本，添加了一些新的 API 以便更容易实现 <code>fitsSystemWindows()</code>，并且跟 View 的其他行为保持一致。你可以覆盖 <code>onApplyWindowInsets()</code> 方法，这个方法允许 View 消费掉指定大小的 inset，也可以根据需要让子节点调用 <code>dispatchApplyWindowInsets()</code>。</p><p>更方便的是，甚至可以不用继承 View 就能在 Lollipop 及以上版本中实现自定义的行为，只需使用 <code>ViewCompat.setOnApplyWindowInsetsListener()</code>。这个方法优先于 <code>View.onApplyWindowInsets()</code> 来调用。<code>ViewCompat</code> 还提供辅助方法用于调用 <code>onApplyWindowInsets()</code> 和 <code>dispatchApplyWindowInsets()</code>。</p><p>自定义 fitsSystemWindows 示例</p><p><code>FrameLayout</code> 和 <code>LinearLayout</code> 等基本布局实现了缺省的 fitsSystemWindows 行为，另外一些布局则为特定的使用场景实现了自定义 fitsSystemWindows 行为。</p><p>一个例子是 <a href="http://www.google.com/design/spec/patterns/navigation-drawer.html" target="_blank" rel="noopener">navigation drawer</a>。</p><p><img src="drawer-layout.png" alt></p><p>上图中的 DrawerLayout 使用了 <code>fitsSystemWindows=true</code>。这个属性让 DrawerLayout 了子节点有 inset，但仍然会按照 material design 规范绘制状态栏的背景(缺省使用<code>colorPrimaryDark</code>)。</p><p>Lollipop 及以上版本中，<code>DrawerLayout</code> 为每个子节点调用 <code>dispatchApplyWindowInsets()</code>，以允许每个子节点也可以有 <code>fitsSystemWindows</code>，这跟缺省的行为有所不同(缺省行为中父节点会消费 <code>fitsSystemWindows</code>，子节点收不到 <code>fitsSystemWindows</code>)。</p><p>CoordinatorLayout also takes advantage of overriding how it handles window insets, allowing the Behavior set on child Views to intercept and change how Views react to window insets, before calling dispatchApplyWindowInsets() on each child themselves. It also uses the fitsSystemWindows flag to know if it needs to paint the status bar background.</p><p>Similarly, CollapsingToolbarLayout looks for fitsSystemWindows to determine when and where to draw the content scrim — a full-bleed scrim which overlays the status bar area when the CollapsingToolbarLayout is scrolled sufficiently off the screen.</p><p>If you’re interested in seeing some of the common cases that accompany the <a href="http://android-developers.blogspot.com/2015/05/android-design-support-library.html" target="_blank" rel="noopener">Design Library</a>, check out the <a href="https://github.com/chrisbanes/cheesesquare" target="_blank" rel="noopener">cheesesquare sample app</a>。</p><p>Use the system, don’t fight it<br>One thing to keep in mind is that it isn’t called fitsStatusBar or fitsNavigationBar. What constitutes system windows, their dimensions, and location may certainly change with different platform releases — for a perfect example, look at the differences between Honeycomb and Ice Cream Sandwich.</p><p>Just rest assured that the insets you do get from fitsSystemWindows will be correct on all platform versions to ensure your content does not overlap with system provided UI components — make sure to avoid any assumptions on their availability or size if you customize the behavior.</p><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/31761046/what-exactly-does-fitssystemwindows-do" target="_blank" rel="noopener">android - What exactly does fitsSystemWindows do? - Stack Overflow</a></li><li><a href="https://www.jianshu.com/p/5cc3bd23be7b" target="_blank" rel="noopener">令人困惑的fitsSystemWindows属性 - 简书</a></li><li><a href="https://medium.com/androiddevelopers/why-would-i-want-to-fitssystemwindows-4e26d9ce1eec?linkId=19685562" target="_blank" rel="noopener">Why would I want to fitsSystemWindows? – Android Developers – Medium</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android dlopen 方法的使用限制及解决方案</title>
      <link href="2019/06/04/fake-dlopen/"/>
      <url>2019/06/04/fake-dlopen/</url>
      
        <content type="html"><![CDATA[<p>近期在实现 hook Bitmap 的功能，而 hook 的第一步是拿到被 hook 方法的地址。获取方法地址的常规方法是使用 <code>dlopen()</code> 和 <code>dlsym()</code>，但 Android 平台上对这两个方法的使用有限制，如何突破这个限制呢？</p><a id="more"></a><h1 id="Android-对-dlsym-的限制"><a href="#Android-对-dlsym-的限制" class="headerlink" title="Android 对 dlsym 的限制"></a>Android 对 dlsym 的限制</h1><p>Android 7.0及以上版本对 <code>dlopen()</code> 和 <code>dlsym()</code> 函数的使用有限制。<code>System.load()</code> 和 <code>System.loadLibrary()</code> 是基于这两个函数实现的，所以也存在同样限制。</p><p>在华为 Nova 2 (Android 8.0) 上试验一下，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoadSoActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_load_so)</span><br><span class="line"></span><br><span class="line">        buttonLoadSo.setOnClickListener &#123;</span><br><span class="line">            System.load(<span class="string">"/system/lib/libart.so"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buttonLoadSo2.setOnClickListener &#123;</span><br><span class="line">            System.loadLibrary(<span class="string">"art"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码和更多测试见 <a href="https://github.com/410063005/cmdemo/blob/master/app/src/main/java/com/sunmoonblog/cmdemo/dlsym/LoadSoActivity.kt" target="_blank" rel="noopener">LoadSoActivity</a>。 </p><p>测试中发现无论是调用 <code>System.load()</code> 还是 <code>System.loadLibrary()</code> 加载 <code>libart.so</code> (系统的so库，非公开 API) 均会导致以下异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">    Process: com.sunmoonblog.cmdemo, PID: 8432</span><br><span class="line">    java.lang.UnsatisfiedLinkError: dlopen failed: library &quot;/system/lib/libart.so&quot; needed or </span><br><span class="line">      dlopened by &quot;/system/lib64/libnativeloader.so&quot; is not accessible for the namespace &quot;classloader-namespace&quot;</span><br><span class="line">        at java.lang.Runtime.load0(Runtime.java:928)</span><br><span class="line">        at java.lang.System.load(System.java:1624)</span><br></pre></td></tr></table></figure><p>异常信息很明确：<strong>第三方应该不应当尝试使用非公开的方法</strong>。当然，官方对此早有说明。</p><ul><li><a href="https://developer.android.com/about/versions/nougat/android-7.0-changes#ndk" target="_blank" rel="noopener">Android-7.0-changes</a> 提到：</li></ul><blockquote><p>Starting in Android 7.0, the system prevents apps from dynamically linking against non-NDK libraries, which may cause your app to crash.</p></blockquote><ul><li><a href="https://android-developers.googleblog.com/2016/06/improving-stability-with-private-cc.html" target="_blank" rel="noopener">Improving Stability with Private C/C++ Symbol Restrictions in Android N</a> 也提到这个限制：</li></ul><blockquote><p>Android N <strong>will restrict which libraries your C/C++ code can link against at runtime</strong>. </p></blockquote><p>官方的作出上述限制的理由是只允许应用访问公开的 API(无论是 Java 层还是 Native 层)，不允许访问非公开的方法，以提升应用的稳定性。出发点是好的，但对于一些合理的使用场景，比如开发包/测试包中调用非公开方法，造成相当的不便。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>如何突破官方的限制呢？<a href="https://github.com/avs333/Nougat_dlfunctions" target="_blank" rel="noopener">Nougat_dlfunctions</a> 提供了一个不错的解决方案，可以完美避开官方限制。</p><p>Nougat_dlfunctions 是这样介绍自己的：</p><blockquote><p>A hack for loading system libraries in Android Nougat where dlopen() has been disabled by some wise guys.</p></blockquote><p>它的两个主要 API 如下。形式上跟 <code>dlopen()</code> 和 <code>dlsysm()</code> 完全一致，所以用起来非常简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fake_dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *libpath, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fake_dlsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>fake_dlopen()</code> - 跟 <code>dlopen()</code> 一样，用于 load and link a dynamic library or bundle</li><li><code>fake_dlsym()</code> - 跟 <code>dlsym()</code> 一样，用于 get address of a symbol</li></ul><p><a href="https://gist.github.com/410063005/c3582c7e9b8d26e3f4f825576a4bae5d" target="_blank" rel="noopener">这里</a> 演示了 <code>dlsym()</code> 的用法，主要代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*CACULATE_FUNC)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* handle = dlopen(<span class="string">"libop.so"</span>, RTLD_NOW);</span><br><span class="line">    <span class="keyword">void</span>* sym_add = dlsym(handle, <span class="string">"add"</span>);</span><br><span class="line">    </span><br><span class="line">    CACULATE_FUNC add_func = sym_add;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d + %d = %d\n"</span>, <span class="number">1</span>, <span class="number">11</span>, add_func(<span class="number">11</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易使用 Nougat_dlfunctions 提供的 <code>fake_dlsym()</code> 函数替代 <code>dlsym()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* handle = fake_dlopen(<span class="string">"libop.so"</span>, RTLD_NOW);</span><br><span class="line">    <span class="keyword">void</span>* sym_add = fake_dlsym(handle, <span class="string">"add"</span>);</span><br><span class="line">    </span><br><span class="line">    CACULATE_FUNC add_func = sym_add;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d + %d = %d\n"</span>, <span class="number">1</span>, <span class="number">11</span>, add_func(<span class="number">11</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>Nougat_dlfunctions 库的原理本身并不复杂，但由于涉及到 <a href="http://ftp.openwatcom.org/devel/docs/elf-64-gen.pdf" target="_blank" rel="noopener">ELF 文件格式</a>，其中的技术细节理解起来还是要花些时间。</p><p>要保证 <code>fake_dlopen()</code> 和 <code>fake_dlsym()</code> 函数可正常运行有一个前提：<strong>so 文件本身已经被加载到当前进程</strong>。所以更准确地说, Nougat_dlfunctions 库并不能主动加载系统库/非公开的库，而是从已加载的系统库/非公开库中找到感兴趣的方法地址。但即使这样，对很多应用场景已经够用了。比如，以 hook Bitmap 为例，可以利用这个库绕开 Android 系统限制拿到目标方法的地址。</p><p>再来看具体流程。</p><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/201906/fake_dlopen_flow.png" alt></p><p>首先，<code>fake_dlopen()</code> 读取 <code>/proc/self/maps</code> 文件。这个文件记录了当前进程的内存布局。<a href="https://stackoverflow.com/questions/1401359/understanding-linux-proc-id-maps" target="_blank" rel="noopener">Understanding-linux-proc-id-maps</a> 对此有简要的描述。</p><blockquote><p>Each row in /proc/$PID/maps describes a region of contiguous virtual memory in a process or thread. Each row has the following fields:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">address           perms offset  dev   inode   pathname</span><br><span class="line">08048000-08056000 r-xp 00000000 03:0c 64593   /usr/sbin/gpm</span><br></pre></td></tr></table></figure><ul><li>address - 进程地址空间的起始地址</li><li>permissions - 访问权限</li><li>pathname - 如果该区域是从文件映射来的，pathname 为文件名</li></ul><p>知道进程的内存布局后，不难从其中获取到指定路径的 so 文件的基址。基址保存在 <code>load_addr</code>。</p><p>然后，Nougat_dlfunctions 调用 <code>mmap()</code> 对该 so 文件进行内存映射，映射结果为 <code>elf</code> 并对其进行解析。<code>elf</code> 数据结构类型是 <code>Elf_Ehdr</code>。<code>Elf_Ehdr</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ELF_NIDENT16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">uint8_t</span>e_ident[ELF_NIDENT];</span><br><span class="line">Elf32_Halfe_type;</span><br><span class="line">Elf32_Halfe_machine;</span><br><span class="line">Elf32_Worde_version;</span><br><span class="line">Elf32_Addre_entry;</span><br><span class="line">Elf32_Offe_phoff;</span><br><span class="line">Elf32_Offe_shoff;      <span class="comment">/* Section header offset */</span></span><br><span class="line">Elf32_Worde_flags;</span><br><span class="line">Elf32_Halfe_ehsize;</span><br><span class="line">Elf32_Halfe_phentsize;</span><br><span class="line">Elf32_Halfe_phnum;</span><br><span class="line">Elf32_Halfe_shentsize; <span class="comment">/* Size of section header entry */</span>  </span><br><span class="line">Elf32_Halfe_shnum;     <span class="comment">/* Number of section header entries */</span> </span><br><span class="line">Elf32_Halfe_shstrndx;</span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><p>简单来说，一个 ELF 文件由一个 Header 及 多个 Section 组成。每个 Section 也有自己的 Section Header，其类型为 <code>Elf32_Shdr</code>。<code>Elf32_Shdr</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">Elf32_Wordsh_name;</span><br><span class="line">Elf32_Wordsh_type;</span><br><span class="line">Elf32_Wordsh_flags;</span><br><span class="line">Elf32_Addrsh_addr;</span><br><span class="line">Elf32_Offsh_offset;   <span class="comment">/* Offset in file */</span></span><br><span class="line">Elf32_Wordsh_size;     <span class="comment">/* Size of section */</span> </span><br><span class="line">Elf32_Wordsh_link;</span><br><span class="line">Elf32_Wordsh_info;</span><br><span class="line">Elf32_Wordsh_addralign;</span><br><span class="line">Elf32_Wordsh_entsize;</span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><p>Section 有不同类型。更多细节可以参考<a href="http://ftp.openwatcom.org/devel/docs/elf-64-gen.pdf" target="_blank" rel="noopener">ELF-64 Object File Format</a>。这里重点关注这几种类型的 Section：</p><ul><li>类型 <code>SHT_DYNSYM</code>, 名字是 <code>.dynsym</code>  - 这个 section 包含 dynamic linking tables</li><li>类型 <code>SHT_STRTAB</code>, 名字是 <code>.dynstr</code>  - 这个 section 包含 string table</li><li>类型 <code>SHT_PROGBITS</code> - 这个 section 包含 information defined by the program</li></ul><p><code>.dynsym</code> 是符号表，表中的元素类型是 <code>Elf32_Sym</code>。 <code>Elf32_Sym</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">Elf32_Wordst_name;</span><br><span class="line">Elf32_Addrst_value;</span><br><span class="line">Elf32_Wordst_size;</span><br><span class="line"><span class="keyword">uint8_t</span>st_info;</span><br><span class="line"><span class="keyword">uint8_t</span>st_other;</span><br><span class="line">Elf32_Halfst_shndx;</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><p>Nougat_dlfunctions 处理 <code>elf</code> 的方式相当简单粗暴：找到关键信息后直接拷贝一份并保存下来。关键信息包括 <code>.dynsym</code>，<code>.dynstr</code> 等等。具体可以对照着代码看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fake_dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *libpath, <span class="keyword">int</span> flags)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *maps;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">256</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ctx</span> *<span class="title">ctx</span> = 0;</span></span><br><span class="line">    <span class="keyword">off_t</span> load_addr, size;</span><br><span class="line">    <span class="keyword">int</span> k, fd = <span class="number">-1</span>, found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> *shoff;</span><br><span class="line">    Elf_Ehdr *elf = MAP_FAILED;</span><br><span class="line">...</span><br><span class="line">ctx = (struct ctx *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct ctx));        </span><br><span class="line"><span class="keyword">if</span>(!ctx) fatal(<span class="string">"no memory for %s"</span>, libpath);</span><br><span class="line"></span><br><span class="line">ctx-&gt;load_addr = (<span class="keyword">void</span> *) load_addr;</span><br><span class="line">shoff = ((<span class="keyword">void</span> *) elf) + elf-&gt;e_shoff;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; elf-&gt;e_shnum; k++, shoff += elf-&gt;e_shentsize)  &#123;</span><br><span class="line"></span><br><span class="line">    Elf_Shdr *sh = (Elf_Shdr *) shoff;</span><br><span class="line">    log_dbg(<span class="string">"%s: k=%d shdr=%p type=%x"</span>, __func__, k, sh, sh-&gt;sh_type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(sh-&gt;sh_type) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SHT_DYNSYM:</span><br><span class="line">    <span class="keyword">if</span>(ctx-&gt;dynsym) fatal(<span class="string">"%s: duplicate DYNSYM sections"</span>, libpath); <span class="comment">/* .dynsym */</span></span><br><span class="line">    ctx-&gt;dynsym = <span class="built_in">malloc</span>(sh-&gt;sh_size);</span><br><span class="line">    <span class="keyword">if</span>(!ctx-&gt;dynsym) fatal(<span class="string">"%s: no memory for .dynsym"</span>, libpath);</span><br><span class="line">    <span class="built_in">memcpy</span>(ctx-&gt;dynsym, ((<span class="keyword">void</span> *) elf) + sh-&gt;sh_offset, sh-&gt;sh_size);</span><br><span class="line">    ctx-&gt;nsyms = (sh-&gt;sh_size/<span class="keyword">sizeof</span>(Elf_Sym)) ;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SHT_STRTAB:</span><br><span class="line">    <span class="keyword">if</span>(ctx-&gt;dynstr) <span class="keyword">break</span>;<span class="comment">/* .dynstr is guaranteed to be the first STRTAB */</span></span><br><span class="line">    ctx-&gt;dynstr = <span class="built_in">malloc</span>(sh-&gt;sh_size);</span><br><span class="line">    <span class="keyword">if</span>(!ctx-&gt;dynstr) fatal(<span class="string">"%s: no memory for .dynstr"</span>, libpath);</span><br><span class="line">    <span class="built_in">memcpy</span>(ctx-&gt;dynstr, ((<span class="keyword">void</span> *) elf) + sh-&gt;sh_offset, sh-&gt;sh_size);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SHT_PROGBITS:</span><br><span class="line">    <span class="keyword">if</span>(!ctx-&gt;dynstr || !ctx-&gt;dynsym) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* won't even bother checking against the section name */</span></span><br><span class="line">    ctx-&gt;bias = (<span class="keyword">off_t</span>) sh-&gt;sh_addr - (<span class="keyword">off_t</span>) sh-&gt;sh_offset; </span><br><span class="line">    k = elf-&gt;e_shnum;  <span class="comment">/* exit for */</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ctx</code> 的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ctx</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *load_addr;</span><br><span class="line">    <span class="keyword">void</span> *dynstr; <span class="comment">// 保存了 string table </span></span><br><span class="line">    <span class="keyword">void</span> *dynsym; <span class="comment">// 保存了 dynamic linking table</span></span><br><span class="line">    <span class="keyword">int</span> nsyms;    <span class="comment">// 保存了 dynamic linking table 的条目大小</span></span><br><span class="line">    <span class="keyword">off_t</span> bias;   <span class="comment">// ? 不清楚</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，根据指定的方法名在 <code>ctx-&gt;dynsym</code> (即之前保存的 dynamic linking table) 进行查找。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fake_dlsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ctx</span> *<span class="title">ctx</span> = (<span class="title">struct</span> <span class="title">ctx</span> *) <span class="title">handle</span>;</span></span><br><span class="line">    Elf_Sym *sym = (Elf_Sym *) ctx-&gt;dynsym;</span><br><span class="line">    <span class="keyword">char</span> *strings = (<span class="keyword">char</span> *) ctx-&gt;dynstr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; ctx-&gt;nsyms; k++, sym++)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(strings + sym-&gt;st_name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/*  NB: sym-&gt;st_value is an offset into the section for relocatables,</span></span><br><span class="line"><span class="comment">but a VMA for shared libs or exe files, so we have to subtract the bias */</span></span><br><span class="line">    <span class="keyword">void</span> *ret = ctx-&gt;load_addr + sym-&gt;st_value - ctx-&gt;bias;</span><br><span class="line">    log_info(<span class="string">"%s found at %p"</span>, name, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果方法名跟 dynamic linking table 中的某一项匹配上了，对应的方法地址可以这样计算出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx-&gt;load_addr + sym-&gt;st_value - ctx-&gt;bias</span><br></pre></td></tr></table></figure><p>看一个实际案例：hook Bitmap。假设我们感兴趣的方法名为 <code>createBitmap</code>，</p><ul><li>这个方法在 <code>system/lib/libandroid_runtime.so</code> 中</li><li>应用启动后 Android 系统会为当前进程加载 <code>libandroid_runtime.so</code></li><li><code>proc/self/maps</code> 中记录了当前进程的内存布局，其中包括 <code>libandroid_runtime.so</code></li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/201906/maps.png" alt></p><p>获取 <code>createBitmap()</code> 方法地址流程：</p><ul><li><code>fake_dlopen()</code><ul><li>parse - 解析 <code>proc/self/maps</code>， 得到 <code>libandroid_runtime.so</code> 的基址 <code>load_addr</code></li><li>mmap -  将 <code>libandroid_runtime.so</code> mmap 映射成 <code>elf</code></li><li>copy -  从 <code>elf</code> 拷贝 <code>.dynstr</code> 和 <code>.dynsym</code></li></ul></li><li><code>fake_dlsym()</code><ul><li>search - 在 <code>.dynsym</code> 查找 <code>createBitmap</code> 字符串对应的项</li><li>calculate - 如果第4步中查找成功，最后一步就是计算 <code>createBitmap</code> 方法的地址。计算规则： <code>load_addr + sym-&gt;st_value - bias</code></li></ul></li></ul><p><img src="https://blog-1251688504.cos.ap-shanghai.myqcloud.com/201906/fake_dlopen_flow.png" alt></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://wiki.osdev.org/ELF_Tutorial" target="_blank" rel="noopener">ELF Tutorial - OSDev Wiki</a></li><li><a href="https://stackoverflow.com/questions/1401359/understanding-linux-proc-id-maps" target="_blank" rel="noopener">Understanding Linux /proc/id/maps - Stack Overflow</a> </li><li><a href="http://ftp.openwatcom.org/devel/docs/elf-64-gen.pdf" target="_blank" rel="noopener">ELF-64 Object File Format</a></li><li><a href="https://pqpo.me/2017/05/31/system-loadlibrary/" target="_blank" rel="noopener">深入理解 System.loadLibrary - Pqpo’s Notes</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652049403&amp;idx=1&amp;sn=a7f56665ec2760cb71bca29c2983cecf&amp;chksm=808cafbeb7fb26a8bcf64bb2fd58c89b1e8741dff0f33eab069ef2a0f41840fb6fa68dde274e&amp;mpshare=1&amp;scene=1&amp;srcid=06053yN9hK2ulAqSAwSFX9TS#rd" target="_blank" rel="noopener">Android Q 对非 SDK 接口限制的更新 </a></li><li><a href="https://www.cnblogs.com/jiqingwu/p/elf_explore_3.html" target="_blank" rel="noopener">ELF格式探析之三：sections - JollyWing - 博客园</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bitmap 解码性能测试</title>
      <link href="2019/05/31/bitmap-decode-perf/"/>
      <url>2019/05/31/bitmap-decode-perf/</url>
      
        <content type="html"><![CDATA[<p>简单测试一下 Bitmap 解码性能，收集一些测试数据。<br><a id="more"></a></p><h1 id="测试结论"><a href="#测试结论" class="headerlink" title="测试结论"></a>测试结论</h1><p>测试代码见 <a href="https://github.com/410063005/cmdemo/blob/master/app/src/main/java/com/sunmoonblog/cmdemo/bitmap/BitmapDecodePerfActivity.kt" target="_blank" rel="noopener">BitmapDecodePerfActivity</a>。</p><p>测试结论：</p><ul><li>解码性能跟图片体积有一定关系, 基本上体积越大解码时间越长</li><li>解码性能跟图片尺寸有一定关系, 基本上尺寸越大解码时间越长</li><li>WebP 解码性能比 PNG 解码性能差</li><li>较大图片的解码时间常常超过 16ms，所以不应该在主线程解码较大图片</li><li>小图片的解码时间很短，几乎不会影响到主线程</li><li>同一个图片放在不同的资源目录, 会影响解码性能</li></ul><h1 id="图片体积和图片尺寸"><a href="#图片体积和图片尺寸" class="headerlink" title="图片体积和图片尺寸"></a>图片体积和图片尺寸</h1><p>图片体积和图片尺寸会影响解码性能。</p><table><thead><tr><th>图片名</th><th>体积(KB)</th><th>尺寸</th><th>内存(MB)</th><th>解码时间(ms)</th></tr></thead><tbody><tr><td>kb_1.png</td><td>1</td><td>116x22</td><td>0</td><td>0.5</td></tr><tr><td>kb_50.png</td><td>53</td><td>750x520</td><td>1.5</td><td>7.1</td></tr><tr><td>kb_80.png</td><td>88</td><td>1125x711</td><td>3.1</td><td>11.1</td></tr><tr><td>kb_100.png</td><td>103</td><td>750x416</td><td>1.2</td><td>7.0</td></tr><tr><td>kb_190.png</td><td>190</td><td>750x460</td><td>1.3</td><td>10.0</td></tr><tr><td>kb_320.png</td><td>326</td><td>752x942</td><td>2.7</td><td>17.8</td></tr></tbody></table><p>(数据来自 BitmapDecodePerfActivity.button12.setOnClickListener {} )</p><p>从上表可以看出，</p><ul><li>随着图片体积增加，解码时间也越来越长</li><li><code>kb_100.png</code> 体积比 <code>kb_80.png</code> 大，但解码时间反而短，看起来是个例外。原因可能是因为图片尺寸增加也会影响到解码时间，<code>kb_80.png</code> 的尺寸是 <code>kb_100.png</code> 的两倍以上</li><li>小图片的解码时间很短，几乎不会影响到主线程。实际开发中可以直接在布局文件中引用小图片资源，不用担心影响主线程</li><li>较大图片的解码时间可能超过 16ms，比如这里的 <code>kb_320.png</code>，所以不应该在主线程解码较大图片</li></ul><h1 id="WebP-与-PNG"><a href="#WebP-与-PNG" class="headerlink" title="WebP 与 PNG"></a>WebP 与 PNG</h1><table><thead><tr><th>图片名</th><th>体积(KB)</th><th>尺寸</th><th>内存(MB)</th><th>解码时间(ms)</th></tr></thead><tbody><tr><td>kb_80.webp</td><td>78</td><td>1500x742</td><td>4.2</td><td>29.7</td></tr><tr><td>kb_90.webp</td><td>91</td><td>750x1206</td><td>3.5</td><td>24.9</td></tr><tr><td>kb_100.webp</td><td>96</td><td>750x1334</td><td>3.8</td><td>27.6</td></tr></tbody></table><p>(数据来自 BitmapDecodePerfActivity.button11.setOnClickListener {} )</p><p>直观上 WebP 图片解码耗时更长。以下是对比：</p><table><thead><tr><th>图片名</th><th>体积(KB)</th><th>尺寸</th><th>内存(MB)</th><th>解码时间(ms)</th></tr></thead><tbody><tr><td>jialuo.png</td><td>326</td><td>752x942</td><td>2.7</td><td>21.5</td></tr><tr><td>jialuo_lossless.webp</td><td>222</td><td>752x942</td><td>2.7</td><td>30.0</td></tr><tr><td>jialuo_lossy_75.webp</td><td>55</td><td>752x942</td><td>2.7</td><td>24.6</td></tr></tbody></table><p>(数据来自 BitmapDecodePerfActivity.button18.setOnClickListener {} )</p><p>上表对三张相同尺寸的图片进行测试：</p><ul><li><code>jialuo.png</code> - 原始 PNG 图片</li><li><code>jialuo_lossless.webp</code> - 原始图片无损压缩得到的 WebP</li><li><code>jialuo_lossy_75.webp</code> - 原始图片有损压缩压缩后得到的 WebP，质量为75%</li></ul><p>从上表可以看出，</p><ul><li>相同尺寸下，WebP 图片体积明显小很多</li><li>相同质量下，WebP 图片解码性能明显比 PNG 要低</li><li>降低质量后 WebP 图片体积减小很多，可能在一定程度上弥补解码性能差的问题</li><li>较大图片的解码时间常常超过 16ms，比方说这里的三张图片均超过 16ms，所以不应该在主线程解码较大图片</li></ul><h1 id="分辨率与图片资源目录"><a href="#分辨率与图片资源目录" class="headerlink" title="分辨率与图片资源目录"></a>分辨率与图片资源目录</h1><p>图片资源该放在哪个目录， <code>hdpi</code> 还是 <code>xhdpi</code> 还是 <code>xxhdpi</code>？官方对此的说明见<a href="https://developer.android.com/training/multiscreen/screendensities#TaskProvideAltBmp" target="_blank" rel="noopener">这里</a></p><table><thead><tr><th>图片名</th><th>目录</th><th>Bitmap尺寸</th><th>内存(MB)</th><th>解码时间(ms)</th></tr></thead><tbody><tr><td>splash_as_xhdpi.webp</td><td>xhdpi</td><td>1125x2001</td><td>8.6</td><td>82.4</td></tr><tr><td>splash_as_xxhdpi.webp</td><td>xxhdpi</td><td>750x1334</td><td>3.8</td><td>27.1</td></tr><tr><td>splash_as_xxxhdpi.webp</td><td>xxxhdpi</td><td>563x1001</td><td>2.1</td><td>40.0</td></tr></tbody></table><p>(数据来自 BitmapDecodePerfActivity.button19.setOnClickListener {} )</p><p>上表中三张图片的体积均为 96KB，尺寸均为 750x1334。</p><p>测试手机是华为 Nova 2，屏幕大小 1080x2150，densityDpi 是 480。根据 Android 源码的定义，480 的手机分类是 DENSITY_XXHIGH。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplayMetrics</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Standard quantized DPI for extra-extra-high-density screens.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DENSITY_XXHIGH = <span class="number">480</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上表可以看出，</p><ul><li>同一张图片放在不同的资源目录，最终解码出来的图片大小不一样。理由很简单，系统会对根据屏幕分辨率图片资源进行缩放处理</li><li>图片放在错误的资源目录会产生不良影响。以 <code>splash.webp</code> 为例，由于我的测试机屏幕分辨率是 DENSITY_XXHIGH，所以预期是将它放在 <code>xxhdpi</code> 目录<ul><li>如果错误地放在 <code>xhdpi</code> 目录，得到一个放大的 Bitmap，白白消耗内存</li><li>如果放在不正确的目录，解码时间变长</li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>精确测试解码性能比较困难，从但上述测试数据中不难归纳出以下结论：</p><ul><li>大图片的解码时间很可能超过 16ms。所以为了更流畅的用户体验，<strong>不应在主线程中解码大图片</strong></li><li>图片放在错误的资源目录，不仅浪费内存，还会增加解码时间。所以为了更好的性能，<strong>应当提供为不同屏幕密度提供合适的图片资源</strong></li></ul><p>以上结论跟 <a href="https://developer.android.com/topic/performance/graphics" target="_blank" rel="noopener">Handling bitmaps</a> 提供的最佳实践是吻合的。</p><blockquote><p>Loading bitmaps on the UI thread can degrade your app’s performance, causing slow responsiveness or even ANR messages. It is therefore important to manage threading appropriately when working with bitmaps.</p></blockquote><blockquote><p>If your app is loading multiple bitmaps into memory, you need to skillfully manage memory and disk caching. Otherwise, the responsiveness and fluidity of your app’s UI may suffer.</p></blockquote><p>(测试过程中，为了让数据更稳定，做法是取解码20次取平均值。这样做是否有问题？之所以有这个疑问，因为测试中发现一个现象：解码20次得到的平均值倾向于比单独测试一次得到的值要小。)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 之 AutoCloseable.use()</title>
      <link href="2019/05/22/kotlin-autocloseable-use/"/>
      <url>2019/05/22/kotlin-autocloseable-use/</url>
      
        <content type="html"><![CDATA[<p>介绍 Kotlin 的一个语言特性：<code>AutoCloseable.use()</code>。<br><a id="more"></a></p><h1 id="Java-try-with-resources"><a href="#Java-try-with-resources" class="headerlink" title="Java try-with-resources"></a>Java try-with-resources</h1><p>Java 7 之前，只能使用 <code>finally</code> 子句来关闭资源，所以代码不太优雅。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">readFirstLineFromFileWithFinallyBlock</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function">                                                     <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="keyword">null</span>) br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 7 引入了 try-with-resources 语句，它可以保证当前语句执行完毕后无论是否发生异常都能关闭资源。使用 try-with-resources 语句优化上述例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">readFirstLineFromFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br =</span><br><span class="line">                   <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅仅是 Java SDK 的内置资源(如 BufferedReader)，任何实现了 <code>java.lang.AutoCloseable</code> 接口的资源都可以用在 try-with-resources 语句中。相当方便。</p><h1 id="Kotlin-AutoCloseable-use"><a href="#Kotlin-AutoCloseable-use" class="headerlink" title="Kotlin AutoCloseable.use()"></a>Kotlin AutoCloseable.use()</h1><p>由于 Java 7 之后才支持 try-with-resources，所以 Kotlin 从 <code>kotlin-stdlib-jre7</code> 和 <code>kotlin-stdlib-jre8</code> 两个新包开始提供 <code>AutoCloseable.use()</code> 功能。</p><p>由于 <code>AutoCloseable.use()</code> 只是一个简单的扩展方法，代码量少且很清晰，这里直接贴完整的源码。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the given [block] function on this resource and then closes it down correctly whether an exception</span></span><br><span class="line"><span class="comment"> * is thrown or not.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> block a function to process this [Closeable] resource.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the result of [block] function invoked on this resource.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@InlineOnly</span></span><br><span class="line"><span class="meta">@RequireKotlin(<span class="meta-string">"1.2"</span>, versionKind = RequireKotlinVersionKind.COMPILER_VERSION, message = <span class="meta-string">"Requires newer compiler version to be inlined correctly."</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Closeable?, R&gt;</span> T.<span class="title">use</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">var</span> exception: Throwable? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">        exception = e</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            apiVersionIsAtLeast(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>) -&gt; <span class="keyword">this</span>.closeFinally(exception)</span><br><span class="line">            <span class="keyword">this</span> == <span class="literal">null</span> -&gt; &#123;&#125;</span><br><span class="line">            exception == <span class="literal">null</span> -&gt; close()</span><br><span class="line">            <span class="keyword">else</span> -&gt;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    close()</span><br><span class="line">                &#125; <span class="keyword">catch</span> (closeException: Throwable) &#123;</span><br><span class="line">                    <span class="comment">// cause.addSuppressed(closeException) // ignored here</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Closes this [Closeable], suppressing possible exception or error thrown by [Closeable.close] function when</span></span><br><span class="line"><span class="comment"> * it's being closed due to some other [cause] exception occurred.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The suppressed exception is added to the list of suppressed exceptions of [cause] exception, when it's supported.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SinceKotlin(<span class="meta-string">"1.1"</span>)</span></span><br><span class="line"><span class="meta">@PublishedApi</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> Closeable?.<span class="title">closeFinally</span><span class="params">(cause: <span class="type">Throwable</span>?)</span></span> = <span class="keyword">when</span> &#123;</span><br><span class="line">    <span class="keyword">this</span> == <span class="literal">null</span> -&gt; &#123;&#125;</span><br><span class="line">    cause == <span class="literal">null</span> -&gt; close()</span><br><span class="line">    <span class="keyword">else</span> -&gt;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            close()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (closeException: Throwable) &#123;</span><br><span class="line">            cause.addSuppressed(closeException)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单总结关键点：</p><ul><li>不同于 Java 7 中，try-with-resources 语句只对实现 <code>AutoCloseable</code> 接口的资源生效，Kotlin 中任何实现 <code>Closeable</code> 接口的资源都会被自动关闭</li><li><code>use()</code> 是扩展方法，它接收一个 block 对象，block 对象将 <code>receiver</code> (被扩展的那个对象) 作为参数。block 对象返回另一个类型为 R 的对象</li><li><code>use()</code> 方法最终会返回 block 对象的返回值</li></ul><p>看个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getBitmap</span><span class="params">()</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">return</span> assets.<span class="keyword">open</span>(<span class="string">"sample.png"</span>).use &#123;</span><br><span class="line">        <span class="keyword">return</span> BitmapFactory.decodeStream(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对照着 <code>AutoCloseable.use()</code> 扩展方法来解读上面的例子：</p><ul><li><code>assets.open()</code> 返回一个 <code>InputStream</code> 实例</li><li><code>InputStream</code> 类实现了 <code>AutoCloseable</code> 接口(<code>AutoCloseable</code> 是 <code>Closeable</code> 的子类)，所以可以对其应用 <code>use()</code> 扩展方法</li><li><code>{ return BitmapFactory.decodeStream(it) }</code> 作为 block 对象传给 <code>use()</code> 方法</li><li>block 对象将 <code>it</code> (<code>it</code> 是 <code>receiver</code>) 解码成 Bitmap，并且返回该 Bitmap 对象</li><li><code>getBitmap()</code> 返回 block 对象返回的 Bitmap</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html" target="_blank" rel="noopener">tryResourceClose</a></li><li><a href="https://blog.jetbrains.com/kotlin/2016/07/first-glimpse-of-kotlin-1-1-coroutines-type-aliases-and-more/" target="_blank" rel="noopener">AutoCloseable.use()</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Jetpack 学习笔记之 LiveData 源码解析</title>
      <link href="2019/05/07/jetpack-livedata-source/"/>
      <url>2019/05/07/jetpack-livedata-source/</url>
      
        <content type="html"><![CDATA[<p>LiveData 是 Android Architecture Components (AAC)中的一个基础类，ViewModel、Room、DataBinding 等多个库用到 LiveData。理解 LiveData 是学习 AAC 的一个关键，本文带你分析 LiveData 源码看看它到底是如何实现的。<br><a id="more"></a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="https://developer.android.com/reference/androidx/lifecycle/LiveData.html" target="_blank" rel="noopener">文档</a>对 LiveData 的介绍是这样的：</p><blockquote><p>LiveData is a data holder class that can be observed within a given lifecycle</p></blockquote><p>短短一句介绍，细细体会却能发现包含很大信息量。</p><ul><li>首先从结构上讲， LiveData 是 holder/wrapper，它持有数据</li><li>其次，LiveData 是观察者模式的应用，它是被观察的一方</li><li>最后，LiveData 能感知生命周期</li></ul><p>下面结合 LiveData 源码分别就这几点进行分析。</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><ul><li>数据持有</li><li>数据变更</li><li>观察者模式</li><li>线程切换</li><li>生命周期感知</li><li>不变性</li></ul><h2 id="数据持有"><a href="#数据持有" class="headerlink" title="数据持有"></a>数据持有</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object mData = NOT_SET;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        mData = value;</span><br><span class="line">        ...</span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object data = mData;</span><br><span class="line">        <span class="keyword">if</span> (data != NOT_SET) &#123;</span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            <span class="keyword">return</span> (T) data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>仅从数据持有者的角度来看 LiveData 的话，它相当简单。LiveData 无非就是一个泛型类，可持有任意类型的数据。Android 应用中随便找个 ViewHolder ，代码可能都要比它要复杂。</p><h2 id="数据变更"><a href="#数据变更" class="headerlink" title="数据变更"></a>数据变更</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object mData = NOT_SET;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mVersion = START_VERSION;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        mVersion++;</span><br><span class="line">        mData = value;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mVersion;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        observer.mLastVersion = mVersion;</span><br><span class="line">        observer.mObserver.onChanged((T) mData);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从字面意思上理解，LiveData 的 <code>mVersion</code> 是用于对持有的数据做版本控制。它的实际作用是用于标识 <code>mData</code> 是否发生变化：</p><ul><li>每次调用 <code>setValue()</code> 时 <code>mVersion</code> 加1</li><li>通过 <code>mLastVersion &gt;= mVersion</code> 判断 <code>mData</code> 是否发生变化</li></ul><p>其实这里也不一定非要用整型的 <code>mVersion</code>，<code>java.util.Observable</code> 就是用布尔类型的 <code>changed</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.Observable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clearChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;       </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">hasChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在处理 “数据是否发生变化” 这个问题上，<code>java.util.Observable</code> 使用布尔类型要比 LiveData 使用整型更易于理解，代码上也更清晰。</p><p>个人猜测使用整型 <code>mVersion</code> 的好处是比布尔值有更多的信息量，也许有更好的扩展性。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when the data is changed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t  The new data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(@Nullable T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SafeIterableMap&lt;Observer&lt;T&gt;, ObserverWrapper&gt; mObservers =</span><br><span class="line">            <span class="keyword">new</span> SafeIterableMap&lt;&gt;();</span><br><span class="line">            </span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observeForever</span><span class="params">(@NonNull Observer&lt;T&gt; observer)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(@NonNull <span class="keyword">final</span> Observer&lt;T&gt; observer)</span> </span>&#123;</span><br><span class="line">        ObserverWrapper removed = mObservers.remove(observer);</span><br><span class="line">        ...</span><br><span class="line">    &#125;                 </span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        mData = value;</span><br><span class="line">        dispatchingValue(<span class="keyword">null</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchingValue</span><span class="params">(@Nullable ObserverWrapper initiator)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">            mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">            considerNotify(iterator.next().getValue());</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        observer.mLastVersion = mVersion;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        observer.mObserver.onChanged((T) mData);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据更新之后，要通知给观察者才有意义。来看看 LiveData 是如何应用观察者模式来通知数据更新的。具体分为以下几个阶段：</p><ul><li>创建观察者</li><li>向 LiveData 添加/移除观察者</li><li>被观察者与观察者之间的交互<ul><li>LiveData 通知数据更新</li><li>观察者响应数据更新</li></ul></li></ul><p>具体步骤如下：</p><ul><li>实现 <code>Observer</code> 接口来创建观察者。该接口只有一个回调方法 <code>onChanged()</code></li><li>使用 <code>LiveData.observeForever()</code> 方法添加观察者。被添加的观察者保存在 <code>mObservers</code> 字段</li><li>使用 <code>LiveData.removeObserver()</code> 方法移除观察者<ul><li>使用 <code>LiveData.setValue()</code> 方法通知数据更新。数据更新过程最终会调用到 <code>LiveData.considerNotify()</code> 方法</li><li><code>Observer.onChanged()</code> 回调方法响应数据更新，该方法的参数即为更新后的数据</li></ul></li></ul><h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><p>你应该注意到 <code>setValue()</code> 有个限制，即只允许从主线程调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    assertMainThread(<span class="string">"setValue"</span>);</span><br><span class="line">    mVersion++;</span><br><span class="line">    mData = value;</span><br><span class="line">    dispatchingValue(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Looper.getMainLooper().getThread() == Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这既是限制，也是个编码技巧。编写只允许从主线程调用的方法的技巧包括：</p><ul><li>技巧一：给方法添加 <code>@MainThread</code>。注意：这个注解本身并不能让方法一定在主线程中运行，但如果从错误的线程中调用本方法，lint 工具马上能自动揪出这种错误</li><li>技巧二：方法中第一时间检查当前线程是否主线程，如果不是，立马抛出 <code>IllegalStateException</code> 异常，让代码快速出错。(谷歌关键字 <a href="https://www.google.com/search?source=hp&amp;ei=3tbcXLrrJ7aUr7wPpNSzkAo&amp;q=fail-fast+in+java&amp;oq=fail-fast+in+java" target="_blank" rel="noopener">fail-fast in java</a>)</li></ul><p>只允许从主线程中调用 <code>setValue()</code> 的好处是避免 <code>Observer.onChanged()</code> 在后台线程中回调这个尴尬的问题。我们知道，最终几乎都是在 Activity/Fragment 实现 <code>Observer</code> 接口，<code>onChanged()</code> 免不了要常常跟 UI 打交道。所以开发者要时时刻刻记得将 <code>onChanged()</code> 切回到主线程，否则 Android 系统一言不合就弹个 crash 提醒你 “Only the original thread that created a view hierarchy can touch its views”。(相当坑是不是？)</p><p>所以不得不说 <code>setValue()</code> 只允许在主线程中调用是一种很赞很值得我们学习的设计，它保证你的代码更不容易出错。</p><p>如果非要从其他线程修改 LiveData 的数据，需要使用 <code>postValue()</code> 方法。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> postTask;</span><br><span class="line">    <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">        postTask = mPendingData == NOT_SET;</span><br><span class="line">        mPendingData = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!postTask) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable mPostValueRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object newValue;</span><br><span class="line">        <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">            newValue = mPendingData;</span><br><span class="line">            mPendingData = NOT_SET;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        setValue((T) newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>postValue()</code> 有几个关键点：</p><ul><li>一是 <code>synchronized</code> 关键字的使用。<code>mDataLock</code> 作为锁，保证后台线程和主线程对 <code>mPendingData</code> 的写操作是互斥的</li><li>二是通过 <code>postToMainThread()</code> 从后台线程切回主线程</li><li>最后，回到主线程中后直接调用 <code>setValue()</code>，完成最终的数据更新</li></ul><p>第二点可以作为 Android 开发中线程切换的一个范例。来详细看一下。(注：<code>postToMainThread()</code> 方法涉及到 <code>TaskExecutor</code> 相关的几个类, 我们这里抛开不相关细节直入主题直接看 <code>DefaultTaskExecutor</code> 的代码)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultTaskExecutor</span> <span class="keyword">extends</span> <span class="title">TaskExecutor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> ExecutorService mDiskIO = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Handler mMainHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeOnDiskIO</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        mDiskIO.execute(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postToMainThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMainHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mMainHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mMainHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">        mMainHandler.post(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Looper.getMainLooper().getThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从后台线程切换到主线程很简单，向一个以跟主线程 <code>Looper</code> 绑定的 <code>Handler</code> 扔 <code>Runnable</code> 消息就可以了。</li><li>反之，从主线程切换到后台线程更简单，向 <strong>恰当的线程池</strong> 扔 <code>Runnable</code> 消息即可。赶紧忘记 new Thread() 吧，不要让你的应用中线程数失控！</li></ul><p><code>postValue()</code> 有个小坑值得提一下，以这段代码为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">liveData.postValue(<span class="string">"b"</span>)</span><br><span class="line">liveData.setValue(<span class="string">"a"</span>)</span><br></pre></td></tr></table></figure><p>要注意的是这段代码执行后 liveData 当前值是 “b” 而不是 “a” 。原因见 <code>postValue()</code> 的实现机制。这个结果可能跟直观上不一致，小心使用 LiveData 过程不要踩到这个坑。</p><h2 id="生命周期感知"><a href="#生命周期感知" class="headerlink" title="生命周期感知"></a>生命周期感知</h2><p>LiveData 是 lifecycle-aware 的，翻译过来就是对组件(这里的组件不妨简单地理解为 Activity/Fragment) 的生命周期有感知的。</p><p>你可能会想，尽是新鲜名词，到底有鸟用？先来看 Android 开发中几个经典的坑。</p><ul><li>坑一，使用 Glide 加载图片出现 crash <a href="https://github.com/bumptech/glide/issues/803" target="_blank" rel="noopener">issue#803</a></li><li>坑二，使用 DialogFragment 弹框出现 crash <a href="https://github.com/410063005/cmdemo/blob/master/app/src/main/java/com/sunmoonblog/cmdemo/lifecycle/DialogWillCrashActivity.kt#L26" target="_blank" rel="noopener">Github</a></li></ul><p>分别沿着这两个 crash 的路径找下去，最后你会发现有个相同之处：在调用链有某处代码会检查 Activity/Fragment 组件的生命周期，如果生命周期状态不对，就抛出 <code>IllegalArgumentException</code> 或 <code>IllegalStateException</code> 异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with()</span><br><span class="line"> -&gt; RequestManagerRetriever.get()</span><br><span class="line">  -&gt; RequestManagerRetriever.assertNotDestroyed()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DialogFragment.show()</span><br><span class="line"> -&gt; FragmentTransaction.commit()</span><br><span class="line">  -&gt; BackStackRecord.commit()</span><br><span class="line">   -&gt; BackStackRecord.commitInternal()</span><br><span class="line">    -&gt; FragmentManagerImpl.enqueueAction()</span><br><span class="line">      -&gt; FragmentManagerImpl.checkStateLoss()</span><br><span class="line">       -&gt; FragmentManagerImpl.isStateSaved()</span><br></pre></td></tr></table></figure><p>从设计上讲，生命周期状态不对时抛出 <code>IllegalArgumentException</code> 或 <code>IllegalStateException</code> 是正确的做法。如果上层代码不能正确地处理这些异常，自然就会 crash。</p><p>问题是，<strong>这些异常太容易被忽略</strong>，你甚至完全意识不到。试想以下场景：</p><ul><li>场景一：某个原因导致 Activity 结束后才调用 <code>Glide.with(context).load(url).into(imageView)</code></li><li>场景二：应用收到消息会弹出一个提示框 (<code>DialogFragment</code>)，但收到消息时应用已经被切到后台去了</li></ul><p>时刻记得检查 Activity 是否结束、应用是否在后台显然是不可能的，这也是为什么 Android 开发中这些地方特别容易出现 crash。换个角度考虑，如果 Glide 能自动感知 Activity 是否被销毁，FragmentTransaction 能自动感知 Activity 是否进入后台，我敢断定相关的 crash 会少很多，开发者的日子也会好过很多。</p><p>题外话：<a href="https://github.com/bumptech/glide/issues/3612" target="_blank" rel="noopener">issue#3612</a> 提议 Glide 支持 <code>Glide.with(LifecycleOwner)</code> 这种形式的调用，好处是 Glide 能感知生命周期，能更好地跟 Android Architecture Components 结合使用。</p><p>总的来说，LiveData 能感知生命周期的特性可以解决这个痛点：</p><ul><li>避免了 Activity/Fragment 不活跃时 listener/observer 被回调导致的 crash</li></ul><p>另外，LiveData 一定程度上避免了忘记 remove listener/observer 导致的内存泄漏，原因稍后解释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class="line">      <span class="comment">// the observer moved to an active state, if we've not received that event, we better not</span></span><br><span class="line">      <span class="comment">// notify for a more predictable notification order.</span></span><br><span class="line">      <span class="comment">// 代码三</span></span><br><span class="line">      <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">          observer.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      observer.mObserver.onChanged((T) mData);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@MainThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 代码四</span></span><br><span class="line">      <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">          <span class="comment">// ignore</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 代码一</span></span><br><span class="line">      LifecycleBoundObserver wrapper = <span class="keyword">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class="line">      ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 代码二</span></span><br><span class="line">      owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title">GenericLifecycleObserver</span> </span>&#123;</span><br><span class="line">      <span class="meta">@NonNull</span> <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line"></span><br><span class="line">      LifecycleBoundObserver(<span class="meta">@NonNull</span> LifecycleOwner owner, Observer&lt;T&gt; observer) &#123;</span><br><span class="line">          <span class="keyword">super</span>(observer);</span><br><span class="line">          mOwner = owner;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 代码五</span></span><br><span class="line">          <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">              removeObserver(mObserver);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 代码六</span></span><br><span class="line">          activeStateChanged(shouldBeActive());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">detachObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          mOwner.getLifecycle().removeObserver(<span class="keyword">this</span>);</span><br><span class="line">      &#125;        </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>前文讲观察者模式时只提到 <code>observeForever()</code> 方法。从名字上可以知道使用 <code>observeForever()</code> 注册的观察者会持续对当前 LiveData 观察，直到手动调用 <code>removeObserver()</code> 删除这个观察者。</p><p>除 <code>observeForever()</code> 外还有另外一个 <code>observe()</code>，这个方法也是用来注册观察者。 它的神奇之处在于通过它注册的观察者，<strong>观察 LiveData 的同时还能感知生命周期</strong>。具体说来：</p><ul><li>通过 <code>observe()</code> 注册的观察者只在 Activity/Fragment 处于活跃的生命周期时才能收到数据更新/回调<ul><li>代码一，注册的 <em>初始的观察者</em> 及 <a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a> 被包装成 LifecycleBoundObserver。LifecycleBoundObserver 是 LiveData 真正的观察者</li><li>代码二，LifecycleBoundObserver 同时作为 Lifecycle 的观察者</li><li>代码六，LifecycleOwner 生命周期的变化会影响 LifecycleBoundObserver 的活跃状态</li><li>代码三，LifecycleBoundObserver 处于不活跃状态时，<em>初始的观察者</em> 并不会收到数据更新</li></ul></li><li>不必手动删除 <code>observe()</code> 方法注册的观察者，它会随着 Activity/Fragment 的结束而自动清理 (忘记取消注册观察者/监听器是 Android 应用内存泄漏问题的一个重要原因，所以这个特性能在一定程度上减少内存泄漏)<ul><li>代码四，<code>observe()</code> 方法在 LifecycleOwner 的 Lifecycle 处于 DESTROYED 状态时并不会真正注册观察</li><li>代码五，LifecycleOwner 的 Lifecycle 进入 DESTROYED 时会自动删除 LifecycleBoundObserver</li></ul></li></ul><p><code>LifecycleBoundObserver</code> 是否处于活动状态由 <code>shouldBeActive()</code> 来判断。其依据很简单：判断LifecycleOwner 当前的 Lifecycle 是否至少处理 STARTED 状态即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">        DESTROYED,</span><br><span class="line"></span><br><span class="line">        INITIALIZED,</span><br><span class="line"></span><br><span class="line">        CREATED,</span><br><span class="line"></span><br><span class="line">        STARTED,</span><br><span class="line"></span><br><span class="line">        RESUMED;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAtLeast</span><span class="params">(@NonNull State state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LiveData 生命周期感知的要点其实很简单，概括一下就是：<font color="red">注册到 LiveData 的观察者同时也观察 LifecycleOwner (Activity/Fragment) 的生命周期状态，仅在 LifecycleOwner 生命周期处于活跃状态时才将 LiveData 中的数据变化通知/加回调给观察者</font>。</p><p>LiveData 看似微不足道的改进，解决了 Android 开发长期以来这两个痛点： 1. 不正确的生命周期状态时回调导致 crash 2. 忘记取消注册观察导致内存泄漏</p><h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><p>应用 LiveData 时，会有两个不同的角色：</p><ul><li>一方是消费者/观察者，它响应数据更新，具体来说通常是在 UI 中监听 LiveData 的变化</li><li>另一方是生产者/被观察者，它通知数据更新，具体来说通常是在 ViewModel 中修改 LiveData</li></ul><p>来看个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        </span><br><span class="line">        viewModel.liveData</span><br><span class="line">                .observe(<span class="keyword">this</span>, Observer &#123;newValue -&gt;</span><br><span class="line">                    Log.i(<span class="string">"MainActivity"</span>, newValue)</span><br><span class="line">                &#125;)        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> liveData = LiveData&lt;String&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        liveData.value = <span class="string">"a new value"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过你会发现这里的代码有个编译错误，无法给 <code>liveData.value</code> 赋值，因为无法访问 <code>setValue()</code> 方法。仔细看 LiveData 的源码中相关的你会发现这是有意为之：LiveData 是不可变的！</p><ul><li><code>setValue()/postValue()</code> 的访问修饰符是 <code>protected</code>，不允许子类以外的类来访问</li><li><code>getValue()</code> 公开的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MainActivity</code> 作为 LiveData 的观察者和消费方，<strong>不应修改</strong> LiveData，所以让 LiveData 对其保持不可变是个非常好的设计。但 <code>MyViewModel</code> LiveData 的生产方，必须要修改 LiveData，该怎么办？</p><p>别急，LiveData 还有个子类 MutableLiveData。由于 MutableLiveData 的代码简单得不能再简单，就完整地贴上来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableLiveData</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.postValue(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MutableLiveData 不过是将 <code>setValue()/postValue()</code> 的访问修饰符从 <code>protected</code> 修改成 <code>public</code>，让其可变。</p><p>使用 MutableLiveData 对之前代码略加修改，这回没有编译错误了，也满足了观察者不修改 LiveData 的要求。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        </span><br><span class="line">        viewModel.getLiveData()</span><br><span class="line">                .observe(<span class="keyword">this</span>, Observer &#123;newValue -&gt;</span><br><span class="line">                    Log.i(<span class="string">"MainActivity"</span>, newValue)</span><br><span class="line">                &#125;)        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> liveData = MutableLiveData&lt;String&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getLiveData</span><span class="params">()</span></span>: LiveData&lt;String&gt; = liveData</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        liveData.value = <span class="string">"a new value"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便简单提一下，LiveData 除了 MutableLiveData 子类，还有另一个子类 MediatorLiveData。另外，Transformations 还提供 LiveData 的变换操作 (是不是有些 RxJava 的感觉？)，目前提供的变换操作包括：</p><ul><li>map()</li><li>switchMap()</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文从以下角度对 LiveData 的源码进行了简单的分析：</p><ul><li>数据持有者</li><li>数据变更和观察者模式</li><li>生命周期感知</li><li>线程切换</li><li>不变性</li></ul><p>从数据持有者的角度来看 LiveData，它并没有什么特别的。Android 开发中早已大量使用观察者模式，所以 LiveData 的观察者模式也不是太大亮点。但对比现有的一些解决方案(如 RxJava)，LiveData 的特点在于<font color="red">它是一个可感知生命周期的观察者模式</font>。可以这样理解 LiveData，它是专注解决 Android 开发问题的一个观察者模式。</p><p>LiveData 的线程切换和不变性的两个技巧则是工程设计上的考虑，这些技巧可以帮助开发者写代码时更不容易出错，写出的代码设计上更好。在日常开发中我们可以有意识地恰当地学习使用这些技巧，以期得到更好的开发质量。</p><hr><p>限于篇幅本文只分析 LiveData 源码。LiveData 作为基础设施，在整个 AAC 中被大量使用，所以其实有不少有意思的话题。这里举几个例子以便有兴趣的读者继续深入了解。</p><p>例一，Room 中结合使用 LiveData 简直完美。比方说你调用 <code>PersonDao.delete()</code> 删除一条数据，会发现原先注册在 <code>PersonDao.getAll()</code> 上的观察者能感知到这个删除动作，新的数据通过 <code>onChanged()</code> 自动通知给活跃的观察者(响应式 UI 就是这么来的)。那么 Room 内部又是如何基于 LiveData 实现这个特性的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Person person)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"select * from person order by id desc"</span>)</span><br><span class="line">    LiveData&lt;List&lt;Person&gt;&gt; getAll();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例二，进行数据绑定时 LiveData 比 BaseObservable 和 ObservableField 方式好用得多。但是，为了保证这里布局中 <code>viewModel.liveData</code> 能正常绑定，事先必须先调用 <code>binding.setLifecycleOwner()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> </span>&#123;</span><br><span class="line">    val liveData = LiveData&lt;String&gt;()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">type</span>=<span class="string">"MyViewModel"</span> <span class="attr">name</span>=<span class="string">"viewModel"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">text</span>=<span class="string">"@&#123;viewModel.liveData&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为什么必须先调用 <code>binding.setLifecycleOwner()</code> ？binding 又是如何跟 liveData 绑定上的？</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Jetpack 学习笔记之 DataBinding</title>
      <link href="2019/05/07/jetpack-data-binding-2/"/>
      <url>2019/05/07/jetpack-data-binding-2/</url>
      
        <content type="html"><![CDATA[<p>简单学习一下 Android 数据绑定的基本用法。<br><a id="more"></a><br>在<a href="https://www.sunmoonblog.com/2019/05/06/jetpack-data-binding/">前一篇</a>中听完对 Android 数据绑定的各种吐槽后再来了解数据绑定的用法并动手实践一下。(是不是顺序搞反了？)</p><p>本文是<a href="https://www.vogella.com/tutorials/AndroidDatabinding/article.html#custom-converters-with-bindingadapter" target="_blank" rel="noopener">这篇博客</a>的学习笔记。主要内容包括：</p><ul><li>数据绑定介绍</li><li>数据绑定和事件绑定</li><li>数据绑定的几种方式</li><li>BindingAdapter</li></ul><h1 id="数据绑定介绍"><a href="#数据绑定介绍" class="headerlink" title="数据绑定介绍"></a>数据绑定介绍</h1><p><a href="https://developer.android.com/topic/libraries/data-binding" target="_blank" rel="noopener">官网</a>关于数据绑定的介绍如下：</p><blockquote><p>The Data Binding Library is a support library that allows you to bind UI components in your layouts to data sources in your app using a declarative format rather than programmatically.<br>Binding components in the layout file lets you remove many UI framework calls in your activities, making them simpler and easier to maintain. This can also improve your app’s performance and help prevent memory leaks and null pointer exceptions.</p></blockquote><p>简单来说这个库的作用是：</p><ul><li>减少 Activity 中大量的 UI 相关调用，让其简单易维护</li><li>使用声明的方式而非编程的方式将 UI 布局跟数据绑定</li></ul><p>什么是 UI 相关的调用呢？相信 <code>findViewById()</code> 方法你一定不陌生。你可能已经习惯了使用 <code>findViewById()</code>，它很直白。但它是编程式的，并不优雅。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TextView textView = findViewById(R.id.sample_text);</span><br><span class="line">textView.setText(viewModel.getUserName());</span><br></pre></td></tr></table></figure><p>实际项目中你会一遍又一遍地写 <code>findViewById()</code> 这种代码，最终会很烦。这也是 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">ButterKnife</a> 之类的库以及 kotlin-android-extensions 插件的由来。</p><p>使用 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">ButterKnife</a> 可以减少 <code>findViewById()</code> 调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="meta">@BindView</span>(R.id.user) EditText username;</span><br><span class="line">  <span class="meta">@BindView</span>(R.id.pass) EditText password;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@BindString</span>(R.string.login_error) String loginErrorMessage;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnClick</span>(R.id.submit) <span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO call server...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 kotlin-android-extensions 插件则可以直接将 XML 布局文件中 id 作为控件本身来使用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_data_binding_demo.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataBindingDemoActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> binding = DataBindingUtil.setContentView&lt;ActivityDataBindingDemoBinding&gt;(<span class="keyword">this</span>,</span><br><span class="line">                R.layout.activity_data_binding_demo)</span><br><span class="line"></span><br><span class="line">        buttonUpdate.text = <span class="string">"this is a button"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但无论如何，以上这些改进方案仍然还是编程式的。那怎样才算声明式的呢？要像这样！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;viewmodel.userName&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>要在项目中使用数据绑定，需要进行如下配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ....</span><br><span class="line">    dataBinding &#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据绑定主要涉及内容包括：</p><ul><li>XML 布局文件</li><li>ViewDataBinding</li><li>生成的 Binding 类</li><li>DataBindingUtil</li></ul><p><img src="pic.png" alt></p><p>其中，</p><ul><li>XML 布局文件跟普通的 XML 文件稍稍有所不同。其结构如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">"message"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">"String"</span> /&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    普通的布局，跟以前一样</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>生成的 Binding 类继承自 ViewDataBinding。生成类与布局文件的对应规则：ActivityDataBindingDemo2Binding.java 对应于 activity_data_binding_demo2.xml。</p></li><li><p>DataBindingUtil 负责最终将布局文件与生成的类关联起来：</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> binding = DataBindingUtil.setContentView&lt;ActivityDataBindingDemo2Binding&gt;(<span class="keyword">this</span>,</span><br><span class="line">R.layout.activity_data_binding_demo2)</span><br></pre></td></tr></table></figure><h1 id="数据绑定的几种方式"><a href="#数据绑定的几种方式" class="headerlink" title="数据绑定的几种方式"></a>数据绑定的几种方式</h1><p>先来看一个最简单的例子。</p><p>XML 布局文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">"message"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">"String"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/text"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@&#123;message&#125;"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">"0.5"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:text</span>=<span class="string">"show a message"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Activity 代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataBindingDemoActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> binding = DataBindingUtil.setContentView&lt;ActivityDataBindingDemoBinding&gt;(<span class="keyword">this</span>,</span><br><span class="line">                R.layout.activity_data_binding_demo)</span><br><span class="line"></span><br><span class="line">        binding.message = <span class="string">"hello, databinding"</span>        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于基于类型和 String 类型，我们按上述方式写是没有问题。那是否可以支持自定义类型呢？</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">"viewmodel"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">"com.demo.MyViewModel"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:text</span>=<span class="string">"@&#123;viewmodel.message&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>假设 <code>MyViewModel</code> 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你使用这种方式更新会发现并不生效：</p><p><code>binding.viewmodel.message = &quot;hello, data binding&quot;</code></p><p>数据绑定是支持自定义类型的。但需要额外的工作来实现，有几种不同的方式：</p><ul><li>实现 <code>Observable</code> 接口或继承 <code>BaseObservable</code> 类</li><li>使用 <code>ObservableField</code> 类</li><li>使用 <code>LiveData</code> 类</li></ul><p>以 <code>MyViewModel</code> 中的三个字段分别加以说明。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> : <span class="type">BaseObservable</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> message: String = <span class="string">"hello, data binding"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            notifyPropertyChanged(BR.message)</span><br><span class="line">            <span class="comment">// notifyChange()</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> message2 : ObservableField&lt;String&gt; = ObservableField(<span class="string">"hello, data binding"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> liveMessage = MutableLiveData&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Observable-接口"><a href="#Observable-接口" class="headerlink" title="Observable 接口"></a>Observable 接口</h2><p>不推荐直接使用 <code>Observable</code> 接口，而是使用它的实现类 <code>BaseObservable</code>。<code>BaseObservable</code> 提供两个方法：</p><ul><li>notifyPropertyChanged(int fieldId) - 通知监听器指定字段有更新</li><li>notifyChange() - 通知监听器所有字段都有更新</li></ul><p>注意这里重写了 <code>message</code> 字段的 setter 方法，在更新字段后调用了 <code>notifyPropertyChanged</code> 通知更新。</p><h2 id="ObservableField-类"><a href="#ObservableField-类" class="headerlink" title="ObservableField 类"></a>ObservableField 类</h2><p>从源码可以看到 <code>ObservableField</code> 其实也是继承自 <code>BaseObservable</code>，Android SDK 提供这个类不过是让开发者更方便而已。</p><p><code>ObservableField</code> 对单一的字段进行包装，并且在字段值发生变化时调用 <code>notifyChange()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseObservableField</span> <span class="keyword">extends</span> <span class="title">BaseObservable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseObservableField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableField</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BaseObservableField</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> T mValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value != mValue) &#123;</span><br><span class="line">            mValue = value;</span><br><span class="line">            notifyChange();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LiveData-类"><a href="#LiveData-类" class="headerlink" title="LiveData 类"></a>LiveData 类</h2><p>上述两种方式各有不足：</p><ul><li>Observable 接口 - 这种方式对外暴露了实现细节 (需要开发者自己调用 <code>notify()</code> 方法) 且依赖于生成的 BR 类</li><li>ObservableField 类 - 在 Observable 接口的基础上有所改进但仍然略显繁琐</li></ul><p>所以个人推荐使用 LiveData 类。不过使用 LiveData 时记得要在 Activity 进行如下调用，否则是 UI 是无法跟数据同步更新的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val binding = DataBindingUtil.setContentView&lt;ActivityDataBindingDemo2Binding&gt;(this, </span><br><span class="line">R.layout.activity_data_binding_demo2)</span><br><span class="line">// 给 binding 设置 lifecycle owner 后才能对 live data 进行数据绑定</span><br><span class="line">binding.setLifecycleOwner(this)</span><br></pre></td></tr></table></figure><h1 id="BindingAdapter"><a href="#BindingAdapter" class="headerlink" title="BindingAdapter"></a>BindingAdapter</h1><p>数据绑定很强大的地方在于 <code>BindingAdapter</code>。听名字很难理解？直接看代码。</p><p>XML 布局文件如下，功能很简单，展示一个网络图片。注意这里非常神奇的 <code>app:imageUrl</code>！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">"imageUrl"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">"String"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/imageView"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"300dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">"180dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:scaleType</span>=<span class="string">"centerCrop"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:imageUrl</span>=<span class="string">"@&#123;imageUrl&#125;"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintDimensionRatio</span>=<span class="string">"H,16:9"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">"0.5"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:srcCompat</span>=<span class="string">"@tools:sample/avatars"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.constraint.ConstraintLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ImageView 并没有 <code>app:imageUrl</code> 属性，它是哪里来的呢？原来使用数据绑定库中提供的 <code>@BindingAdapter</code> 注解可以很轻松地 ImageView 生成一个名为 <code>imageUrl</code> 的自定义属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Utils</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BindingAdapter</span>(<span class="string">"app:imageUrl"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setImageUrl</span><span class="params">(ImageView view, String url)</span> </span>&#123;</span><br><span class="line">        Glide.with(view.getContext()).load(url).placeholder(R.color.grey).into(view);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的 Activity 的代码就更简单了，可以像使用本地图片资源一样使用网络图片：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataBindingAdapterActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> binding = DataBindingUtil.setContentView&lt;ActivityDataBindingAdapterBinding&gt;(<span class="keyword">this</span>,</span><br><span class="line">                R.layout.activity_data_binding_adapter)</span><br><span class="line">        binding.imageUrl = <span class="string">"http://e.hiphotos.baidu.com/image/pic/item/dc54564e9258d1092f7663c9db58ccbf6c814d30.jpg"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        <span class="comment">// force placeholder to be displayed</span></span><br><span class="line">        Glide.<span class="keyword">get</span>(<span class="keyword">this</span>).clearMemory()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很久很久以前我想基于 Glide 来造一个简单的轮子：扩展 <code>ImageView</code>，给它提供一个 <code>setImageUrl()</code> 方法以方便地加载网络图片。后来因为我很忙，每天都很忙(说白了就是拖延)，这个想法就搁浅了。不过现在看来，这个轮子没必要了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Android 数据绑定是个不错的技术，合理地使用可以为开发带来相当大的方便，最让人眼前一亮的是 <code>BindingAdapter</code>。但不得不说的是，对比 vue.js 中的数据绑定，使用起来还是复杂太多，有太多繁琐的细节(静态语言的限制？)。</p><p>这是从 <a href="https://vuejs.org/v2/guide/#Declarative-Rendering" target="_blank" rel="noopener">vue.js</a> 摘抄的一个例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello Vue!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个 vue.js 的例子跟 Android 对比一下：</p><ul><li>没有 <code>&lt;data&gt;</code> 和 <code>&lt;variable&gt;</code> (这两个标签完全是形式上的东西)</li><li>不需要用插件生成类似 ActivityDataBindingDemoBinding 的代码 (可能有，但对开发者不可见)</li><li><code>&amp;#123;&amp;#123;&amp;#125;&amp;#125;</code> 比 <code>@{}</code> 看起来更清晰，写起来也更不容易出错</li><li>没有类似 DataBindingUtil 的类，不容易出错 (DataBindingUtil 工具类有超多的方法，每次使用得小心地选择)</li></ul><p>vue.js 中的数据绑定无疑比 Andriod 简明很多，如果 Android 的数据绑定库能有这么易懂，相信能吸引更多开发者使用。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.vogella.com/tutorials/AndroidDatabinding/article.html#custom-converters-with-bindingadapter" target="_blank" rel="noopener">Using data binding in Android - Tutorial</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Android Jetpack 学习笔记之关于 DataBinding 的争论</title>
      <link href="2019/05/06/jetpack-data-binding/"/>
      <url>2019/05/06/jetpack-data-binding/</url>
      
        <content type="html"><![CDATA[<p>数据绑定在 Android 应用开发中到底是不是一个好的实践？你肯定说话好，因为是 Google 出的嘛，Google 都说它好。不过这里有篇奇怪的文章，它说 Android 数据绑定技术不好，存在不少问题。到底什么问题，它说得对还是不对？我翻译一下，当作学习。<br><a id="more"></a><br><a href="https://medium.com/@hellotimmutton/an-argument-against-data-binding-13e2aaf7a9b1" target="_blank" rel="noopener">原文</a></p><p>注：随意 Android 数据绑定库的更新，这篇文章中提到的一些问题已经被修复了。</p><p>从一个比较高的角度来说，Android 的数据绑定库是一个非常不错的概念。更新 ViewModel 中的数据就可以让界面自动更新 (是不是很爽？)。但在本文中我会说说为什么我觉得这个库其实是在鼓励写糟糕的代码，以至于必须非常小心地管理这些糟糕的代码，以及这个库带来的其他的问题。这里的讨论基于我在实际项目中使用 Android 数据绑定库的体验。</p><h1 id="关注点分离"><a href="#关注点分离" class="headerlink" title="关注点分离"></a>关注点分离</h1><p>使用数据绑定最大的问题是它鼓励将展示逻辑写在 XML 文件中。布局文件应当只定义跟屏幕展示内容相关的布局，这个道理是不言自明的。</p><p>看这个简单的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:visibility="@&#123;viewModel.showTitle ? View.VISIBLE : View.GONE&#125;"</span><br></pre></td></tr></table></figure><p>为了更改一个 View 的可见性，你必须在 XML 中实现一个基于 boolean 值的三元操作，或者在 ViewModel 中设置正确的 integer 值。</p><p>考虑到这里的代码非常简单，所以你并不介意在 XML 中写类似代码。但问题是一旦你允许在布局中写逻辑，它就可能变得一团糟。某天你可能看到这样的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:visibility="@&#123;!viewModel.hideFragmentLayout &amp;&amp; !viewModel.showError &amp;&amp; viewModel.vehiclesViewModel.showFullScreenProgress ? View.VISIBLE : View.GONE&#125;"</span><br><span class="line">android:visibility="@&#123;!viewModel.isError &amp;&amp; !viewModel.hideFragmentLayout ? View.VISIBLE : View.GONE&#125;"</span><br></pre></td></tr></table></figure><p>以上是一个比较极端的例子。解决办法是为每种组合引入一个变量，然后基于这个变量来恰当地更新 visibility。</p><p>如果使用数据绑定的布局有 include 其他布局文件，问题会变得更加明显。你可能会在子布局中定义变量，然后在父布局中为这些变量进行绑定。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span></span></span><br><span class="line"><span class="tag">    <span class="attr">layout</span>=<span class="string">"@layout/layout_full_screen_error"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:errorMessage</span>=<span class="string">"@&#123;viewModel.errorMessage&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:errorTitle</span>=<span class="string">"@&#123;viewModel.errorTitle&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:imageResource</span>=<span class="string">"@&#123;viewModel.errorImage&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:onClick</span>=<span class="string">"@&#123;() -&gt; viewModel.onErrorRetryClicked()&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:visibility</span>=<span class="string">"@&#123;viewModel.showError ? View.VISIBLE : View.GONE&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>被包含的布局如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.graphics.drawable.Drawable"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.view.View"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.text.TextUtils"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag"> <span class="attr">name</span>=<span class="string">"visibility"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag"> <span class="attr">name</span>=<span class="string">"errorTitle"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">type</span>=<span class="string">"java.lang.CharSequence"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag"> <span class="attr">name</span>=<span class="string">"errorMessage"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">type</span>=<span class="string">"java.lang.CharSequence"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag"> <span class="attr">name</span>=<span class="string">"onClick"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">type</span>=<span class="string">"android.view.View.OnClickListener"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag"> <span class="attr">name</span>=<span class="string">"imageResource"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">type</span>=<span class="string">"Drawable"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个包含子布局的例子看起来非常乱。我甚至都不想讨论这个例子中的 <code>onClick</code> 绑定。我想我已经通过这个例子表明了我的观点。</p><h1 id="不一致-不清晰的用法"><a href="#不一致-不清晰的用法" class="headerlink" title="不一致/不清晰的用法"></a>不一致/不清晰的用法</h1><p>到目前为止上面的例子主要是说将展示逻辑引入到 XMl 布局文件引起的问题。另一个问题是你如何进行绑定的方法并不清晰。ViewModel 有多种方式来更新数据：</p><ul><li>如果 ViewModel 是继承自 <code>BaseObservable</code>，你可以使用 <code>@Bindable</code> 注解</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> showError: <span class="built_in">Boolean</span></span><br><span class="line"> <span class="meta">@Bindable</span> <span class="keyword">get</span>() = !hideFragmentLayout.<span class="keyword">get</span>() &amp;&amp; isError.<span class="keyword">get</span>()</span><br></pre></td></tr></table></figure><ul><li>也可以使用 <code>ObservableField</code></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> errorMessage = ObservableField&lt;CharSequence&gt;()</span><br></pre></td></tr></table></figure><ul><li>或者让 Activity/Fragment 监听 <code>ObservableCommand</code></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> showLoading = ObservableCommand&lt;<span class="built_in">Boolean</span>&gt;()</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viewModel.showLoading.subscribe &#123;</span><br><span class="line">    progressBar?.showLoadingAnimation(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(译者注：我在最新的 support library 中找不到 ObservableCommand 类，去掉了？)</p><p>关于哪种场景下应该使用哪个方法我们有一些宽泛的规则，但由于这些方法太过相似，什么时候该用哪种方法还是非常容易弄混，所以给看代码和调代码都造成了困难。</p><p>更新：写这篇文章时 Google 推出了 Architecture Components library，它通过 LiveData 提供了另外一种类似 ObservableField 和 ObservableCommand 数据绑定方式。也许 LiveData 是数据绑定事实上的标准方式。</p><h1 id="将-ViewModel-作为-POJO"><a href="#将-ViewModel-作为-POJO" class="headerlink" title="将 ViewModel 作为 POJO"></a>将 ViewModel 作为 POJO</h1><p>我之前聊过这个话题，最好是将 ViewModel 作为 POJO。既有语义上的原因，另一个原因是它有助于单元测试。但是，由于 ViewModel 负责设置 text/drawables 等资源，为了实现这个目的我们最终不得不对 Android SDK 进行部分封装，最后会写出这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uiService.hideKeyboard()</span><br></pre></td></tr></table></figure><p>Which is a method on a UiService interface that is implemented as either an ActivityUiService or FragmentUiService an injected into the view model using dagger. This should be obvious, but a view model should not be responsible for showing and hiding the keyboard.</p><p>译者注：这一节我没有完全明白，感觉是原作者对 ViewModel 的用法理解有误，所以干脆略过没有翻译。我的理解是 ViewModel 只负责管理数据状态，不负责管理 UI 状态，所以不存在设置 text/drawables 一说。</p><h1 id="构架"><a href="#构架" class="headerlink" title="构架"></a>构架</h1><p>我跟一个非常热衷于数据绑定库的同事聊天时，他的回应是我提出的大部分问题其实是可以避免的，前提是你要小心地管理你的代码。但我认为就算他是正确的，一个好的架构应该可以限制你写出糟糕的代码，而不是鼓励你写出糟糕的代码。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>我之前也聊过这个话题，但值得再说一次：使用了数据绑定之后，展示层变得很难单元测试，有时甚至是无法测试的。</p><p>在 ViewModel 中引入 Android 类后意味着你可能需要使用生成的 R.java 文件，以及模块一些 Android 类，而其中某些类是 final 类。</p><p>更糟糕的是，如果你将展示逻辑放在 XML 文件中或者 Activity/Fragment 中(这个库推荐这种设计方式)，也会让单元测试变得困难。如果有谁知道有什么好的测试办法，也请告诉我。</p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>使用了数据绑定库之后，kotlin 和 dagger 都会在编译期生成代码，所以项目的编译耗时成了恶梦。另外，由于多个库在编译期生成代码，kotlin 增量编译无法正常运行，instant run 也无法正常运行。我参与的另一个项目也在使用 kotlin 和 dagger，但是没有使用数据绑定库，这个项目就不存在这些问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我问了一些使用过数据绑定库的同事以上这些问题，他们的回答通常是”我也不知道哪里去找代码逻辑”，所以我决定写这篇文章，文章中使用几个例子展示了逻辑是如何分散在多个地方并且没有清晰的界限的。考虑到开发过程中很多时间是在读代码，所以代码放在容易被找到的位置很重要。加上不易测试，以及过长的编译时间，所以很容易解释为什么新的开发者不愿意使用数据绑定库。我也不愿意在后续项目中使用这个库。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Jetpack 学习笔记之 Lifecycle</title>
      <link href="2019/05/05/jetpack-lifecycle/"/>
      <url>2019/05/05/jetpack-lifecycle/</url>
      
        <content type="html"><![CDATA[<p>本文介绍 LifecycleOwner 的主要概念和基本用法。<br><a id="more"></a></p><h1 id="ProcessLifecycleOwner"><a href="#ProcessLifecycleOwner" class="headerlink" title="ProcessLifecycleOwner"></a><a href="https://developer.android.com/reference/androidx/lifecycle/ProcessLifecycleOwner.html" target="_blank" rel="noopener">ProcessLifecycleOwner</a></h1><p>先来看看 <code>ProcessLifecycleOwner</code>。</p><p>为什么先说这个类呢？相信大家可能都有开发这样的一个常见需求：监听当前应用前后台切换，并对此进行响应。这个功能并不复杂，实现 <code>Application.ActivityLifecycleCallbacks</code> 接口即可。问题在于，在 Android 上并没有标准的方法来判断是应用是处于前台还是后台，即使使用 <code>ActivityLifecycleCallbacks</code> 接口，多多少少有些 trick 在其中，所以大部分代码写得并不优雅易读。</p><p>而 <code>ProcessLifecycleOwner</code>，可以被视为 Android 上一个比较标准的监听应用前后台切换的方式。老习惯，先翻译一遍<a href="https://developer.android.com/reference/androidx/lifecycle/ProcessLifecycleOwner.html" target="_blank" rel="noopener">文档</a>。</p><blockquote><p>这个类提供整个应用进程的生命周期。<br>你可以将这个 LifecycleOwner 作为全体 Activity 的 LifecycleOwner，除了 <code>Lifecycle.Event.ON_CREATE</code> 事件只会分发一次，而 <code>Lifecycle.Event.ON_DESTROY</code> 永远不被分发。其他事件的分发遵守以下规则：<br>ProcessLifecycleOwner 会在第一个 Activity 经历 <code>Lifecycle.Event.ON_START</code> 和 <code>Lifecycle.Event.ON_RESUME</code> 事件时分发这些事件。 ProcessLifecycleOwner 会在最后一个 Activity 经历 <code>Lifecycle.Event.ON_PAUSE</code> 和 <code>Lifecycle.Event.ON_STOP</code> 事件 <em>延迟一段时间</em> 分发这些事件。这个延时足够长以确保 ProcessLifecycleOwner 不会在 Activity 由于配置变更而销毁重建期间发送任何事件。<br>这个类非常适用于对 app 前后台状态切换时进行响应、且对生命周期不要求毫秒级准确性的场景。</p></blockquote><p>再来看看 <code>ProcessLifecycleOwner</code> 的用法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForegroundMonitorActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_foreground_monitor)</span><br><span class="line"></span><br><span class="line">        AppLifecycleObserver.<span class="keyword">init</span>(application)</span><br><span class="line"></span><br><span class="line">        buttonStartMonitor.setOnClickListener &#123;</span><br><span class="line">            ProcessLifecycleOwner.<span class="keyword">get</span>().lifecycle.addObserver(AppLifecycleObserver)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buttonStopMonitor.setOnClickListener &#123;</span><br><span class="line">            ProcessLifecycleOwner.<span class="keyword">get</span>().lifecycle.removeObserver(AppLifecycleObserver)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressLint(<span class="meta-string">"StaticFieldLeak"</span>)</span></span><br><span class="line"><span class="keyword">object</span> AppLifecycleObserver : LifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> context : Context</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foreground</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(<span class="string">"AppLifecycleObserver"</span>, <span class="string">"goto foreground"</span>)</span><br><span class="line">        Toast.makeText(context, <span class="string">"goto foreground"</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">background</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(<span class="string">"AppLifecycleObserver"</span>, <span class="string">"goto background"</span>)</span><br><span class="line">        Toast.makeText(context, <span class="string">"goto background"</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码使用 <code>ProcessLifecycleOwner</code> 很优雅地实现了如下功能：</p><ul><li>应用切换到前台时，打印日志并弹出 toast “goto foreground”</li><li>应用切换到后台时，打印日志并弹出 toast “goto background”</li></ul><h1 id="Lifecycle-库"><a href="#Lifecycle-库" class="headerlink" title="Lifecycle 库"></a>Lifecycle 库</h1><h2 id="Lifecycle-的优势"><a href="#Lifecycle-的优势" class="headerlink" title="Lifecycle 的优势"></a>Lifecycle 的优势</h2><p>lifecycle 组件的意义在于更容易组织代码。写过 Android 代码的都知道，常常需要在 Activity/Fragment 的生命周期回调中执行一些操作。比如说：</p><ul><li><code>onCreate()</code> 中初始化某些资源</li><li><code>onDestory()</code> 中释放某些资源</li></ul><p>所以 Activity/Fragment 的代码很容易就越写越多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, location -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// what if this callback is invoked AFTER activity is stopped?</span></span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                myLocationListener.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocationListener</span><span class="params">(Context context, Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// connect to system location service</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// disconnect from system location service</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity/Fragment 代码多本身并不是问题，真正的问题在于正确性和可测试性。以上述代码为例，它就不能保证正确性和可测试性。</p><ul><li>先说正确性。如果 <code>Util.checkUserStatus()</code> 是一个耗时的异步操作，等到真正调用到 <code>myLocationListener.start()</code> 时可能 Activity 已经处于停止状态，所以无法保证正确性</li><li>再说可测试性。写在 Activity/Fragment 中的代码基本是无法做单元测试的。</li></ul><p>来看 lifecycle 组件是如何解决正确性和可测试性问题的。修改后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, getLifecycle(), location -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                myLocationListener.enable();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocationListener</span><span class="params">(Context context, Lifecycle lifecycle, Callback callback)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_START)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">           <span class="comment">// connect</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        enabled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (lifecycle.getCurrentState().isAtLeast(STARTED)) &#123;</span><br><span class="line">            <span class="comment">// connect if not connected</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_STOP)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// disconnect if connected</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的代码有这几个好处：</p><ul><li><code>MyLocationListener</code> 可感知生命周期，将生命周期的响应与 Activity 解耦</li><li><code>MyLocationListener</code> 易于测试</li><li><code>MyLocationListener</code> 可以避免在不正确的生命周期时进行回调</li></ul><h2 id="Lifecycle-简介"><a href="#Lifecycle-简介" class="headerlink" title="Lifecycle 简介"></a>Lifecycle 简介</h2><p>lifecycle 组件包括 <code>Lifecycle</code>, <code>LifecycleOwner</code>, <code>LifecycleObserver</code> 三个主要类：</p><ul><li><a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.html" target="_blank" rel="noopener">Lifecycle</a> 类持有 Fragment 和 Activity (LifecycleOwner) 的生命周期状态信息，并且允许其他对象(LifecycleObserver)观察这些信息。<ul><li>此外 Lifecycle 还使用 Event 和 Status 来记录组件的生命周期状态</li></ul></li></ul><p><img src="1_RqOdr-NppqAl4elgMY6Qkw.jpg" alt></p><ul><li><a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner.html" target="_blank" rel="noopener">LifecycleOwner</a> 仅有一个 <code>getLifecycle()</code> 方法，用于返回当前对象的 <code>Lifecycle</code>。Fragment 和 Activity 实现了 <code>LifecycleOwner</code> 接口</li><li><a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleObserver.html" target="_blank" rel="noopener">LifecycleObserver</a>，这个接口通常由 app 来实现，用于封装那需要感知生命周期的对象或业务逻辑</li></ul><p>官方文档是这样描述三者的关系的：</p><blockquote><p>LifecycleOwner 接口将 Lifecycle 的所有权从单独的类 (Fragment 和 Activity) 中抽象出来。其他的类也可以实现 LifecycleOwner 接口<br>实现了 LifecycleObserver 接口的组件可以跟实现了 LifecycleOwner 接口的类很好地协同工作，owner 可以提供 lifecycle，而 observer 则注册到 owner 提供的 lifecycle 进行观察</p></blockquote><p>官方给出的关于 lifecycle 的最佳实践：</p><ul><li>UI controller 尽可能”瘦”</li><li>编写数据驱动的 UI，UI controller 的作用仅仅是在数据更新时渲染界面</li><li>数据逻辑放到 ViewModel 中</li><li>使用数据绑定技术保持 view 和 UI controller 之间有干净的接口</li><li>如果 UI 过于复杂，考虑使用 presenter 模式</li><li>避免在 ViewModel 中持有 View 或 UI controller</li></ul><p>官方给出的一些应用场景：</p><ul><li>在精确定位和粗略定位之间切换。使用 lifecycle-aware 组件进行切换，当应用处于前台时使用精确空位，当应用处于后台时切换到粗略定位</li><li>停止或开始视频流缓冲。使用 lifecycle-aware 组件尽早开始缓冲，但直到 app 完全启动后才开始播放</li><li>开始或停止网络连接。使用 lifecycle-aware 组件，当应用在前台时开启网络数据，在后台时则停止</li><li>停止或开始 animated drawable。使用 lifecycle-aware 组件，当应用在前台时播放 animated drawable，在后台时则停止</li></ul><hr><blockquote><p>If a library provides classes that need to work with the Android lifecycle, we recommend that you use lifecycle-aware components. Your library clients can easily integrate those components without manual lifecycle management on the client side.</p></blockquote><p>早期版本的 Glide (v3.7.0之前) 就已经意识到 lifecycle-aware 问题，所以它抽象出以下两个接口来作为解决方案。</p><ul><li><code>com.bumptech.glide.manager.Lifecycle</code></li><li><code>com.bumptech.glide.manager.LifecycleListener</code></li></ul><p>不过 Android 官方推出 lifecycle 组件后，Glide 其实没必要使用自定义接口了。不过截至目前(2019.5.6)它仍然是使用 <a href="https://github.com/bumptech/glide/blob/master/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java" target="_blank" rel="noopener">Lifecycle</a>，也许是有历史包袱，也许是不想信赖 lifecycle 库。</p><h2 id="Lifecycle-与可测试"><a href="#Lifecycle-与可测试" class="headerlink" title="Lifecycle 与可测试"></a>Lifecycle 与可测试</h2><p>将代码从 Activity/Fragment 抽出来封装成 lifecycle-aware 组件后带来的一个额外好处是可以单元测试。(Activity/Fragment 中的代码几乎没办法单元测试！)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLifeCycleObserverTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> lifeCycleObserver: MyLifeCycleObserver</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> lifeCycle: LifecycleRegistry</span><br><span class="line">    <span class="keyword">val</span> logger : MyLogger = mock(MyLogger::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> lifeCycleOwner: LifecycleOwner = mock(LifecycleOwner::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        lifeCycle = LifecycleRegistry(lifeCycleOwner)</span><br><span class="line">        lifeCycleObserver = MyLifeCycleObserver(lifeCycle, logger)</span><br><span class="line">        lifeCycle.addObserver(lifeCycleObserver)</span><br><span class="line"></span><br><span class="line">        lifeCycle.handleLifecycleEvent(Lifecycle.Event.ON_CREATE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">shouldLogStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lifeCycle.markState(Lifecycle.State.STARTED)</span><br><span class="line">        verify(logger).logStart()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">shouldLogStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lifeCycle.handleLifecycleEvent(Lifecycle.Event.ON_RESUME)</span><br><span class="line">        lifeCycle.handleLifecycleEvent(Lifecycle.Event.ON_STOP)</span><br><span class="line">        verify(logger).logStop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="Jietu20190506-113922.png" alt></p><p>Kotlin 代码中使用 mockito 时会遇到无法 mock final 类的问题，解决方法见<a href="https://antonioleiva.com/mockito-2-kotlin/" target="_blank" rel="noopener">这里</a>。</p><p>完整的代码见 <a href="https://github.com/410063005/cmdemo/blob/master/app/src/main/java/com/sunmoonblog/cmdemo/lifecycle/lifecycle.kt" target="_blank" rel="noopener">Github</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developer.android.com/topic/libraries/architecture/lifecycle.html" target="_blank" rel="noopener">lifecycle</a></li><li><a href="https://medium.com/@MinaSamy/android-architecture-components-lifecycle-433ace1ec05d" target="_blank" rel="noopener">Android Architecture Components: LifeCycle – Mina Samy – Medium</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava 2 异常处理分析</title>
      <link href="2019/04/30/rxjava-undeliverable-exception/"/>
      <url>2019/04/30/rxjava-undeliverable-exception/</url>
      
        <content type="html"><![CDATA[<p>使用 RxJava 2 时稍不注意就会出现 <code>UndeliverableException</code>。在桌面环境中该异常还不算严重，但对于 Android 应用来说却是致命的。<br><a id="more"></a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>这个版本上线后出现收到很多 <code>UndeliverableException</code> 上报，导致 crash 率明显上升。<code>UndeliverableException</code> 是使用 RxJava 2 过程中上报的。但之前也使用了 RxJava 2，并没有引起这么多 crash。分析后发现 crash 是这样引起的：</p><ol><li>这个版本对网络层了进行改造。准备逐步删除旧的网络层，统一使用新的网络层，所以业务代码调整成使用新的网络层请求后台</li><li>旧的网络层使用了 RxJava 2 处理连接请求(例如，先请求 token，拿到 token 后再查个人信息)，但新的网络层对 RxJava 2 支持不完善</li><li>为了既能使用新的网络层又不对原有业务代码做过多修改，增加 <code>RxRequestServiceBridge</code> 工具类将新网络层网络请求调用转换成 RxJava 的形式</li><li>问题出在 <code>RxRequestServiceBridge</code> 中，它有缺陷。其源码类似下面这样</li><li>业务代码经过 <code>RxRequestServiceBridge</code> 转换后访问后台接口，其中有个接口稳定性不好，频繁出错</li><li>后台接口访问失败将 <code>RxRequestServiceBridge</code> 的问题暴露出来，最终导致 app 崩溃</li></ol><p><code>RxRequestServiceBridge</code> 的代码类似这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxRequestServiceBridge</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Message&gt; <span class="function">Observable&lt;T&gt; <span class="title">convert</span><span class="params">(<span class="keyword">final</span> Message req)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> convert(<span class="number">900</span>, req);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Message&gt; <span class="function">Observable&lt;T&gt; <span class="title">convert</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> cmd, <span class="keyword">final</span> Message req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> ObservableEmitter&lt;T&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                call(emitter, cmd, req);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T extends Message&gt; <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> ObservableEmitter&lt;T&gt; emitter, <span class="keyword">final</span> <span class="keyword">int</span> cmd, <span class="keyword">final</span> Message req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> RequestService()</span><br><span class="line">                .reqNetWork(cmd, req)</span><br><span class="line">                .setCallBack(<span class="keyword">new</span> RequestService.OnCallBack&lt;T&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(T message)</span> </span>&#123;</span><br><span class="line">                         emitter.onNext(message);</span><br><span class="line">                         emitter.onComplete();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailed</span><span class="params">(<span class="keyword">int</span> errorCode, String errorMsg, T message)</span> </span>&#123;</span><br><span class="line">                         emitter.onError(<span class="keyword">new</span> RetrofitException(errorCode, errorMsg));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).request();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>crash 日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com.app.RetrofitException: 连接失败，请重试！(#99)</span><br><span class="line">io.reactivex.exceptions.UndeliverableException:com.app.RetrofitException: cmd=[3], reqName=[], resultCode=[99], errorMessage=[连接失败，请重试！(#99)]</span><br><span class="line">io.reactivex.plugins.RxJavaPlugins.void onError(java.lang.Throwable)(Unknown Source:20)</span><br><span class="line">......</span><br><span class="line">com.app.RxRequestServiceBridge$2.void onFailed(int,java.lang.String,com.squareup.wire.Message)(Unknown Source:32)</span><br></pre></td></tr></table></figure><h1 id="RxJava-2-异常处理"><a href="#RxJava-2-异常处理" class="headerlink" title="RxJava 2 异常处理"></a>RxJava 2 异常处理</h1><p>搜了下，才发现2017年就有人给 RxJava 2 提出类似的问题，见这个<a href="https://github.com/ReactiveX/RxJava/issues/5214" target="_blank" rel="noopener">issue #5214</a>。</p><p>复现步骤很简单：</p><ol><li>订阅某个可能抛出异常的 Observable，<code>Disposable disposable = observable.subscribe()</code>。以访问后台接口这个过程为例，其中可能抛出 IOException</li><li>Observable 耗时太久，在其结束前调用 <code>disposable.dispose()</code>。以 Android app 为例，某个界面网络加载太久，用户等不及所以退出了，<code>Activity.onDestory()</code> 中调用了 <code>disposable.dispose()</code></li><li>Observable 发生 Exception。以网络请求为例，可能的场景是发生了读超时或连接超时</li></ol><p>写代码来看看复现结果 (注，这段代码参考自 <a href="https://github.com/ReactiveX/RxJava/issues/5214" target="_blank" rel="noopener">issue #5214</a>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disposeBeforeExceptionOccurredWithoutErrorHandler</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    RxJavaPlugins.setErrorHandler(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让当前线程不要过早退出</span></span><br><span class="line">    <span class="keyword">final</span> CountDownLatch keepRunning = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> CountDownLatch mainThreadLock = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch workerThreadLock = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Disposable disposable = Observable.fromCallable(</span><br><span class="line">            <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    mainThreadLock.countDown();</span><br><span class="line">                    workerThreadLock.await();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"后台线程有异常, 会被 RxJava 吞掉么"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .subscribeOn(Schedulers.io())</span><br><span class="line">            .subscribe(emptyConsumer(),</span><br><span class="line">                    <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            System.err.println(<span class="string">"I'm Local Exception Handler"</span>);</span><br><span class="line">                            throwable.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">    mainThreadLock.await();</span><br><span class="line">    disposable.dispose();</span><br><span class="line">    workerThreadLock.countDown();</span><br><span class="line"></span><br><span class="line">    keepRunning.await(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对代码中有三个不同作用的 <code>CountDownLatch</code></p><ul><li><code>keepRunning</code> 用于保持当前线程至少运行5秒</li><li><code>mainThreadLock</code> 和 <code>workerThreadLock</code> 用于制造 <code>dispose()</code> 后抛出异常的场景</li></ul><p>运行后果然有情况，我们自己抛出的异常不见了，出现另一个预期外的异常 <strong>UndeliverableException</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">io.reactivex.exceptions.UndeliverableException: java.lang.InterruptedException</span><br><span class="line">at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:366)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableFromCallable.subscribeActual(ObservableFromCallable.java:48)</span><br><span class="line">at io.reactivex.Observable.subscribe(Observable.java:11194)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96)</span><br><span class="line">at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:463)</span><br></pre></td></tr></table></figure><p>官方对这个预期外的异常解释如下：</p><blockquote><p>The exception is there because RxJava 2 has the policy of NEVER allowing an onError call to be lost. It is either delivered downstream or thrown as a global UndeliverableException if the observable has already terminated. It is up to the creator of the Observable to ‘properly’ handle the case where the observable has ended and an Exception occurs.</p></blockquote><blockquote><p>RxJava can’t decide if your exception thrown from you callable is important or not, even if the sequence is cancelled. Indeed you have to install a global error consumer and decide yourself if that error is something your app should crash on or not.<br>The current wisdom is that NullPointerExceptions, IllegalArgumentExceptions, IllegalStateExceptions are crash-worthy while IOExceptions, SocketExceptions and InterruptedExceptions are likely not, but depends on your actual app.</p></blockquote><p>简单来说，</p><ul><li>如果 <code>dispose()</code> 后拿到数据也好，抛出异常也好，RxJava 是不知道该如何处理的。但它肯定不能”吞掉异常”，所以就有了 UndeliverableException</li><li>可以使用 <code>RxJavaPlugins.setErrorHandler()</code> 设置一个 ErrorHandler 用于处理上述情况中的异常</li></ul><p>RxJava 官方文档中 <a href="https://github.com/ReactiveX/RxJava/wiki/What&#39;s-different-in-2.0#error-handling" target="_blank" rel="noopener">Error handle</a> 其实对此有比较详细的描述。</p><h1 id="RxJava-error-handle"><a href="#RxJava-error-handle" class="headerlink" title="RxJava error handle"></a>RxJava error handle</h1><h2 id="文档-译"><a href="#文档-译" class="headerlink" title="文档(译)"></a>文档(译)</h2><p>这一节内容翻译自 <a href="https://github.com/ReactiveX/RxJava/wiki/What&#39;s-different-in-2.0#error-handling" target="_blank" rel="noopener">Error handle</a> 其实对此有比较详细的描述。</p><p>RxJava 2.0 一个重要的设计就是不能吞掉任何 <code>Throwable</code>。这意味着由于下游的生命周期已到达结束状态导致无法发射(emit)错误或者下游取消一个序列等情形，会导致发射(emit)一个错误。</p><p>这类错误会被路由到 <code>RxJavaPlugins.onError</code> 处理器。可以使用 <code>RxJavaPlugins.setErrorHandler(Consumer&lt;Throwable&gt;)</code> 方法来设置新的 <code>onError</code> 处理器。如果没有指定这个处理器，缺省情况下 RxJava 会将 <code>Throwable</code> 堆栈信息输出到控制台并调用当前线程的未捕获异常处理器(uncaught exception handler)。</p><p>在桌面 Java 环境中，uncaught exception handler 不会对基于 <code>ExecutorService</code> 的 <code>Scheduler</code> 中运行的线程产生的错误进行任何处理，所以应用可以继续运行。但 Android 平台处理更严格，它在这种情况下会终止应用。</p><p>这是否是预想中的行为还有争论，但如果你想避免调用到 uncaught exception handler，无论是直接使用还是间接使用 RxJava2，最终的应用都应该设置一个无操作的 handler (no-op handler)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If Java 8 lambdas are supported</span></span><br><span class="line">RxJavaPlugins.setErrorHandler(e -&gt; &#123; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If no Retrolambda or Jack </span></span><br><span class="line">RxJavaPlugins.setErrorHandler(Functions.&lt;Throwable&gt;emptyConsumer());</span><br></pre></td></tr></table></figure><p>不建议基于 RxJava2 的第三方库在测试环境以外修改 error handler。(It is not advised intermediate libraries change the error handler outside their own testing environment.)</p><p>不幸的是，RxJava 不知道哪些对象处于生命周期结束状态(out-of-lifecycle)，未被分发的异常是应该让应用 crash。而定位这类问题的根源又非常麻烦，尤其是问题来自链的底部(especially if they originate from a source and get routed to RxJavaPlugins.onError somewhere lower the chain) 却被路由到 <code>RxJavaPlugins.onError</code> 时。</p><p>所以 RxJava 2.0.6 引入了特定的异常包装器用于包装原始异常以便容易定位问题。</p><ul><li><code>OnErrorNotImplementedException</code> - 重新引入这个异常，用于检查用户是否忘记给 <code>subscribe()</code> 方法传入一个 error handler</li><li><code>ProtocolViolationException</code> - 这个异常表示操作符中有 bug</li><li><code>UndeliverableException</code> - <code>Subscriber/Observer</code> 生命周期限制导致原始异常无法分发时，使用 <code>UndeliverableException</code> 进行包装。<code>RxJavaPlugins.onError</code> 自动使用这个异常以保持原有的完整堆栈信息。</li></ul><p>如果未被分发的异常是 <code>NullPointerException</code>, <code>IllegalStateException</code> (<code>UndeliverableException</code> 和 <code>ProtocolViolationException</code> 继承自 <code>IllegalStateException</code>), <code>IllegalArgumentException</code>, <code>CompositeException</code>, <code>MissingBackpressureException</code>, <code>OnErrorNotImplementedException</code> 的实例或子类实例，不会使用 <code>UndeliverableException</code> 对该异常进行包装。</p><p>此外，一些第三方库被 <code>cancel()</code> 或 <code>dispose()</code> 调用中断时会抛出异常，大部分时候这种中断会引起未分发的异常。RxJava 2.0.6 内部现在总是先对 <code>Subscription/Disposable</code> 执行 <code>cancel</code> 或 <code>dispose</code>，再 cancelling/disposing 一个 task 或 worker (这会导致目标线程出现中断，which causes the interrupt on the target thread)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in some library</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   doSomethingBlockingly()</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">   <span class="comment">// check if the interrupt is due to cancellation</span></span><br><span class="line">   <span class="comment">// if so, no need to signal the InterruptedException</span></span><br><span class="line">   <span class="keyword">if</span> (!disposable.isDisposed()) &#123;</span><br><span class="line">      observer.onError(ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果第三方库已经这样做了，<code>InterruptedExceptions</code> 会停止而不是继续住下游传递。如果第三方库还没有使用这个模式，建议尽快升级/更新有问题的代码。</p><p>如果准备添加一个非空的全局 error consumer，以下是个例子。这个例子基于异常是 bug 还是可忽略的应用/网络状态来管理未分发的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">RxJavaPlugins.setErrorHandler(e -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> UndeliverableException) &#123;</span><br><span class="line">        e = e.getCause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((e <span class="keyword">instanceof</span> IOException) || (e <span class="keyword">instanceof</span> SocketException)) &#123;</span><br><span class="line">        <span class="comment">// fine, irrelevant network problem or API that throws on cancellation</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> InterruptedException) &#123;</span><br><span class="line">        <span class="comment">// fine, some blocking code was interrupted by a dispose call</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((e <span class="keyword">instanceof</span> NullPointerException) || (e <span class="keyword">instanceof</span> IllegalArgumentException)) &#123;</span><br><span class="line">        <span class="comment">// that's likely a bug in the application</span></span><br><span class="line">        Thread.currentThread().getUncaughtExceptionHandler()</span><br><span class="line">            .handleException(Thread.currentThread(), e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IllegalStateException) &#123;</span><br><span class="line">        <span class="comment">// that's a bug in RxJava or in a custom operator</span></span><br><span class="line">        Thread.currentThread().getUncaughtExceptionHandler()</span><br><span class="line">            .handleException(Thread.currentThread(), e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.warning(<span class="string">"Undeliverable exception received, not sure what to do"</span>, e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="RxJava2-Adapter"><a href="#RxJava2-Adapter" class="headerlink" title="RxJava2 Adapter"></a><a href="https://github.com/square/retrofit/blob/master/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java#L34" target="_blank" rel="noopener">RxJava2 Adapter</a></h2><p>RxJava2 Adapter 用于 Retrofit 2 集成 RxJava 2。看看它是如何进行错误处理的。关键代码见 <a href="https://github.com/square/retrofit/blob/master/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java" target="_blank" rel="noopener">CallExecuteObservable.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallExecuteObservable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">Response</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> Response&lt;T&gt;&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Since Call is a one-shot type, clone it for each new observer.</span></span><br><span class="line">    Call&lt;T&gt; call = originalCall.clone();</span><br><span class="line">    CallDisposable disposable = <span class="keyword">new</span> CallDisposable(call);</span><br><span class="line">    observer.onSubscribe(disposable);</span><br><span class="line">    <span class="keyword">if</span> (disposable.isDisposed()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> terminated = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Response&lt;T&gt; response = call.execute();</span><br><span class="line">      <span class="keyword">if</span> (!disposable.isDisposed()) &#123;</span><br><span class="line">        observer.onNext(response);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!disposable.isDisposed()) &#123;</span><br><span class="line">        terminated = <span class="keyword">true</span>;</span><br><span class="line">        observer.onComplete();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      Exceptions.throwIfFatal(t);</span><br><span class="line">      <span class="keyword">if</span> (terminated) &#123;</span><br><span class="line">        RxJavaPlugins.onError(t);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!disposable.isDisposed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          observer.onError(t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable inner) &#123;</span><br><span class="line">          Exceptions.throwIfFatal(inner);</span><br><span class="line">          RxJavaPlugins.onError(<span class="keyword">new</span> CompositeException(t, inner));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RxJavaPlugins</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> Consumer&lt;? <span class="keyword">super</span> Throwable&gt; errorHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setErrorHandler</span><span class="params">(@Nullable Consumer&lt;? <span class="keyword">super</span> Throwable&gt; handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lockdown) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Plugins can't be changed anymore"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        errorHandler = handler;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable error)</span> </span>&#123;</span><br><span class="line">        Consumer&lt;? <span class="keyword">super</span> Throwable&gt; f = errorHandler;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">            error = <span class="keyword">new</span> NullPointerException(<span class="string">"onError called with null. Null values are generally not allowed in 2.x operators and sources."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isBug(error)) &#123;</span><br><span class="line">                error = <span class="keyword">new</span> UndeliverableException(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 关键点二</span></span><br><span class="line">                f.accept(error);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="comment">// Exceptions.throwIfFatal(e); TODO decide</span></span><br><span class="line">                e.printStackTrace(); <span class="comment">// NOPMD</span></span><br><span class="line">                uncaught(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关键点三</span></span><br><span class="line">        error.printStackTrace(); <span class="comment">// NOPMD</span></span><br><span class="line">        uncaught(error);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uncaught</span><span class="params">(@NonNull Throwable error)</span> </span>&#123;</span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">        UncaughtExceptionHandler handler = currentThread.getUncaughtExceptionHandler();</span><br><span class="line">        handler.uncaughtException(currentThread, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableFromCallable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Callable&lt;? extends T&gt; callable;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableFromCallable</span><span class="params">(Callable&lt;? extends T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">        DeferredScalarDisposable&lt;T&gt; d = <span class="keyword">new</span> DeferredScalarDisposable&lt;T&gt;(s);</span><br><span class="line">        s.onSubscribe(d);</span><br><span class="line">        <span class="keyword">if</span> (d.isDisposed()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T value;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            value = ObjectHelper.requireNonNull(callable.call(), <span class="string">"Callable returned null"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(e);</span><br><span class="line">            <span class="comment">// 关键点一            </span></span><br><span class="line">            <span class="keyword">if</span> (!d.isDisposed()) &#123;</span><br><span class="line">                s.onError(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                RxJavaPlugins.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        d.complete(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 <code>ObservableFromCallable.subscribeActual()</code> 方法为例可以看到 RxJava 处理异常时有几个关键点：</p><ul><li>关键点一，<code>isDisposed()</code> 为 false 才交由 <em>local error handler</em> 进行错误处理，为 true 时直接交由 <em>global error handler</em></li><li>关键点二，<code>global error handler</code> 不为 null 时，由其进行错误处理</li><li>关键点三，<code>global error handler</code> 为 null 时，RxJava 先出异常信息，最终交由当前线程的 <code>UncaughtExceptionHandler</code> 进行错误处理</li></ul><p>当前线程的 <code>UncaughtExceptionHandler</code> 如果处理错误很关键。很不幸，在 Android 应用中默认的处理行为往往是 <strong>结束</strong> 应用，也就是我们看到的 crash。</p><blockquote><p>On desktop Java, this latter handler does nothing on an ExecutorService backed Scheduler and the application can keep running. However, Android is more strict and terminates the application in such uncaught exception cases.</p></blockquote><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>经过上面的源码分析，解决方法其实很简单。<code>RxRequestServiceBridge</code> 的代码修改如下，主要变化是调用 <code>ObservableEmitter.onXXX()</code> 方法前先判断是否已经被 dispose 掉了。如果是，不应将数据或异常往下游 <code>ObservableEmitter</code> 继续传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxRequestServiceBridge</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Message&gt; <span class="function">Observable&lt;T&gt; <span class="title">convert</span><span class="params">(<span class="keyword">final</span> Message req)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> convert(<span class="number">900</span>, req);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Message&gt; <span class="function">Observable&lt;T&gt; <span class="title">convert</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> cmd, <span class="keyword">final</span> Message req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> ObservableEmitter&lt;T&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                call(emitter, cmd, req);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T extends Message&gt; <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> ObservableEmitter&lt;T&gt; emitter, <span class="keyword">final</span> <span class="keyword">int</span> cmd, <span class="keyword">final</span> Message req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> RequestService()</span><br><span class="line">                .reqNetWork(cmd, req)</span><br><span class="line">                .setCallBack(<span class="keyword">new</span> RequestService.OnCallBack&lt;T&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(T message)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (!emitter.isDisposed()) &#123;</span><br><span class="line">                            emitter.onNext(message);</span><br><span class="line">                            emitter.onComplete();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailed</span><span class="params">(<span class="keyword">int</span> errorCode, String errorMsg, T message)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (!emitter.isDisposed()) &#123;</span><br><span class="line">                            emitter.onError(<span class="keyword">new</span> RetrofitException(errorCode, errorMsg));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).request();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/48712262/rxjava2s-undeliverableexception-and-disposed-streams" target="_blank" rel="noopener">android - RxJava2’s UndeliverableException and disposed streams - Stack Overflow</a></li><li><a href="https://stackoverflow.com/questions/43525052/rxjava2-observable-take-throws-undeliverableexception" target="_blank" rel="noopener">java - RxJava2 observable take throws UndeliverableException - Stack Overflow</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> RxJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConstraintLayout 动画</title>
      <link href="2019/04/29/constraint-layout-animation/"/>
      <url>2019/04/29/constraint-layout-animation/</url>
      
        <content type="html"><![CDATA[<p>学习 ContraintLayout 动画的用法。<br><a id="more"></a></p><p>ConstraintLayout 除了将布局平坦化，提高 UI 性能，还有一个很有用的功能：只用很少的代码就能实现非常酷的动画(要求 API 9 以上)。</p><p>代码少到什么程度呢？少到像下面这样，只要 4 行！</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> constraintSet = ConstraintSet()</span><br><span class="line">constraintSet.clone(context, R.layout.second_keyframe)</span><br><span class="line"></span><br><span class="line">TransitionManager.beginDelayedTransition(myView)</span><br><span class="line">constraintSet.applyTo(myView)</span><br></pre></td></tr></table></figure><h1 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h1><p>先上几个 demo 看看 ConstraintLayout 实现的动画效果。</p><iframe width="300" height="500" src="SVID_20190429_155351_1.mp4" frameborder="0" allowfullscreen></iframe><iframe width="300" height="500" src="SVID_20190429_155408_1.mp4" frameborder="0" allowfullscreen></iframe><ul><li><a href="https://github.com/410063005/cmdemo/blob/master/app/src/main/java/com/sunmoonblog/cmdemo/layout/ClAnimationActivity.kt" target="_blank" rel="noopener">源码一</a></li><li><a href="https://github.com/410063005/cmdemo/blob/master/app/src/main/java/com/sunmoonblog/cmdemo/layout/ClAnimationActivity2.kt" target="_blank" rel="noopener">源码二</a></li></ul><h1 id="主要类"><a href="#主要类" class="headerlink" title="主要类"></a>主要类</h1><p>ContraintLayout 动画涉及到的主要类和方法：</p><ul><li><a href="https://developer.android.com/reference/android/support/constraint/ConstraintLayout.html" target="_blank" rel="noopener">ConstraintLayout</a></li><li><a href="https://developer.android.com/reference/android/support/constraint/ConstraintSet.html" target="_blank" rel="noopener">ConstraintSet</a><ul><li>clone()</li><li>applyTo()</li></ul></li><li>TransitionManager<ul><li>beginDelayedTransition()</li></ul></li><li>Transition<ul><li>ChangeBounds</li></ul></li><li>Interpolator</li></ul><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>建议先看看这个视频，<a href="https://www.youtube.com/watch?v=OHcfs6rStRo" target="_blank" rel="noopener">如何用四行代码搞定动画</a>。</p><p>ConstraintLayout 动画的基本用法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> constraintSet = ConstraintSet()</span><br><span class="line">constraintSet.clone(context, R.layout.second_keyframe)</span><br><span class="line"></span><br><span class="line">TransitionManager.beginDelayedTransition(myView)</span><br><span class="line">constraintSet.applyTo(myView)</span><br></pre></td></tr></table></figure><p>当然，也可以指定自定义的过渡效果。(实际上你不指定过度效果的情况下，系统会使用默认的过渡效果 <code>AutoTransition</code>)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> constraintSet = ConstraintSet()</span><br><span class="line">constraintSet.clone(context, R.layout.second_keyframe)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> transition = ChangeBounds()</span><br><span class="line">transition.interpolator = AnticipateOvershootInterpolator(<span class="number">1.0f</span>)</span><br><span class="line"></span><br><span class="line">TransitionManager.beginDelayedTransition(myView)</span><br><span class="line">constraintSet.applyTo(myView)</span><br></pre></td></tr></table></figure><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>ConstraintLayout 动画的本质是这样的：使用 <a href="https://link.jianshu.com/?t=https://developer.android.com/reference/android/transition/TransitionManager.html" target="_blank" rel="noopener">TransitionManager</a> 在 Constrainlayout 中启动了一个延时动画，TransitionManager 在交换两种布局时自动使用动画效果。</p><p><a href="https://youtu.be/s7d1nSEckEo" target="_blank" rel="noopener">ConstraintLayout 动画工作原理</a> 对此有介绍，总结如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> constraintSetOne = ConstraintSet()</span><br><span class="line"><span class="comment">// 使用 clone() 方法从缺省的布局中获取 constraint 并将其映射到 constraintSetOne</span></span><br><span class="line">constraintSetOne.clone(constraintLayoutId)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> constraintSetTwo = ConstraintSet()</span><br><span class="line"><span class="comment">// 使用 clone() 方法从另一个布局中获取 constraint 并将其映射到 constraintSetTwo</span></span><br><span class="line">constraintSetTwo.clone(R.layout.other)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借助 TransitionManager 类的 beginDelayedTransition 方法为 ConstraintLayout 开启一个缺省的 transition 动画</span></span><br><span class="line"></span><br><span class="line">TransitionManager.beginDelayedTransition(constraintView)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 applyTo() 方法将已设置好的 constraint 应用到 ConstraintLayout</span></span><br><span class="line">constraintSetTwo.applyTo(constraintView)</span><br></pre></td></tr></table></figure><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ul><li><p>Q: 会有重复代码吗？ A: 不会。会自动重用第一个 layout 中的样式，比如字体大小和颜色</p></li><li><p>Q: 在旧设备上可以运行吗？ A: 支持 API 9 以上的设备，对于不支持的设备直接显示第一个 layout，不会有动画效果</p></li><li><p>Q: 也可以使用 ObjectAnimator 实现相同的动画效果，ConstraintLayout 有什么好处？ A: 代码量少，开发效率高，无需手写各种数学计算</p></li></ul><p>注意：ConstraintLayout 动画只对直接子元素起作用</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/ibhavikmakwana/Constraint-Layout-Animations.git" target="_blank" rel="noopener">Constraint-Layout-Animations</a> 其中的视差效果非常有意思</li><li><a href="https://proandroiddev.com/creating-awesome-animations-using-constraintlayout-and-constraintset-part-i-390cc72c5f75" target="_blank" rel="noopener">creating-awesome-animations-using-constraintlayout</a></li><li><a href="https://github.com/Hariofspades/ConstraintSetZone" target="_blank" rel="noopener">ConstraintSetZone</a></li><li><a href="https://github.com/googlesamples/android-BasicTransition" target="_blank" rel="noopener">BasicTransition</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Android Jetpack 学习笔记之 LiveData</title>
      <link href="2019/04/25/learn-jetpack-livedata-1/"/>
      <url>2019/04/25/learn-jetpack-livedata-1/</url>
      
        <content type="html"><![CDATA[<p>一篇关于 LiveData 的文章，简单明了。翻译一下当作学习。</p><a id="more"></a><p>文章翻译自 <a href="https://codinginfinite.com/android-livedata-example" target="_blank" rel="noopener">Android LiveData With Example</a> 和 <a href="https://codinginfinite.com/android-livedata-transformation-example/" target="_blank" rel="noopener">Android LiveData Transformation With Example</a>。两篇都不是很长，所以翻译的内容放在一起。</p><p>相关源码见 <a href="https://github.com/CodingInfinite/LiveDataExample.git" target="_blank" rel="noopener">Github</a>。</p><hr><p>今天要介绍几个解决方案。我认为每个项目中反复尝试去解决一类问题，而这些方案适用于这类问题。</p><p>比如，我响应在 <strong>Android Component</strong> 生命周期状态的变化(简单来说就是响应 <code>onResume()</code> 或 <code>onPause()</code> 之类的方法)。还有些时候你想配置变化后某些值的状态。我们经常面临这种问题，也尝试使用不同的架构来解决问题，比如 MVP，MVVM 或其他的。但对初级开发人员来说实现这些架构并不是个简单问题。</p><p>好消息是使用 <a href="https://codinginfinite.com/category/jetpack/" target="_blank" rel="noopener">Android Architecture Component</a>，更准确地说是使用 <a href="https://developer.android.com/topic/libraries/architecture/livedata" target="_blank" rel="noopener">LiveData</a> 和 <a href="https://developer.android.com/topic/libraries/architecture/viewmodel" target="_blank" rel="noopener">ViewModel</a>，我们可以轻易地解决这些问题。</p><h1 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h1><p>LiveData 是可观察数据的持有者。它可感知组件的生命周期(<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle" target="_blank" rel="noopener">lifecycle</a> aware)。可感知组件生命周期的意思是，LiveData 仅仅在生命周期期间可被观察，更准确地说是在 Activity 和 Fragment 的生命周期中。通过 Activity 和 Fragment 的引用，LiveData 知道 UI 是处于 onScreen 状态还是 offScreen 状态或者是被销毁状态。将 UI 对象传给 LiveData，无论何时数据发生变化，它都会通知 lifecycle owner，并且让 UI 重绘。</p><h1 id="LiveData-的优势"><a href="#LiveData-的优势" class="headerlink" title="LiveData 的优势"></a>LiveData 的优势</h1><ul><li><strong>没有内存泄漏</strong>：<a href="https://developer.android.com/reference/android/arch/lifecycle/Observer" target="_blank" rel="noopener">Observers</a> 跟 <a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a> 绑定，当关联的对象销毁后 LiveData 也会被清理</li><li><strong>不会让处于停止状态的 Activity 崩溃</strong>：即 Activity 在 back stack 中时，不会收到 LiveData 事件流</li><li><strong>数据永远保持最新</strong>：一旦处于活跃状态时总能收到最新数据</li><li><strong>不必手动处理组件生命周期</strong>：<a href="https://developer.android.com/reference/android/arch/lifecycle/Observer" target="_blank" rel="noopener">Observers</a> 只需要专注于观察相关的数据，而不必操作是否要停止观察或开始观察。LiveData 底层会处理这些细节</li><li><strong>保证 UI 跟数据同步</strong>：生命周期状态变化时 LiveData 会通知观察者。比起每次在数据变化后去更新 UI，观察者可以在有变更后主动更新 UI</li><li><strong>正确处理 configuration 变化</strong>：当观察者由于 configuration 变化而重建时，比如屏幕旋转，它马上可以收到最新的可用数据</li><li><strong>共享资源</strong>：可以继承 LiveData，并使用单例模式来包装 system service，以例在 app 内共享</li></ul><h1 id="添加-LiveData-库"><a href="#添加-LiveData-库" class="headerlink" title="添加 LiveData 库"></a>添加 LiveData 库</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation &quot;android.arch.lifecycle:extensions:$current_version&quot;</span><br><span class="line">annotationProcessor &quot;android.arch.lifecycle:compiler:1.0.0&quot;</span><br></pre></td></tr></table></figure><h1 id="创建-LiveData"><a href="#创建-LiveData" class="headerlink" title="创建 LiveData"></a>创建 LiveData</h1><p>通常在 ViewModel 中创建 LiveData。接下来将使用<a href="https://codinginfinite.com/architecture-component-viewmodel-example/" target="_blank" rel="noopener">前一篇文章</a>中的例子， <strong>Color Changer</strong> app。首先使用一个 ViewModel 来持有当前背景色。</p><p><img src="http://codinginfinite.com/wp-content/uploads/2018/07/videotogif_2018.07.14_12.38.37.gif" alt></p><p>代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorChangerViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> colorResource = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        colorResource.value = <span class="number">0xfff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：是在 ViewModel 保存更新 UI 的 LiveData，而不是在 Activity 或 Fragment 中保存在 LiveData。ViewModel 和 LiveData 是 UI controller，它们负责持有数据而不是数据的状态。</p><p>关于 <a href="https://developer.android.com/reference/android/arch/lifecycle/MutableLiveData" target="_blank" rel="noopener">MutableLiveData</a></p><p>MutableLiveData 也是 LiveData。MutableLiveData 在内部是继承 LiveData 的，它向外暴露两个方法 <code>setValue()</code> 和 <code>getValue()</code>。调用 <code>setValue()</code>，可以设置新的值，设置后将用新值调用所有的活跃 observers。<code>getValue()</code> 可以获取到保存在 LiveData 实例中的最新值。</p><p>为 LiveData 设置值的不同方法</p><p>有两种不同的方法来为 LiveData 设置新值。第一方法是 <a href="https://developer.android.com/reference/android/arch/lifecycle/MutableLiveData.html#setValue(T" target="_blank" rel="noopener">setValue</a>)，另一种方法是 <a href="https://developer.android.com/reference/android/arch/lifecycle/MutableLiveData.html#postValue(T" target="_blank" rel="noopener">postValue</a>)。<code>setValue()</code> 用于从主线程中为 LiveData 设置值。如果要从后台线程中设置值，使用 <code>postValue()</code>。</p><p>看看如何在 Activity 中使用 ViewModel：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        <span class="keyword">val</span> colorChangerViewModel = ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(ColorChangerViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        colorChangerViewModel.colorResource.observe(<span class="keyword">this</span>, <span class="keyword">object</span>: Observer&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChanged</span><span class="params">(t: <span class="type">Int</span>?)</span></span> &#123;</span><br><span class="line">                mainActivityRootView.setBackgroundColor(t!!)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        changeColorButton.setOnClickListener &#123;</span><br><span class="line">            colorChangerViewModel.colorResource.value = generateRandomColor()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">generateRandomColor</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> rnd = Random()</span><br><span class="line">        <span class="keyword">return</span> Color.argb(<span class="number">255</span>, rnd.nextInt(<span class="number">256</span>), rnd.nextInt(<span class="number">256</span>), rnd.nextInt(<span class="number">256</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多数时候在 <code>onCreate()</code> 中创建 ViewModel 即可。调用 <code>LiveData.observe()</code> 方法来观察数据。该方法的第一个参数是当前 UI，第二个参数是一个 <a href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html" target="_blank" rel="noopener">Observer</a>，其实也就是个回调。</p><p>当 <code>setValue()</code> 被调用后，<code>onChanged()</code> 立即被调用并获取到保存在 colorResource 中的最新值。</p><p>前面说过可以使用 <code>setValue()</code> 和 <code>postValue()</code> 来修改 LiveData 的值。在我们的例子中使用 <code>setValue()</code> 即可，因为是在主线程进行的。</p><p>再来看另一个例子更实际的例子。这个例子是一个计时器。计时器显示当前时间并且每2秒更新一次。</p><p><img src="http://codinginfinite.com/wp-content/uploads/2018/07/videotogif_2018.07.21_12.20.17.gif" alt></p><p>TimeChangerViewModel 的代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeChangerViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> timerValue = MutableLiveData&lt;<span class="built_in">Long</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        timerValue.value = System.currentTimeMillis()</span><br><span class="line">        startTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">startTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">        disposable = Observable.interval(<span class="number">2</span>, <span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">                .subscribe(&#123;</span><br><span class="line">                    timerValue.postValue(System.currentTimeMillis())</span><br><span class="line">                &#125;, Throwable::printStackTrace)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TimeChangerViewModel 初始化后启动计时器，每2秒更新一次。这里使用 <a href="https://github.com/ReactiveX/RxJava/wiki/What&#39;s-different-in-2.0" target="_blank" rel="noopener">RxJava2</a> 来创建计时器。另外需要注意的是这里使用 <code>postValue()</code> 而不是 <code>setValue()</code>，因为 <a href="http://reactivex.io/documentation/operators/interval.html" target="_blank" rel="noopener">interval</a> 方法是在 <strong>后台线程</strong> 中订阅的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        <span class="keyword">val</span> timeChangerViewModel = ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(TimeChangerViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        <span class="keyword">val</span> calendar = Calendar.getInstance()</span><br><span class="line">        timeChangerViewModel.timerValue.observe(<span class="keyword">this</span>, Observer&lt;<span class="built_in">Long</span>&gt; &#123; t -&gt;</span><br><span class="line">            Log.e(<span class="string">"TimeValue"</span>, t.toString())</span><br><span class="line">            calendar?.timeInMillis = t!!</span><br><span class="line">            timTextView.text = calendar.time.toString()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子非常简单。将 <a href="https://developer.android.com/reference/android/arch/lifecycle/Observer" target="_blank" rel="noopener">Observer</a> 设置到 LiveData 之后，如果 <strong>TimeChangerViewModel</strong> 中的 timerValue 发生变化，马上就会使用新的值调用 <code>onChanged()</code>。如果我们的 Activity 处于后台，LiveData 会暂停发送新的值。我是通过 logcat 打印日志来验证这一点的。</p><p>注意：当我们从 <a href="https://developer.android.com/reference/android/arch/lifecycle/Observer" target="_blank" rel="noopener">Observer</a> 接收新的值时，是运行在主线程中的。尽管是从后台线程发送新的值，但底层会帮我们进行线程切换以方便开发者使用。</p><h1 id="停止监听-LiveData"><a href="#停止监听-LiveData" class="headerlink" title="停止监听 LiveData"></a>停止监听 LiveData</h1><p>有时不需要继续监听 LiveData。这时可以移除指定的观察者。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someViewModel.liveData.removeObservers(lifecycle : <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>下一篇中我将讲讲这几个话题：</p><ul><li><a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#map(android.arch.lifecycle.LiveData%3CX%3E,%20android.arch.core.util.Function%3CX,%20Y%3E" target="_blank" rel="noopener">map</a>)</li><li><a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#switchMap(android.arch.lifecycle.LiveData%3CX%3E,%20android.arch.core.util.Function%3CX,%20android.arch.lifecycle.LiveData%3CY%3E%3E" target="_blank" rel="noopener">swicthMap</a>)</li><li><a href="https://developer.android.com/reference/android/arch/lifecycle/MediatorLiveData" target="_blank" rel="noopener">MediatorLiveData</a></li><li><a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html" target="_blank" rel="noopener">Transformation</a></li></ul><hr><p>这篇文章中将讲讲关于 <a href="https://developer.android.com/topic/libraries/architecture/livedata" target="_blank" rel="noopener">LiveData</a> 的 Transformations。有时在将 LiveData 中的值分发给 <a href="https://developer.android.com/reference/android/arch/lifecycle/Observer" target="_blank" rel="noopener">Observer</a> 前需要进行转换，有时在某些条件下你可能要返回一个不同的 LiveData。所以就有了 Transformations。</p><h1 id="Transformations-介绍"><a href="#Transformations-介绍" class="headerlink" title="Transformations 介绍"></a>Transformations 介绍</h1><p>Transformation 基本上就是对 LiveData 对象中持有的值应用一个 function，并且将得到的结果传给下游。有两种不同的 Transformation：</p><ul><li><a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations#map(android.arch.lifecycle.LiveData%3CX%3E,%20android.arch.core.util.Function%3CX,%20Y%3E" target="_blank" rel="noopener">Transformations.map</a>)  - <strong>map</strong> 允许对 LiveData 持有的值应用一个 function 并将结果传给下游</li><li><a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#switchMap(android.arch.lifecycle.LiveData%3CX%3E,%20android.arch.core.util.Function%3CX,%20android.arch.lifecycle.LiveData%3CY%3E%3E" target="_blank" rel="noopener">Transformations.switchMap:</a>) - <strong>swicthMap</strong> 跟 map 其实很类似，不过它而返回 LiveData 本身而不是 LiveData 持有的值。同样，<strong>swicthMap</strong> 向下游传递 LiveData 而不是值。</li></ul><h1 id="Transformations-map-示例"><a href="#Transformations-map-示例" class="headerlink" title="Transformations.map 示例"></a>Transformations.map 示例</h1><p>看这样一个场景：用户向数据库中添加一个新用户后展示一个 Snackbar。Snackbar 上显示用户名。</p><p><img src="http://codinginfinite.com/wp-content/uploads/2018/07/videotogif_2018.07.22_15.36.40.gif" alt></p><p>直接看代码。这段代码中，ViewModel 持有含有 User 的 LiveData：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransformationViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> userLiveData = MutableLiveData&lt;User&gt;()</span><br><span class="line">    <span class="keyword">val</span> userAddedData: LiveData&lt;String&gt; = Transformations.map(userLiveData, ::someFunc)</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">someFunc</span><span class="params">(user: <span class="type">User</span>)</span></span> = <span class="string">"New user <span class="subst">$&#123;user.username&#125;</span> added to database!"</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addNewUser</span><span class="params">(user: <span class="type">User</span>)</span></span> = apply &#123; userLiveData.value = user &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两点要注意：</p><ul><li>首先，并没有向外公开持有 User 的 LiveData。只有一个公开的 <code>addNewUser()</code> 方法用于添加用户。这样做可以保持不变性。(By doing this we’re keeping our Immutability principle)</li><li>其次，为了添加 map transformation 操作，我们需要提供原始的 LiveData 以及一个用于转换的 function (你从这个 function 返回自定义的值)。在本例中是返回用户名</li></ul><p>再来看看如何在 Activity 中使用 ViewModel 和 LiveData：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        <span class="keyword">val</span> viewModel = ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(TransformationViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        viewModel.userAddedData.observe(<span class="keyword">this</span>, <span class="keyword">object</span> : Observer&lt;String&gt;&#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChanged</span><span class="params">(t: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                Snackbar.make(mainActivityRootView, t!!, Snackbar.LENGTH_SHORT).show()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        addUserButton.setOnClickListener &#123;</span><br><span class="line">            viewModel.addNewUser(User(addNewEditText.text.toString()))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Activity 非常简单。我们只观察 LiveData 实例。向数据库添加用户时，会自动调用 <code>onChanged()</code> 方法并得到用户名。</p><h1 id="Transformations-switchMap-示例"><a href="#Transformations-switchMap-示例" class="headerlink" title="Transformations.switchMap 示例"></a>Transformations.switchMap 示例</h1><p>再看另一个场景：根据名字查询用户，并且在 <a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView" target="_blank" rel="noopener">RecyclerView</a> 中展示查询结果。</p><p><img src="http://codinginfinite.com/wp-content/uploads/2018/07/videotogif_2018.07.24_01.24.14.gif" alt></p><p>代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRepo</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">searchUserWithName</span><span class="params">(name : <span class="type">String</span>)</span></span> : LiveData&lt;List&lt;User&gt;&gt;&#123;</span><br><span class="line">      ..... logic <span class="keyword">for</span> search user</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> query = MutableLiveData&lt;String&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> userRepo = UserRepo()</span><br><span class="line">    <span class="keyword">val</span> userNameResult: LiveData&lt;List&lt;User&gt;&gt; = Transformations.map(</span><br><span class="line">            query,</span><br><span class="line">            ::temp</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">temp</span><span class="params">(name: <span class="type">String</span>)</span></span> = userRepo.searchUserWithName(name)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">searchUserByName</span><span class="params">(name: <span class="type">String</span>)</span></span> = apply &#123; query.value = name &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中 ViewModel 从 <strong>UserRepo</strong> 类获取数据。所以当查询某个名字的时候，repo 会创建一个新的 LiveData 实例(持有 List<user>)。我们最终基于这个 LiveData 来展示查询结果。</user></p><p>为了能讲清楚 <code>map()</code> 和 <code>swicthMap()</code> 的区别。以上代码我使用的是 <code>map()</code>，这会引起一个问题。</p><p>先查询用户名的是 Alice。 repo 创建了持有 List<user> 的 LiveData，并且展示了结果。之后又查询用户名 Bob，repo 又创建了一个新 LiveData，并且 UI 会订阅这个新的 LiveData。所以这时 UI 订阅了两个 LiveData，因为我们并没有取消订阅前一个 LiveData。这意味着当 repo 变化时， repo 会向 UI 发送两次订阅结果。那么如何解决这个问题呢？</user></p><p>解决方案是实现一个机制，当我们观察新的数据时能自动停止观察前一个数据。 使用 <code>swicthMap()</code> 代替 <code>map()</code> 即可达到这种效果。在底层，<a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#switchMap(android.arch.lifecycle.LiveData%3CX%3E,%20android.arch.core.util.Function%3CX,%20android.arch.lifecycle.LiveData%3CY%3E%3E" target="_blank" rel="noopener">switchMap</a>) 使用 <a href="https://developer.android.com/reference/android/arch/lifecycle/MediatorLiveData" target="_blank" rel="noopener">MediatorLiveData</a>，当开始观察新的数据时它会自动取消前一个数据。简而言之，它提供一个自动取消前一个 Observer 的机制。</p><p>修改后的代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRepo</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">searchUserWithName</span><span class="params">(name  : <span class="type">String</span>)</span></span> : LiveData&lt;List&lt;User&gt;&gt;&#123;</span><br><span class="line">         .... logic <span class="keyword">for</span> search user</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> query = MutableLiveData&lt;String&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> userRepo = UserRepo()</span><br><span class="line">    <span class="keyword">val</span> userNameResult: LiveData&lt;List&lt;User&gt;&gt; = Transformations.switchMap(</span><br><span class="line">            query,</span><br><span class="line">            ::temp</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">temp</span><span class="params">(name: <span class="type">String</span>)</span></span> = userRepo.searchUserWithName(name)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">searchUserByName</span><span class="params">(name: <span class="type">String</span>)</span></span> = apply &#123; query.value = name &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 MainActivity 中使用 ViewModel：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> userList: MutableList&lt;User&gt; = ArrayList()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> userAdapter: UserAdapter</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        userRecyclerView.layoutManager = LinearLayoutManager(<span class="keyword">this</span>)</span><br><span class="line">        userRecyclerView.setHasFixedSize(<span class="literal">true</span>)</span><br><span class="line">        userAdapter = UserAdapter(<span class="keyword">this</span>, userList)</span><br><span class="line">        userRecyclerView.adapter = userAdapter</span><br><span class="line">        <span class="keyword">val</span> viewModel = ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(UserViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        addUserButton.setOnClickListener &#123; viewModel.searchUserByName(addNewEditText.text.toString()) &#125;</span><br><span class="line">        viewModel.userNameResult.observe(<span class="keyword">this</span>, Observer &#123;</span><br><span class="line">            <span class="keyword">if</span> (userList.isNotEmpty())</span><br><span class="line">                userList.clear()</span><br><span class="line">            userList.addAll(it!!)</span><br><span class="line">            userAdapter.notifyDataSetChanged()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Activity 很简单。先是为 RecyclerView 设置属性，当用户点击按钮时根据输入的用户名调用 ViewModel 类的方法来查找用户。最后，只用简单地监听来自 ViewModel 的 LiveData 即可。</p><hr><h1 id="问题验证"><a href="#问题验证" class="headerlink" title="问题验证"></a>问题验证</h1><p>从上面两个文章中可以学习到 LiveData 的基本用法。不过对以下两个问题还是有些疑问：</p><ul><li>Activity 或 Fragment 处于后台时，LiveData 的观察者是否仍然会收到事件</li><li>文中提到 <code>map()</code> 与 <code>swicthMap()</code> 差异讲得不是太清，似乎也不可信</li></ul><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>第一个问题比较容易验证。我改写了一下代码，观察 Activity 在前台和后台 logcat 日志的区别。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> timeChangerViewModel: TimeChangerViewModel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.tmp)</span><br><span class="line"></span><br><span class="line">        timeChangerViewModel = ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(TimeChangerViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        timeChangerViewModel.timerValue.observe(<span class="keyword">this</span>, android.arch.lifecycle.Observer &#123;t -&gt;</span><br><span class="line">            Log.i(<span class="string">"TimeValue"</span>, <span class="string">"consume <span class="subst">$&#123;t.toString()&#125;</span>"</span>)</span><br><span class="line">            textView.text = t.toString()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeChangerViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> timerValue = MutableLiveData&lt;<span class="built_in">Long</span>&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> disposable = CompositeDisposable()</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0L</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        timerValue.value = <span class="number">0</span></span><br><span class="line">        startTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCleared</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCleared()</span><br><span class="line">        <span class="keyword">if</span> (!disposable.isDisposed) &#123;</span><br><span class="line">            disposable.dispose()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">startTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> d = Observable.interval(<span class="number">2</span>, <span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">                .subscribe(&#123;</span><br><span class="line">                    count++</span><br><span class="line">                    timerValue.postValue(count)</span><br><span class="line">                    Log.i(<span class="string">"TimeValue"</span>, <span class="string">"produce <span class="variable">$count</span>"</span>)</span><br><span class="line">                &#125;, Throwable::printStackTrace)</span><br><span class="line">        disposable.add(d)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟原来代码的主要区别：</p><ul><li>为了容易观察，不是输出当前时间到日志，而是直接输出一个整数</li><li>TimeChangerViewModel 负责生产整数，Main 负责消费整数，为了容易观察，生产者和消费者均输出日志</li></ul><p>这是输出的日志：</p><p><img src="livedata.png" alt></p><ul><li>绿框阶段，Main Activity 处于前台，这时 TimeChangerViewModel 负责生产，Main 负责消费</li><li>红框阶段，Main Activity 处于后台，这时 TimeChangerViewModel 继续生产，但 Main 不消费了。由于 LiveData 只能持有一个值，所以以前生产的整数都被覆盖了。</li></ul><p>如果我们想让 Main Activity 处于后台时也能继续消费 TimeChangerViewModel 生产的整数该怎么办呢？这时就要使用 <code>observeForever()</code> 方法来代替 <code>observe()</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> timeChangerViewModel: TimeChangerViewModel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.tmp)</span><br><span class="line"></span><br><span class="line">        timeChangerViewModel = ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(TimeChangerViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        timeChangerViewModel.timerValue.observeForever( android.arch.lifecycle.Observer &#123;t -&gt;</span><br><span class="line">            Log.i(<span class="string">"TimeValue"</span>, <span class="string">"consume <span class="subst">$&#123;t.toString()&#125;</span>"</span>)</span><br><span class="line">            textView.text = t.toString()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        timeChangerViewModel.timerValue.removeObservers(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeChangerViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> timerValue = MutableLiveData&lt;<span class="built_in">Long</span>&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> disposable = CompositeDisposable()</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0L</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        timerValue.value = <span class="number">0</span></span><br><span class="line">        startTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCleared</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCleared()</span><br><span class="line">        <span class="keyword">if</span> (!disposable.isDisposed) &#123;</span><br><span class="line">            disposable.dispose()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">startTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> d = Observable.interval(<span class="number">2</span>, <span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">                .subscribe(&#123;</span><br><span class="line">                    count++</span><br><span class="line">                    timerValue.postValue(count)</span><br><span class="line">                    Log.i(<span class="string">"TimeValue"</span>, <span class="string">"produce <span class="variable">$count</span>"</span>)</span><br><span class="line">                &#125;, Throwable::printStackTrace)</span><br><span class="line">        disposable.add(d)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>observeForever()</code> 和 <code>observe()</code> 有两个明显不同：</p><ul><li>首先从名字可以大概猜测出来前者是 <strong>永远</strong> 观测，不会主动感知组件的生命周期</li><li>第二，既然不关心组件生命周期，所以前者没有 lifecycleOwner 参数</li><li>最后，通过 <code>observeForever()</code> 注册的观察者，要记得手动移除！</li></ul><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><ul><li><a href="https://stackoverflow.com/questions/47575961/what-is-the-difference-between-map-and-switchmap-methods" target="_blank" rel="noopener">What is the difference between map() and switchMap() methods?</a><ul><li>map() applies a function on the value stored in the LiveData object, and propagates the result downstream.</li><li>swicthMap() applies a function to the value stored in the LiveData object and unwraps and dispatches the result downstream. <strong>The function passed to switchMap() must return a LiveData object</strong>.</li></ul></li><li><a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations" target="_blank" rel="noopener">Transformations 官方文档</a></li></ul><p>可以不同的层面来理解二者的差异。</p><ul><li>在 <code>map()</code> 场景中被传进来的 LiveData 扮演 <em>source</em> 的角色</li><li>在 <code>swicthMap()</code> 场景中被传进来的 LiveData 扮演 <em>trigger</em> 的角色。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Jetpack 学习笔记之 Navigation</title>
      <link href="2019/04/19/learn-jetpack-nav-1/"/>
      <url>2019/04/19/learn-jetpack-nav-1/</url>
      
        <content type="html"><![CDATA[<p>Android Jetpack Navigation 学习笔记。<br><a id="more"></a></p><p>学习内容来自官方文档 <a href="https://developer.android.com/guide/navigation/" target="_blank" rel="noopener">Navigation</a>。</p><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>Android Jetpack 中的 Navigation 组件用于 app 导航。Navigation 组件主要有三个部分：</p><ul><li>Navigation graph - 这是一个包括所有导航相关信息的 XML 文件<ul><li>destination - 应用中的内容承载区域，简单来说就是 Fragment 或者 Activity</li></ul></li><li><code>NavHost</code> - 一个空的容器，用于展示 destination<ul><li><a href="https://developer.android.com/reference/androidx/navigation/fragment/NavHostFragment.html" target="_blank" rel="noopener">NavHostFragment</a> - Navigation 组件中提供 <code>NavHost</code> 实现，用于展示 Fragment</li></ul></li><li><code>NavController</code> - 管理 app 导航</li></ul><p>使用 Navigation 组件的好处：</p><ul><li>Handling fragment transactions</li><li>Handling Up and Back actions correctly by default</li><li>Providing standardized resources for animations and transitions</li><li>Implementing and handling deep linking</li><li>Including Navigation UI patterns</li><li><a href="https://developer.android.com/guide/navigation/navigation-pass-data#Safe-args" target="_blank" rel="noopener">Safe Args</a></li></ul><p>使用 Navigation 组件需要使用 Android Studio 3.3 及以上版本。</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>第一步是创建 navigation graph 文件。navigation graph 文件位置 <code>res/navigation/nav_graph.xml</code>。可以使用 Navigation Editor 预览和编辑该文件。</p><p><em>A navigation graph is a resource file that contains all of your destinations and actions</em>. </p><ul><li>Destinations are the different content areas in your app</li><li>Actions are logical connections between your destinations that represent paths that users can take</li></ul><p>第二步是在 Activity 中添加 <code>NavHost</code>。这是一个空的容器，当用户在 app 内导航时 destination 被添加到该容器或从容器中移除。</p><p>navigation host 必须继承自 <a href="https://developer.android.com/reference/androidx/navigation/NavHost.html" target="_blank" rel="noopener">NavHost</a>。<a href="https://developer.android.com/reference/androidx/navigation/fragment/NavHostFragment.html" target="_blank" rel="noopener">NavHostFragment</a> 是 Navigation 组件的缺省实现，你也可以提供自己的实现。</p><p>添加了 <code>NavHostFragment</code> 作为 navigation host。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.appcompat.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/nav_host_fragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"androidx.navigation.fragment.NavHostFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        <span class="attr">app:defaultNavHost</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:navGraph</span>=<span class="string">"@navigation/nav_graph"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.bottomnavigation.BottomNavigationView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.constraint.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上 XML 文件中</p><ul><li><code>android:name</code> - 指定 <code>NavHost</code> 实现类的名字</li><li><code>app:navGraph</code> - 将 <code>NavHost</code> 跟 <code>nav_graph.xml</code> 文件关联</li><li><code>app:defaultNavHost=&quot;true&quot;</code> - 指定 <code>NavHost</code> 是否处理系统 Back 键<ul><li>同一布局中可以有多个 <code>NavHost</code></li><li>同一布局中只能有一个 default 的 <code>NavHost</code></li></ul></li></ul><p>第三步是编辑 navigation graph 文件。在 Editor 中点 “New Destination”，</p><ul><li>可以创建新的 Fragment 以新建 destination</li><li>可以从已有的 Fragment 来新建 destination</li><li>可以创建一个 placeholder destination (占位符，不影响编译)</li></ul><p>以下是一个例子。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">navigation</span> <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:startDestination</span>=<span class="string">"@id/blankFragment"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/blankFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.example.cashdog.cashdog.BlankFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"Blank"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:layout</span>=<span class="string">"@layout/fragment_blank"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure><p>切换到 Design 模式可以看到4个重要属性：</p><ul><li>Type - 指定 destination 是由 Fragment, Activity 还是其他的某个代码来实现</li><li>Label - 展示 destination 时的标题名</li><li>ID - destination ID，用于在代码中引用这个 destination</li><li>Class - 跟 destination 关联的 Java 类</li></ul><p><img src="atrributes.png" alt></p><p>对 navigation graph 的编辑操作主要有以下几个：</p><ul><li>指定 <a href="https://developer.android.com/guide/navigation/navigation-principles" target="_blank" rel="noopener">start destination</a>，即进入该 Activity 后看到的第一屏界面</li><li>为 destination 添加连接</li></ul><p>完成以上三步后，就可以开始在 app 内导航了。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用 <a href="https://developer.android.com/reference/androidx/navigation/NavController.html" target="_blank" rel="noopener">NavController</a> 导航至 destination。NavController 是在一个 <code>NavHost</code> 范围内进行导航管理的对象。每个 <code>NavHost</code> 都有自己的 <code>NavController</code>。</p><h3 id="获取-NavController"><a href="#获取-NavController" class="headerlink" title="获取 NavController"></a>获取 <code>NavController</code></h3><p>Kotlin 代码</p><ul><li>Fragment.findNavController()</li><li>View.findNavController()</li><li>Activity.findNavController(viewId: Int)</li></ul><p>Java 代码</p><ul><li>NavHostFragment.findNavController(Fragment)</li><li>Navigation.findNavController(Activity, @IdRes int viewId)</li><li>Navigation.findNavController(View)</li></ul><h3 id="导航至-destination"><a href="#导航至-destination" class="headerlink" title="导航至 destination"></a>导航至 destination</h3><p>使用 <code>NavController.navigate()</code> 导航至指定的 destination。</p><ul><li>NavController.navigateUp() </li><li>NavController.popBackStack()</li></ul><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><p>场景：在用户首次注册流程中，一旦注册成功，就应该从 back stack 中清空所有注册相关的 destination 以免用户退回到这些 destination</p><p>场景：<a href="https://developer.android.com/guide/navigation/navigation-getting-started#popupto_example_circular_logic" target="_blank" rel="noopener">循环跳转问题</a> </p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><ul><li><a href="https://developer.android.com/guide/navigation/navigation-design-graph#nested_graphs" target="_blank" rel="noopener">Nested graphs</a></li><li>跨 module 跳转</li><li><a href="https://developer.android.com/guide/navigation/navigation-conditional" target="_blank" rel="noopener">Conditional navigation</a></li><li><a href="https://developer.android.com/guide/navigation/navigation-design-graph#global_actions" target="_blank" rel="noopener">Global actions</a></li><li><a href="https://developer.android.com/guide/navigation/navigation-pass-data" target="_blank" rel="noopener">Pass data between destinations</a></li></ul><h2 id="Nested-graphs"><a href="#Nested-graphs" class="headerlink" title="Nested graphs"></a>Nested graphs</h2><p>可以将一组 destination 组合成一个 nested graphs。needed graphs 适用于用户注册、<a href="https://developer.android.com/guide/navigation/navigation-conditional#first-time_user_experience" target="_blank" rel="noopener">滑屏页</a>等场景，可以更好地组织特定流程。</p><ul><li>nested graph 必须有一个 start destination</li><li>nested graph 以外的 destination 只能通过 start destination 来访问这个 nested graph</li></ul><p>小技巧：使用 <include> 标签包含其他 navigation graph。</include></p><h2 id="跨-module-跳转"><a href="#跨-module-跳转" class="headerlink" title="跨 module 跳转"></a>跨 module 跳转</h2><h2 id="Conditional-navigation"><a href="#Conditional-navigation" class="headerlink" title="Conditional navigation"></a>Conditional navigation</h2><p>根据 <a href="https://developer.android.com/guide/navigation/navigation-conditional" target="_blank" rel="noopener">文档</a>，可知 Navigation 组件自身并没有真正实现 conditional navigation，而是需要开发者自己使用 ViewModel + NavController 来实现</p><h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p>支持的参数类型：</p><ul><li>基本类型</li><li>string - app:argType=”string”    </li><li>Resource Reference - app:argType=”reference”    </li><li>Custom Parcelable - app:argType=”<type>“, where <type> is the fully-qualified class name of the Parcelable    </type></type></li><li>Custom Serializable - app:argType=”<type>“, where <type> is the fully-qualified class name of the Serializable    </type></type></li><li>Custom Enum - app:argType=”<type>“, where <type> is the fully-qualified name of the enum</type></type></li></ul><p>如果参数支持 null 值，可以填 “@null”</p><h3 id="Safe-Args"><a href="#Safe-Args" class="headerlink" title="Safe Args"></a>Safe Args</h3><h3 id="混淆配置"><a href="#混淆配置" class="headerlink" title="混淆配置"></a><a href="https://developer.android.com/guide/navigation/navigation-pass-data#use_keep_annotations" target="_blank" rel="noopener">混淆配置</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Keep class ParcelableArg : Parcelable &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">@Keep class SerializableArg : Serializable &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">@Keep enum class EnumArg &#123; ... &#125;</span><br></pre></td></tr></table></figure><h1 id="其他话题"><a href="#其他话题" class="headerlink" title="其他话题"></a>其他话题</h1><p>Navigation 组件内容很丰富。限于时间和精力，我略过了以下内容：</p><ul><li>Deep Link</li><li>动画</li><li>手动创建 <code>NavHostFragment</code></li><li>测试</li><li>添加新的 destination type</li><li><a href="https://developer.android.com/guide/navigation/navigation-migrate" target="_blank" rel="noopener">如何迁移</a></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.youtube.com/watch?v=9O1D_Ytk0xg" target="_blank" rel="noopener">10 Best Practices for Moving to a Single Activity</a></li><li><a href="https://www.youtube.com/watch?v=2k8x8V77CrU" target="_blank" rel="noopener">Single Activity: Why, When, and How (Android Dev Summit ‘18)</a></li><li><a href="https://github.com/googlesamples/android-architecture-components/tree/master/NavigationBasicSample" target="_blank" rel="noopener">https://github.com/googlesamples/android-architecture-components/tree/master/NavigationBasicSample</a></li><li><a href="https://developer.android.com/guide/navigation/" target="_blank" rel="noopener">Navigation</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Groovy与Gradle</title>
      <link href="2019/03/19/groovy-basic/"/>
      <url>2019/03/19/groovy-basic/</url>
      
        <content type="html"><![CDATA[<p>总结一下 Groovy 和 Gradle。<br><a id="more"></a></p><h1 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h1><p>Github 上搜索热门的 groovy 项目，发现屈指可数。star 数大于 2000 的项目才 7 个。</p><p><img src="groovy-repo.png" alt></p><p>看来它的热度实在不怎么样。但考虑到 Gradle 的影响力，还是有必要粗略地了解一下这门语言。</p><p>先上要点(排名分先后)：</p><p><img src="groovy-core.png" alt></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>之所以要把工具放在第一个讲，是因为只要你打开了 Android Studio，其实是很容易尝试写 groovy 代码的。</p><p>Android Studio &gt; Tools &gt; Groovy Console</p><p><img src="groovy-tool.png" alt></p><p>Tips：</p><ul><li>你也可以在 Groovy Console 写 Java 代码，所以如果下次想验证某个 Java API 的用法不如先在 Groovy Console 下先试一下</li><li>找不到 Groovy Console 入口的话，双击 Shift 搜索 groovy console</li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是 groovy 最为强大的功能。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="what-is-closure.png" alt></p><p>你其实使用过闭包，只是没有意识到而已。比如<code>java.io.File.list(FilenameFilter)</code>，<code>FilenameFilter</code>接口只有一个<code>filter()</code>方法，这个方法对list()返回的列表进行过滤。而<code>FilenameFilter</code>接口存在的唯一意义就在于定义<code>filter()</code>方法。这是一种设计模式：方法对象模式(Method-Object pattern)。这种设计模式通常用来模拟一个行为：为一个目的定义一个独立的方法接口，这个接口的实例能够传递一组参数给方法，然后调用这个接口方法。相当繁琐，且导致非常多的类。虽然可以使用Java匿名类，但是会让代码更难理解。</p><p>看看 Groovy 中是怎么做的。第一种是 Java 的处理方式，第二种是 Groovy 的处理方式。后一种方式是不是简单很多？</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> accept(Integer integer) &#123;</span><br><span class="line">        println <span class="string">"for each "</span> + integer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].each &#123; println <span class="string">"each "</span> + it &#125;</span><br></pre></td></tr></table></figure><p><a href="http://docs.groovy-lang.org/latest/html/api/groovy/lang/Closure.html" target="_blank" rel="noopener">Closure</a>定义如下。Closure 表示 Groovy 中的闭包对象，它是一个普通的 Java 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>Groovy 允许 Closure 以如下形式被调用：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> c = &#123; a &#125;</span><br><span class="line"><span class="keyword">assert</span> c() == <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> c.call() == <span class="number">1</span></span><br></pre></td></tr></table></figure><p>简单来说，一个闭包是被包装为一个对象的代码块，见如下代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">log = <span class="string">''</span></span><br><span class="line"><span class="comment">// 使用赋值的方式声明闭包</span></span><br><span class="line">Closure c = &#123; counter -&gt; log += counter&#125;</span><br><span class="line">(<span class="number">1.</span><span class="number">.10</span>).each(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接声明闭包</span></span><br><span class="line">(<span class="number">1.</span><span class="number">.10</span>).each(&#123; counter -&gt; log += counter &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包的缩写定义，省略了方法调用时的括号</span></span><br><span class="line">(<span class="number">1.</span><span class="number">.10</span>).each &#123; counter -&gt; log += counter&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包的缩写定义，使用隐式参数it</span></span><br><span class="line">(<span class="number">1.</span><span class="number">.10</span>).each &#123; log += it &#125;</span><br></pre></td></tr></table></figure><p>这里使用 Groovy 写个 Visitor 模式：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> accept(Closure yield) &#123;</span><br><span class="line">        yield(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> width</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> area() &#123;</span><br><span class="line">        width**<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> radius</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> area() &#123;</span><br><span class="line">        Math.PI * (radius**<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawing</span> &#123;</span></span><br><span class="line">    List&lt;Shape&gt; shapes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> accept(Closure yield) &#123;</span><br><span class="line">        shapes.each &#123; it.accept(yield) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> drawing = <span class="keyword">new</span> Drawing(</span><br><span class="line"><span class="symbol">        shapes:</span> [<span class="keyword">new</span> Square(<span class="string">width:</span> <span class="number">1</span>), <span class="keyword">new</span> Circle(<span class="string">radius:</span> <span class="number">2</span>)]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">def</span> total = <span class="number">0</span></span><br><span class="line">drawing.accept &#123; total += it.area() &#125;</span><br><span class="line">println(<span class="string">"total is $total"</span>)</span><br></pre></td></tr></table></figure><p>你能找出谁是 Visitor 吗？</p><h3 id="理解闭包"><a href="#理解闭包" class="headerlink" title="理解闭包"></a>理解闭包</h3><p>Closure 有三个属性，分别是 this, owner, delegate, 通常delegate被设置为 owner  <a href="https://stackoverflow.com/questions/8120949/what-does-delegate-mean-in-groovy" target="_blank" rel="noopener">来源</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def testClosure(closure) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line">testClosure() &#123;</span><br><span class="line">    println &quot;this is &quot; + this + &quot;, super:&quot; + this.getClass().superclass.name</span><br><span class="line">    println &quot;owner is &quot; + owner + &quot;, super:&quot; + owner.getClass().superclass.name</span><br><span class="line">    println &quot;delegate is &quot; + delegate + &quot;, super:&quot; + delegate.getClass().superclass.name</span><br><span class="line"></span><br><span class="line">    testClosure() &#123;</span><br><span class="line">        println &quot;this is &quot; + this + &quot;, super:&quot; + this.getClass().superclass.name</span><br><span class="line">        println &quot;owner is &quot; + owner + &quot;, super:&quot; + owner.getClass().superclass.name</span><br><span class="line">        println &quot;delegate is &quot; + delegate + &quot;, super:&quot; + delegate.getClass().superclass.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this is ideaGroovyConsole@610f7aa, super:groovy.lang.Script</span><br><span class="line">owner is ideaGroovyConsole@610f7aa, super:groovy.lang.Script</span><br><span class="line">delegate is ideaGroovyConsole@610f7aa, super:groovy.lang.Script</span><br><span class="line">this is ideaGroovyConsole@610f7aa, super:groovy.lang.Script</span><br><span class="line">owner is ideaGroovyConsole$_run_closure1@2b4bac49, super:groovy.lang.Closure</span><br><span class="line">delegate is ideaGroovyConsole$_run_closure1@2b4bac49, super:groovy.lang.Closure</span><br></pre></td></tr></table></figure><p>每个闭包都有一个委托对象，Groovy 使用它来查找变量和方法的引用，而不是作为闭包的局部变量或参数。Gradle 在配置闭包中使用到它，把委托对象设置为被配置的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    assert delegate == project.dependencies // 这一行证明了将dependencies的委托对象设置为被配置的对象</span><br><span class="line">    compile(&apos;junit:junit:4.11&apos;)</span><br><span class="line">    delegate.compile(&apos;junit:junit:4.11&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GString"><a href="#GString" class="headerlink" title="GString"></a>GString</h2><p>GString 中可以使用占用位，格式化字符串时特别方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def name = &apos;cm&apos;</span><br><span class="line">def hello = &quot;hello $name&quot;</span><br></pre></td></tr></table></figure><p>举例说明 GString 的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4.times &#123;</span><br><span class="line">     task &quot;task$it&quot; &lt;&lt; &#123;</span><br><span class="line">         println &quot;I&apos;m task number $it&quot;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Java 中无法直接表示 List 字面量和 Map 字面量，非常不便。Groovy 解决了这个痛点：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">def</span> map = [<span class="number">200</span>: <span class="string">'OK'</span>, <span class="number">400</span>: <span class="string">'BAD REQUEST'</span>]</span><br></pre></td></tr></table></figure><h2 id="def-类型"><a href="#def-类型" class="headerlink" title="def 类型"></a>def 类型</h2><p>Groovy 中 <code>def</code> 关键字表示动态类型(或者说是没有类型，但内部实际上是 Object 类型)。</p><h2 id="其他话题"><a href="#其他话题" class="headerlink" title="其他话题"></a>其他话题</h2><h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> oracle(Object o) &#123; <span class="keyword">return</span> <span class="string">'object'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> oracle(String o) &#123; <span class="keyword">return</span> <span class="string">'string'</span> &#125;</span><br><span class="line"></span><br><span class="line">Object x = <span class="number">1</span></span><br><span class="line">Object y = <span class="string">'foo'</span></span><br><span class="line">println(oracle(x))</span><br><span class="line">println(oracle(y))</span><br></pre></td></tr></table></figure><p>以上这段 Groovy 代码输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object</span><br><span class="line">string</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">oracle</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"object"</span>; &#125;</span><br><span class="line">    <span class="function">String <span class="title">oracle</span><span class="params">(String o)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"string"</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object x = <span class="number">1</span>;</span><br><span class="line">        Object y = <span class="string">"foo"</span>;</span><br><span class="line">        System.out.println(oracle(x));</span><br><span class="line">        System.out.println(oracle(y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上这段 Java 代码输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object</span><br><span class="line">object</span><br></pre></td></tr></table></figure><p>对比可以发现，Groovy 使用参数的动态类型来查找方法，而 Java 使用参数的静态类型来查找方法。Java 这种做法有问题，以 <code>equals()</code> 方法为例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> E)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    E e = (E) obj;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 这种做法似乎是主动丢失掉类型信息。</p><h3 id="MetaClass"><a href="#MetaClass" class="headerlink" title="MetaClass"></a>MetaClass</h3><p>在 Groovy 中，所有的对象都实现了 GroovyObject 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GroovyObject</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeMethod</span><span class="params">(String name, Object args)</span></span>; <span class="function"><span class="keyword">public</span> Object <span class="title">getProperty</span><span class="params">(String property)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperty</span><span class="params">(String property, Object newValue)</span></span>; <span class="function"><span class="keyword">public</span> MetaClass <span class="title">getMetaClass</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMetaClass</span><span class="params">(MetaClass metaClass)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MetaClass 是 Groovy 元概念的核心，它提供了一个 Groovy 类的所有的元数据，如可用的方法、属性列表。</p><p>GroovyObject 的 invokeMethod 方法默认实现总是转到相应的 MetaClass。</p><p>MetaClass 被存储在一个名称为 MetaClassRegistry 的中心存储器中。</p><h3 id="Groovy-代理与委托"><a href="#Groovy-代理与委托" class="headerlink" title="Groovy 代理与委托"></a>Groovy 代理与委托</h3><p><a href="http://www.flysnow.org/2016/05/22/groovy-basis.html" target="_blank" rel="noopener">Groovy基础 | 飞雪无情的博客</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">task configClosure &lt;&lt; &#123;</span><br><span class="line">    person &#123;</span><br><span class="line">        personName = &quot;张三&quot;</span><br><span class="line">        personAge = 20</span><br><span class="line">        dumpPerson()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">class Person &#123;</span><br><span class="line">    String personName</span><br><span class="line">    int personAge</span><br><span class="line">   </span><br><span class="line">    def dumpPerson()&#123;</span><br><span class="line">        println &quot;name is $&#123;personName&#125;,age is $&#123;personAge&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">def person(Closure&lt;Person&gt; closure)&#123;</span><br><span class="line">    Person p = new Person();</span><br><span class="line">    closure.delegate = p</span><br><span class="line">    //委托模式优先</span><br><span class="line">    closure.setResolveStrategy(Closure.DELEGATE_FIRST);</span><br><span class="line">    closure(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整内容"><a href="#完整内容" class="headerlink" title="完整内容"></a>完整内容</h2><p><img src="groovy.png" alt></p><h1 id="Gradle-DSL"><a href="#Gradle-DSL" class="headerlink" title="Gradle DSL"></a>Gradle DSL</h1><p><a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="noopener">Gradle DSL</a> 对 DSL 有详细的描述。</p><p>先来看几个基本概念。</p><ul><li>Gradle脚本是配置脚本。当脚本执行时，它会配置一个特定类型的对象。比如构建脚本会配<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html" target="_blank" rel="noopener">Project</a>对象。它是脚本的 <em>代理对象</em></li><li>每种Gradle脚本都实现了<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Script.html" target="_blank" rel="noopener">Script</a>接口。</li></ul><p>下表显示了每种Gradle脚本的代理对象。可以在脚本中使用代码对象的属性和方法。</p><table><thead><tr><th>script类型</th><th>代理对象</th><th>对应文件</th></tr></thead><tbody><tr><td>构建脚本</td><td>Project</td><td>build.gradle</td></tr><tr><td>初始化脚本</td><td>Gradle</td><td>init.gradle?</td></tr><tr><td>设置脚本</td><td>Settings</td><td>setting.gradle</td></tr></tbody></table><h2 id="脚本结构"><a href="#脚本结构" class="headerlink" title="脚本结构"></a>脚本结构</h2><ul><li>构建脚本由零个语句或脚本块组成<ul><li>语句</li><li>方法调用</li><li>属性赋值</li><li>本地变量声明</li><li>脚本块，实质上是一个接收闭包作为参数的方法调用。顶层的常用脚本块包括：</li><li><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:allprojects(groovy.lang.Closure" target="_blank" rel="noopener">allprojects { }</a>) - 对项目及子项目进行配置</li><li><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:buildscript(groovy.lang.Closure" target="_blank" rel="noopener">buildscript { }</a>) - 构建脚本的类路径</li><li><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:dependencies(groovy.lang.Closure" target="_blank" rel="noopener">dependencies { }</a>) - 当前项目的依赖</li><li><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:repositories(groovy.lang.Closure" target="_blank" rel="noopener">repositories { }</a>) - 当前项目的中央库</li></ul></li><li>构建脚本是Groovy脚本，可以包含方法定义和类定义</li></ul><h2 id="主要类型"><a href="#主要类型" class="headerlink" title="主要类型"></a>主要类型</h2><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html" target="_blank" rel="noopener">Project</a></td><td>Gradle的主要API接口</td></tr><tr><td><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html" target="_blank" rel="noopener">Task</a></td><td>构建中最小的工作单元</td></tr><tr><td><a href="https://docs.gradle.org/current/dsl/org.gradle.api.invocation.Gradle.html" target="_blank" rel="noopener">Gradle</a></td><td>代表对Gradle的一次调用</td></tr><tr><td><a href="https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html" target="_blank" rel="noopener">Settings</a></td><td>用于配置和初始化Project实例</td></tr><tr><td><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Script.html" target="_blank" rel="noopener">Script</a></td><td></td></tr><tr><td><a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.SourceSet.html" target="_blank" rel="noopener">SourceSet</a></td><td>Java代码和资源</td></tr></tbody></table><h2 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h2><p>通过 project 对象，可以访问到 gradle.properties 里的属性。如果此类文件中的属性有一个systemProp.的前缀，该属性和它的值会被添加到系统属性。你可以通过使用方法 hasProperty(‘propertyName’) 来进行检查属性是否存在，它返回 true 或 false</p><p><code>Project.configure(Object, Closure)</code>用于配置任意对象，</p><h2 id="常见-Task"><a href="#常见-Task" class="headerlink" title="常见 Task"></a>常见 Task</h2><p>常见的包括 copy, delete, jar, test, upload。 每个 Task 都是一个脚本的属性(更准确地说，Task 是 Project 的属性)。</p><p>定义一个名为 <code>hello</code> 的 Task：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task hello</span><br><span class="line">println tasks.hello.name</span><br><span class="line">println tasks[&apos;hello&apos;].name</span><br></pre></td></tr></table></figure><p>每个任务都有一个 inputs 和 outputs 的属性，用来声明任务的输入和输出。任务的 inputs 属性是 TaskInputs 类型。任务的 outputs 属性是 TaskOutputs 类型。 一个没有定义输出的任务将永远不会被当作是最新的。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>gradle tasks</code> 查看默认tasks</p><p><code>gradle tasks --all</code> 查看全部tasks</p><p><code>gradle properties</code> 查看插件添加的属性以及默认值</p><p><code>gradle projects</code> 列出子项目名称列表</p><p><code>gradle help --task someTask</code> 显示指定任务的详细信息</p><p><code>--profile</code> 收集构建期信息并保存到 build/reports/profile 目录下并且以构建时间命名这些文件。</p><h1 id="Gradle-疑难"><a href="#Gradle-疑难" class="headerlink" title="Gradle 疑难"></a>Gradle 疑难</h1><p>Gradle 的核心在于基于 Groovy 的丰富而可扩展的域描述语言(DSL)。 但同时也带来了一些理解上的障碍。</p><p>障碍主要是语法层面的。以Android 项目的 Gradle 构建脚本为例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根目录的 build.gradle 文件</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">    ext.kotlin_version = <span class="string">'1.1.51'</span></span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:3.0.1'</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task clean(<span class="string">type:</span> Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子目录的 build.gradle 文件 </span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">26</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.example.kingcmchen.myapplication"</span></span><br><span class="line">        minSdkVersion <span class="number">15</span></span><br><span class="line">        ...</span><br><span class="line">        vectorDrawables.useSupportLibrary = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="string">dir:</span> <span class="string">'libs'</span>, <span class="string">include:</span> [<span class="string">'*.jar'</span>])</span><br><span class="line">    implementation <span class="string">'com.android.support:appcompat-v7:26.1.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际使用过程中我大概知道使用 <code>implementation</code> 如何添加更多依赖，但仍然有以下问题：</p><ul><li>问题一：<code>buildscript {}</code>，<code>allprojects {}</code>，<code>android {}</code>，<code>dependencies {}</code>的含义是什么？</li><li>问题二：<code>buildscript {}</code>中的<code>ext.kotlin_version = &#39;1.1.51&#39;</code>是在赋值吗？<code>ext</code>又是什么？</li><li>问题三：<code>google()</code>和<code>jcenter()</code>是函数调用吗？</li><li>问题四：<code>defaultConfig {}</code>中<code>minSdkVersion 15</code>和<code>vectorDrawables.useSupportLibrary = true</code>，一个有”=”一个没有”=”，有什么区别？</li><li>问题五：如何理解<code>apply plugin: &#39;com.android.application&#39;</code></li></ul><p>弄明白这几个问题前先要了解 Groovy 的几个知识点：</p><ul><li>如果闭包是方法的最后一个参数，可以放在括号外</li><li>方法调用的括号可以省略</li><li>Groovy map 通常使用字符串作为 key，key 的引号可以省略</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> testClosure(Closure closure) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始语法</span></span><br><span class="line">testClosure(&#123; println <span class="string">'Hello World'</span>&#125;)</span><br><span class="line"><span class="comment">// 支持的语法</span></span><br><span class="line">testClosure() &#123; println <span class="string">'Hello World'</span> &#125;</span><br><span class="line"><span class="comment">// 简化后的语法</span></span><br><span class="line">testClosure &#123; println <span class="string">'Hello World'</span> &#125;</span><br></pre></td></tr></table></figure><p>map 的原始形式与简化形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Map literal,  apply from: &apos;other.gradle&apos;与此类似</span><br><span class="line">apply plugin: &apos;java&apos;</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;()</span><br><span class="line">map.put(&apos;plugin&apos;, &apos;java&apos;)</span><br><span class="line">apply(map)</span><br></pre></td></tr></table></figure><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p><code>buildscript {}</code> 是在调用 <code>Project</code> 类的方法，方法原型是 <code>void buildscript(Closure configureClosure)</code>。这个方法会对当前 Project 的 <code>ScriptHandler</code> 执行指定的闭包。</p><p><code>allprojects {}</code> 也是在调用 <code>Project</code> 类的方法，方法原型是 <code>void allprojects(Closure configureClosure)</code></p><p><code>dependencies {}</code> 则是调用 <code>ScriptHandler</code> 类的方法，方法原型是 <code>void dependencies(Closure configureClosure)</code></p><p>但 <code>android {}</code> 不是方法，而一个名为 “android” 的插件，相关的类有：</p><ul><li><a href="https://android.googlesource.com/platform/tools/base/+/master/build-system/gradle/src/main/groovy/com/android/build/gradle/AppExtension.java" target="_blank" rel="noopener">com.android.build.gradle.AppExtension</a></li><li><a href="https://android.googlesource.com/platform/tools/base/+/master/build-system/gradle/src/main/groovy/com/android/build/gradle/AppPlugin.groovy" target="_blank" rel="noopener">com.android.build.gradle.AppPlugin</a></li><li><a href="https://android.googlesource.com/platform/tools/base/+/master/build-system/gradle/src/main/groovy/com/android/build/gradle/BasePlugin.java" target="_blank" rel="noopener">com.android.build.gradle.BasePlugin</a></li></ul><p>关键代码如下(如果你了解 Gradle 插件开发的话，应该不会对这个代码感到陌生)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base class for all Android plugins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePlugin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;? extends BaseExtension&gt; getExtensionClass();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        extension = project.getExtensions().create(<span class="string">"android"</span>, getExtensionClass(),</span><br><span class="line">                project, instantiator, androidBuilder, sdkHandler,</span><br><span class="line">                buildTypeContainer, productFlavorContainer, signingConfigContainer,</span><br><span class="line">                extraModelInfo, isLibrary());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppPlugin</span> <span class="keyword">extends</span> <span class="title">BasePlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><p><code>google()</code> 和 <code>jcenter()</code> 都是 <code>RepositoryHandler</code> 接口的方法，原型分别为：</p><ul><li><code>MavenArtifactRepository google()</code></li><li><code>MavenArtifactRepository jcenter()</code></li></ul><h2 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h2><p><code>defaultConfig {}</code> 是在调用 <code>BaseExtension.defaultConfig(Action&lt;ProductFlavor&gt; action)</code> 方法。其中</p><ul><li><code>minSdkVersion 15</code> 是方法调用，它是 <code>minSdkVersion(15)</code> 的简写形式。方法原型是 <code>BaseFlavor.minSdkVersion(int minSdkVersion)</code></li><li><code>vectorDrawables.useSupportLibrary = true</code> 也是方法调用，它的完整形式见以下代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VectorDrawablesOptions opt = ProductFlavor.getVectorDrawables();</span><br><span class="line">opt.setUseSupportLibrary(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="问题五"><a href="#问题五" class="headerlink" title="问题五"></a>问题五</h2><p>至于 <code>apply plugin: &#39;com.android.application&#39;</code>，它是方法调用，完整形式是 <code>Project.apply([&#39;plugin&#39;: &#39;com.android.application&#39;])</code>。</p><p>调用方法时括号是可选的。类似的例子还有 <code>include()</code> 及 <code>dependsOn()</code>。 以 <code>include()</code> 为例：</p><ul><li>简写形式：<code>include &#39;:lib1&#39;, &#39;:lib2&#39;, &#39;:lib3&#39;</code></li><li>完整形式：<code>include(&#39;:lib1&#39;, &#39;:lib2&#39;, &#39;:lib3&#39;)</code></li></ul><h1 id="零碎知识"><a href="#零碎知识" class="headerlink" title="零碎知识"></a>零碎知识</h1><h2 id="构建工具发展"><a href="#构建工具发展" class="headerlink" title="构建工具发展"></a>构建工具发展</h2><p><a href="http://blog.csdn.net/yanquan345/article/details/46710869" target="_blank" rel="noopener">构建工具的发展及Android Gradle快速上手</a>介绍了构建工具的产生背景及其发展，我用一张图稍加总结一下。</p><div align="center"><br><img src="building-tools.png" width="60%" height="60%"><br></div><h2 id="修改-APK-名"><a href="#修改-APK-名" class="headerlink" title="修改 APK 名"></a>修改 APK 名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android.applicationVariants.all &#123; variant -&gt;</span><br><span class="line">    variant.outputs.all&#123; output -&gt;</span><br><span class="line">        def file = output.outputFile</span><br><span class="line">        output.outputFileName = file.name.replace(&quot;.apk&quot;, &quot;-modify.apk&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="transitive-dependencies"><a href="#transitive-dependencies" class="headerlink" title="transitive dependencies"></a>transitive dependencies</h2><p>transitive dependencies 见<a href="https://docs.gradle.org/current/userguide/multi_project_builds.html#sec:project_jar_dependencies" target="_blank" rel="noopener">官方文档</a></p><h2 id="compile-api-implementation"><a href="#compile-api-implementation" class="headerlink" title="compile, api, implementation"></a>compile, api, implementation</h2><p>TODO</p><p>## </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">task hello1 &#123; println &apos;hello1&apos; &#125;</span><br><span class="line">task hello2 &lt;&lt; &#123; println &apos;hello2&apos; &#125;</span><br></pre></td></tr></table></figure><p><code>gradle tasks</code> 时前者后打印 <code>hello1</code> 但不会打印 <code>hello2</code>。如何解释？</p><p>TODO</p><h2 id="allprojects-与-subprojects"><a href="#allprojects-与-subprojects" class="headerlink" title="allprojects 与 subprojects"></a>allprojects 与 subprojects</h2><p>这里两个hello有什么区别？</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    task hello &#123;</span><br><span class="line">        doLast &#123; task -&gt;</span><br><span class="line">            println <span class="string">"I'm $task.project.name"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">subprojects &#123;</span><br><span class="line">    hello &#123;</span><br><span class="line">        doLast &#123;</span><br><span class="line">            println <span class="string">"- I depend on water"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Configuration-on-demand"><a href="#Configuration-on-demand" class="headerlink" title="Configuration on demand"></a>Configuration on demand</h2><p>编译IGame时为什么还会检查GameLife</p><h2 id="如何理解-ext"><a href="#如何理解-ext" class="headerlink" title="如何理解 ext"></a>如何理解 ext</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://share.weiyun.com/5ICjqlI" target="_blank" rel="noopener">Groovy In Action</a></p><p><a href="https://www.processon.com/view/link/5c908d7de4b0c996d368845b" target="_blank" rel="noopener">Groovy In Action 思维导图总结</a></p><p><a href="http://blog.csdn.net/yanquan345/article/details/46710869" target="_blank" rel="noopener">构建工具的发展及Android Gradle快速上手</a></p><p><a href="https://www.zhihu.com/question/30432152" target="_blank" rel="noopener">如何通俗地理解Gradle</a></p><p><a href="https://developer.android.com/studio/build/index.html?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/studio/build/index.html?hl=zh-cn</a></p><p><a href="https://dongchuan.gitbooks.io/gradle-user-guide-/" target="_blank" rel="noopener">https://dongchuan.gitbooks.io/gradle-user-guide-/</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeakCanary 的几个 bug</title>
      <link href="2019/02/10/2019-02-10-leakcanary-bug/"/>
      <url>2019/02/10/2019-02-10-leakcanary-bug/</url>
      
        <content type="html"><![CDATA[<p>神器 LeakCanary 并不是完美的，它仍然有一些问题待完善。<br><a id="more"></a></p><h1 id="检测不到内存泄漏的-bug"><a href="#检测不到内存泄漏的-bug" class="headerlink" title="检测不到内存泄漏的 bug"></a>检测不到内存泄漏的 bug</h1><p><a href="https://github.com/square/leakcanary/issues/1163" target="_blank" rel="noopener">1163</a></p><p>问题描述：</p><p>使用 LeakCanary version: 1.6.2 / master <a href="https://github.com/square/leakcanary/commit/cefc33d0d8ee136e7ea3b1faeb57a710ef300078" target="_blank" rel="noopener">cefc33d</a> 检查如下代码中的内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Lol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object foo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    Lol.foo = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查结果：</p><ul><li>On API 26, no leak is detected</li><li>On API 21, the leak is detected</li></ul><p>问题原因：</p><blockquote><p>Snapshot.getGCRoots() only returns the GC Roots from the first heap. In both API 21 and API 26, we had 4 heaps, however on API 21 only the first heap has GC Roots, while on API 26 the first 3 heaps had GC Roots. The missing gc roots lived in subsequent heaps.</p></blockquote><p>最新版本的 LeakCanary 中已修复这个问题。</p><h1 id="Fragment-View-内存泄漏问题"><a href="#Fragment-View-内存泄漏问题" class="headerlink" title="Fragment View 内存泄漏问题"></a>Fragment View 内存泄漏问题</h1><p><a href="https://github.com/square/leakcanary/pull/1061" target="_blank" rel="noopener">1061</a></p><p>问题描述：</p><p>如下代码中，如果没有在 <code>onDestroyView</code> 中及时清理 <code>leakingView</code>，就会产生内存泄漏问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewLeakingFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addToBackstack</span><span class="params">(<span class="keyword">final</span> TestActivity activity)</span> </span>&#123;</span><br><span class="line">    InstrumentationRegistry.getInstrumentation().runOnMainSync(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        activity.getSupportFragmentManager()</span><br><span class="line">            .beginTransaction()</span><br><span class="line">            .addToBackStack(<span class="keyword">null</span>)</span><br><span class="line">            .replace(R.id.fragments, <span class="keyword">new</span> ViewLeakingFragment())</span><br><span class="line">            .commit();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> View leakingView;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">      Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> View(container.getContext());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(View view, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Leak: this fragment will stay in memory after being replaced, leakingView should be cleared</span></span><br><span class="line">    <span class="comment">// onDestroyView()</span></span><br><span class="line">    leakingView = view;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fragment view 内存泄漏容易发生的两个时机：</p><ul><li><code>replace</code> + <code>addToBackStack</code> fragment transaction is executed.</li><li>This also occurs when you use <code>detach</code> regardless of the backstack.</li></ul><p>最新 LeakCanary 中已增加对 fragment 以及 fragment view 内存泄漏的检查。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析 LeakCanary 对应用性能的影响</title>
      <link href="2019/02/09/2019-02-09-leakcanary-perf/"/>
      <url>2019/02/09/2019-02-09-leakcanary-perf/</url>
      
        <content type="html"><![CDATA[<p>为什么不能将 LeakCanary 用于 release 包？<br><a id="more"></a><br>如何将 <a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCanary</a> 应用于正式发布包？</p><p>官方明确表示 LeakCanary 只适用于开发包中的内存泄漏。<a href="https://github.com/square/leakcanary/wiki/FAQ#how-many-methods-does-leakcanary-add" target="_blank" rel="noopener">参考</a></p><blockquote><p>LeakCanary should only be used in debug builds, and should be disabled in release builds. We provide a special empty dependency for your release builds: leakcanary-android-no-op.</p></blockquote><blockquote><p>The full version of LeakCanary is bigger and should never ship in your release builds.</p></blockquote><p>这也是为什么通常来讲，debug 包使用 <code>leakcanary-android</code>，release 包使用 <code>leakcanary-android-no-op</code>。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  debugImplementation <span class="string">'com.squareup.leakcanary:leakcanary-android:1.6.3'</span></span><br><span class="line">  releaseImplementation <span class="string">'com.squareup.leakcanary:leakcanary-android-no-op:1.6.3'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LeakCanary 在 release 包真的无用武之地吗，毕竟 release 包中也的的确确可能存在内存泄漏。</p><h1 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h1><p>为什么要在 release 包中关闭 LeakCanary 呢？答案是它会对应用性能产生影响。具体分析如下。关键点都在 <a href="https://github.com/square/leakcanary/blob/master/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java" target="_blank" rel="noopener">RefWatcher</a> 中</p><p>LeakCanary 检查内存泄漏包括四个阶段：</p><ul><li>watch</li><li>gc</li><li>heap dump</li><li>analysis </li></ul><p>logcat 中可以看到如下日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">2019-02-09 10:47:55.287 3483-3932/com.example.leakcanary:leakcanary D/LeakCanary: * Durations: watch=5046ms, gc=149ms, heap dump=5121ms, analysis=1348ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从上述数据来看，这四个阶段对性能的影响从大到小分别是：heap dump &gt; watch &gt; analysis &gt; gc。不过实际情况并非如此。</p><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>实际上 watch 阶段对性能的影响非常小。虽然从数据上看有 5s 之久，但这个其实是等待时间。等待过程中并不额外消耗 CPU 或 IO 资源。</p><p>watch 阶段指的是调用 <code>RefWatcher.watch()</code> 后到 <code>RefWatcher.ensureGone()</code> 实际被执行的耗时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// AndroidWatchExecutor.java</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">waitForIdle</span><span class="params">(<span class="keyword">final</span> Retryable retryable, <span class="keyword">final</span> <span class="keyword">int</span> failedAttempts)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This needs to be called from the main thread.</span></span><br><span class="line">    Looper.myQueue().addIdleHandler(<span class="keyword">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        postToBackgroundWithDelay(retryable, failedAttempts);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToBackgroundWithDelay</span><span class="params">(<span class="keyword">final</span> Retryable retryable, <span class="keyword">final</span> <span class="keyword">int</span> failedAttempts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> exponentialBackoffFactor = (<span class="keyword">long</span>) Math.min(Math.pow(<span class="number">2</span>, failedAttempts), maxBackoffFactor);</span><br><span class="line">    <span class="keyword">long</span> delayMillis = initialDelayMillis * exponentialBackoffFactor;</span><br><span class="line">    backgroundHandler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Retryable.Result result = retryable.run();</span><br><span class="line">        <span class="keyword">if</span> (result == RETRY) &#123;</span><br><span class="line">          postWaitForIdle(retryable, failedAttempts + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, delayMillis);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>RefWatcher.ensureGone()</code> 被封装成 <code>Retryable</code> </li><li>主线程空闲时才由 <code>postToBackgroundWithDelay()</code> 调用该 <code>Retryable</code></li><li><code>Retryable</code> 最终由名为 <code>LeakCanary-Heap-Dump</code> 的 HandlerThread 处理，延迟时间为 delayMillis</li><li>initialDelayMillis 为 5s</li><li>delayMillis 是基于 initialDelayMillis 和 failedAttempts (失败次数) 计算得到的。delayMillis 也为 5s</li></ul><p>从上面的分析可知，watch 阶段对性能基本无影响。</p><h2 id="gc"><a href="#gc" class="headerlink" title="gc"></a>gc</h2><p>频繁 gc 会对应用性能产生影响。作为良好实践，我们也应该避免调用 <code>System.gc()</code> 或 <code>Runtime.gc()</code> 主动触发 gc。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GcTrigger</span> </span>&#123;</span><br><span class="line">  GcTrigger DEFAULT = <span class="keyword">new</span> GcTrigger() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runGc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Code taken from AOSP FinalizationTest:</span></span><br><span class="line">      <span class="comment">// https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/</span></span><br><span class="line">      <span class="comment">// java/lang/ref/FinalizationTester.java</span></span><br><span class="line">      <span class="comment">// System.gc() does not garbage collect every time. Runtime.gc() is</span></span><br><span class="line">      <span class="comment">// more likely to perform a gc.</span></span><br><span class="line">      Runtime.getRuntime().gc();</span><br><span class="line">      enqueueReferences();</span><br><span class="line">      System.runFinalization();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueueReferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Hack. We don't have a programmatic way to wait for the reference queue daemon to move</span></span><br><span class="line">      <span class="comment">// references to the appropriate queues.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">runGc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gc 阶段指的是 <code>GcTrigger()</code> 的耗时。实际上 ART 虚拟机中 gc 带来的开销已大大减少，日志中 gc=149ms，其中有 100ms 的开销是由于线程主动 <code>sleep()</code> 带来的。</p><h2 id="heap-dump"><a href="#heap-dump" class="headerlink" title="heap dump"></a>heap dump</h2><p>heap dump 对 app 的性能影响非常大。<code>AndroidHeapDumper</code> 实现了 <code>HeapDumper</code> 接口，它调用 <code>Debug.dumpHprofData()</code> 方法进行 heap dump。</p><p>heap dump 是非常重的磁盘 IO 操作，虽然发生在 <code>LeakCanary-Heap-Dump</code> 线程，仍然可能让 UI 卡顿，以至于 LeakCanary 会弹出如下提示：</p><p><img src="toast.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AndroidHeapDumper.java</span></span><br><span class="line"><span class="meta">@Override</span> <span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">dumpHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  File heapDumpFile = leakDirectoryProvider.newHeapDumpFile();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (heapDumpFile == RETRY_LATER) &#123;</span><br><span class="line">    <span class="keyword">return</span> RETRY_LATER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FutureResult&lt;Toast&gt; waitingForToast = <span class="keyword">new</span> FutureResult&lt;&gt;();</span><br><span class="line">  showToast(waitingForToast);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!waitingForToast.wait(<span class="number">5</span>, SECONDS)) &#123;</span><br><span class="line">    CanaryLog.d(<span class="string">"Did not dump heap, too much time waiting for Toast."</span>);</span><br><span class="line">    <span class="keyword">return</span> RETRY_LATER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Notification.Builder builder = <span class="keyword">new</span> Notification.Builder(context)</span><br><span class="line">      .setContentTitle(context.getString(R.string.leak_canary_notification_dumping));</span><br><span class="line">  Notification notification = LeakCanaryInternals.buildNotification(context, builder);</span><br><span class="line">  NotificationManager notificationManager =</span><br><span class="line">      (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">  <span class="keyword">int</span> notificationId = (<span class="keyword">int</span>) SystemClock.uptimeMillis();</span><br><span class="line">  notificationManager.notify(notificationId, notification);</span><br><span class="line"></span><br><span class="line">  Toast toast = waitingForToast.get();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Debug.dumpHprofData(heapDumpFile.getAbsolutePath());</span><br><span class="line">    cancelToast(toast);</span><br><span class="line">    notificationManager.cancel(notificationId);</span><br><span class="line">    <span class="keyword">return</span> heapDumpFile;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    CanaryLog.d(e, <span class="string">"Could not dump heap"</span>);</span><br><span class="line">    <span class="comment">// Abort heap dump</span></span><br><span class="line">    <span class="keyword">return</span> RETRY_LATER;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analysis"><a href="#analysis" class="headerlink" title="analysis"></a>analysis</h2><p>与 heap dump 这个 IO 密集型操作不同，analysis 是个 CPU 密集型操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Retryable.<span class="function">Result <span class="title">ensureGone</span><span class="params">(<span class="keyword">final</span> KeyedWeakReference reference, <span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (!gone(reference)) &#123;</span><br><span class="line">    <span class="keyword">long</span> startDumpHeap = System.nanoTime();</span><br><span class="line">    <span class="keyword">long</span> gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);</span><br><span class="line"></span><br><span class="line">    File heapDumpFile = heapDumper.dumpHeap();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">long</span> heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);</span><br><span class="line"></span><br><span class="line">    HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)</span><br><span class="line">        .referenceName(reference.name)</span><br><span class="line">        .watchDurationMs(watchDurationMs)</span><br><span class="line">        .gcDurationMs(gcDurationMs)</span><br><span class="line">        .heapDumpDurationMs(heapDumpDurationMs)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    heapdumpListener.analyze(heapDump);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> DONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RefWatcher</code> 将 heap 文件封装成 <code>HeapDump</code> 对象，并交由 <code>HeapDump.Listener</code> 进行分析。<code>ServiceHeapDumpListener</code> 是缺省的 <code>HeapDump.Listener</code>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHeapDumpListener</span> <span class="keyword">implements</span> <span class="title">HeapDump</span>.<span class="title">Listener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Context context;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ServiceHeapDumpListener</span><span class="params">(@NonNull <span class="keyword">final</span> Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull <span class="keyword">final</span> Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listenerServiceClass = checkNotNull(listenerServiceClass, <span class="string">"listenerServiceClass"</span>);</span><br><span class="line">    <span class="keyword">this</span>.context = checkNotNull(context, <span class="string">"context"</span>).getApplicationContext();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">analyze</span><span class="params">(@NonNull HeapDump heapDump)</span> </span>&#123;</span><br><span class="line">    checkNotNull(heapDump, <span class="string">"heapDump"</span>);</span><br><span class="line">    HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">`ServiceHeapDumpListener` 又将真正的 analyze 工作交给 `HeapAnalyzerService` 进行处理。</span><br><span class="line"></span><br><span class="line">为了避免拖慢应用的速度或引起 OOM，`HeapAnalyzerService` 运行在 `:leakcanary` 进程。</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">  &lt;application&gt;</span><br><span class="line">    &lt;service</span><br><span class="line">        android:name=<span class="string">".internal.HeapAnalyzerService"</span></span><br><span class="line">        android:process=<span class="string">":leakcanary"</span></span><br><span class="line">        android:enabled=<span class="string">"false"</span></span><br><span class="line">        /&gt;</span><br><span class="line">    &lt;service</span><br><span class="line">        android:name=<span class="string">".DisplayLeakService"</span></span><br><span class="line">        android:process=<span class="string">":leakcanary"</span></span><br><span class="line">        android:enabled=<span class="string">"false"</span></span><br><span class="line">        /&gt;</span><br><span class="line">  &lt;/application&gt;</span><br></pre></td></tr></table></figure><p>核心代码代码非常简单明了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntentInForeground</span><span class="params">(@Nullable Intent intent)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">    CanaryLog.d(<span class="string">"HeapAnalyzerService received a null intent, ignoring."</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);</span><br><span class="line">  HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);</span><br><span class="line"></span><br><span class="line">  HeapAnalyzer heapAnalyzer =</span><br><span class="line">      <span class="keyword">new</span> HeapAnalyzer(heapDump.excludedRefs, <span class="keyword">this</span>, heapDump.reachabilityInspectorClasses);</span><br><span class="line"></span><br><span class="line">  AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey,</span><br><span class="line">      heapDump.computeRetainedHeapSize);</span><br><span class="line">  AbstractAnalysisResultService.sendResultToListener(<span class="keyword">this</span>, listenerClassName, heapDump, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>经过上面的分析可知，</p><ul><li>watch - 对应用性能几乎无影响</li><li>gc - 对应用性能有少量影响，不应频繁主动触发 gc</li><li>heap dump - 对应用性能有影响，可能引起卡顿</li><li>analysis - 对应用性能有影响，特别耗 CPU 和 内存</li></ul><p>解决方案如下：</p><p>方案一: 后台 analysis</p><ul><li>不要主动 gc，而是等待系统 gc 事件</li><li>选择合适的 heap dump 时机</li><li>不要在客户端进行 analysis，而是上传 heap 至后台进行 analysis</li></ul><p>方案二: 避免 analysis</p><p>watch 是为了检查是否有 leak，而 gc &amp; heap dump &amp; analysis 是为了找到最短强引用路径。前一步是为了发现问题，必须的步骤。后一步是为了解决问题，可选的步骤。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>watch 放在 release 包中是没有问题的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>例说 Profile GPU Rendering</title>
      <link href="2019/01/27/profile-gpu-rendering-demo/"/>
      <url>2019/01/27/profile-gpu-rendering-demo/</url>
      
        <content type="html"><![CDATA[<p>Profile GPU Rendering 工具很好用，但你真的清楚每个颜色的含义吗？<br><a id="more"></a><br>官方 Profile GPU Rendering 工具用于分析 UI 渲染瓶颈。官方通过两篇文档分别给出了工具用法及常见问题原因和解决办法：</p><ul><li><a href="https://developer.android.com/studio/profile/inspect-gpu-rendering" target="_blank" rel="noopener">Inspect GPU rendering speed and overdraw  |  Android Developers</a></li><li><a href="https://developer.android.com/topic/performance/rendering/profile-gpu#psb" target="_blank" rel="noopener">Analyze with Profile GPU Rendering  |  Android Developers</a></li></ul><p><img src="s-profiler-legend.png" alt></p><p>但我仍然有以下疑问：</p><ul><li>几个绿色太相近，我常常难以区分，这给分析问题带来困难</li><li>实际项目较复杂，对应的图形也相应变得复杂，如何分析</li><li>我的华为手机(Android 8.0)上似乎只能找到 7 种颜色，而不是官方给出的 8 种</li><li>如何理解 Upload，Issue，Swap 这几个阶段，什么样的代码会引起这些阶段耗时变长？</li></ul><p>带着这些疑问，我写了一个 demo，尝试生成官方将代码跟颜色对应起来，以便于理解问题。 demo 截图如下：</p><p><img src="issue.gif" width="40%" height="40%"></p><p>demo地址: <a href="https://github.com/410063005/cmdemo/tree/master/gpuprofilerdemo" target="_blank" rel="noopener">https://github.com/410063005/cmdemo/tree/master/gpuprofilerdemo</a></p><h1 id="Demo介绍"><a href="#Demo介绍" class="headerlink" title="Demo介绍"></a>Demo介绍</h1><p>首先看 Draw，Measure/Layout，Anim，Input 这几个相对容易理解的阶段。</p><h2 id="Draw"><a href="#Draw" class="headerlink" title="Draw"></a>Draw</h2><p><img src="draw.png" width="40%" height="40%"></p><p><code>RecyclerView</code> 中的每个 item 是 <code>HeavyDrawView</code>。<code>HeavyDrawView</code> 代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeavyDrawView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(context: Context,</span><br><span class="line">                                              attributes: AttributeSet? = <span class="literal">null</span>, defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span>)</span><br><span class="line">    : View(context, attributes, defStyleAttr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">        canvas?.drawColor(ContextCompat.getColor(context, R.color.color_ececec))</span><br><span class="line">        <span class="keyword">if</span> (Config.heavyDraw) &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(Config.heavyDrawDelay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当开关打开时 <code>onDraw()</code> 方法会导致主线程 sleep 一段时间，用于模拟绘制性能低下的场景，结果就是我们看到的蓝色区域明显升高以至于超过 16ms 绿线。</p><h2 id="Measure-Layout"><a href="#Measure-Layout" class="headerlink" title="Measure/Layout"></a>Measure/Layout</h2><p>如法炮制了一个 <code>HeavyLayoutView</code> 代替 <code>HeavyDrawView</code>，想让对应颜色的区域升高。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeavyLayoutView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(context: Context, attributes: AttributeSet? = <span class="literal">null</span>, defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span>)</span><br><span class="line">    : View(context, attributes, defStyleAttr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLayout</span><span class="params">(changed: <span class="type">Boolean</span>, left: <span class="type">Int</span>, top: <span class="type">Int</span>, right: <span class="type">Int</span>, bottom: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom)</span><br><span class="line">        <span class="keyword">if</span> (Config.heavyLayout) &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(Config.heavyLayoutDelay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="layout1.png" width="40%" height="40%"></p><p><code>RecyclerView</code> 中的每个 item 是 <code>HeavyDrawView</code>。但这回行不通，并非我们预期的 Measure/Layout 对应区域变长，而是 Input 阶段变长。推测原因是 RecyclerView 滚动被统计到 Input 阶段，而 <code>onLayout()</code> 在 RecyclerView 滚动后马上被触发。</p><p>换一种简单粗暴的实现方式：点击 <code>forceLayout</code> 按钮时会强制调用 <code>HeavyLayoutView.requestLayout()</code></p><p><img src="layout2.png" width="40%" height="40%"></p><p>结果我们看到 Measure/Layout 阶段对应的绿色区域明显升高。</p><h2 id="Anim"><a href="#Anim" class="headerlink" title="Anim"></a>Anim</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">textView.setOnClickListener &#123;</span><br><span class="line">    textView.animate().x(<span class="number">500f</span>)</span><br><span class="line">            .setDuration(<span class="number">2000L</span>)</span><br><span class="line">            .setInterpolator &#123;</span><br><span class="line">                <span class="keyword">if</span> (Config.heavyAnimate) &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(Config.heavyAnimateDelay)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@setInterpolator</span> it</span><br><span class="line">            &#125;</span><br><span class="line">            .setListener(<span class="keyword">object</span> : AnimatorListenerAdapter() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationEnd</span><span class="params">(animation: <span class="type">Animator</span>?)</span></span> &#123;</span><br><span class="line">                    <span class="keyword">super</span>.onAnimationEnd(animation)</span><br><span class="line">                    textView.x = <span class="number">0f</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;).start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="anim.png" width="40%" height="40%"></p><h2 id="Input-和-Misc"><a href="#Input-和-Misc" class="headerlink" title="Input 和 Misc"></a>Input 和 Misc</h2><p>前面提到在我的华为手机上只有 7 种颜色，貌似是 Input 和 Misc 都统计到同一种颜色中，而不同于官方给出的不同颜色。这似乎也说得通</p><p><img src="bug.png" alt></p><p>因为无论是 Input 还是 Misc ，本质都是在主线程中执行了过多的工作，无非就是 Input 阶段特指 “input event callback”。</p><p>Input 对应的颜色升高其实很常见。一个典型的场景就是点击一个按钮启动另一个 Activity。无论被启动的 Activity 是谁，启动的那一瞬间都会一个明显升高的绿色区域。这个无法避免。</p><p><img src="start-activity.png" width="40%" height="40%"></p><p>很容易模拟 Input 耗时多的场景：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clickMe.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">if</span> (Config.heavyInput) &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(Config.heavyInputDelay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="input.png" width="40%" height="40%"></p><h1 id="Upload"><a href="#Upload" class="headerlink" title="Upload"></a>Upload</h1><blockquote><p>the CPU and the GPU have different RAM areas dedicated to processing. When you draw a bitmap on Android, the system transfers the bitmap to GPU memory before the GPU can render it to the screen. Then, the GPU caches the bitmap so that the system doesn’t need to transfer the data again unless the texture gets evicted from the GPU texture cache.</p></blockquote><p>根据文档知道，只要不停地绘制 Bitmap 就可以让 Sync/Upload 阶段升高。不过为了让升高得更明显：</p><ul><li>Bitmap 要大一点</li><li>Bitmap 要有变化(防止 GPU 缓存)</li></ul><p>代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_heavy_upload)</span><br><span class="line"></span><br><span class="line">    clickMe.setOnClickListener &#123;</span><br><span class="line">        image.setImageBitmap(createRandomBitmap())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createRandomBitmap</span><span class="params">()</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">return</span> Bitmap.createBitmap(<span class="number">2000</span>, <span class="number">2000</span>, Bitmap.Config.ARGB_8888).apply &#123;</span><br><span class="line">        <span class="keyword">val</span> canvas = Canvas(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> rand = Random()</span><br><span class="line">        canvas.drawColor(Color.rgb(rand.nextInt(<span class="number">256</span>), rand.nextInt(<span class="number">256</span>), rand.nextInt(<span class="number">256</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="upload.png" width="40%" height="40%"></p><h1 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h1><blockquote><p>For the system to draw display lists to the screen, it sends the necessary commands to the GPU. Typically, it performs this action through the OpenGL ES API.</p></blockquote><blockquote><p>This process takes some time, as the system performs final transformation and clipping for each command before sending the command to the GPU. Additional overhead then arises on the GPU side, which computes the final commands. These commands include final transformations, and additional clipping.</p></blockquote><p>一帧中系统需要渲染的 display list 的复杂性以及数量决定了 Issue 阶段的耗时。<a href="https://developer.android.com/topic/performance/rendering/profile-gpu#psb" target="_blank" rel="noopener">文档</a>给出了让 Issue 阶段耗时变多的一个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">1000</span>) &#123;</span><br><span class="line">    canvas.drawPoint()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上的代码性能低下</span></span><br><span class="line"><span class="comment">// 更好的写法是这样</span></span><br><span class="line"><span class="comment">// canvas.drawPoints(mThousandPointArray)</span></span><br></pre></td></tr></table></figure><p>封装成 <code>HeavyIssueView</code>，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeavyIssueView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(context: Context,</span><br><span class="line">                                               attributes: AttributeSet? = <span class="literal">null</span>, defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span>)</span><br><span class="line">    : View(context, attributes, defStyleAttr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> p = Paint().apply &#123;</span><br><span class="line">        color = ContextCompat.getColor(context, R.color.color1)</span><br><span class="line">        strokeWidth = <span class="number">4f</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> arr = FloatArray(<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> rand = Random()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Config.heavyIssue) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">1000</span>) &#123;</span><br><span class="line">                canvas?.drawPoint(rand.nextInt(width).toFloat(), rand.nextInt(height).toFloat(), p)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">1000</span> step <span class="number">2</span>) &#123;</span><br><span class="line">                arr[i] = rand.nextInt(width).toFloat()</span><br><span class="line">                arr[i + <span class="number">1</span>] = rand.nextInt(height).toFloat()</span><br><span class="line">            &#125;</span><br><span class="line">            canvas?.drawPoints(arr, p)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="issue.png" width="40%" height="40%"></p><h1 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h1><blockquote><p>The GPU executes work in parallel with the CPU. The Android system issues draw commands to the GPU, and then moves on to the next task. The GPU reads those draw commands from a queue and processes them.</p></blockquote><blockquote><p>In situations where the CPU issues commands faster than the GPU consumes them, the communications queue between the processors can become full. When this occurs, the CPU blocks, and waits until there is space in the queue to place the next command. This full-queue state arises often during the Swap Buffers stage, because at that point, a whole frame’s worth of commands have been submitted.</p></blockquote><p>不知如何让这个阶段升高。待补充</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上 demo 演示了不同的代码是如何让渲染过程中出现不同的性能瓶颈的，可以为实际项目中分析 UI 性能问题提供指导。</p><ul><li>渲染中的每一阶段并不是完全独立的。比如，绘制大图，可能引起 Upload 和 Issue 两个阶段均出现瓶颈</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何制作 Anki 卡片</title>
      <link href="2019/01/17/make-anki-card/"/>
      <url>2019/01/17/make-anki-card/</url>
      
        <content type="html"><![CDATA[<p>记录如何制作 Anki 卡片来教幼儿认字。<br><a id="more"></a><br>皮皮3岁4个月，上幼儿园小班，最近特别喜欢认汉字。</p><p>于是在京东上买了很多纸质的卡片回来写上一些他感兴趣的字。他乐此不疲，一百张卡片很快就写玩了。</p><p>纸质卡片有几个问题：</p><ul><li>一百张就很大一摞，屋子里丢得到处都是</li><li>太单调，没图没声音</li><li>有些字认得快，有些认得慢，不好控制每个卡片出现的频率</li></ul><p>所以尝试制作 Anki 卡片。这是卡片效果。</p><p><img src="1.jpeg" width="40%" height="40%"></p><p>具体怎么操作呢？</p><h1 id="制作卡片"><a href="#制作卡片" class="headerlink" title="制作卡片"></a>制作卡片</h1><p>制作 Anki 卡片用到这几个工具：</p><ul><li>Anki - Anki 是一个记忆软件，支持 PC/Mac/Android/iOS，除 iOS 版本收费外其他均免费</li><li><a href="https://github.com/google/guetzli" target="_blank" rel="noopener">guetzli</a> - 用于图片压缩</li><li>Google 照片扫描仪 - 扫描书本上的图片</li><li>腾讯文档 - 用作图床</li><li>百度tts接口 - 用作文本转换语音 </li></ul><p>制作 Anki 卡片的步骤如下：</p><ol><li>首先找到感兴趣的字或单词</li><li>找到字或单词对应的图片<ul><li>如果图片是书上的，使用 Google 照片扫描仪扫描到手机，然后拷贝到电脑</li><li>如果图片是网络上的，直接下载到电脑本地</li></ul></li><li>通过百度tts接口将字或单词转换到语音文件，下载到电脑本地</li><li>打开 Anki，选择 <code>Basic</code> 类型的卡片</li><li>输出字或单词，以及对应的图片和语音文件</li></ol><p>搞定！现在拿出手机或电脑就可以看 Anki 卡片了。</p><p><img src="2.jpeg" width="40%" height="40%"></p><p>图中是一张制作完成的卡片，从上到下依次是：</p><ul><li>单词 - 尽量选一些感兴趣或是简单的</li><li>图片 - 跟单词相关的卡通图片</li><li>语音 - 单词发音</li><li>难度 - 对于已经记住的，直接点简单；记不住的，点重来</li></ul><p>Anki 卡片的优点是：</p><ul><li>记忆内容可量身定制，汉字、单词、图片、电话号码、公交线路…，只要他感兴趣即可，兴趣比什么都重要</li><li>一部手机就可以看卡片了，而且多终端同步。担心影响视力的话可以电脑或手机投屏到电视机</li><li>Anki 会帮你控制卡片出现频率，认得慢的可以多记</li><li>有图片，有语音</li></ul><p>它的缺点是：</p><ul><li>制作一张好的卡片还是很费时间的</li><li>Anki 的界面很丑</li><li>小孩子对手机或电脑的兴趣有时大过卡片本身，容易分心</li></ul><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>当然，使用过程中遇到一些问题。这里总结了一下解决方法。</p><h2 id="卡片同步"><a href="#卡片同步" class="headerlink" title="卡片同步"></a>卡片同步</h2><p>官方的同步服务器速度比较慢，你可以<a href="https://github.com/410063005/10years/blob/master/tools.md#anki" target="_blank" rel="noopener">自己搭建 Anki 服务器</a>加快同步速度。整个过程比较折腾，慎重。</p><p>注意，iOS 版本的 Anki 不能配置自己的 Anki 服务器。( 价格 100 多元，我买来发现不能配置立马后悔，不过就当对 Anki 的支持吧)</p><h2 id="卡片太大"><a href="#卡片太大" class="headerlink" title="卡片太大"></a>卡片太大</h2><p>制作卡片时直接将图片文件拷贝到卡片中很省事，但这样做会导致卡片太大，各终端之间同步卡片速度很慢。</p><p>一个方法是使用 guetzli 对图片进行压缩。不过我在 win 10 上 guetzli 压缩速度极慢。</p><p>一个终极解决方法是先将图片上传到腾讯文档(随便建一个 word 文件，然后上传图片到这个文件)，从文档中拷贝出图片地址。制作卡片时不要直接拷贝图片而是通过 html 代码引用图片地址：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">http://image.url</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(将图片先压缩再上传到腾讯文档可能效果更好，一是保证卡片小易同步，二是使用卡片时图片加载速度快)</p><h2 id="拍照"><a href="#拍照" class="headerlink" title="拍照"></a>拍照</h2><p>有些图片来自幼儿书，直接对着书拍照效果通常不好，所以还是使用 Google 照片扫描仪吧。自从用上这个工具，即便你手抖眼歪，也能扫出方方正正的照片。</p><h2 id="语音"><a href="#语音" class="headerlink" title="语音"></a>语音</h2><p>百度查单词后可以发音，其原理是使用通过后台接口生成一个 <code>tts.mp3</code> 文件。Chrome 浏览器中很容易找到这个文件并下载下来。</p><p>我写了一个批量转语音的 Python 脚本，见<a href="https://gist.github.com/410063005/7f464d8ca3300c7af43bfbb5af301323" target="_blank" rel="noopener">这里</a></p><hr><h1 id="Anki-使用技巧"><a href="#Anki-使用技巧" class="headerlink" title="Anki 使用技巧"></a>Anki 使用技巧</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/24194695" target="_blank" rel="noopener">Monokai程序员风格之随机选择题模板</a> - 这个模板不错，可以用来在 Anki 中添加选择题</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于空指针的一点思考</title>
      <link href="2019/01/17/just-talk/"/>
      <url>2019/01/17/just-talk/</url>
      
        <content type="html"><![CDATA[<p>关于一个空指针问题的思考。纯属个人观点，如有雷同，绝对不是抄袭。<br><a id="more"></a></p><h1 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h1><p>Java 空指针很好，它省内存。Java 空指针也很让人恼火，它是 Android 应用 crash 的最主要原因。另一个 crash 的主要原因可能是数组越界。</p><p>看着 crash 率上涨，我们恨不得将空指针和数组越界从地球上抹去。Java 不是号称比 C/C++ 更安全吗。但从 crash 的角度来看，Java 似乎并没有更安全啊！</p><p>对此我的理解是，Java 的所谓的更安全，其含义在于这空指针和数组越界是程序错误，是程序员必须去修复的程序错误！既然错了，那停止运行就是最正确的策略。而不是像 C/C++ 一样，空指针和数组越界，程序可能是停止运行，也可能是继续莫名奇妙地继续运行。</p><p>你分析为什么 C/C++ 程序为什么莫名其妙地运行，耗时耗力，到最后却发现是空指针(野指针)或者数组越界。你会真心觉得 Java 遇到空指针和数组越界后让程序直接停止运行是更为明智的做法！</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p><code>loadImage()</code> 是我们 Android 项目中加载图片的工具方法。分别是修改前和修改后的代码。</p><p>修改前：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadImage</span><span class="params">(Context context, String url, <span class="keyword">int</span> placeholder, ImageView imageView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Glide.with(context)....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改后：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadImage</span><span class="params">(@NonNull Context context, String url, <span class="keyword">int</span> placeholder, ImageView imageView)</span> </span>&#123;</span><br><span class="line">    Glide.with(context)....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>坏消息的是修改后的代码引起 crash 率明显上涨，好消息是这些 crash 集中在同一处代码。这是否说明修改后的代码不如修改前的呢？单从 crash 率来看，修改后的确不如修改后安全。</p><p>修改前的代码有对 context 判空，不会 crash，看似非常安全。我们思考一下它有什么问题呢。</p><p>第一，为什么会出现传空 context 呢？</p><p>我们知道，遵循良好习惯编写 Android 代码时并不容易出现空 context 的情形。以下是一些最佳实践：</p><ul><li>尽量减少 Context 的使用范围</li><li>选择合理生命周期的 Context</li><li>尽量将 Context 字段定义成 final</li><li>尽量不要将 Context 作为 static 字段</li></ul><p>当然不能否认 Android SDK 也确实有少量坑，比如在没有跟 Activity 关联的 Fragent 中调用 <code>getContext()</code> 时会返回 null。但对于 Fragment 这一情形，我们应该选择调用 <code>loadImage(fragment)</code> 而不是 <code>loadImage(fragment.getContext())</code>。</p><p>第二，万一传了空 context 呢？</p><p>很显然这时并不会加载图片。不加载图片且没有任何日志，这是最糟糕的情形！这其实跟 C/C++ 中空指针/野指针导致程序莫名其妙运行没有本质的区别。</p><p>用户不清楚发生了什么，只会反馈 app 中有个地方看不到图片。开发就惨了，<strong>这个问题不好复现，也不容易跟踪</strong>。</p><p>一些思考：</p><p>从修改后的代码比修改前的代码 crash 率高这一点来看，我们的代码中有一些地方传入的空的 context。空 context 本身并不可怕。可怕的是，我们并不确定是什么时候以及在哪里传入的。引起的问题轻则导致不加载图片，重则导致各种诡异事件。比起诡异，我更喜欢看似严重但更为直观明了的 crash，因为 crash 揭露了问题的本质！</p><p>当然以上说得过于理想，现实是 crash 率也是一个重要质量指标。折衷的做法可能是 <code>loadImage()</code> 对 context 判空并添加一些上报日志的机制，既不 crash 也能找到问题根源。</p><h1 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h1><p>我们经常有这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String myName = ...</span><br><span class="line">        <span class="keyword">if</span> (myName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码中 <code>foo()</code> 很安全，因为它一定不会 crash。</p><p>但它也很丑陋，<code>bar()</code> 和 <code>foo()</code> 两处都有判空。问题的表面现象是 <code>foo()</code> 明显不信任 <code>bar()</code>，担心它传入一个 <code>null</code>。而问题的实质是 </p><ul><li><strong>你不信任你自己，或者是不信任你的队友</strong></li><li>或者是，<strong>你跟自己或你的队友没有达到明确、一致的约定</strong></li></ul><p>你担心代码中有不确定性。你在 <code>boo()</code> 和 <code>far()</code>  能否处理 <code>null</code> 参数以及谁该处理 <code>null</code> 这些问题上的答案是模糊的。</p><p>为些我们不得不背上很重的负担。</p><ul><li>每次调用 <code>far()</code> 前是不是要判断是下参数呢？</li><li>如果有的地方判断了，有的地方没判断，谁对谁错？</li></ul><p>(这就好比你有好几块表，有的是11点，有的是12点，你会糊涂么？)</p><p>当然你也可以所有地方加判空，不去进行任何思考，让负担从大脑转移到双手。</p><p>Guava 库中有一篇 wiki <a href="https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained" target="_blank" rel="noopener">UsingAndAvoidingNullExplained · google/guava Wiki</a>是专门讨论 Java 中 null 问题的，很值得一看。Guava 中也专门提供 <a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Optional.html" target="_blank" rel="noopener">Optional</a> 工具类用于处理 null 问题。</p><p>可以做一个非常简单的约定：</p><ul><li>公开方法(public)，不允许 null 参数</li><li>私有方法(private)，允许 null 参数</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>largeHeap属性的作用</title>
      <link href="2019/01/14/android-large-heap/"/>
      <url>2019/01/14/android-large-heap/</url>
      
        <content type="html"><![CDATA[<p>本文简单聊聊 Android 中经常用到的 largeHeap 属性。<br><a id="more"></a><br>我的习惯，先看<a href="https://developer.android.com/guide/topics/manifest/application-element" target="_blank" rel="noopener">官方文档</a>。</p><blockquote><p>Whether your application’s processes should be created with a large Dalvik heap. This applies to all processes created for the application. It only applies to the first application loaded into a process; if you’re using a shared user ID to allow multiple applications to use a process, they all must use this option consistently or they will have unpredictable results.<br>Most apps should not need this and should instead focus on reducing their overall memory usage for improved performance. Enabling this also does not guarantee a fixed increase in available memory, because some devices are constrained by their total available memory.</p></blockquote><p>简单来说，有两点：</p><ul><li>这是用于控制当前应用进程是否可以创建一个更大的 Dalvik heap 的开关。</li><li>大部分应用不应该使用这个开关，而是关注如何减少自身内存占用以提升性能。</li></ul><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在 adb shell 中使用如下命令可以找到 <code>heapgrowthlimit</code> 和 <code>heapsize</code>。另外，你可能还对 <code>heapstartsize</code> 感兴趣。</p><p>这是在我的华为 Nova 手机上的测试结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HWANE:/ $ getprop | grep vm.heap                                                                                                                      </span><br><span class="line">[dalvik.vm.heapgrowthlimit]: [384m] // 受控情况下的极限堆，即 largeHeap=false</span><br><span class="line">[dalvik.vm.heapmaxfree]: [8m]</span><br><span class="line">[dalvik.vm.heapminfree]: [4m]</span><br><span class="line">[dalvik.vm.heapsize]: [512m] // 不受控情况下的极限堆大小，即 largeHeap=true</span><br><span class="line">[dalvik.vm.heapstartsize]: [8m] // 堆分配的初始大小</span><br><span class="line">[dalvik.vm.heaptargetutilization]: [0.75]</span><br></pre></td></tr></table></figure><p>如果你是 root 手机，也可以在 <code>system/build.prop</code> 中找到这几个属性值。</p><p><a href="https://blog.csdn.net/cqupt_chen/article/details/11068129" target="_blank" rel="noopener">android dalvik heap 浅析</a>一文中对这几个参数有很形象的比喻：</p><blockquote><p>分配dalvik heap就好像去食堂打饭，有人饭量大，要吃三碗，有人饭量小，连一碗都吃不完。如果食堂按照三碗的标准来给每个人打饭，那绝对是铺张浪费，所以食堂的策略就是先打一碗，凑合吃，不够了自己再来加，设定堆大小也是一样，先给一个合理值，凑合用，自己不够了再跟系统要。食堂毕竟是做买卖的，如果很多人明显吃不了那么多，硬是一碗接着一碗。为了制止这种不合理的现象，食堂又定了一个策略，一般人就只能吃三碗。但是如果虎背熊腰的大汉确实有需要，可以吃上五碗，超过五碗就不给了（太亏本了）</p></blockquote><ul><li>dalvik.vm.heapstartsize - 一开始每人能打几碗饭。不妨为1</li><li>dalvik.vm.heapgrowthlimit - 一般人最多吃几碗饭。假定为3</li><li>dalvik.vm.heapsize - 虎背熊腰的大汉最多能吃五碗。假定为5</li></ul><p>(可想而知，无论需不需要，中国的 app 通常上来就是5碗)</p><!--数据?--><p><code>PackagePaser.parseApplication()</code> 方法解析 APK 文件。如果解析到 largeHeap=true 会在 applicationInfo 中添加 FLAG_LARGE_HEAP 标签。相关逻辑最终会进入到 <a href="https://android.googlesource.com/platform/dalvik/+/kitkat-release/vm/alloc/HeapSource.cpp#1201" target="_blank" rel="noopener">HeapSource.dvmClearGrowthLimit()</a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Removes any growth limits.  Allows the user to allocate up to the</span></span><br><span class="line"><span class="comment"> * maximum heap size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dvmClearGrowthLimit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    dvmWaitForConcurrentGcToComplete();</span><br><span class="line">    gHs-&gt;growthLimit = gHs-&gt;maximumSize;</span><br><span class="line">    ...</span><br><span class="line">    dvmUnlockHeap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释说明代码的作用是允许用户应用分配最大的堆内存，也即从 largeHeap=false 调整成 largeHeap=true 的状态。</p><ul><li>largeHeap=false 时，用户应用允许分配的最大堆内存为 <code>dalvik.vm.heapgrowthlimit</code> 指定的值</li><li>largeHeap=true 时，用户应用允许分配的最大堆内存为 <code>dalvik.vm.heapsize</code> 指定的值</li></ul><p>具体的内存分配过程可以看<a href="https://android.googlesource.com/platform/dalvik.git/+/android-4.3_r3/vm/alloc/Heap.cpp#183" target="_blank" rel="noopener">Heap.cpp 源码</a>。</p><p>另外，<a href="https://developer.android.com/reference/android/app/ActivityManager.html#getMemoryClass(" target="_blank" rel="noopener">getMemoryClass()</a>) 和 <a href="https://developer.android.com/reference/android/app/ActivityManager.html#getLargeMemoryClass(" target="_blank" rel="noopener">getLargeMemoryClass()</a>) 分别用于获取 heap 和 largeHeap (单位均为字节)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMemoryClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> staticGetMemoryClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">staticGetMemoryClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Really brain dead right now -- just take this from the configured</span></span><br><span class="line">    <span class="comment">// vm heap size, and assume it is in megabytes and thus ends with "m".</span></span><br><span class="line">    String vmHeapSize = SystemProperties.get(<span class="string">"dalvik.vm.heapgrowthlimit"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (vmHeapSize != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(vmHeapSize)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(vmHeapSize.substring(<span class="number">0</span>, vmHeapSize.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> staticGetLargeMemoryClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLargeMemoryClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> staticGetLargeMemoryClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">staticGetLargeMemoryClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Really brain dead right now -- just take this from the configured</span></span><br><span class="line">    <span class="comment">// vm heap size, and assume it is in megabytes and thus ends with "m".</span></span><br><span class="line">    String vmHeapSize = SystemProperties.get(<span class="string">"dalvik.vm.heapsize"</span>, <span class="string">"16m"</span>);</span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(vmHeapSize.substring(<span class="number">0</span>, vmHeapSize.length() - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里附带提一下另外几个常用的内存值：</p><ul><li><code>ActivityManager.getMemoryClass()</code> - 正常的 heap 大小上限值</li><li><code>ActivityManager.getLargeMemoryClass()</code> - 较大的 heap 大小上限值</li><li><code>Runtime.totalMemory()</code> - 当前 VM 的 heap 大小</li><li><code>Runtime.maxMemory()</code> - 当前 VM 的 heap 上限值，即 <code>getMemoryClass()</code> 或 <code>getLargeMemoryClass()</code> 的返回值</li><li><code>Runtime.freeMemory()</code> - 当前 VM 的 heap 中可用内存大小</li><li><code>MemoryInfo.availMem</code> - 系统可用内存大小</li><li><code>MemoryInfo.lowMemory</code> - 系统是否处于低内存状态</li><li><code>MemoryInfo.threshold</code> - 系统 availMem 低于这个值时认为处理 lowMemory 状态</li><li><code>MemoryInfo.totalMem</code> - 系统总内存大小</li></ul><p><a href="https://juejin.im/entry/59f7ea06f265da43143ffee4" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exoplayer 介绍</title>
      <link href="2019/01/14/exoplayer-usage/"/>
      <url>2019/01/14/exoplayer-usage/</url>
      
        <content type="html"><![CDATA[<p>本文记录了一些关于 ExoPlayer 库的一些入门知识。<br><a id="more"></a></p><p>我们的 Android 项目中可能要使用到视频播放功能。于是提前进行预研，在此记录。</p><ul><li><code>WebView</code> - 性能较差，用于H5页面的视频尚能接受，但作为原生播放组件体验差</li><li><code>VideoView</code> - 性能尚可，但它无缓存，无缓冲动画。要自行实现这些功能有较大工作量</li></ul><p>官方推荐使用 <a href="https://github.com/google/ExoPlayer/" target="_blank" rel="noopener">ExoPlayer</a> 库用于音视频播放。</p><h1 id="ExoPlayer"><a href="#ExoPlayer" class="headerlink" title="ExoPlayer"></a>ExoPlayer</h1><p>ExoPlayer 提供目前 MediaPlayer API 接口不支持的功能，例如 DASH 和 SmoothStreaming 自适应播放。相比 MediaPlayer，ExoPlayer 易于自定义扩展。</p><h2 id="库概览"><a href="#库概览" class="headerlink" title="库概览"></a>库概览</h2><p>整个 ExoPlayer 库的核心是 <code>ExoPlayer</code> 接口。一个 <code>ExoPlayer</code> 实例对外暴露传统上常见的高级媒体播放器功能，比如媒体缓冲、播放、暂停及seek。<code>ExoPlayer</code> 的实现被设计成对媒体类型，如何存储，在哪里存储，如何渲染等问题有很少的假定和限制。<code>ExoPlayer</code> 并不是直接实现媒体加载和渲染功能，而是将这些工作代理给专门的组件。这些组件在播放器被创建时或准备播放时被注入进来。<code>ExoPlayer</code> 的常用组件包括：</p><ul><li><code>MediaSource</code> - 用于定义将被播放的媒体，用于加载媒体，用于指定可以从哪里读取媒体。在开始播放媒体时通过 <code>ExoPlayer.prepare()</code> 方法将 <code>MediaSource</code> 注入进来</li><li><code>Renderers</code> - 用于渲染 media 中的单个组件。创建 player 时注入进来</li><li><code>TrackSelector</code> - 用于选择 <code>MediaSource</code> 中的 tracks 给每个可用的 <code>Renderer</code> 来消费。创建 player 时注入进来</li><li><code>LoadControl</code> - 用于控制 <code>MediaSource</code> 何时缓冲更多媒体数据，以及如何缓冲。创建 player 时注入进来</li></ul><p>ExoPlayer 提供了各种缺省的实现。如果仍然不能满足使用需求，也可以进行自定义。比如，自定义 <code>LoadControl</code> 来修改 player 的缓冲策略。或者自定义 <code>Renderer</code> 来使用 Android 并不能原生支持的视频解码器。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>ExoPlayer 对比 Android MediaPlayer API 的优缺点：</p><ul><li>DASH(Dynamic Adaptive Streaming over HTTP) 和 SmoothStreaming 支持</li><li><a href="https://google.github.io/ExoPlayer/supported-formats.html" target="_blank" rel="noopener">支持更多的媒体格式</a></li><li>设备和 Android 版本兼容性更好</li><li>自定义和扩展能力更好</li><li>使用官方扩展跟第三方库交互的能力更好</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>简单介绍 ExoPlayer 的用法。先保证在 <code>build.gradle</code> 中包含 Google 和 JCenter 库：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    google()</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>build.gradle</code> 中添加依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.google.android.exoplayer:exoplayer:2.9.0'</span></span><br></pre></td></tr></table></figure><p>另外注意 ExoPlayer 使用 Java 8 编译，所以你的 app 也必须使用 Java 8 编译。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compileOptions &#123;</span><br><span class="line">    targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以按需要添加对特定 ExoPlayer API 的依赖，而不是整个 ExoPlayer 库。比如，只依赖 Core，DASH 和 UI：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.google.android.exoplayer:exoplayer-core:2.X.X'</span></span><br><span class="line">implementation <span class="string">'com.google.android.exoplayer:exoplayer-dash:2.X.X'</span></span><br><span class="line">implementation <span class="string">'com.google.android.exoplayer:exoplayer-ui:2.X.X'</span></span><br></pre></td></tr></table></figure><p>ExoPlayer 可用的模块如下：</p><ul><li><code>exoplayer-core</code> - 核心功能(必须)</li><li><code>exoplayer-dash</code> - 支持 DASH</li><li><code>exoplayer-hls</code> - 支持 HLS</li><li><code>exoplayer-smoothstreaming</code> - 支持 SmoothStreaming</li><li><code>exoplayer-ui</code> - 提供 ExoPlayer 使用的 UI 组件及资源</li></ul><p>除了以上库模块，ExoPlayer 还提供若干依赖外部库的扩展模块用于额外功能。具体见<a href="https://github.com/google/ExoPlayer/tree/release-v2/extensions/" target="_blank" rel="noopener">扩展库列表</a>。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>对于简单场景，按照以下几个步骤使用 <code>ExoPlayer</code>：</p><ul><li>添加 <code>ExoPlayer</code> 依赖</li><li>创建 <code>SimpleExoPlayer</code> 实例</li><li>将 player 跟 view 关联(用于视频输出和用户输入)</li><li>使用完毕后释放 player</li></ul><h3 id="创建-ExoPlayer"><a href="#创建-ExoPlayer" class="headerlink" title="创建 ExoPlayer"></a>创建 ExoPlayer</h3><ul><li>使用 <code>ExoPlayerFactory</code> 创建 <code>SimpleExoPlayer</code></li><li><code>ExoPlayerFactory</code> 中有不同的方法用于创建 <code>SimpleExoPlayer</code></li><li>最常用的创建方法是 <code>ExoPlayerFactory.newSimpleInstance</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimpleExoPlayer player = ExoPlayerFactory.newSimpleInstance(context);</span><br></pre></td></tr></table></figure><p>关于线程安全问题：</p><ul><li>必须从同一个线程来访问 <code>ExoPlayer</code> 实例(通常来说就是主线程)</li><li>访问 <code>ExoPlayer</code> 的线程必须要有 <code>Looper</code></li></ul><h3 id="关联-view"><a href="#关联-view" class="headerlink" title="关联 view"></a>关联 view</h3><p>ExoPlayer 库提供 <code>PlayerView</code>，它封装了 <code>PlayerControlView</code> 和用于渲染 video 的 <code>Surface</code>。可以在布局中使用 <code>PlayerView</code>，然后像下面这样进行绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bind the player to the view.</span></span><br><span class="line">playerView.setPlayer(player);</span><br></pre></td></tr></table></figure><p><code>SimpleExoPlayer</code> 提供接口用于设置自定义的组件以便更精细地控制 player controls 以及 <code>Surface</code>。</p><ul><li><code>setVideoSurfaceView</code></li><li><code>setVideoTextureView</code></li><li><code>setVideoSurfaceHolder</code></li><li><code>setVideoSurface</code></li></ul><h3 id="准备播放"><a href="#准备播放" class="headerlink" title="准备播放"></a>准备播放</h3><p>ExoPlayer 库中 每个媒体片断由 <code>MediaSource</code> 表示。首先创建媒体片断 <code>MediaSource</code>，然后将其传给 <code>ExoPlayer.prepare()</code> 方法。ExoPlayer 库提供不同的 <code>MediaSource</code> 实现：</p><ul><li><code>DashMediaSource</code> - DASH</li><li><code>SsMediaSource</code> - SmoothStreaming    </li><li><code>HlsMediaSource</code> - HLS</li><li><code>ExtractorMediaSource</code> - regular media files</li></ul><p>这段代码用于播放 MP4 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Produces DataSource instances through which media data is loaded.</span></span><br><span class="line">DataSource.Factory dataSourceFactory = <span class="keyword">new</span> DefaultDataSourceFactory(context,</span><br><span class="line">    Util.getUserAgent(context, <span class="string">"yourApplicationName"</span>));</span><br><span class="line"><span class="comment">// This is the MediaSource representing the media to be played.</span></span><br><span class="line">MediaSource videoSource = <span class="keyword">new</span> ExtractorMediaSource.Factory(dataSourceFactory)</span><br><span class="line">    .createMediaSource(mp4VideoUri);</span><br><span class="line"><span class="comment">// Prepare the player with the source.</span></span><br><span class="line">player.prepare(videoSource);</span><br></pre></td></tr></table></figure><h3 id="播放控制"><a href="#播放控制" class="headerlink" title="播放控制"></a>播放控制</h3><p>有两种途径进行播放控制：</p><ul><li>直接调用 player 相应的方法。例如：<ul><li><code>setPlayWhenReady</code> - 播放或暂停</li><li><code>seekTo</code> - seek</li><li><code>setRepeatMode</code> - 控制是否循环以及如何循环</li><li><code>setShuffleModeEnabled</code> - 控制是否乱序播放</li><li><code>setPlaybackParameters</code> - 调整播放速度</li></ul></li><li>player 绑定到 view 的情况下，用户操作也会导致调用 player 相应的方法</li></ul><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>使用 <code>Player.EventListener</code> 监听播放状态及可能出现的错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add a listener to receive events from the player.</span></span><br><span class="line"><span class="comment">// 有时使用 Player.DefaultEventListener 更方便</span></span><br><span class="line">player.addListener(eventListener);</span><br></pre></td></tr></table></figure><p><code>SimpleExoPlayer</code> 还提供一些额外的监听器：</p><ul><li><code>addVideoListener</code> - 监听视频渲染相关事件，可以用于调整 UI</li><li><code>addAnalyticsListener</code> - 监听详细事件，可以用于问题诊断分析</li></ul><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>使用 <code>ExoPlayer.release</code> 释放资源。</p><h1 id="ExoPlayer-demo"><a href="#ExoPlayer-demo" class="headerlink" title="ExoPlayer demo"></a>ExoPlayer demo</h1><p><a href="https://google.github.io/ExoPlayer/demo-application.html" target="_blank" rel="noopener">demo</a>展示了 ExoPlayer 的基本用法。</p><p>从 <a href="git clone https://github.com/google/ExoPlayer.git">github</a> 下载代码后导入 Android Studio 编译成功后如下图所示。</p><p><img src="https://google.github.io/ExoPlayer/images/demo-app-project.png" alt></p><p><a href="https://google.github.io/ExoPlayer/faqs.html#does-exoplayer-support-emulators" target="_blank" rel="noopener">demo 可能在模拟器上无法运行</a>。我在 Genemotion 上的现象是卡在播放状态，不报错也不 crash，原因是某些模拟器并没有正确地实现 Android media stack。不过官方模拟器是支持 ExoPlayer 的(SDK level 23及以上)。</p><p>建议在真机上运行 demo。</p><p>demo 最终都是通过 <code>PlayerActivity</code> 来播放视频。使用如下命令在 logcat 中查看日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat EventLogger:V *:E</span><br></pre></td></tr></table></figure><p>可以调整 demo 的 build variants 为 <code>withExtensions</code> 以使用各种<a href="https://github.com/google/ExoPlayer/tree/release-v2/extensions/" target="_blank" rel="noopener">扩展库</a>。</p><p><img src="https://google.github.io/ExoPlayer/images/demo-app-build-variants.png" alt></p><p>编辑 <code>assets/media.exolist.json</code> 文件可以向 demo 中添加自己的视频 sample。</p><p>关于代码混淆问题：不用特殊配置，直接混淆即可。</p><h1 id="ExoPlayer-tutorial"><a href="#ExoPlayer-tutorial" class="headerlink" title="ExoPlayer tutorial"></a>ExoPlayer tutorial</h1><p><a href="https://codelabs.developers.google.com/codelabs/exoplayer-intro/#0" target="_blank" rel="noopener">这里</a>提供了不错的入门指导。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Analyze with Profile GPU Rendering</title>
      <link href="2019/01/11/profile-gpu/"/>
      <url>2019/01/11/profile-gpu/</url>
      
        <content type="html"><![CDATA[<p>翻译自<a href="https://developer.android.com/topic/performance/rendering/profile-gpu#psb" target="_blank" rel="noopener">Analyze with Profile GPU Rendering</a><br><a id="more"></a></p><hr><p>疑问：</p><ul><li>Unlike Issue Commands, which captures the time it takes to send drawing commands to the GPU, the Draw metric represents the time that it took to capture the issued commands into the display list.</li></ul><h2 id="如何理解这一句？"><a href="#如何理解这一句？" class="headerlink" title="如何理解这一句？"></a>如何理解这一句？</h2><p>Profile GPU Rendering tool 表示渲染前一帧时每个阶段消耗的相对时间。可以使用这个相对时间用于定位渲染流水线中的性能瓶颈，并用于优化app渲染性能。</p><p>本文简单介绍每个流水线阶段发生了什么，并且讨论了可能引起性能瓶颈的问题。读本文前，你应该先熟悉<a href="https://developer.android.com/studio/profile/inspect-gpu-rendering.html#profile_rendering" target="_blank" rel="noopener">Profile GPU rendering</a>中的内容。另外，想想从整体上了解每个阶段是如何工作的也可以参考<a href="https://www.youtube.com/watch?v=we6poP0kw6E&amp;index=64&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="noopener">how the rendering pipeline works.</a>。</p><p>Profile GPU Rendering tool 在图表中展示每个阶段和它们的相对时间：彩色直方图。</p><p>图中每个直条表示流水线中的一个阶段，每个阶段使用特定的颜色高亮。</p><p>一旦你理解每种颜色的含义，就可以针对app中特定目标进行渲染性能优化。</p><h1 id="不同阶段及含义"><a href="#不同阶段及含义" class="headerlink" title="不同阶段及含义"></a>不同阶段及含义</h1><h2 id="Input-handling"><a href="#Input-handling" class="headerlink" title="Input handling"></a>Input handling</h2><p>input handling 阶段用于测量 app 花了多久时间处理 input events。这个值表示 app 花了多少时间用于执行 input event 回调中的代码。</p><p>当这个阶段的时间变多时，通常是因为在 input-handler event 回调中执行太多或太复杂的工作。而这些回调一般总是在主线程中，所以解决方法是优化代码本身，或将代码移到工作线程。</p><p>另外要注意的是，RecyclerView 的滚动也是发生在这个阶段。RecyclerView 消耗 touch event 时会马上滚动。而滚动后，RecyclerView 会 inflate 或 populate 新的 item views。所以，inflate 或 populate 操作要尽可能快。Traceview 或 Systrace 可以用于更深入的分析。</p><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><p>动画阶段表示你在这一帧中使用 animator 花了多少时间。常用的 animator 包括：ObjectAnimator，ViewPropertyAnimator 和 Transitions。</p><p>当这个阶段的时间变多时，通常是因为动画一些属性变化引起某些工作的结果。比如，在滚动 ListView 或 RecyclerView 时 fling 动画会导致大量的 inflate 或 populate 操作。</p><h2 id="Measurement-layout"><a href="#Measurement-layout" class="headerlink" title="Measurement/layout"></a>Measurement/layout</h2><p>Android 将 view 绘制到屏幕上时，会在 view hierarchy 中的 layout 和 view 上执行两个特定的操作。</p><p>首先，系统测量 view items。每个 view 和 layout 有特定数据用于描述对象在屏幕上的大小。一些 view 有特定大小，另一些则适应父容器的大小。</p><p>其次，系统对 view items进行布局。一旦系统计算完每个 children view 的大小，就会继续对它们进行布局。</p><p>系统不仅对将要绘制的 view 进行测量和布局，也会对这些 view 的父容器进行测量和布局，直到 root view。</p><p>当这个阶段的时间变多时，通常是要么是因为要处理的 view 太多，可者 view hierarchy 遇到了 “double taxation” 问题。</p><p><code>onLayout(boolean, int, int, int, int)</code> 和 <code>onMeasure(int, int)</code> 中的代码也会导致性能问题。Traceview 和 Systrace 可以帮助检查这些回调，以定位代码问题。</p><h2 id="Draw"><a href="#Draw" class="headerlink" title="Draw"></a>Draw</h2><p>绘制阶段将 view 上的渲染操作，比如绘制背景或绘制文本，转换成一系列的绘制命令。系统将这些命令放在 <a href="#">display list</a> 中。</p><p>这个阶段记录了将绘制命令放在 display list 中的耗时(用于更新到屏幕上的所有 view 的绘制命令)。这个时间适用于任何你添加到 UI 对象中代码。比如，<code>onDraw()</code>，<code>dispatchDraw()</code>，以及不同的 <code>Drawable.draw()</code> 方法。</p><p>当这个阶段的时间变多时，简单来说以将这个值视为为每个 invalidated view 调用 <code>onDraw()</code> 方法的耗时总和。这个值包含分发绘制命令到 children 以及 drawable 的耗时。基于这个原因，它这阶段耗时变多时，也可能是因为一堆 view 突然执行 <code>invalidate()</code>。让 view 无效会导致重新生成 view display list。另外，在自定义 view 的 <code>onDraw()</code> 方法中执行复杂逻辑的自定义 view 也会导致耗时变长。</p><h2 id="Sync-upload"><a href="#Sync-upload" class="headerlink" title="Sync/upload"></a>Sync/upload</h2><p>Sync &amp; Upload 值表示这一帧中将 bitmap 对象从 CPU memory 传输到 GPU memory 的耗时。</p><p>作为不同的处理器，CPU 和 GPU 有不同的专用 RAM 区域。它你绘制 bitmap 时，系统会在渲染 bitmap 之前 将其传输到 GPU memory。接着 GPU 会缓存这个 bitmap，以免系统重新传输数据，除非这个在 GPU 中的缓存数据被清理。</p><p>当这个阶段的时间变长时，一帧的所有资源都在 GPU 内存中才能绘制这一帧，较大的值表示加载了大量的小资源或少量的过大资源。一个典型的场景是 app 展示了一个接近屏幕大小的 bitmap。另一个场景是 app 展示了很多小图标。</p><p>要减少这个阶段的耗时，可采用的技巧如下：</p><ul><li>保证 bitmap 的分辨率不会比将要展示的大太多。比如，你应该避免在一个 48x48 的 ImageView 上展示一个 1024x1024 的 bitmap</li><li>使用 <code>prepareToDraw()</code> 方法在下一帧之前异步预加载 bitmap</li></ul><h2 id="Issue-commands"><a href="#Issue-commands" class="headerlink" title="Issue commands"></a>Issue commands</h2><p>The Issue Commands segment represents the time it takes to issue all of the commands necessary for drawing display lists to the screen.</p><p>示发送所有的必要 display list 绘制命令的耗时。系统将 display list 绘制到屏幕时，它会向 GPU 发送必要的命令。通常是通过 OpenGL ES API 进行发送。</p><p>这个过程需要一些时间，因为系统要在发送命令到 GPU 前对每个命令进行最终的转换和裁剪。另外的开销来自 GPU 侧，它会计算最终的命令。这些命令包含最终的转换和附加的裁剪。</p><p>当这个阶段的时间变长时，这个时间是对系统在给定的帧进行渲染时 display lists 复杂性和数量的直接度量。比如，进行非常多的绘制操作，特别是过多无关的原子绘制，会极大的增加这个时间。比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">1000</span>) &#123;</span><br><span class="line">    canvas.drawPoint()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个代码就比下面的代码要耗时得多：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawPoints(mThousandPointArray)</span><br></pre></td></tr></table></figure><p>发送命令跟实际绘制 display lists 并不总是 1:1 的关系。Unlike Issue Commands, which captures the time it takes to send drawing commands to the GPU, the Draw metric represents the time that it took to capture the issued commands into the display list. (?? 没太明白)</p><p>系统会尽可能缓存 display lists，导致差异更大。所以在滚动、transform、以及动画场景下，系统会重新发送 display list，但并不用真的重建 (As a result, there are situations where a scroll, transform, or animation requires the system to re-send a display list, but not have to actually rebuild it—recapture the drawing commands—from scratch)。所以你会看到 “Issue Commands” 升高的同时 “Draw” 并没有变高。</p><h2 id="Process-swap-buffers"><a href="#Process-swap-buffers" class="headerlink" title="Process/swap buffers"></a>Process/swap buffers</h2><p>当 Android 将所有 display list 提交给 GPU 后，系统会发送一个最终的命令通知 graphics driver 这一帧已经完成。这时起，driver 就可以将更新的 image 显示成屏幕。</p><p>当这个阶段的时间变长时，需要理解提 GPU 是跟 CPU 并行工作。Android 系统发送命令给 GPU，并进入下一个任务。而 GPU 从队伍读取绘制命令并进行处理。</p><p>当 CPU 发送绘制命令的速度比 GPU 的处理速度快时，处理器之间的通信队列满了。这种情况下，CPU 阻塞并等待直到队列有新的位置给下一条绘制命令。队列满的状态经常发生在 Swap Buffers 阶段，因为这个时间点整个帧的绘制命令被提交。(This full-queue state arises often during the Swap Buffers stage, because at that point, a whole frame’s worth of commands have been submitted.)</p><p>解决这个问题的关键是降低 GPU 中工作的复杂性。</p><h2 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h2><p>渲染系统除了花时间处理其工作，还有一些额外的工作发生在主线程中所以不能渲染(there’s an additional set of work that occurs on the main thread and has nothing to do with rendering)。这些时间被统计为 misc time。Misc time 通常表示两个连接帧之间 UI 线程发生的工作。</p><p>如果这个值变高，很可能是app有某些回调、intents或其他工作应当放在工作线程处理。Method tracing 和 Systrace 可以用于分析主线程中运行的任务，这些信息有助于进行性能优化。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Memory Profiler</title>
      <link href="2019/01/10/memory-profile-1/"/>
      <url>2019/01/10/memory-profile-1/</url>
      
        <content type="html"><![CDATA[<p>翻译自 <a href="https://developer.android.com/studio/profile/memory-profiler.html" target="_blank" rel="noopener">View the Java Heap and Memory Allocations with Memory Profiler</a>。介绍了 Memory Profiler 的用法。<br><a id="more"></a><br>Memory Profiler是<a href="https://developer.android.com/studio/preview/features/android-profiler.html" target="_blank" rel="noopener">Android Profiler</a>提供的内存分析组件，它可用于分析内存泄漏、内存抖动，这些内存问题会导致卡顿甚至崩溃。Memory Profiler可展示应用的实时内存图，可导出heap，强制GC以及跟踪内存分配。</p><p>通过以下步骤打开Memory Profiler</p><ol><li>点击 <strong>View &gt; Tool Windows &gt; Android Profiler</strong> (也可点击工具栏中的 <strong>Android Profiler</strong>)</li><li>选择待分析的设备和应用进程</li><li>点击 <strong>MEMORY</strong> 时间线中任意地方来打开Memory Profiler</li></ol><p>另外，也可以通过<a href="https://developer.android.com/studio/command-line/dumpsys.html" target="_blank" rel="noopener">dumpsys</a>或<a href="https://developer.android.com/studio/debug/am-logcat.html#memory-logs" target="_blank" rel="noopener">观察logcat中的GC事件</a>来检查内存。</p><h2 id="为什么要分析内存"><a href="#为什么要分析内存" class="headerlink" title="为什么要分析内存"></a>为什么要分析内存</h2><p>Android提供<a href="https://developer.android.com/topic/performance/memory-overview.html" target="_blank" rel="noopener">内存管理环境</a>，当它检查到应用不再需要某些对象时垃圾回收器会自动回收不再使用的内存。Android一直在改进找到不再使用内存的算法，但无论哪个版本的Android中一定会在某个时候短暂地停止执行应用代码。大部分时候这种暂停不被察觉到。但当应用分配内存的速度快过系统回收内存的速度，应用在等待系统回收释放内存以重新分配过程中会产生延迟。应用延迟会导致掉帧或可察觉的运行缓慢。</p><p>就算应用并不慢，但当它有内存泄漏时，即使在后台它仍然会占用不必要的内存。这种行为会导致不必要的内存回收，拖慢系整体统内存性能。系统可能最终不得不强制杀死内存泄漏的应用进程 。当用户返回到应用时，它不得不完全重启。</p><p>为了避免这些问题，你可以使用Memory Profiler：</p><ul><li>在时间线中找到可能导致问题的、不必要的内存分配</li><li>导出Java堆观察哪些对象正在占用内存。某些周期较长的heap dump中可以发现内存泄漏</li><li>记录正常用户操作和极端用户操作时内存的分配过程，分析哪些地方你的代码在短时间内创建了太多对象，或者某些对象存在泄漏。</li></ul><p>更多关于减少应用内存占用的编程技巧请参考[Manage Your App’s Memory](<a href="https://developer.android.com/topic/performance/memory.html。" target="_blank" rel="noopener">https://developer.android.com/topic/performance/memory.html。</a></p><h2 id="Memory-Profiler简介"><a href="#Memory-Profiler简介" class="headerlink" title="Memory Profiler简介"></a>Memory Profiler简介</h2><p>打开Memory Profiler首先看到的内存使用时间线，以及强制GC，导出heap dump，记录内存分配的访问入口。</p><p><img src="https://developer.android.com/studio/images/profile/memory-profiler-callouts_2x.png" alt></p><p>这里只介绍几个新的功能</p><ul><li>5, A button to jump forward to the live memory data</li><li>6, The event timeline, which shows the activity states, user input events, and screen rotation events</li><li>7, 内存使用时间线，它包括以下部分：<ul><li>各内存类别占用图，左边的y轴显示了各具体类别</li><li>一条表示对象数量的虚线，由右边的y轴表示</li></ul></li></ul><p>但如果使用Android 7.1或以下版本，并不是所有数据缺省可见。如果你看到提示信息”Advanced profiling is unavailable for the selected process”，则需要<a href="https://developer.android.com/studio/preview/features/android-profiler.html#advanced-profiling" target="_blank" rel="noopener">开启高级分析功能</a>以显示以下信息：</p><ul><li>Event timeline</li><li>Number of allocated objects</li><li>Garbage collection events</li></ul><p>在Android 8.0或更高版本上，高级分析功能一直会为可调试的app打开。</p><h2 id="内存是如何统计的"><a href="#内存是如何统计的" class="headerlink" title="内存是如何统计的"></a>内存是如何统计的</h2><p>Memory Profiler(图2)中顶部显示的数据是基于应用的私有内存页面统计的。这个数字不包括应用跟系统或其他应用共享的内存页面。</p><p><img src="https://developer.android.com/studio/images/profile/memory-profiler-counts_2x.png" alt></p><p>内存的类型包括以下几种：</p><ul><li><strong>Java</strong>: Java或Kotlin代码创建的对象占用的内存</li><li><strong>Native</strong>: C或C++代码创建的对象占用的内存。就算你在应用中并没有使用C++，也可能看到一些native memory，因为Android框架会使用native memory来帮你完成某些工作，比如处理图片资源或其他图像时</li><li><strong>Graphics</strong>: graphics buffer queue将像素显示到屏幕时占用的内存，包括GL surface, GL textures等等(注意这里说的是跟CPU共享的内存，而不是专用的GPU内存)</li><li><strong>Stack</strong>: 应用中native代码或Java代码使用的栈内存。这通常跟应用中有多少线程在运行有关</li><li><strong>Code</strong>: 应用代码和资源占用的内存，比如dex字节码，优化后的dex code, .so库或字体</li><li><strong>Other</strong>: 系统不确定该如何分类的内存</li><li><strong>Allocated</strong>: Java和Kotlin创建的对象数量。这个数字不包括C或C++对象。当连接到Android 7.1或以下设备上时，这个数字只在Memory Profiler连接到正在运行的应用时开始生效。所以在此之前分配的对象并不会计算在内。但Android 8.0版本开始设备上自带一个可以跟踪所有对象分配过程的工具，所以这个数字能准确表示所有的Java对象数量。</li></ul><p>跟之前的Android Monitor tool中的内存数量相比，新的Memory Profiler记录内存的方式有所不同，所以看起来内存占用比以前变高了。Memory Profiler会监听其他类型的内存，导致总量变高，但如果你只关心Java堆内存，那么看到的”Java”类型的内存数量，跟以前应该是一致的。</p><p>尽管Java类型的内存占用跟Android Monitor中看到的并不完全一样，但现在是app进程从Zygote fork出来之后所有分配的物理内存页面都有统计，所以新的统计数据在反映物理内存占用方面应该更准确。</p><blockquote><p>目前Memory Profiler会将其自身占用的native内存统计到应用上，大约10MB(100k个对象)。后续版本中会从应用内存占用数据中去掉这些数据。</p></blockquote><h2 id="查看内存分配"><a href="#查看内存分配" class="headerlink" title="查看内存分配"></a>查看内存分配</h2><p>Memory Allocations显示 <em>内存中每个对象是如何分配的</em> 。Memory Profiler还可以显示如下信息：</p><ul><li>分配的对象类型，以及占用了多少内存</li><li>每个分配过程的调用栈，包括所在线程</li><li>对象在什么时候回收(仅在Android 8.0及以上设备上可见)</li></ul><p>如果是Android 8.0或以上设备上运行，可以在任意时刻查看对象的分配。点击并按下时间线，然后拖动以选择想要查看内存分配的时间段(如下图)。Android 8.0上自带一个可一直跟踪应用内存分配的工具，所以没必要”Start Allocation Tracking”。</p><p><img src="https://storage.googleapis.com/androiddevelopers/videos/studio/memory-profiler-allocations-jvmti.mp4" alt></p><p>如果是Android 7.1或以下设备上运行，则需要点击Memory Profiler工具条中的 <strong>Record memory allcations</strong> 。开始后，Android Monitor会一直记录应用中发生的内存分配。点击 <strong>Stop recording</strong> 来查看分配过程。</p><p><img src="https://storage.googleapis.com/androiddevelopers/videos/studio/memory-profiler-allocations-record.mp4" alt></p><p>一旦选择了时间线区域或完成了一次”Record memory allcations”，已分配对象列表会出现在时间线下面，按类名分组，并按heap count排序。</p><blockquote><p>在Android 7.1及以下版本中，可以记录最多65536个分配。如果超过这个数字，仅在记录中保存最近的65535个分配。Android 8.0中没有这个限制。</p></blockquote><p>按以下步骤检查内存分配记录：</p><ol><li>浏览对象列表，找到反常的较大的heap count。点 <strong>Class Name</strong> 可以对数据按字母表顺序排序。 右侧的 <strong>Instance View</strong> 面板展示了该类的每个实例，见图3</li><li>在 <strong>Instance View</strong> 中点击一个instance, 在下方会出现 <strong>Call Stack</strong> ， call stack中会显示该instance在哪里以及哪个线程分配的。</li><li>在 <strong>Call Stack</strong> 标签页，点击任意一行会跳转到相应的代码行</li></ol><p><img src="https://developer.android.com/studio/images/profile/memory-profiler-allocations-detail_2x.png" alt></p><p>缺省情况下左边的分配列表按类名排列。在列表上方，你可以根据右边的下拉菜单来在下列的方式中切换：</p><ul><li><strong>Arrange by class</strong> 按类名分组</li><li><strong>Arrange by package</strong> 按包名分组</li><li><strong>Arrange by callstack</strong> 按调用栈分组</li></ul><h2 id="导出heap"><a href="#导出heap" class="headerlink" title="导出heap"></a>导出heap</h2><p>导出的heap中可以看到应用中哪些对象正在使用内存。用户使用一段时间之后，你确认应该不再存在的对象仍然出现在heap dump中，可以判断存在内存泄漏。导出heap后可以查看如下内容：</p><ul><li>应用创建了哪些对象，每种对象的数量</li><li>每个对象使用了多少内存</li><li>每个对象被哪里的代码引用</li><li>对象在调用栈的什么地方被创建 (Call stacks are currently available with a heap dump only with Android 7.1 and lower when you capture the heap dump while recording allocations.)</li></ul><p>点击 <strong>Dump Java heap</strong> 来导出heap。导出时，Java内存总量可能短暂增加。这是正常的，因为heap dump发生在应用进程中，它需要一些内存用于收集数据。</p><p><img src="https://developer.android.com/studio/images/profile/memory-profiler-dump_2x.png" alt></p><p>如果你需要更精确的heap dump，可以在代码中调用<a href="https://developer.android.com/reference/android/os/Debug.html#dumpHprofData(java.lang.String" target="_blank" rel="noopener">dumpHprofData()</a>)来导出heap。</p><p>在类列表中，可以看到如下信息：</p><ul><li><strong>Alloc Count</strong> : heap中的Allocations数量</li><li><strong>Native Size</strong> : 这种对象类型使用的native memory数量。这列数据仅在Android 7.0以及更高设备上可见。</li><li><strong>Shallow Size</strong> : 这种对象类型使用的Java内存</li><li><strong>Retained Size</strong> : 这个类的所有实例持有的所有内存数量</li></ul><p>在类列表顶部，可以使用左边的下拉菜单在以下heap dump中切换：</p><ul><li><strong>Default heap</strong> : 当系统没有指定heap时显示default heap</li><li><strong>App heap</strong> : 应用主要在这个heap中分配内存</li><li><strong>Image heap</strong> : system boot image，包括启动时预加载的类。这里分配的内存保证不会被改变或移除</li><li><strong>Zygote heap</strong> : 应用进程在这个heap上从Android系统fork出来</li></ul><p>缺省情况下heap中的对象按类名排列。在列表上方，你可以使用下拉菜单来在下列的方式中切换：</p><ul><li><strong>Arrange by class</strong> 按类名分组</li><li><strong>Arrange by package</strong> 按包名分组</li><li><strong>Arrange by callstack</strong> 按调用栈分组。这个选项仅在recording allcations过程中capture heap dump时才有效。所以，heap中可能有对象是在开始record allcations之前创建的，所以这些对象先出现。</li></ul><p>列表缺省按 <strong>Retained Size</strong> 列排列。可以点击任一列表头来调整列表的排列顺序。</p><p>点击类名打开 <strong>Instance View</strong> 窗口。每个列出的实例包括以下信息：</p><ul><li><strong>Depth</strong> : 从GC根节点到当前对象的最短路径</li><li><strong>Native Size</strong> : 这种对象类型使用的native memory数量。这列数据仅在Android 7.0以及更高设备上可见。</li><li><strong>Shallow Size</strong> : 这种对象类型使用的Java内存</li><li><strong>Retained Size</strong> : 这个对象持有的所有内存数量 (见<a href="https://en.wikipedia.org/wiki/Dominator_(graph_theory" target="_blank" rel="noopener">dominator tree</a>))</li></ul><blockquote><p>注意：缺省时heap dump中并不显示每个对象的stack trace。想要看到stack trace，在点击 <strong>Dump Java heap</strong> 前必须开始<a href="https://developer.android.com/studio/profile/memory-profiler.html#record-allocations" target="_blank" rel="noopener">recording memory allocations</a>。只有这样才能在 <strong>Instance View</strong> 中选择实例看到 <strong>Reference</strong> 和 <strong>Call Stack</strong> 标签，如下图。但有可能某些对象在你开始recording allcations之前创建，所以这些对象并没有call stack。(由于要求执行allcation recording才能看到stack trace，所以Android 8.0上目前无法看到heap dump中的stack trace)</p></blockquote><p><img src="https://developer.android.com/studio/images/profile/memory-profiler-dump-stacktrace_2x.png" alt></p><p>按以下步骤检查heap：</p><ol><li>浏览列表找到大小反常的对象，它们可能存在泄漏。点 <strong>Class Name</strong> 可以对数据按字母表顺序排序。 然后点击类列， <strong>Instance View</strong> 面板显示在右边，显示该类的每个实例</li><li>在 <strong>Instance View</strong> 面板中点击查看实例。 <strong>References</strong> 标签页在下方，显示指向这个对象的引用。或者也可以点击实例左边的箭头来查看它的字段，然后点击字段名来查看引用。如果想查看字段指向的具体实例，右击字段并选择 <strong>Go to Instance</strong></li><li>如果在 <strong>References</strong> 标签页，你觉得某个引用可能存在泄漏，右击并选择 <strong>Go to Instance</strong> 。 这一操作会从heap dump中选择对应的实例，并显示实例数据</li></ol><p>在heap dump中，需要检查以下原因引起的内存泄漏：</p><ul><li>指向 <code>Activity</code> , <code>Context</code>, <code>View</code>, <code>Drawable</code>的长生命周期引用，以及其他可能引用 <code>Activity</code> 或 <code>Context</code> 的对象</li><li>非静态的内部类，比如 <code>Runnable</code>，它可能持有 <code>Activity</code> 引用</li><li>缓存。缓存可能长时间持有引用，以致超出需要</li></ul><h2 id="heap-dump保存为HPROF"><a href="#heap-dump保存为HPROF" class="headerlink" title="heap dump保存为HPROF"></a>heap dump保存为HPROF</h2><p>一旦导出heap，这些数据仅在Memory Profiler运行时才可见。当你退出Memory Profiler，heap dump会丢失。如何想保存该数据以便以后查看，可使用 <strong>Export capture to file</strong> 将其导出为HPROF文件。请确保以<code>.hprof</code>作为文件后缀名。</p><p>可将<code>.hprof</code>文件拖放到Android Studio来打开。</p><p>如果使用其他HPROF分析工具，比如<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jhat.html" target="_blank" rel="noopener">jhat</a>，你需要把HPROF文件从Android格式转换为标准的Java SE HPROF格式。使用 <code>android_sdk/platform-tools</code>目录下的<code>hprof-conv</code>工具进行转换。用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hprof-conv heap-original.hprof heap-converted.hprof</span><br></pre></td></tr></table></figure><h2 id="内存分析技巧"><a href="#内存分析技巧" class="headerlink" title="内存分析技巧"></a>内存分析技巧</h2><p>暴露内存泄漏问题的一个办法时让应用运行一段时间然后再检查内存。泄漏可能发生在heap的前一部分(Leaks might trickle up to the top of the allocations in the heap.)。当泄漏越小，需要运行应用以发现问题的时间越长。</p><p>可以使用下面的方法触发内存泄漏：</p><ul><li>在不同的activity状态下切换屏幕方向。由于系统会重新创建<code>Activity</code>，切换屏幕方向常常会导致应用泄漏 <code>Activity</code>, <code>Context</code>或<code>View</code>对象。如果应用在别的地方持有这些对象，系统是无法将其回收的</li><li>在不同的activity状态下，在当前应用和别的应用之前进行切换。比如，回到Home然后又返回应用</li></ul><blockquote><p>Tip: 也可以使用<a href="https://developer.android.com/tools/help/monkeyrunner_concepts.html" target="_blank" rel="noopener">monkeyrunner</a>完成上述操作。</p></blockquote><!--===## tasks对比开启20个线程之后，Stack类型的内存占用用什么变化观察Android Monitor tool和Memory Profiler内存数据差别-->]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Manage Your App&#39;s Memory</title>
      <link href="2019/01/10/manage-your-memory/"/>
      <url>2019/01/10/manage-your-memory/</url>
      
        <content type="html"><![CDATA[<p>翻译自<a href="https://developer.android.com/topic/performance/memory.html" target="_blank" rel="noopener">Manage Your App’s Memory | Android Developers</a>。介绍了如何管理应用的内存。<br><a id="more"></a></p><p>在任何软件开发中RAM都是宝贵的资源，而在移动操作系统中由于内存受限所以更加宝贵。虽然ART和Davik虚拟机都能回收内存，但并不表示你可以忽略内存的分配和回收的时机和位置。你仍然需要避免内存泄漏，并生命周期回调中的恰当时间释放对象引用。</p><h2 id="监视可用内存和已使用内存"><a href="#监视可用内存和已使用内存" class="headerlink" title="监视可用内存和已使用内存"></a>监视可用内存和已使用内存</h2><p>Memory Profiler可以帮助诊断内存问题：</p><ol><li>观察分配了多少内存</li><li>发起内存回收，导出Java堆</li><li>记录内存分配并检查分配的对象</li></ol><h2 id="响应并释放内存"><a href="#响应并释放内存" class="headerlink" title="响应并释放内存"></a>响应并释放内存</h2><p> <a href="https://developer.android.com/topic/performance/memory-overview.html" target="_blank" rel="noopener">Overview of Android Memory Management</a>中提到Android可以从应用中以多种方式回收内存，必要时直接杀死应用进程以给更高优先级的任务分配内存。</p><p><a href="https://www.youtube.com/watch?v=x8Hddx1eOZo&amp;index=5&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="noopener">(42) Trimming and Sharing Memory (Android Performance Patterns Season 3 ep5) - YouTube</a></p><p>使用<a href="https://developer.android.com/reference/android/content/ComponentCallbacks2.html" target="_blank" rel="noopener">ComponentCallbacks2</a>接口。该接口中的<code>onTrimMemory()</code>回调方法允许应用在前台或后台监听内存相关事件，应用可响应这些事件来回收内存。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.ComponentCallbacks2;</span><br><span class="line"><span class="comment">// Other import statements ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ComponentCallbacks2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other activity code ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Release memory when the UI becomes hidden or when system resources become low.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> level the memory-related event that was raised.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Determine which lifecycle or system event was raised.</span></span><br><span class="line">        <span class="keyword">switch</span> (level) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN:</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                   Release any UI objects that currently hold memory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                   The user interface has moved to the background.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE:</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW:</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL:</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                   Release any memory that your app doesn't need to run.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                   The device is running low on memory while the app is running.</span></span><br><span class="line"><span class="comment">                   The event raised indicates the severity of the memory-related event.</span></span><br><span class="line"><span class="comment">                   If the event is TRIM_MEMORY_RUNNING_CRITICAL, then the system will</span></span><br><span class="line"><span class="comment">                   begin killing background processes.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_BACKGROUND:</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_MODERATE:</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_COMPLETE:</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                   Release as much memory as the process can.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                   The app is on the LRU list and the system is running low on memory.</span></span><br><span class="line"><span class="comment">                   The event raised indicates where the app sits within the LRU list.</span></span><br><span class="line"><span class="comment">                   If the event is TRIM_MEMORY_COMPLETE, the process will be one of</span></span><br><span class="line"><span class="comment">                   the first to be terminated.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                  Release any non-critical data structures.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  The app received an unrecognized memory level value</span></span><br><span class="line"><span class="comment">                  from the system. Treat this as a generic low-memory message.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>API level 14中添加的<code>onTrimMemory()</code>方法，而之前版本中可使用<code>onLowMemory()</code>方法。</p><h2 id="检查可供使用的内存"><a href="#检查可供使用的内存" class="headerlink" title="检查可供使用的内存"></a>检查可供使用的内存</h2><p>Android为分配给每个应用的堆大小设置了设置，以允许多个进程运行。基于当前设备有多少内存，这个值大小会有所不同。当应用的堆大小到达上限时继续分配内存，系统会抛出<code>OutOfMemoryError</code>。</p><p>使用<code>getMemoryInfo()</code>查询当前设备上的可用内存，该方法返回<code>ActivityManager.MemoryInfo</code>对象。该对象描述了设备当前内存状态，包括可用内存、总内存以及内存阈值——系统在什么内存状态下开始杀应用进程。<code>lowMemory</code>字段表示设备内存是否过低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingMemoryIntensive</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before doing something that requires a lot of memory,</span></span><br><span class="line">    <span class="comment">// check to see whether the device is in a low memory state.</span></span><br><span class="line">    ActivityManager.MemoryInfo memoryInfo = getAvailableMemory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!memoryInfo.lowMemory) &#123;</span><br><span class="line">        <span class="comment">// Do memory intensive work ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get a MemoryInfo object for the device's current memory status.</span></span><br><span class="line"><span class="keyword">private</span> ActivityManager.<span class="function">MemoryInfo <span class="title">getAvailableMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ActivityManager activityManager = (ActivityManager) <span class="keyword">this</span>.getSystemService(ACTIVITY_SERVICE);</span><br><span class="line">    ActivityManager.MemoryInfo memoryInfo = <span class="keyword">new</span> ActivityManager.MemoryInfo();</span><br><span class="line">    activityManager.getMemoryInfo(memoryInfo);</span><br><span class="line">    <span class="keyword">return</span> memoryInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更多地使用节省内存的代码结构"><a href="#更多地使用节省内存的代码结构" class="headerlink" title="更多地使用节省内存的代码结构"></a>更多地使用节省内存的代码结构</h2><h3 id="少用Service"><a href="#少用Service" class="headerlink" title="少用Service"></a>少用Service</h3><p>让一个不必要的service运行是Andrdoid应用最糟糕的内存问题。</p><p>启动service之后，系统总是会让该service所在进程保持运行。这种行为让service进程非常昂贵，因为它占用的内存无法分给其它进程。这导致LRU缓存中的cached process变少。</p><p>建议使用<a href="https://developer.android.com/reference/android/app/job/JobScheduler.html" target="_blank" rel="noopener">JobScheduler</a>代替service。如果一定要使用service，请优先使用<a href="https://developer.android.com/reference/android/app/IntentService.html" target="_blank" rel="noopener">IntentService</a></p><h2 id="使用优化的数据结构"><a href="#使用优化的数据结构" class="headerlink" title="使用优化的数据结构"></a>使用优化的数据结构</h2><p>Java语言中的一些类并没有专门为移动设备优化。比如<a href="https://developer.android.com/reference/java/util/HashMap.html" target="_blank" rel="noopener">HashMap</a>使用内存的效率就很低。</p><p>Android框架提供</p><ul><li><a href="https://developer.android.com/reference/android/util/SparseArray.html" target="_blank" rel="noopener">SparseArray</a></li><li><a href="https://developer.android.com/reference/android/util/SparseBooleanArray.html" target="_blank" rel="noopener">SparseBooleanArray</a></li><li><a href="https://developer.android.com/reference/android/support/v4/util/LongSparseArray.html" target="_blank" rel="noopener">LongSparseArray</a></li></ul><h3 id="少用抽象"><a href="#少用抽象" class="headerlink" title="少用抽象"></a>少用抽象</h3><p>抽象是个好的编程实践，可以增加代码灵活性，更容易维护。但抽象是有代价的，需要执行更多的代码，需要更多执行时间，更多内存空间来加载。所以如果没有足够的好处，不要使用抽象。</p><p>enum通常比常量多占用两倍内存，所以Android应用中一定要避免enum。</p><h3 id="使用nano-protobuf"><a href="#使用nano-protobuf" class="headerlink" title="使用nano protobuf"></a>使用nano protobuf</h3><p>常规的protobuf生成非常冗余松散的代码，会导致内存增加，APK包大小增加，拖慢执行速度。所以请用nano protobuf代替。</p><h3 id="避免内存抖动"><a href="#避免内存抖动" class="headerlink" title="避免内存抖动"></a>避免内存抖动</h3><p>GC通常不会影响应用性能。但短时间内大量发生GC会消耗帧时间。</p><p>内存抖动是指短时间内分配了大量临时对象。比如在<code>for</code>循环中创建许多临时对象。或者在View的<code>onDraw()</code>中创建<code>Paint</code>或<code>Bitmap</code>。这些情形下，应用会以非常快的速度创建很多对象。它们迅速占用可用内存，导致必须GC。</p><h2 id="去掉占用内存过多的资源和库"><a href="#去掉占用内存过多的资源和库" class="headerlink" title="去掉占用内存过多的资源和库"></a>去掉占用内存过多的资源和库</h2><p>有些资源和库会在你不知情的情况下增加内存占用。检查APK中可能影响内存使用的第三方库和资源。从代码中去掉冗余，不必要以及过于臃肿的组件、资源和库。</p><h3 id="减少包大小"><a href="#减少包大小" class="headerlink" title="减少包大小"></a>减少包大小</h3><p>减少包大小的同时也可以减少内存占用。关于减少包大小的更多信息见<a href="https://developer.android.com/topic/performance/reduce-apk-size.html" target="_blank" rel="noopener">Reduce APK Size</a></p><h3 id="使用Dagger-2"><a href="#使用Dagger-2" class="headerlink" title="使用Dagger 2"></a>使用Dagger 2</h3><p>使用依赖注入框架可以简化代码，并提供响应式环境以便于测试和配置。如果需要使用依赖注入，建议使用<a href="http://google.github.io/dagger/" target="_blank" rel="noopener">Dagger 2</a>。因为它不使用反射。其他一些依赖注入框架使用反射，会对代码中的注解进行扫描。该过程占用相当多的CPU和内存，当应用启动时会产生明显延迟。</p><h3 id="慎用第三方库"><a href="#慎用第三方库" class="headerlink" title="慎用第三方库"></a>慎用第三方库</h3><p>很多外部库通常不是专门为移动设备环境开发的，所以用于移动客户端时非常低效。虽然<a href="https://developer.android.com/tools/help/proguard.html" target="_blank" rel="noopener">ProGuard</a>可以移除不必要的API和资源，但它并不能移除库内部的大部分依赖。而你想使用的功能很可能只是库当中的一小部分。当你使用第三方库中的Activity子类时，这通常都是问题。使用反射的第三方库(很常见)也意味着你需要不少时间去调整ProGuard配置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用启动速度优化(二)</title>
      <link href="2019/01/10/app-startup-speed2/"/>
      <url>2019/01/10/app-startup-speed2/</url>
      
        <content type="html"><![CDATA[<p>再谈谈冷启动速度优化。<br><a id="more"></a><br>这是之前写的另一篇(不好意思，半成品)，<a href="/2019/01/10/app-startup-speed/" title="应用启动速度优化(一)">应用启动速度优化(一)</a>。对冷启动速度优化有了一些新的认识，所以今天再次旧话重提。</p><p>本文的主要内容包括：</p><ul><li>优化冷启动速度的关注点<ul><li><code>Application.onCreate()</code> 中的初始化过程。注意多进程对这个方法的影响</li><li><code>Activity.onCreate()</code> 中的初始化过程。重点关注应用的第一个 Activity</li></ul></li><li>冷启动耗时的测量方法<ul><li><code>Debug.startMethodTracing()</code> 的用法</li><li><a href="https://developer.android.com/studio/profile/cpu-profiler" target="_blank" rel="noopener"><code>.trace</code> 文件的分析方法</a></li></ul></li><li>闪屏页的优化方法</li></ul><h1 id="启动速度的关注点"><a href="#启动速度的关注点" class="headerlink" title="启动速度的关注点"></a>启动速度的关注点</h1><p>应用冷启动过程是这样的：</p><p><img src="http://hukai.me/images/android_perf_6_launch_time_start_process.png" alt></p><p><a href="http://hukai.me/android-performance-patterns-season-6/" target="_blank" rel="noopener">Android性能优化典范</a>中提到应用开发者能够控制并且需要特别关注的地方主要有三处：</p><ul><li><code>Application.onCreate()</code> 流程，对于大型的APP来说，通常会在这里做大量的通用组件的初始化操作</li><li><code>Activity.onCreate()</code> 流程，特别是UI的布局与渲染操作，如果布局过于复杂很可能导致严重的启动性能问题</li><li>自定义的启动窗口(也就是通常所说的闪屏页)</li></ul><p>我根据自己的开发经验补充一个关注点：现在的app动不动就多进程，多进程app会多次调用 <code>Application.onCreate()</code> 方法进行初始化，而实际上某些初始化过程仅仅对主进程才有意义。反复调用 <code>Application.onCreate()</code> 不仅拖慢启动速度，还会无意义地占用内存。</p><p>有两种简单的测试 Activity 启动时间的方法：</p><ul><li>在 Android Studio logcat 中搜索 <code>ActivityManager: Displayed ...</code> 日志</li><li><code>adb logcat -v time | grep &#39;Displayed com.tencent.PmdCampus/.view.IndexActivity&#39;</code></li></ul><p>小知识：Displayed Time 是界面 inflate 完成的时间，是区别于界面真实加载完成的时间的(比如说，inflate 完成后可能会异步加载图片，图片加载完才算真实加载完成)。如果关注这里的差异的话，一个解决方法是使用 <code>activity.reportFullyDrawn()</code> 告诉系统以便获取真实加载时间。</p><p><img src="http://hukai.me/images/android_perf_6_launch_time_report_fully_drawn.png" alt></p><h1 id="Method-Tracing"><a href="#Method-Tracing" class="headerlink" title="Method Tracing"></a>Method Tracing</h1><p>上述提到的三个关注点完全适用于我们的app。</p><ul><li>首先，我们app在 <code>Application.onCreate()</code> 中初始化了大量第三方 SDK</li><li>其次，我们app在 <code>IndexActivity.onCreate()</code> 中加载了复杂布局。IndexActivity 作为首页承载了5个Tab页</li><li>最后，我们app使用了不完全合理的闪屏实现方式</li></ul><p>在 <code>Application.onCreate()</code> 中初始化大量第三方 SDK 到底有多耗时呢？需要先测出数据。</p><a href="/2019/01/10/app-startup-speed/" title="应用启动速度优化(一)">应用启动速度优化(一)</a>使用了一个笨办法，通过 <code>Log.i</code> 输出各个方法调用的耗时。<br><br>容易想到另外一个工具，<a href="https://developer.android.com/studio/profile/cpu-profiler" target="_blank" rel="noopener">Android Studio 中的 CPU Profiler</a>。但使用 CPU Profiler 的有个问题，它不便于精确分析应用启动时的 cpu 状态。<br><br>所以更好的办法是使用 <code>Debug.startMethodTracing()</code>。方法如下：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        Debug.startMethodTracing();</span><br><span class="line">        ...</span><br><span class="line">        Debug.stopMethodTracing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺省的文件为 <code>dmtrace.trace</code>，通过如下方式导出来：</p><p><code>adb pull /sdcard/Android/data/&lt;package&gt;/files/dmtrace.trace</code></p><p>Android Studio 3.0 之后 traceview 工具已废弃，我们直接在 Studio 中分析 <code>.trace</code> 文件就可以了。方法如下：</p><p>Profiler &gt; SESSIONS &gt; Load from file，然后选择 <code>.trace</code> 文件</p><p><img src="https://qqadapt.qpic.cn/txdocpic/0/84d9a3d2a3eb54970ef5c507f2be529d/0" alt="Call Chart"></p><p><img src="https://qqadapt.qpic.cn/txdocpic/0/91e60ddde3d330b12d6660afa4911f82/0" alt="Top Down"></p><p>通过 Top Down 这张图，拎出启动速度慢的罪魁祸首简直易于反掌。名单整理如下：</p><ul><li>IGameApplication.initBugly() - 初始化 bugly SDK，耗时 389.62.ms<ul><li>RqdHotfix.init() - 389.26ms</li></ul></li><li>ReservoirHelper.init() - 初始化 Reservoir 库，耗时 101.43ms</li><li>LoginHelper.getInstance() - 初始化 Wtlogin SDK，耗时 755.6ms<ul><li>WtloginHelper() - 755.42.ms</li></ul></li></ul><h1 id="首页启动速度优化"><a href="#首页启动速度优化" class="headerlink" title="首页启动速度优化"></a>首页启动速度优化</h1><p>首页承载多个 Tab 导致启动慢时，一般通过懒加载的方法来避免启动时立即加载全部 Fragment。可以参考<a href="https://blog.csdn.net/yewei02538/article/details/50329119" target="_blank" rel="noopener">这里</a>，不再赘述。</p><h1 id="闪屏页的优化"><a href="#闪屏页的优化" class="headerlink" title="闪屏页的优化"></a>闪屏页的优化</h1><p>我们 app 中闪屏页跟首页是分离的。每次启动时都会先显示闪屏页再跳转到首页 (注意是每次，而不仅仅是冷启动时）。 感觉这一做法有背离闪屏页初衷的嫌疑，而且从技术角度上讲多启动了一个 Activity 增加了启动耗时。</p><ul><li>闪屏页 - SplashActivity，</li><li>首页 - IndexActivity，有5个Tab</li></ul><p>更好的做法是将闪屏页与首页合并。要点如下：</p><ul><li>创建一个用于闪屏的主题 <code>Laucher</code> 以及一个应用主题 <code>MyApp</code></li><li>创建 <code>laucher_drawable</code>，它包含跟 <code>MyApp</code> 主题相近的背景色以及一个居中的小 logo</li><li><code>Laucher</code> 主题使用 <code>laucher_drawable</code> 作为 <code>windowBackground</code></li><li>manifest 中将 IndexActivity 的主题设置为 <code>Laucher</code></li><li><code>IndexActivity.onCreate()</code> 方法中使用 <code>setTheme()</code> 方法将主题从 <code>Laucher</code> 切换到 <code>MyApp</code></li></ul><p>注意：在调用 <code>super.onCreate()</code> 之前调用 <code>setTheme()</code></p><p>核心代码如下：</p><p><code>laucher_drawable.xml</code> 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layer-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@color/color_app"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bitmap</span> <span class="attr">android:src</span>=<span class="string">"@drawable/logo"</span> <span class="attr">android:gravity</span>=<span class="string">"center"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Laucher</code> 主题：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme.Laucher"</span> <span class="attr">parent</span>=<span class="string">"@style/Theme.AppCompat.NoActionBar"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowBackground"</span>&gt;</span>@drawable/laucher_drawable<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>manifest 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">name</span>=<span class="string">".view.IndexActivity"</span> <span class="attr">theme</span>=<span class="string">"@style/AppTheme.Laucher"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>IndexActivity.java 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexActivity</span> <span class="keyword">extends</span> <span class="title">AppCompactActivity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在 `super.onCreate()` 之调用 `setTheme()`</span></span><br><span class="line">        setTheme(R.style.Theme_MyApp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用启动速度优化(一)</title>
      <link href="2019/01/10/app-startup-speed/"/>
      <url>2019/01/10/app-startup-speed/</url>
      
        <content type="html"><![CDATA[<p>大概一两年前写的，关于app冷启动速度优化的。直到项目停了，内容也一直没写全（我也懒得可以！）。不过还是发出来，备忘。<br><a id="more"></a></p><p>本文内容还没写全，项目已停了。仅用于备忘。文章要点：</p><ul><li>使用 <code>adb logcat</code> 测试 Activity 启动速度的方法</li><li><code>ViewPager.setOffscreenPageLimit()</code> 方法简介</li><li>在 ViewPager + Fragment 模式使用懒加载的技巧</li></ul><p>我们项目的首页采用经典的多tab页结构(类似微信首页)。从UI上看，首页承载了”遇见”、”发现”、”消息”和”我的”四个tab页。实际实现中使用的 <code>ViewPager</code> + <code>FragmentPagerAdapter</code>，每个tab页对应一个 <code>fragment</code>。跟微信不一样的是，进入首页后我们的tab页会发请求拉取数据，而微信更多的直接显示已有的推送消息。我们的tab页中加载的图片远远多于微信，甚至还可能有视频。</p><p>首页相对其他页面较重，启动慢、性能差。用户进入应用后首先看到的就是首页，它的启动最为频繁。首页启动慢除了影响用户体验，更会让用记对app产生不好的感知：这个app做得不行。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>首页相对其他页面较重。所以直观上启动慢相对较慢是说得通的。但更深层次的原因是什么呢？有没有办法优化呢？</p><p>我们先测一下首页启动速度。使用 logcat 抓取 <code>ActivityManager</code> 打印的 Activity 启动时间应该是最简单有效的测试方法了。</p><p><code>adb logcat -v time | grep &#39;Displayed com.tencent.PmdCampus/.view.IndexActivity&#39;</code>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">02-03 17:44:04.672 1116-1168/? I/ActivityManager: Displayed com.tencent.PmdCampus/.view.IndexActivity: +622ms</span><br></pre></td></tr></table></figure><p>在我的OPPO R7sm上空页面的启动速度少于100ms，app中普通页面多数在200ms左右，而首页慢得可以，居然到了629.4ms！</p><table><thead><tr><th>第一次</th><th>第二次</th><th>第三次</th><th>第四次</th><th>第五次</th><th>平均</th></tr></thead><tbody><tr><td>622ms</td><td>634ms</td><td>638ms</td><td>614ms</td><td>639ms</td><td>629.4ms</td></tr></tbody></table><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>通过分析代码和traceview日志，以下几个地方引起注意：</p><ul><li>为了避免切换tab过程中 fragment 频繁销毁和初始化，调用了 <code>ViewAdapter.setOffscreenPageLimit(3)</code>。这个调用会产生什么影响？</li><li>traceview 日志显示有些在主线执行时间过长的方法。这些方法会产生什么影响？</li></ul><p>下面逐步展开分析。</p><h2 id="fragment-的初始化"><a href="#fragment-的初始化" class="headerlink" title="fragment 的初始化"></a>fragment 的初始化</h2><p>关于 <code>ViewPager</code> 中 fragment 的初始化，我们先从 <code>ViewAdapter.setOffscreenPageLimit()</code> 方法说起。</p><blockquote><p>Set the number of pages that should be retained to either side of the current page in the view hierarchy in an idle state. Pages beyond this limit will be recreated from the adapter when needed.<br>This is offered as an optimization. If you know in advance the number of pages you will need to support or have lazy-loading mechanisms in place on your pages, tweaking this setting can have benefits in perceived smoothness of paging animations and interaction. If you have a small number of pages (3-4) that you can keep active all at once, less time will be spent in layout for newly created view subtrees as the user pages back and forth.<br>You should keep this limit low, especially if your pages have complex layouts. This setting defaults to 1</p></blockquote><p>这个方法用于设置空闲状态时当前页面两边需要保留的页面数量。超过这个数量限制的页面将被销毁，而需要时又会重新创建。这个方法可以用于调优。比如你提前知道ViewPager中的页面数量或者页面有延迟加载机制，可以调整这里的参数以便页面动画及交互更流畅。如果页面数量很少的话(3到4个页面)，完全可以同时保留全部页面。这样，在用户切换页面时可以花更少的时间用于新创建的view的布局。应当保证这里的数量较小，尤其是在页面布局较复杂时。值为1。</p><p>容易理解 <code>offscreenPageLimit</code> 的含义。比如，我们有四个tab，假设 <code>offscreenPageLimit</code> 为1，</p><ul><li>启动时当前页为”遇见”，这时”遇见”右边的”发现”也会被初始化</li><li>切换到”发现”时，左边的”遇见”页面仍被保留，右边的”消息”页面被初始化</li><li>切换到”消息”页面时效果与上面的类似，但”遇见”页面则会被销毁，因为它相对当前的位置已超过 <code>offscreenPageLimit</code></li></ul><h2 id="traceview-分析"><a href="#traceview-分析" class="headerlink" title="traceview 分析"></a>traceview 分析</h2><p><img src="/images/index_activity.png" alt></p><p><img src="/images/from_json.png" alt></p><p>traceview 分析 IndexActivity 的生命周期，看不出任何异常。但 <code>UserPref.getRemoteUserInfo()</code> 方法引起我们的注意，它的耗时有些异常。而这个方法被”遇见”和”我的”等fragment 调用了一共5次。</p><p>前面提到过 IndexActivity 由”遇见”，”发现”，”消息”和”我的”一共4个 fragment 组成。这里的 fragment 由 ViewAdapter 提供，而 ViewAdapter 的数据来自一个FragmentStatePagerAdapter。<code>viewAdapter.setOffscreenPageLimit(3)</code>被调用。</p><h1 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h1><p>避免主线程中过多的JSON反序列化。</p><p>UserInfo对象表示当前用户，这个对象比较大，结构复杂。该对象JSON序列化后持久化到SharedPreference当中。</p><p>初始化IndexActivity的过程，会从SharedPreference读取数据反序列化为UserInfo对象。设计不当导致会频繁在主线程中进行反序列化。</p><p>优化后，我们只需要一次反序列化，减轻主线程压力。</p><p>优化后OPPO R7sm上首页的启动速度如下</p><table><thead><tr><th>第一次</th><th>第二次</th><th>第三次</th><th>第四次</th><th>第五次</th><th>平均</th></tr></thead><tbody><tr><td>389ms</td><td>375ms</td><td>429ms</td><td>405ms</td><td>414ms</td></tr></tbody></table><h1 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h1><p>优化 Fragment 的加载。主要有两个策略：</p><ul><li>一个最简单的做法是，调整 PageLimit 数量。 PageLimit 越小，同时加载的 Fragment 越少。</li><li>Fragment 懒加载。即使 PageLimit 设置成 1，首次启动时也会同时加载两个 Fragment，可以使用懒加载进一步优化。</li></ul><h2 id="调整-PageLimit-数量"><a href="#调整-PageLimit-数量" class="headerlink" title="调整 PageLimit 数量"></a>调整 PageLimit 数量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaggedFragmentPagerAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentStatePagerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">Log.i(<span class="string">"TaggedFragmentPagerAdapter"</span>, <span class="string">"getItem for position="</span> + position);</span><br><span class="line"><span class="keyword">switch</span> (position): &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> 遇见Fragment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> 发现Fragment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span> 消息Fragment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">return</span> 我的Fragment;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IndexActivity中四个fragment的初始化过程如下。但发现IndexActivity启动时，打印的日志表明四个fragment被马上全部创建。而fragment创建时会立即请求后台数据，导致更多的开销。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TaggedFragmentPagerAdapter: getItem for position=0</span><br><span class="line">TaggedFragmentPagerAdapter: getItem for position=1</span><br><span class="line">TaggedFragmentPagerAdapter: getItem for position=2</span><br><span class="line">TaggedFragmentPagerAdapter: getItem for position=3</span><br></pre></td></tr></table></figure><p>去掉 <code>viewAdapter.setOffscreenPageLimit(3)</code> 调用后，打印的日志如表明启动IndexActivity时只会创建前两个fragment。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TaggedFragmentPagerAdapter: getItem for position=0</span><br><span class="line">TaggedFragmentPagerAdapter: getItem for position=1</span><br></pre></td></tr></table></figure><h2 id="Fragment-懒加载"><a href="#Fragment-懒加载" class="headerlink" title="Fragment 懒加载"></a>Fragment 懒加载</h2><p>“遇见”页面又细分为”随遇”和”推荐”，启动IndexActivity时只初始化”随遇”即可。但目前是”随遇”和”推荐”都被初始化了。使用<code>FragmentPagerAdapter</code> + <code>ViewPager</code>实现，ViewPager的offscreenPageLimit最小为1，所以肯定会至少加载两个fragment，导致”随遇”和”推荐”都被初始化。</p><p>通过如下方式延迟”推荐”的加载过程。<a href="http://blog.csdn.net/yewei02538/article/details/50329119" target="_blank" rel="noopener">来源</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecommendFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mViewCreated;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">view = ...</span><br><span class="line">mViewCreated = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserVisibleHint</span><span class="params">(<span class="keyword">boolean</span> isVisibleToUser)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.setUserVisibleHint(isVisibleToUser);</span><br><span class="line"><span class="keyword">if</span> (isVisibleToUser &amp;&amp; mViewCreated) &#123;</span><br><span class="line">loadData();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mViewCreated = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后启动时间的变化</p><table><thead><tr><th>第一次</th><th>第二次</th><th>第三次</th><th>第四次</th><th>第五次</th><th>平均</th></tr></thead><tbody><tr><td>256ms</td><td>274ms</td><td>262ms</td><td>266ms</td><td>277ms</td></tr></tbody></table><p>优化后的另一个额外收益是启动时请求数的减少了</p><h1 id="更多优化"><a href="#更多优化" class="headerlink" title="更多优化"></a>更多优化</h1><p>抓取<a href="/images/ddms7813906848591170267.trace">traceview文件</a>进行分析。耗时较多的方法统计如下(统计依据是IndexActivity启动过程中在主线程中运行且”Incl Cpu Time”占比超过1%)：</p><p><img src="/images/perf1.png" alt><br><img src="/images/perf2.png" alt><br><img src="/images/perf3.png" alt><br><img src="/images/perf4.png" alt><br><img src="/images/perf5.png" alt><br><img src="/images/perf6.png" alt><br><img src="/images/perf7.png" alt><br><img src="/images/perf8.png" alt><br><img src="/images/perf9.png" alt><br><img src="/images/perf10.png" alt><br><img src="/images/perf11.png" alt><br><img src="/images/perf12.png" alt></p><p>这里的耗时方法可以分为两类，一类是消耗时间远超预期，比如<code>CampusApplication.getVideoUrl()</code>，看名字它应该不会耗时太多。一类是是这些方法不应该运行，或者说是可以避免运行的。下面详细分析。</p><ul><li><code>CampusApplication.getVideoUrl()</code> 性能较低导致 <code>MostMatchAdapter.onBindViewHolder()</code> 性能低</li><li>复杂布局导致 <code>MostMatchAdapter.onCreateViewHolder()</code> 性能低</li><li><code>TweetResponsePref.getTweet()</code> 在主线程中反序列化，导致性能低</li><li><code>NetworkUtil.isNetWorkConnectedGood()</code> 耗时多(?)</li><li><code>MostMatchAdapter.onMeasure()</code> 中调用 <code>SystemUtils.getScreenWidth()</code> 和 <code>SystemUtils.getScreenHeight()</code> 耗时多</li><li><code>MostMatchAdapter.onCreateViewHolder()</code> 性能低导致 <code>RecyclerViewPagerAdatper.onCreateViewHolder()</code> 耗时多</li><li><code>MostMatchAdapter.onBindViewHolder()</code> 性能低导致 <code>RecyclerViewPagerAdatper.onBindViewHolder()</code> 耗时多</li><li><code>TweetResponsePref.getTweet()</code> 性能低导致 <code>FindPresenterImpl.getFriendTweets()</code> 的回调耗时多</li><li>布局复杂导致 <code>RecommendPresenterImpl.getLikeRank()</code> 的回调耗时多(根源在于 <code>RecommendFragment.onGetLikeRank()</code> 的 inflate 有问题)</li><li>布局复杂导致 <code>RecommendFragment.onGetNewStudents()</code> 耗时较多</li><li><code>TweetResponsePref.getTweet()</code> 性能低导致 <code>FindFragment.initHeaderView()</code> 和 <code>FindFragment.onCreateView()</code> 耗时多</li><li><code>TweetResponsePref.getTweet()</code> 性能低导致 <code>FindFragment.onGetFriendTweets()</code> 耗时较多</li><li>布局复杂导致 <code>RecommendFragment.onCreateView()</code> 耗时较多</li><li><code>NetworkUtil.isNetWorkConnectedGood()</code> 耗时多导致 <code>autoPlayVideo()</code> 耗时多</li></ul><p><code>TweetResponsePref.getTweet()</code>中有JSON反序列化的操作，在主线程中调用时会严重拖慢UI。修改调用方式，将这些操作放到后台线程中。</p><table><thead><tr><th>第一次</th><th>第二次</th><th>第三次</th><th>第四次</th><th>第五次</th><th>平均</th></tr></thead><tbody><tr><td>315ms</td><td>307ms</td><td>325ms</td><td>312ms</td><td>305ms</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android-studio-shortcut</title>
      <link href="2018/11/14/android-studio-shortcut/"/>
      <url>2018/11/14/android-studio-shortcut/</url>
      
        <content type="html"><![CDATA[<p>像使用VIM一样使用Android Studio<br><a id="more"></a></p><h1 id="Sync-Project-with-Gradle-Files"><a href="#Sync-Project-with-Gradle-Files" class="headerlink" title="Sync Project with Gradle Files"></a>Sync Project with Gradle Files</h1><p>就我自己而言，感觉Android开发中修改构建脚本是一个相当高频的操作。 一旦修改，Android Studio马上会提示你需要同步：<br><img src="sync-now.png" alt><br>不过貌似Android Studio并没有为”Sync now”配置快捷，所以我不得不拿鼠标点一下那个黄色提示条。这怎么行，赶紧给”Sync now”配置一个快捷键吧</p><p><img src="sync-project-with-gradle-files.png" alt></p><p>配置方法：Preferences &gt; Keymap &gt; Plug-ins &gt; Android Support &gt; Sync Project with Gradle Files &gt; Add Keyboard Shortcut</p><p>我设置的快捷键是”Shift+S”。从此以后”Shift+S”一下就可以轻松同步啦。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Instant Run浅析(三)</title>
      <link href="2018/11/13/reading-instant-run-source/"/>
      <url>2018/11/13/reading-instant-run-source/</url>
      
        <content type="html"><![CDATA[<p>我们知道，Android热修复的补丁通常是通过网络下发的，并且加载补丁后要重启进程才能生效。那么Instant Run的补丁是如何下发并且生效的呢？</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>先看这张图：</p><p><img src="bg.png" alt></p><p>图中的<code>base.apk</code>是首次运行应用时生成的apk包，<code>reload.dex</code>是接下来Instant Run运行生成的补丁包(<code>HelloWorld$override.class</code>被打包成<code>reload.dex</code>)。</p><p>前面两篇文章分别就图中某些问题进行了讨论：</p><ul><li><a href="https://www.sunmoonblog.com/2018/10/19/dive-into-run/">Android Studio是如何运行app的？</a> - 分析了点击Run或Apply Changes后是如何运行app的</li><li><a href="https://www.sunmoonblog.com/2018/10/30/instant-run-1/">Instant Run浅析(二)</a> - 分析了如何使用instrumentation技术生成<code>HelloWorld$override.class</code></li></ul><p>本篇要讨论的是补丁包如何被发送、接收以及加载。</p><p>为便于理解问题，先直接给出几个相关的知识点：</p><ul><li>首先必须了解的是，<font color="red">Instant Run是CS架构的，它分为服务端和客户端</font></li><li>Instant Run的客户端运行在Android Studio中</li><li>Instant Run的服务端运行在手机上的app进程</li></ul><p>也就是说，当你看见Android Studio的黄色闪电图标(Apply Change)亮起时，可以理解为Instant Run客户端成功连接/登录到Instant Run服务端，就像QQ客户端成功连接/登录QQ服务器端。这个比喻不完全准确，但二者并无本质上的不同。Instant Run客户端向Instant Run服务端发送消息，服务端处理消息并返回结果。</p><p>为了更直观地理解Instant Run，先看一个基于<code>instant-run-client</code>库开发的demo，代码见<a href="https://github.com/410063005/instant-run-demo" target="_blank" rel="noopener">Github</a>。这个demo有几个功能：</p><ul><li>让app弹出toast</li><li>让app重启当前activity</li><li>手工版的hot swap</li></ul><iframe width="1000" height="500" src="instant-run-client-demo.mp4" frameborder="0" allowfullscreen></iframe><p>demo的玩法如下：</p><ul><li>下载demo源码<a href="https://github.com/410063005/instant-run-demo" target="_blank" rel="noopener">Github</a></li><li>Android Studio中运行demo的app module，确认黄色闪电图标亮起</li><li>从上一步生成的<code>build-info.xml</code>文件找到token (一长串数字)</li><li>下载并运行<code>appclient.jar</code>，运行方法<code>java -jar appclient.jar</code></li></ul><p>注：</p><ul><li><code>build-info.xml</code>文件的具体路径是<code>/build/intermediates/build-info/debug/build-info.xml</code></li><li><code>appclient.jar</code>编译自demo源码中的appclient module，编译方法<code>./gradlew shadowJar</code></li></ul><p>视频中demo发出”put patches”指令后紧接着发出”restart activity”，原来的”hello”变成了”你好”。很神奇？一起来看看背后的原理吧。</p><h1 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a>架构分析</h1><p>上述demo是基于<code>instant-run-client</code>库实现的。<code>instant-run-client</code>和<code>instant-run-server</code>的关系大致如下图：</p><p><img src="instant-flow.png" alt></p><ul><li>Android Gradle Plugin生成patch</li><li><code>instant-run-client</code>发送patch</li><li><code>instant-run-server</code>接收并加载patch</li></ul><p>Instant Run的源码在ASOP的<code>platform/tools/base/</code>目录。<a href="https://android.googlesource.com/platform/tools/base/" target="_blank" rel="noopener">base项目</a>是ASOP中一个独立的git工程。注意，base项目无法独立编译。本文基于该项目<code>studio-master-dev</code>分支进行分支，最后一次提交是<code>ec8e2b78ea42ac57d6e63bf88a3e09e1713bcc08</code>。</p><p>代码结构很清晰，它分成以下几个模块：</p><p><img src="instant-run-project.png" alt></p><p>Instant Run各模块及主要类总结如下：</p><ul><li><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-common/" target="_blank" rel="noopener">common模块</a> - 公共组件</li><li><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-runtime/" target="_blank" rel="noopener">runtime模块</a> - Instant Run运行时</li><li><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-server/" target="_blank" rel="noopener">server模块</a> - Instant Run服务端</li><li><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-client/" target="_blank" rel="noopener">client模块</a> - Instant Run客户端</li></ul><table><thead><tr><th>模块</th><th>类名</th><th>功能</th></tr></thead><tbody><tr><td>common</td><td><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-common/src/main/java/com/android/tools/ir/common/ProtocolConstants.java" target="_blank" rel="noopener">ProtocolConstants</a></td><td>instant run协议</td></tr><tr><td>common</td><td><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-common/src/main/java/com/android/tools/ir/runtime/ApplicationPatch.java" target="_blank" rel="noopener">ApplicationPatch</a></td><td>对patch的路径及数据的封装</td></tr><tr><td>runtime</td><td><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-runtime/src/main/java/com/android/tools/ir/runtime/IncrementalChange.java" target="_blank" rel="noopener">IncrementalChange</a></td><td>关键的接口，代表代码变更</td></tr><tr><td>runtime</td><td><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-runtime/src/main/java/com/android/tools/ir/runtime/PatchesLoader.java" target="_blank" rel="noopener">PatchesLoader</a></td><td>关键接口，用于加载patch，具体见<code>AbstractPatchesLoaderImpl</code></td></tr><tr><td>server</td><td><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-server/src/main/java/com/android/tools/ir/server/Server.java" target="_blank" rel="noopener">Server</a></td><td>服务端的核心</td></tr><tr><td>client</td><td><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-client/src/main/java/com/android/tools/ir/client/UpdateMode.java" target="_blank" rel="noopener">UpdateMode</a></td><td>app加载patch后的启动模式</td></tr><tr><td>client</td><td><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-client/src/main/java/com/android/tools/ir/client/InstantRunBuildInfo.java" target="_blank" rel="noopener">InstantRunBuildInfo</a></td><td>对应于<code>build-info.xml</code>文件</td></tr><tr><td>client</td><td><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-client/src/main/java/com/android/tools/ir/client/InstantRunClient.java" target="_blank" rel="noopener">InstantRunClient</a></td><td>客户端的核心</td></tr></tbody></table><p>注意这里的两个重点：</p><ul><li><font color="red">Instant Run服务端被打包到APK</font></li><li><font color="red">Instant Run客户端被集成到Android Studio</font></li></ul><p>如果你不太了解<code>build-info.xml</code>，可以参考这里：</p><ul><li><a href="https://www.sunmoonblog.com/2018/10/26/instant-run/">(译)Instant Run</a></li><li><a href="https://www.sunmoonblog.com/2018/10/19/dive-into-run/">Android Studio是如何运行app的？</a> - 分析了点击Run或Apply Changes后是如何运行app的</li></ul><p>另外，<code>server</code>模块的<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-server/src/main/java/com/android/tools/ir/server/InstantRunContentProvider.java" target="_blank" rel="noopener">InstantRunContentProvider</a>很有意思，有必要提一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantRunContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMainProcess()) &#123;</span><br><span class="line">            Log.i(Logging.LOG_TAG, <span class="string">"starting instant run server: is main process"</span>);</span><br><span class="line">            Server.create(getContext());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.i(Logging.LOG_TAG, <span class="string">"not starting instant run server: not main process"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译<code>base.apk</code>你会发现构建系统偷偷帮你添加了<code>InstantRunContentProvider</code>，这么做的原因是利用<code>ContentProvider.onCreate()</code>早于<code>Application.onCreate()</code>运行的特点来简化Instant Run的实现。2016年Google推出Instant Run，在早期版本中为了能将Instant Run应用于<code>Application</code>，会向app中注入<code>BootstrapApplication</code>，这个<code>BootstrapApplication</code>代理到app原来的<code>Application</code>。<code>BootstrapApplication</code>方案带来不必要的复杂性，后期版本中采用<code>InstantRunContentProvider</code>方案。2016年关于Instant Run的技术博客中，比如<a href="https://blog.csdn.net/nupt123456789/article/details/51828701" target="_blank" rel="noopener">这篇</a>，经常可以看到<code>BootstrapApplication</code>，请注意避免踩坑。</p><p>如果你不相信<code>provider</code>比<code>application</code>先运行，可以看看日志。</p><p><img src="instant-run-provider.png" alt></p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>Instant Run客户端通过<code>ddmlib</code>库跟服务端通信。使用<code>ddmlib</code>时在<code>build.gradle</code>添加如下依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// https://mvnrepository.com/artifact/com.android.tools.ddms/ddmlib</span><br><span class="line">compile &apos;com.android.tools.ddms:ddmlib:26.2.1&apos;</span><br></pre></td></tr></table></figure><h2 id="Instant-Run客户端"><a href="#Instant-Run客户端" class="headerlink" title="Instant Run客户端"></a>Instant Run客户端</h2><p><code>instant-run-client</code>模块并不复杂，这是它的类图。</p><p><img src="instant-run-client-classes.png" alt></p><p><code>instant-run-client</code>最终会调用<code>ServiceCommunicator.talkToService(IDevice device, Communicator&lt;T&gt; communicator)</code>跟Android设备通信的。</p><ul><li><code>device</code>参数通过<code>ddmlib</code>库获取<ul><li>使用<code>ddmlib</code>获取device列表的方法可参考<a href="https://github.com/410063005/instant-run-demo/blob/master/appclient/src/main/java/com/sunmoonblog/appclient/Demo.java#L29" target="_blank" rel="noopener">这里</a></li><li>通信前<code>device</code>通过本地的TCP 46622端口跟远程的Unix Domain Socket建立端口转发关系</li></ul></li><li><code>communicator</code>参数封装了通信逻辑，<code>ProtocolConstants</code>中的每个命令字都有对应的<code>Communicator</code>实现</li></ul><p><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-client/src/main/java/com/android/tools/ir/client/InstantRunClient.java" target="_blank" rel="noopener">InstantRunClient</a>有如下几个重要方法：</p><ul><li><code>getAppState()</code></li><li><code>showToast()</code></li><li><code>restartActivity()</code></li><li><code>pushPatches()</code></li></ul><p>鉴于这些方法非常容易理解，这里就不做无聊的分析。有兴趣可以参考前面提到的<a href="https://github.com/410063005/instant-run-demo" target="_blank" rel="noopener">demo</a>。</p><h2 id="Instant-Run服务端"><a href="#Instant-Run服务端" class="headerlink" title="Instant Run服务端"></a>Instant Run服务端</h2><p><strong>Server是Instant Run服务端的核心，它是一个典型的服务端程序</strong>。</p><p>不过跟常见的服务端程序有所不同的是，<code>Server</code>使用<a href="https://developer.android.com/reference/android/net/LocalServerSocket" target="_blank" rel="noopener">LocalServerSocket</a>以及<a href="https://developer.android.com/reference/android/net/LocalSocket" target="_blank" rel="noopener">LocalSocket</a>编程，而不是Java中常用的<code>ServerSocket</code>以及<code>Socket</code>编程。</p><p>查文档知道<code>LocalServerSocket</code>和<code>LocalSocket</code>是Android平台特有的类，它们与<code>Socket</code>的区别可参考<a href="https://stackoverflow.com/questions/12580415/what-if-the-difference-between-android-localserversocket-and-java-serversocket" target="_blank" rel="noopener">这里</a></p><p><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-server/src/main/java/com/android/tools/ir/server/Server.java" target="_blank" rel="noopener">Server</a>的核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LocalServerSocket serverSocket = Server.<span class="keyword">this</span>.serverSocket;</span><br><span class="line">                <span class="keyword">if</span> (serverSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// stopped?</span></span><br><span class="line">                &#125;</span><br><span class="line">                LocalSocket socket = serverSocket.accept();</span><br><span class="line">                SocketServerReplyThread socketServerReplyThread = <span class="keyword">new</span> SocketServerReplyThread(</span><br><span class="line">                        socket);</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种代码结构是不是很眼熟？总结一下它的套路：</p><ol><li>启动<code>SocketServerThread</code>线程 </li><li><code>SocketServerThread</code>线程进入无限循环 </li><li><code>accept()</code>监听客户端连接 </li><li>启动<code>SocketServerReplyThread</code>线程处理客户端连接 </li><li>跳转到2，继续循环 </li></ol><p><code>SocketServerReplyThread.handle()</code>方法负责处理客户端消息，我们感兴趣的消息指令见下表。</p><table><thead><tr><th>命令字</th><th>功能</th></tr></thead><tbody><tr><td><code>MESSAGE_PING</code></td><td>检查服务端在线状态。 服务端在线时Android Studio的黄色闪电图标亮起</td></tr><tr><td><code>MESSAGE_SHOW_TOAST</code></td><td>通知服务端弹出Toast提示</td></tr><tr><td><code>MESSAGE_RESTART_ACTIVITY</code></td><td>通知服务端重启当前activity 。某些修改必须重起activity才能生效</td></tr><tr><td><code>MESSAGE_PATCHES</code></td><td>向服务端发送patch</td></tr></tbody></table><p><code>MESSAGE_PATCHES</code>的处理流程如下：</p><p><img src="message_patches.png" alt></p><p>再来看对应的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(DataInputStream input, DataOutputStream output)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MESSAGE_PATCHES: &#123;</span><br><span class="line"><span class="keyword">if</span> (!authenticate(input)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;ApplicationPatch&gt; changes = ApplicationPatch.read(input);</span><br><span class="line"><span class="keyword">if</span> (changes == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> hasResources = hasResources(changes);</span><br><span class="line"><span class="comment">// 第1处，初始的 updateMode 值由客户端发过来</span></span><br><span class="line"><span class="keyword">int</span> updateMode = input.readInt();</span><br><span class="line"><span class="comment">// 第2处， 服务端重新计算updateMode</span></span><br><span class="line">updateMode = handlePatches(changes, hasResources, updateMode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> showToast = input.readBoolean();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send an "ack" back to the IDE; this is used for timing purposes only</span></span><br><span class="line">output.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">restart(updateMode, hasResources, showToast);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">handlePatches</span><span class="params">(@NonNull List&lt;ApplicationPatch&gt; changes, <span class="keyword">boolean</span> hasResources,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> updateMode)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (hasResources) &#123;</span><br><span class="line">FileManager.startUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ApplicationPatch change : changes) &#123;</span><br><span class="line">String path = change.getPath();</span><br><span class="line"><span class="comment">// 第3处，更新代码或更新资源</span></span><br><span class="line"><span class="keyword">if</span> (path.equals(RELOAD_DEX_FILE_NAME)) &#123;</span><br><span class="line">updateMode = handleHotSwapPatch(updateMode, change);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isResourcePath(path)) &#123;</span><br><span class="line">updateMode = handleResourcePatch(updateMode, change, path);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hasResources) &#123;</span><br><span class="line">FileManager.finishUpdate(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> updateMode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handleResourcePatch</span><span class="params">(<span class="keyword">int</span> updateMode, @NonNull ApplicationPatch patch,</span></span></span><br><span class="line"><span class="function"><span class="params">@NonNull String path)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Log.isLoggable(Logging.LOG_TAG, Log.VERBOSE)) &#123;</span><br><span class="line">Log.v(Logging.LOG_TAG, <span class="string">"Received resource changes ("</span> + path + <span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line">FileManager.writeAaptResources(path, patch.getBytes());</span><br><span class="line"><span class="comment">//noinspection ResourceType</span></span><br><span class="line"><span class="comment">// 第4处代码，资源更新时，updateMode至少是WARM_SWAP</span></span><br><span class="line">updateMode = Math.max(updateMode, UPDATE_MODE_WARM_SWAP);</span><br><span class="line"><span class="keyword">return</span> updateMode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意第3处代码，它在更新资源或代码。更新代码时会调用<code>handleHotSwapPatch()</code>，它是加载patch的关键所在，代码如下(为了保持代码清晰这里仅保留主要部分)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">handleHotSwapPatch</span><span class="params">(<span class="keyword">int</span> updateMode, @NonNull ApplicationPatch patch)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         String dexFile = FileManager.writeTempDexFile(patch.getBytes());</span><br><span class="line">         String nativeLibraryPath = FileManager.getNativeLibraryFolder().getPath();</span><br><span class="line">         <span class="comment">// 第5处，从dex文件加载指定类</span></span><br><span class="line">         DexClassLoader dexClassLoader = <span class="keyword">new</span> DexClassLoader(dexFile,</span><br><span class="line">                 context.getCacheDir().getPath(), nativeLibraryPath,</span><br><span class="line">                 getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">         <span class="comment">// we should transform this process with an interface/impl</span></span><br><span class="line">         Class&lt;?&gt; aClass = Class.forName(</span><br><span class="line">                 <span class="string">"com.android.tools.ir.runtime.AppPatchesLoaderImpl"</span>, <span class="keyword">true</span>, dexClassLoader);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 第6处，创建loader实例并加载patch</span></span><br><span class="line">             PatchesLoader loader = (PatchesLoader) aClass.newInstance();</span><br><span class="line">             <span class="keyword">if</span> (!loader.load()) &#123;</span><br><span class="line"><span class="comment">// 第7处，更新updateMode</span></span><br><span class="line">                 updateMode = UPDATE_MODE_COLD_SWAP;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             Log.e(Logging.LOG_TAG, <span class="string">"Couldn't apply code changes"</span>, e);</span><br><span class="line"><span class="comment">// 第8处，更新updateMode</span></span><br><span class="line">             updateMode = UPDATE_MODE_COLD_SWAP;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">         Log.e(Logging.LOG_TAG, <span class="string">"Couldn't apply code changes"</span>, e);</span><br><span class="line"><span class="comment">// 第9处，更新updateMode</span></span><br><span class="line">         updateMode = UPDATE_MODE_COLD_SWAP;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> updateMode;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>第5处代码：从dex文件中加载<code>AppPatchesLoaderImpl</code></li><li>第6处代码：创建loader实例并加载patch</li><li>第7，8，9处代码：loader加载patch不成功或者发生异常时，updateMode直接升级为<code>COLD_SWAP</code></li></ul><p>关于这段代码还应注意的是classloader之间是如何建立关系的：</p><p><img src="classloader.png" alt></p><p>上面的代码中使用<code>AppPatchesLoaderImpl</code>加载其他类。<code>AppPatchesLoaderImpl</code>由Android Gradle Plugin生成，我们看不到源码。不过可以在<code>build/intermediates/transforms/instantRun/debug</code>目录找对应的类文件，其反编译结果如下。</p><p><img src="hello-world-apppatch.png" alt></p><p><code>getPatchedClasses()</code>方法返回的<code>String[]</code>记录了本次修改的类。就本次而言，仅修改了<code>HelloWorld</code>。</p><p><code>AbstractPatchesLoaderImpl</code>是<code>AppPatchesLoaderImpl</code>的父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPatchesLoaderImpl</span> <span class="keyword">implements</span> <span class="title">PatchesLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个方法用于加载patch</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String className : getPatchedClasses()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ClassLoader cl = getClass().getClassLoader();</span><br><span class="line">                Class&lt;?&gt; aClass = cl.loadClass(className + <span class="string">"$override"</span>);</span><br><span class="line">                Object o = aClass.newInstance();</span><br><span class="line"></span><br><span class="line">                Class&lt;?&gt; originalClass = cl.loadClass(className);</span><br><span class="line">                Field changeField = originalClass.getDeclaredField(<span class="string">"$change"</span>);</span><br><span class="line">                <span class="comment">// force the field accessibility as the class might not be "visible"</span></span><br><span class="line">                <span class="comment">// from this package.</span></span><br><span class="line">                changeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                Object previous =</span><br><span class="line">                        originalClass.isInterface()</span><br><span class="line">                                ? patchInterface(changeField, o)</span><br><span class="line">                                : patchClass(changeField, o);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法用于指定要加载哪些patch类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String[] getPatchedClasses();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbstractPatchesLoaderImpl.load()</code>用于加载patch。以<code>HelloWorld</code>为例，<code>load()</code>方法的几个关键操作如下：</p><ul><li>加载<code>HelloWorld$override</code>类</li><li>创建<code>HelloWorld$override</code>实例</li><li>找到<code>HelloWorld</code>类的<code>$change</code>字段</li><li>将<code>HelloWorld$override</code>实例设置到<code>$change</code>字段。参考<a href="https://www.sunmoonblog.com/2018/10/30/instant-run-1/">Instant Run浅析(二)</a></li></ul><h1 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h1><p>这里记录了一些有用的知识点，分析Instant Run源码时可能会用到。</p><h2 id="updateMode"><a href="#updateMode" class="headerlink" title="updateMode"></a>updateMode</h2><p><code>InstantRunClient.pushPatches()</code>用于发送patch，这个方法返回<code>UpdateMode</code>。通过<code>pushPatches()</code>的代码容易明白<font color="red"><strong>updateMode是由Android gradle plugin，instant-run-server以及Android Studio三方共同确定的</strong> ，instant-run-client 充当协调者</font></p><p>用图画出来大概是这样：</p><p><img src="calc-update-mode.png" alt></p><p>总结一下就是以下三个影响因素，其中最重要的是<code>build-info.xml</code>：</p><ul><li><code>build-info.xml</code> - Android gradle plugin生成的<code>build-info.xml</code> (文件路径<code>/build/intermediates/build-info/debug/build-info.xml</code>)</li><li>app状态信息 - 运行状态、前台状态以及 <code>AbstractPatchesLoaderImpl.load()</code> 返回值</li><li>Android Studio <em>instant run设置</em> - 见下图</li></ul><p><img src="update-mode.png" alt></p><p>instant-run-client作为协调者综合考量这三个因素，得到最终的updateMode，而最终的updateMode决定app是否会被重启。</p><h2 id="build-info-xml"><a href="#build-info-xml" class="headerlink" title="build-info.xml"></a>build-info.xml</h2><p>Android Studio开启instant run之后，每次instant run的编译信息记录在<code>/build/intermediates/build-info/debug/build-info.xml</code>文件中。文件内容类似这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">instant-run</span></span></span><br><span class="line"><span class="tag">    <span class="attr">abi</span>=<span class="string">"x86,armeabi-v7a,armeabi"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">api-level</span>=<span class="string">"24"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">build-mode</span>=<span class="string">"COLD"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">density</span>=<span class="string">"420dpi"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">format</span>=<span class="string">"10"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ir-eligibility</span>=<span class="string">"SYNTHETIC_CONSTRUCTOR_CHANGE"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">plugin-version</span>=<span class="string">"3.1.3"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">timestamp</span>=<span class="string">"1537942541795"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">token</span>=<span class="string">"-1881962896096570399"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">verifier</span>=<span class="string">"COLD_SWAP_REQUESTED"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span></span></span><br><span class="line"><span class="tag">        <span class="attr">build-mode</span>=<span class="string">"COLD"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ir-eligibility</span>=<span class="string">"SYNTHETIC_CONSTRUCTOR_CHANGE"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timestamp</span>=<span class="string">"1537942541795"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">verifier</span>=<span class="string">"COLD_SWAP_REQUESTED"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifact</span></span></span><br><span class="line"><span class="tag">            <span class="attr">location</span>=<span class="string">"/Users/build/intermediates/split-apk/debug/slices/slice_2.apk"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">"SPLIT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">instant-run</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接看xml文件会有些无聊，结合代码容易理解一些。</p><ul><li><code>InstantRunBuildInfo</code> - instant run编译信息，对应于<code>build-info.xml</code>的<code>&lt;instant-run&gt;</code>节点</li><li><code>InstantRunArtifact</code> - instant run编译结果，对应于<code>build-info.xml</code>的<code>&lt;artifact&gt;</code>节点。编译结果本质上文件</li><li><code>InstantRunArtifactType</code> - instant run编译结果的类型，对应于<code>build-info.xml</code>中<code>&lt;artifact&gt;</code>节点的type属性</li></ul><p><code>InstantRunArtifactType</code>分为以下几种类型：</p><ul><li><code>MAIN</code> - 包含资源文件的主APK </li><li><code>SPLIT_MAIN</code> - 包含资源文件的主APK，适用于分包(多个APK文件)的场景</li><li><code>SPLIT</code> - 分包APK</li><li><code>RELOAD_DEX</code> - 代码更新包</li><li><code>RESOURCES</code> - 资源更新包</li></ul><p>instant run会进行根据情况进行不同类型的构建，每次构建会生成一个<code>&lt;build&gt;</code>节点保存到<code>build-info.xml</code>中：</p><ul><li><code>FULL</code> - 全量构建，一般发生在首次运行instant run时。生成一个类型为<code>SPLIT_MAIN</code>的apk文件以及一个或多个类型为<code>SPLIT</code>的apk文件</li><li><code>HOT_WARM</code> - 一般发生在进行了兼容的改动之后。生成类型为 <code>RELOAD_DEX</code> 的dex文件，或者类型为<code>RESOURCES</code>的ap_文件</li><li><code>COLD</code> - 一般发生在进行了不兼容的改动后。生成类型为<code>SPLIT</code>的文件</li></ul><p><img src="build-info.png" alt></p><p><code>build-info.xml</code>中还会记录两个关键信息：</p><ul><li><code>duration</code> - 最后一次构建时各任务的耗时信息</li><li><code>ir-eligibility</code> - 违反哪条规则导致COLD构建。比如修改方法签名会导致COLD构建，这时的<code>ir-eligibility</code>是METHOD_DELETED</li></ul><p>当你发生instant run运行慢或者行为不符合预期，<code>build-info.xml</code>或许能提供一些线索。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">instant-run</span> <span class="attr">build-mode</span>=<span class="string">"COLD"</span> <span class="attr">ir-eligibility</span>=<span class="string">"METHOD_DELETED"</span> <span class="attr">verifier</span>=<span class="string">"COLD_SWAP_REQUESTED"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">task</span> <span class="attr">name</span>=<span class="string">"javac"</span> <span class="attr">duration</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">task</span> <span class="attr">name</span>=<span class="string">"instant-run-dex"</span> <span class="attr">duration</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">task</span> <span class="attr">name</span>=<span class="string">"instant-run-transform"</span> <span class="attr">duration</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">task</span> <span class="attr">name</span>=<span class="string">"verifier"</span> <span class="attr">duration</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">instant-run</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用如下命令在<code>platform/tools/base/</code>工程中搜索”build-info”字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.java&quot; | xargs grep &quot;build-info&quot;</span><br></pre></td></tr></table></figure><p>可以找到几个跟<code>build-info.xml</code>相关的类：</p><ul><li>BuildInfoWriterTask</li><li>ApplicationTaskManager</li><li>InstantRunBuildContext</li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>这里介绍几个跟Instant Run相关的重要日志。</p><h3 id="Instant-Run日志"><a href="#Instant-Run日志" class="headerlink" title="Instant Run日志"></a>Instant Run日志</h3><p>小技巧：instant run打印了非常详尽的日志。打开日志后运行代码，对照着日志和运行结果分析代码，看”动”的代码比看”静止”的代码更简单。adb shell中执行<code>setprop log.tag.InstantRun VERBSOE</code>命令可以打开instant run日志。</p><p>instant run日志类似这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">09-27 18:16:25.766 7749-7867 V/InstantRun: Received Ping message from the IDE; returned active = true</span><br><span class="line">09-27 18:16:25.769 7749-7867 V/InstantRun: Received EOF from the IDE</span><br><span class="line">09-27 18:16:25.783 7749-7867 V/InstantRun: Received connection from IDE: spawning connection thread</span><br><span class="line">09-27 18:16:25.787 7749-7867 V/InstantRun: Received incremental code patch</span><br><span class="line">09-27 18:16:25.794 7749-7867 V/InstantRun: Writing new dex file: /data/data/com.sunmoonblog.demo_screenshot/files/instant-run/dex-temp/reload0x0004.dex</span><br><span class="line">09-27 18:16:25.798 7749-7867 V/InstantRun: Reading live code from /data/data/com.sunmoonblog.demo_screenshot/files/instant-run/dex-temp/reload0x0004.dex</span><br><span class="line">09-27 18:16:25.978 7749-7867 V/InstantRun: Got the patcher class class com.android.tools.ir.runtime.AppPatchesLoaderImpl</span><br><span class="line">    Got the patcher instance com.android.tools.ir.runtime.AppPatchesLoaderImpl@1314ec2</span><br><span class="line">    Got the list of classes </span><br><span class="line">    class com.sunmoonblog.demo_screenshot.MainActivity</span><br><span class="line">09-27 18:16:25.982 7749-7867 V/InstantRun: Finished loading changes; update mode =1</span><br><span class="line">    Applying incremental code without restart</span><br><span class="line">09-27 18:16:25.984 7749-7867 V/InstantRun: About to show toast for activity com.sunmoonblog.demo_screenshot.MainActivity@665fe86: Applied code changes without activity restart</span><br><span class="line">    Received EOF from the IDE</span><br></pre></td></tr></table></figure><h3 id="Android-Studio日志"><a href="#Android-Studio日志" class="headerlink" title="Android Studio日志"></a>Android Studio日志</h3><p><a href="https://developer.android.com/studio/report-bugs?utm_source=android-studio#instant-run-bugs" target="_blank" rel="noopener">Android Studio日志</a> - 在Android Studio - Help - Show Log in Finder中可以找到这些日志。强烈推荐看看<a href="https://developer.android.com/studio/report-bugs?utm_source=android-studio#instant-run-bugs" target="_blank" rel="noopener">官方介绍</a></p><p><img src="idea-log.png" alt></p><p>其中<code>idea.log</code>是Android Studio以及SDK运行时生成的日志，在这里可以找到<code>build-info.xml</code>中build-mode的根源。</p><h3 id="其他日志"><a href="#其他日志" class="headerlink" title="其他日志"></a>其他日志</h3><p>跟<code>idea.log</code>同级别有一个flr目录，其中包括几个重要日志。</p><p><img src="build-log.png" alt></p><ul><li><code>build.log</code> - This log captures build information from Gradle。这个日志跟Android Studio build工具栏中看到的日志是一样的，跟gradle带–info参数运行时看到的日志也是一样的。</li><li><code>build-info.xml</code> - 这个日志我们之前分析过，官方对它的介绍是这样的： This is an intermediate file that Android Studio uses to coordinate Instant Run features with the Android plugin for Gradle</li><li><code>profile.log</code> - This log provides a profile of how quickly Gradle progressed through each build task.</li></ul><p>注：你可能觉得这么既然Android Studio build工具栏(第1种方式)或<code>gradle --info</code>(第2种方式)者能看到日志，何必要那么麻烦去Android Studio的日志目录中找build.log文件。问题在于日志往往较多，第1种方式无法显示完整日志，不便于排查问题。而第2种方式压根不能进行instant run</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2018-09-30 10:37:10,325 [e-1024-b01]   INFO -                    #InstantRun - Invoking hotswap launch </span><br><span class="line">2018-09-30 10:37:11,216 [thread 878]   INFO -                    #InstantRun - Build timestamps: Local: 1538274511551, Device: 1538274511551 </span><br><span class="line">2018-09-30 10:37:11,247 [thread 878]   INFO -                    #InstantRun - Ping sent and replied successfully, application seems to be running. Foreground=true </span><br><span class="line">2018-09-30 10:37:11,267 [thread 878]   INFO -                    #InstantRun - Ping sent and replied successfully, application seems to be running. Foreground=true </span><br><span class="line">2018-09-30 10:37:11,924 [thread 878]   INFO - ools.idea.fd.InstantRunBuilder - BuildCause: APP_USES_MULTIPLE_PROCESSES, BuildMode: COLD </span><br><span class="line">...</span><br><span class="line">2018-09-30 10:37:45,834 [e-1024-b01]   INFO - ild.invoker.GradleBuildInvoker - Gradle build finished in 33s 900ms</span><br></pre></td></tr></table></figure><p>如果找不到上述日志，可以检查一下日志开关是否开启：</p><p><img src="insant-run-log.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单总结一下本文内容：</p><ul><li>Instant Run是CS架构</li><li>Android Studio作为客户端，app作为服务端</li><li>补丁包是由Android Studio发送到app</li><li>app加载hotswap类型补丁时不重启即可生效<ul><li><code>PatchesLoader</code>从补丁包加载<code>HelloWorld$override</code>类并创建其实例</li><li><code>HelloWorld$override</code>实例设置到<code>HelloWorld.$change</code>字段</li></ul></li><li>demo演示了<code>instant-run-client</code>库的用法，demo见<a href="https://github.com/410063005/instant-run-demo" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LayoutAnimationController介绍</title>
      <link href="2018/11/07/android-animation-2/"/>
      <url>2018/11/07/android-animation-2/</url>
      
        <content type="html"><![CDATA[<p>你或许注意到<code>android.view.animation</code>包下有个类很特别的类叫<code>LayoutAnimationController</code>。<br><a id="more"></a></p><h1 id="LayoutAnimationController介绍"><a href="#LayoutAnimationController介绍" class="headerlink" title="LayoutAnimationController介绍"></a>LayoutAnimationController介绍</h1><p>跟<code>AlphaAnimation</code>等类不同，<a href="https://developer.android.com/reference/android/view/animation/LayoutAnimationController" target="_blank" rel="noopener">LayoutAnimationController</a>并不是<code>Animation</code>的子类。先看看官方文档。</p><blockquote><p>A layout animation controller is used to animated a layout’s, or a view group’s, children. Each child uses the same animation but for every one of them, the animation starts at a different time. A layout animation controller is used by ViewGroup to compute the delay by which each child’s animation start must be offset. The delay is computed by using characteristics of each child, like its index in the view group. This standard implementation computes the delay by multiplying a fixed amount of miliseconds by the index of the child in its parent view group. Subclasses are supposed to override getDelayForView(android.view.View) to implement a different way of computing the delay. For instance, a GridLayoutAnimationController will compute the delay based on the column and row indices of the child in its parent view group. Information used to compute the animation delay of each child are stored in an instance of LayoutAnimationController.AnimationParameters, itself stored in the ViewGroup.LayoutParams of the view</p></blockquote><p>简单来说就是，<code>ViewGroup</code>使用<code>LayoutAnimationController</code>来计算子View动画的延迟时间。通常使用子View的某个特征来计算延迟时间，比如子View的索引。标准实现中是使用子View的索引乘上一个固定的时间。<code>LayoutAnimationController</code>的子类也可以重写<code>getDelayForView()</code>方法，以使用其它计算方式。比如<code>GridLayoutAnimationController</code>就是基于行索引和列索引来计算子View的动画的延迟时间。</p><p>用于计算每个子View动画延迟时间的信息保存在<code>LayoutAnimationController.AnimationParameters</code>参数中，而该参数本身又保存在<code>ViewGroup.LayoutParams</code>中。</p><h1 id="LayoutAnimationController用法"><a href="#LayoutAnimationController用法" class="headerlink" title="LayoutAnimationController用法"></a>LayoutAnimationController用法</h1><p>它的用法还是比较简单，所以直接上例子。</p><p><code>rv_item_list_anim.xml</code>用于指定item的动画。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:shareInterpolator</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alpha</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromAlpha</span>=<span class="string">"0.0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toAlpha</span>=<span class="string">"1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromXDelta</span>=<span class="string">"-100%"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toXDelta</span>=<span class="string">"0%"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>rv_layout_animation.xml</code>用于定义LayoutAnimationController。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layoutAnimation</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:animation</span>=<span class="string">"@anim/rv_item_list_anim"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:animationOrder</span>=<span class="string">"normal"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:delay</span>=<span class="string">"0.2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:interpolator</span>=<span class="string">"@android:anim/linear_interpolator"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><iframe width="300" height="500" src="layoutanimationcontroller.mp4" frameborder="0" allowfullscreen></iframe><h1 id="LayoutAnimationController源码分析"><a href="#LayoutAnimationController源码分析" class="headerlink" title="LayoutAnimationController源码分析"></a>LayoutAnimationController源码分析</h1><p><code>ViewGroup</code>使用<code>LayoutAnimationController</code>成员来实现动画效果。相关的方法包括：</p><ul><li><code>setLayoutAnimation()</code>和<code>getLayoutAnimation()</code> - 分别用于设置和获取动画</li><li><code>canAnimate()</code> - 判断是否有动画效果</li><li><code>startLayoutAnimation()</code> - 启动动画</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewGroup</span> <span class="keyword">extends</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>, <span class="title">ViewManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layout animation</span></span><br><span class="line">    <span class="keyword">private</span> LayoutAnimationController mLayoutAnimationController;</span><br><span class="line">    <span class="keyword">private</span> Animation.AnimationListener mAnimationListener;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the layout animation controller used to animate the group's</span></span><br><span class="line"><span class="comment">     * children.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current animation controller</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LayoutAnimationController <span class="title">getLayoutAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLayoutAnimationController;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the layout animation controller used to animate the group's</span></span><br><span class="line"><span class="comment">     * children after the first layout.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> controller the animation controller</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLayoutAnimation</span><span class="params">(LayoutAnimationController controller)</span> </span>&#123;</span><br><span class="line">        mLayoutAnimationController = controller;</span><br><span class="line">        <span class="keyword">if</span> (mLayoutAnimationController != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mGroupFlags |= FLAG_RUN_ANIMATION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates whether the view group has the ability to animate its children</span></span><br><span class="line"><span class="comment">     * after the first layout.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the children can be animated, false otherwise</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">canAnimate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLayoutAnimationController != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Runs the layout animation. Calling this method triggers a relayout of</span></span><br><span class="line"><span class="comment">     * this view group.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startLayoutAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mLayoutAnimationController != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mGroupFlags |= FLAG_RUN_ANIMATION;</span><br><span class="line">            requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>LayoutAnimationController</code>的时序图如下：</p><p><img src="lac-seq.png" alt></p><p>对几个关键步骤稍加说明：</p><ul><li>第5步 - 调用<code>LayoutAnimationController.getAnimationForView()</code>为child view创建animation</li><li>第6步 - 调用<code>LayoutAnimationController.start()</code>启动动画</li><li>第8步 - 注意这一步调用的是<code>boolean View.draw(Canvas canvas, ViewGroup parent, long drawingTime)</code>方法。所以其实最终又回到了前一篇所讲的<a href="https://www.sunmoonblog.com/2018/11/06/android-animation-1/#more">View Animation</a></li></ul><!--为什么用于ListView和RecyclerView时不够流畅???-->]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解Android View Animation</title>
      <link href="2018/11/06/android-animation-1/"/>
      <url>2018/11/06/android-animation-1/</url>
      
        <content type="html"><![CDATA[<p>Android的View Animation是如何实现的？<br><a id="more"></a><br>Android中的Tween动画由<code>android.view.animation</code>包实现。网上很容易找到<code>Animation</code>相关API的用法，那么背后的原理是什么样的呢？</p><p>我们由浅入深一步步来看。</p><p><img src="basic-step.png" alt></p><h1 id="几何与矩阵"><a href="#几何与矩阵" class="headerlink" title="几何与矩阵"></a>几何与矩阵</h1><p>参考自<a href="https://blog.csdn.net/oHeHeHou/article/details/46352277" target="_blank" rel="noopener">Android Matrix图形变换</a>和<a href="https://www.jianshu.com/p/6aa6080373ab" target="_blank" rel="noopener">深入理解 Android 中的 Matrix</a></p><p>可以从几何的角度考虑平面中的平移，旋转，缩放以及错切。前三者分别见下图：</p><p><img src="translate.jpg" alt></p><p><img src="rotate.jpg" alt></p><p><img src="scale.jpg" alt></p><p>引入矩阵(3x3矩阵)可简化并且统一上图中的方程式。为了便于表示，先将(x0, y0)和(x, y)从二维作扩展成三维：</p><ul><li>(x0, y0)写作矩阵X0 (x0, y0, 1)</li><li>(x, y)写作矩阵X (x, y, 1)</li></ul><p>所以原来的方程写成如下形式：</p><p>X = C * X0</p><p>其中，X0矩阵是变换前的点的位置，X矩阵是变换后的点的位置，C是变换矩阵。C的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ a  b  c</span><br><span class="line">  d  e  f</span><br><span class="line">  g  h  i ]</span><br></pre></td></tr></table></figure><p>不难求出进行平移变换时C的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ 1  0  ∆x</span><br><span class="line">  0  1  ∆y</span><br><span class="line">  0  0  1 ]</span><br></pre></td></tr></table></figure><p>类似地，旋转变换的时C的值如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ cosθ  -sinθ 0</span><br><span class="line">  sinθ  cosθ  0</span><br><span class="line">  0     0     1 ]</span><br></pre></td></tr></table></figure><p>缩放变换时C的值如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ k1  0   0</span><br><span class="line">  0   k2  0</span><br><span class="line">  0   0   1 ]</span><br></pre></td></tr></table></figure><p>另外还有一种错切变换的情形上述没有提及。错切变换时C的值如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ 1   k1  0</span><br><span class="line">  k2  1   0</span><br><span class="line">  0   0   1 ]</span><br></pre></td></tr></table></figure><p>所以对于矩阵</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ a  b  c</span><br><span class="line">  d  e  f</span><br><span class="line">  g  h  i ]</span><br></pre></td></tr></table></figure><ul><li>a, e 控制缩放变换</li><li>b, d 控制错切变换</li><li>c, f 控制平移变换</li></ul><p>下面这个demo演示上述参数是如何对变换进行控制的：</p><iframe width="300" height="500" src="matrix-demo.mp4" frameborder="0" allowfullscreen></iframe><h1 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h1><p>参考自<a href="https://blog.csdn.net/xx326664162/article/details/60142947" target="_blank" rel="noopener">Android Matrix图像变换处理</a></p><p><code>android.graphics.Matrix</code>类是用于坐标变换的3x3矩阵。坐标变换类型包括平移变换、旋转变换、缩放变换和错切变换。<code>Matrix</code>内部维护一个float[9]数组用于表示3x3矩阵，如上一节所述，实际上所有的变换其中本质上是修改矩阵中(即数组中)的某些值。不同于a,b,c这种命名，<code>Matrix</code>中每个值有更有意义的命名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ MSCALE_X, MSKEW_X,  MTRANS_X,</span><br><span class="line">  MSKEW_Y,  MSCALE_Y, MTRANS_Y,</span><br><span class="line">  MPERSP_0, MPERSP_1, MPERSP_2]</span><br></pre></td></tr></table></figure><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><p><code>Matrix</code>的两个最基本方法是向矩阵赋值<code>setValues()</code>，以及从矩阵获取值<code>getValues()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy 9 values from the matrix into the array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValues</span><span class="params">(<span class="keyword">float</span>[] values)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy 9 values from the array into the matrix. Depending on the implementation of Matrix,</span></span><br><span class="line"><span class="comment"> * these may be transformed into 16.16 integers in the Matrix, such that a subsequent call to</span></span><br><span class="line"><span class="comment"> * getValues() will not yield exactly the same values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValues</span><span class="params">(<span class="keyword">float</span>[] values)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>Matrix</code>的另一个基本操作是乘法。不过，矩阵的乘法不满足交换律。所以左乘<code>preConcat()</code>区别于右乘<code>postConcat()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the matrix to the concatenation of the two specified matrices and return true.</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment">public boolean setConcat(Matrix a, Matrix b);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Preconcats the matrix with the specified matrix. M' = M * other</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preConcat</span><span class="params">(Matrix other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Postconcats the matrix with the specified matrix. M' = other * M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postConcat</span><span class="params">(Matrix other)</span></span>;</span><br></pre></td></tr></table></figure><p>上述几个方法对应矩阵基本运算，可以写代码验证，这里不再赘述。</p><h2 id="高级方法"><a href="#高级方法" class="headerlink" title="高级方法"></a>高级方法</h2><p><code>Matrix</code>用于平移变换、旋转变换、缩放变换和错切变换其实质是修改矩阵的值。但直接调用<code>Matrix.setValues()</code>来修改是低级的做法，非常繁琐易错。<code>Matrix</code>提供了更高级的接口用于完成此类变换操作。</p><ul><li>Translate</li><li>Scale</li><li>Rotate</li><li>Skew</li></ul><p>除Translate外其他三种变换操作都可以围绕一个中心点来进行。对每种变换操作有<code>pre</code>, <code>post</code>和<code>post</code>三种不同形式API。</p><p><a href="https://blog.csdn.net/xx326664162/article/details/60142947" target="_blank" rel="noopener">Android Matrix图像变换处理 - 薛瑄的博客 - CSDN博客</a>中提到</p><blockquote><p>我们可以把Matrix变换想象成一个队列，队列里面包含了若干个变换操作，队列中每个操作按照先后顺序操作变换目标完成变换，pre相当于向队首增加一个操作，post相当于向队尾增加一个操作，set相当于清空当前队列重新设置</p></blockquote><p>下面这个demo演示上述API的变换效果：</p><iframe width="300" height="500" src="matrix-demo2.mp4" frameborder="0" allowfullscreen></iframe><h1 id="View-Animation"><a href="#View-Animation" class="headerlink" title="View Animation"></a>View Animation</h1><p><code>android.view.animation</code>包下主要类之间的关系：</p><p><img src="animation-classes.png" alt></p><p><code>View</code>, <code>Animation</code>, <code>Transformation</code>, <code>Matrix</code>之间的时序关系：</p><p><img src="animation-matrix.png" alt></p><p><code>View</code>, <code>Animation</code>, <code>Transformation</code>, <code>Matrix</code>之间的交互关系：</p><p><img src="animation-relationship.png" alt></p><p>理解以上内容后，不难自定义<code>Animation</code>。下面是一个自定义的<a href="http://www.aviyehuda.com/blog/2011/07/01/android-development-custom-animation/" target="_blank" rel="noopener">ColorAnimation</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorAnimation</span> <span class="keyword">extends</span> <span class="title">Animation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> View mView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mFromR;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mFromG;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mFromB;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mToR;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mToG;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mToB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColorAnimation</span><span class="params">(View view, <span class="keyword">int</span> fromColor, <span class="keyword">int</span> toColor)</span> </span>&#123;</span><br><span class="line">        mView = view;</span><br><span class="line"></span><br><span class="line">        mFromR = Color.red(fromColor);</span><br><span class="line">        mFromG = Color.green(fromColor);</span><br><span class="line">        mFromB = Color.blue(fromColor);</span><br><span class="line">        mToR = Color.red(toColor);</span><br><span class="line">        mToG = Color.green(toColor);</span><br><span class="line">        mToB = Color.blue(toColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">willChangeBounds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">willChangeTransformationMatrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyTransformation</span><span class="params">(<span class="keyword">float</span> interpolatedTime, Transformation t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = (<span class="keyword">int</span>) (mFromR + (mToR - mFromR) * interpolatedTime);</span><br><span class="line">        <span class="keyword">int</span> g = (<span class="keyword">int</span>) (mFromG + (mToG - mFromG) * interpolatedTime);</span><br><span class="line">        <span class="keyword">int</span> b = (<span class="keyword">int</span>) (mFromB + (mToB - mFromB) * interpolatedTime);</span><br><span class="line">        <span class="keyword">int</span> color = Color.rgb(r, g, b);</span><br><span class="line">        mView.setBackgroundColor(color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下：</p><iframe width="500" height="280" src="color-animation.mp4" frameborder="0" allowfullscreen></iframe><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developer.android.com/reference/android/view/animation/package-summary" target="_blank" rel="noopener">animation包</a></li><li><a href="https://developer.android.com/guide/topics/graphics/view-animation" target="_blank" rel="noopener">view animation</a></li><li><a href="https://blog.csdn.net/oHeHeHou/article/details/46352277" target="_blank" rel="noopener">Android Matrix图形变换</a></li><li><a href="https://blog.csdn.net/xx326664162/article/details/60142947" target="_blank" rel="noopener">Android Matrix图像变换处理</a></li><li><a href="https://www.jianshu.com/p/6aa6080373ab" target="_blank" rel="noopener">深入理解 Android 中的 Matrix</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Instant Run浅析(二)</title>
      <link href="2018/10/30/instant-run-1/"/>
      <url>2018/10/30/instant-run-1/</url>
      
        <content type="html"><![CDATA[<p>从使用体验上讲，Instant Run加快了开发效率，相当高大上。从技术上讲，其涉及到的技术点比较多，初看神秘又复杂。不过个人觉得Instant Run的复杂性主要在于工程实现，略过这种复杂性后聚焦其背后原理，会发现它还是非常简单明了的。<a href="https://www.sunmoonblog.com/2018/10/19/dive-into-run/">前一篇</a>中我们分析了Instant Run的流程，在此基础上再来看看Instant Run的原理。<br><a id="more"></a><br>本文的主要参考资料是：</p><ul><li><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/README.md" target="_blank" rel="noopener">instant-run</a> - 官方关于Instant Run实现目标和技术选型的介绍</li><li><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/instant-run-instrumentation/README.md" target="_blank" rel="noopener">instant-run-instrumentation</a> - 官方关于Instant Run插桩技术介绍</li></ul><p>我的博客中有这两篇文章的翻译，供参考：</p><ul><li><a href="https://www.sunmoonblog.com/2018/10/26/instant-run/">(译)Instant Run</a></li><li><a href="https://www.sunmoonblog.com/2018/10/28/instant-run-instrumentation/">(译)Instant Run Instrumentation</a></li></ul><p>看完上面两篇官方文档，你应该基本能明白Instant Run的原理。如果是这样的话，你可以直接忽略接下来的内容。不过为了检验一下自己是否真的有明白Instant Run，我还是要接着往下写。</p><p>首先，Instant Run的核心原理可以概括成以下两点：</p><ul><li><a href="https://en.wikipedia.org/wiki/Delegation_pattern" target="_blank" rel="noopener">Delegation pattern</a>，代理模式</li><li><a href="https://en.wikipedia.org/wiki/Instrumentation_(computer_programming" target="_blank" rel="noopener">Instrumentation</a> - Java插桩技术</li></ul><p>接下来分别就这两点展开讨论。</p><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>你会疑惑Instant Run怎么能跟代理模式扯上关系，是不是搞错了？但相信我没错。</p><p><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/instant-run-instrumentation/README.md" target="_blank" rel="noopener">instant-run-instrumentation</a>中指出：Instant Run为了规避Java类加载带来本身的限制带来的一些技术问题，并不玩classloader相关的黑科技，而是用了另外一个简单粗暴的方法(原文只说简单，粗暴是个人观点)。这里用Instant Run版本的<code>HelloWorld</code>作为例子来演示一下这个方法是如何简单粗暴。</p><p>假设你有个<code>HelloWorld</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现<code>HelloWorld</code>有个问题，它不具备”更新能力”。现在各种app都流行热修复啊，对不对？我们的<code>HelloWorld</code>不能更新不能热修那怎么行，万一有bug怎么办？</p><p>好吧，为了让其具备更新能力，代码改成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> IncrementalChange $change;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IncrementalChange var1 = $change;</span><br><span class="line">        <span class="keyword">if</span> (var1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            var1.access$dispatch(<span class="string">"sayHello.()V"</span>, <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会好奇这里的<code>IncrementalChange</code>是什么，请暂且放一放不和它纠结，它并不影响我们对以上代码的理解。这些代码含义很清晰：</p><ul><li>如果<code>$change</code>字段没被设置，代码逻辑没变化</li><li>如果<code>$change</code>字段有被设置(被设置成<code>HelloWorld$override</code>实例，后面会提到)，执行更新/修复后的逻辑</li></ul><p>简单来说，<code>HelloWorld</code>现在具备更新能力了！现在需求变了，这回我们的<code>HelloWorld</code>不说”hello”要说”你好”，代码改成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"你好"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是修改后的<code>HelloWorld</code>如何跟修改前的<code>HelloWorld</code>联系起来呢？这里用一张图来说明：</p><p><img src="flow1.png" alt></p><p>(特别需要注意的是， <em>上图中绿框表示的类文件才被真正被打包到APK中</em> )</p><p><code>HelloWorld$override</code>实现了<code>IncrementalChange</code>接口，可被设置到<code>$change</code>字段。其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span>$<span class="title">override</span> <span class="keyword">implements</span> <span class="title">IncrementalChange</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> HelloWorld$override() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> init$body(HelloWorld $<span class="keyword">this</span>, Object[] var1) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(HelloWorld $<span class="keyword">this</span>)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"你好"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object access$dispatch(String var1, Object... var2) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(var1.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">350191790</span>:</span><br><span class="line">            sayHello((HelloWorld)var2[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是Instant Run的核心原理。但有几个问题需要考虑：</p><ul><li>第2步的enhance过程 - 如何 <strong>自动修改</strong> 版本1的<code>HelloWorld</code>让其具备更新能力？</li><li>第5步的enhance过程 - 如何 <strong>自动修改</strong> 版本2的<code>HelloWorld</code>生成用于更新的版本？</li><li>第6步 - 如何设置<code>$change</code>字段</li></ul><p>本文只讨论前两个问题，它们本质上是同一个问题：我们不可能通过手工修改Java源文件的方式去实现Instant Run，而要借助Java插桩技术自动修改Java类文件。</p><h1 id="插桩技术"><a href="#插桩技术" class="headerlink" title="插桩技术"></a>插桩技术</h1><p>instrumentation，这个词指的应该是获取计算机软件或者硬件状态的数据的技术，一般翻译为插桩。字面意思理解起来有困难的话，可以这样考虑：</p><ul><li>你只管动手写版本1的<code>HelloWorld.java</code>。但是构建时有个家伙默默地帮你修改<code>HelloWorld</code>让其具备更新能力(第2步enhance过程，初始插桩)</li><li>你只管动手改版本1的<code>HelloWorld.java</code>，得到版本2的<code>HelloWorld.java</code>。那个神秘的家伙帮你生成<code>HelloWorld$override</code>(第5步enhance过程，增量插桩)</li></ul><p><img src="flow1.png" alt></p><p>instrumentation就是藏在背后那个神秘的家伙。</p><h2 id="ASM库"><a href="#ASM库" class="headerlink" title="ASM库"></a>ASM库</h2><p>其实在Java世界，instrumentation并不神秘，有各种instrumentation相关的库。</p><h3 id="ASM介绍"><a href="#ASM介绍" class="headerlink" title="ASM介绍"></a>ASM介绍</h3><p>Java中最常用的插桩库是<a href="https://asm.ow2.io/" target="_blank" rel="noopener">ASM</a>。这是关于ASM的介绍：</p><blockquote><p>ASM is an all purpose Java bytecode manipulation and analysis framework. It can be used to modify existing classes or to dynamically generate classes, directly in binary form. ASM provides some common bytecode transformations and analysis algorithms from which custom complex transformations and code analysis tools can be built. </p></blockquote><blockquote><p>The goal of the ASM library is to generate, transform and analyze compiled Java classes, represented as byte arrays (as they are stored on disk and loaded in the Java Virtual Machine). For this purpose ASM provides tools to read, write and transform such byte arrays by using higher level concepts than bytes, such as numeric constants, strings, Java identifiers, Java types, Java class structure elements, etc. Note that the scope of the ASM library is strictly limited to reading, writing, transforming and analyzing classes.</p></blockquote><p>翻译一下：</p><p>ASM是一个全功能型的Java字节码操作和分析框架。它用于修改已存在的类文件，或者直接以二进制形式生成动态类。ASM提供一些常用的字节码转换和分析算法，可以基于这些算法构建自定义的复杂转换和分析工具。</p><p>ASM库的目标是生成，转换或分析编译后的Java类，这些类以byte数组形式存在(它们保存在磁盘上，由JVM加载)。出于这个目的，ASM提供在更高层面而非字节层面提供读写和转换这些byte数组的方法，比如数字常量、字符串、Java关键字、Java类型、Java类结构等等。注意，ASM库的应用范围严格限定在读写、变换和分析Java类</p><p>更多ASM相关的内容可以参考这里：</p><ul><li><a href="https://asm.ow2.io/asm4-guide.pdf" target="_blank" rel="noopener">ASM user guide</a></li><li><a href="https://asm.ow2.io/developer-guide.html" target="_blank" rel="noopener">ASM developer guide</a></li></ul><p>Tips：ASM这个名字并非随便取的，它来自于C语言中的<code>__asm__</code>关键字。这个关键字允许在C语言中使用汇编语言。</p><h3 id="ASM-API模型"><a href="#ASM-API模型" class="headerlink" title="ASM API模型"></a>ASM API模型</h3><p>ASM提供两种API模型用于生成和转换Java类：核心API提供 <strong>基于事件</strong> 的表示模型，而tree API提供 <strong>基于对象</strong> 的表示模型。</p><ul><li>基于事件的API - 使用事件序列表示Java类，每个事件代表类中的一个元素。这个API定义了可能的事件以及这些事件需要遵守的顺序</li><li>基于对象的API - 使用对象树表示Java类，每个对象表示类中的一部分。这个API也可以将事件序列转换成对象树，或者反过来将对象树转换成事件序列</li></ul><p>ASM的这两种API模型有点像处理XML文档的API模型。基于事件的API类似于Simple API for XML (SAX)，而基于对象的API类似于Document Object Model (DOM)。</p><p>ASM的主要类之间的关系见<a href="https://asm.ow2.io/developer-guide.html" target="_blank" rel="noopener">这里</a>。ASM中有几个关键的角色，这几个角色可以组合成复杂处理流程：</p><ul><li>event producer(class parser)</li><li>event consumer(class writer)</li><li>event filter</li></ul><p>ASM库中最关键的类是<code>ClassVisitor</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassVisitor</span><span class="params">(<span class="keyword">int</span> api)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassVisitor</span><span class="params">(<span class="keyword">int</span> api, ClassVisitor cv)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">        String signature, String superName, String[] interfaces)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitSource</span><span class="params">(String source, String debug)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitOuterClass</span><span class="params">(String owner, String name, String desc)</span></span>; <span class="function">AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(String desc, <span class="keyword">boolean</span> visible)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitAttribute</span><span class="params">(Attribute attr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInnerClass</span><span class="params">(String name, String outerName, String innerName, <span class="keyword">int</span> access)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FieldVisitor <span class="title">visitField</span><span class="params">(<span class="keyword">int</span> access, String name, String desc,</span></span></span><br><span class="line"><span class="function"><span class="params">        String signature, Object value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc,</span></span></span><br><span class="line"><span class="function"><span class="params">        String signature, String[] exceptions)</span></span>; <span class="function"><span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ClassVisitor</code>中的每个方法对应于Java类文件中相应部分。Java类文件结构见下图。</p><p><img src="class-structure.png" alt></p><p>ASM基于<code>ClassVisitor</code>API提供以下三个核心组件：</p><ul><li><code>ClassReader</code> - 它作为event producer，用于解析byte数组中的Java类。它的<code>accept()</code>方法接收<code>ClassVisitor</code>实例作为参数，<code>ClassReader</code>调用该实例对应的<code>visitXxx()</code>方法</li><li><code>ClassWriter</code> - 它作为event consumer，是<code>ClassVisitor</code>的子类。<code>ClassWriter</code>用于构建Java类并输出到byte数组</li><li><code>ClassVisitor</code> - 它作为event filter，将收到的所有方法调用代理到另一个<code>ClassVisitor</code>实例</li></ul><p>好了讲了这么多虚点，上代码来点实的。<code>ClassPrinter</code>是基于ASM库的一个简化版本的<code>javap</code>程序，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPrinter</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPrinter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ASM5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature, String superName, String[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">        System.out.println(name + <span class="string">" extends "</span> + superName + <span class="string">" &#123;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FieldVisitor <span class="title">visitField</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, Object value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"    "</span> + name + <span class="string">" "</span> + desc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.visitField(access, name, desc, signature, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"    "</span> + name + <span class="string">" "</span> + desc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.visitEnd();</span><br><span class="line">        System.out.println(<span class="string">"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ClassPrinter cp = <span class="keyword">new</span> ClassPrinter();</span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(<span class="string">"java.lang.Runnable"</span>);</span><br><span class="line">        cr.accept(cp, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java/lang/Runnable extends java/lang/Object &#123;</span><br><span class="line">    run ()V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是另一个例子，这段代码用于修改字节码中的版本号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeVersionAdapter</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChangeVersionAdapter</span><span class="params">(ClassVisitor cv)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">super</span>(ASM4, cv);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, </span></span></span><br><span class="line"><span class="function"><span class="params">    String signature, String superName, String[] interfaces)</span> </span>&#123; </span><br><span class="line">cv.visit(V1_5, access, name, signature, superName, interfaces);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b1 = ...</span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(b1);</span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(cr, <span class="number">0</span>); ChangeVersionAdapter ca = <span class="keyword">new</span> ChangeVersionAdapter(cw); cr.accept(ca, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] b2 = cw.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类之间的关系如下图：</p><p><img src="relationship.png" alt></p><p>时序图：</p><p><img src="seq.png" alt></p><h2 id="InstantRunTransform"><a href="#InstantRunTransform" class="headerlink" title="InstantRunTransform"></a>InstantRunTransform</h2><p><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/gradle-core/src/main/java/com/android/build/gradle/internal/transforms/InstantRunTransform.java" target="_blank" rel="noopener">InstantRunTransform</a>是正是Android Gradle Plugin中用于 <strong>自动修改</strong> 字节码的工具。了解了ASM之后，再来分析<code>InstantRunTransform</code>就相对容易，因为它不过是对ASM库的应用。</p><p><code>InstantRunTransform.doTransform()</code>是插桩入口，它的主要流程如下图：</p><p><img src="do-transform.png" alt></p><ul><li><code>InstantRunTransform.transformToClasses2Format()</code>即上文中提到的初始插桩，实际插桩工作由<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/instant-run-instrumentation/src/main/java/com/android/build/gradle/internal/incremental/IncrementalSupportVisitor.java" target="_blank" rel="noopener">IncrementalSupportVisitor</a>完成</li><li><code>InstantRunTransform.transformToClasses3Format()</code>即上文中提到的增量插桩，实际插桩工作由<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/instant-run-instrumentation/src/main/java/com/android/build/gradle/internal/incremental/IncrementalChangeVisitor.java" target="_blank" rel="noopener">IncrementalChangeVisitor</a>完成</li></ul><p>前文提到第2步和第5步两个enhance过程，其实分别是<code>transformToClasses2Format()</code>和<code>transformToClasses3Format()</code>。</p><p><img src="transform.png" alt></p><p><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/instant-run-instrumentation/src/main/java/com/android/build/gradle/internal/incremental/IncrementalSupportVisitor.java" target="_blank" rel="noopener">IncrementalSupportVisitor</a>和<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/instant-run-instrumentation/src/main/java/com/android/build/gradle/internal/incremental/IncrementalChangeVisitor.java" target="_blank" rel="noopener">IncrementalChangeVisitor</a>是纯粹对ASM库的应用，其实现目标以及可能遇到的一些技术难题见<a href="https://www.sunmoonblog.com/2018/10/28/instant-run-instrumentation/#more">(译)Instant Run Instrumentation</a>，在此不展开具体分析。如果想深入研究ASM的话这二者可作为不错的学习材料，建议对对照着<a href="https://asm.ow2.io/asm4-guide.pdf" target="_blank" rel="noopener">ASM user guide</a>和<a href="https://asm.ow2.io/developer-guide.html" target="_blank" rel="noopener">ASM developer guide</a>学习这两个类的源码。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>本文通过介绍Instant Run中的代理模式和字节码插桩技术，希望能带理解你Instant Run的原理。下一篇中将讨论Instant Run是如何发送并加载<code>HelloWorld$override</code>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650821004&amp;idx=1&amp;sn=120899d7ecaae5a2f74d67059dcab5e9&amp;pass_ticket=W4nv7dMI7tRatGj6kxkJk9rkIORQBbIG4EkbSHCxUbc%3D" target="_blank" rel="noopener">浅谈Instan Run中的热替换</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Instant Run Instrumentation</title>
      <link href="2018/10/28/instant-run-instrumentation/"/>
      <url>2018/10/28/instant-run-instrumentation/</url>
      
        <content type="html"><![CDATA[<p>官方关于instant run插桩技术的介绍。<br><a id="more"></a><br>翻译自<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/instant-run-instrumentation/README.md" target="_blank" rel="noopener">官方文档</a>。</p><p>汇总一下文中提到的几个类：</p><ul><li><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/instant-run-instrumentation/src/main/java/com/android/build/gradle/internal/incremental/InstantRunPatchingPolicy.java" target="_blank" rel="noopener">InstantRunPatchingPolicy.java</a></li><li><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/instant-run-instrumentation/src/main/java/com/android/build/gradle/internal/incremental/InstantRunBuildMode.java" target="_blank" rel="noopener">InstantRunBuildMode.java</a></li><li><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/instant-run-instrumentation/src/main/java/com/android/build/gradle/internal/incremental/InstantRunVerifierStatus.java" target="_blank" rel="noopener">InstantRunVerifierStatus.java</a></li><li><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/gradle-core/src/main/java/com/android/build/gradle/internal/incremental/InstantRunBuildContext.java" target="_blank" rel="noopener">InstantRunBuildContext.java</a></li></ul><p>注：不太明白如何翻译instrumenttation这个词，查了一下这个词指的应该是获取计算机软件或者硬件状态的数据的技术，一般翻译为插桩</p><p>本文介绍了instant run hot swap的插桩操作，翻译自<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/instant-run-instrumentation/README.md" target="_blank" rel="noopener">instant run hot swap instrumentation</a>。</p><p>另一篇相关的文章是<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/README.md" target="_blank" rel="noopener">instant run</a>。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Instant run的一个目标是可以在旧的Android设备上运行(低至Android ICS)，所以不会考虑那些要求修改运行时环境(Runtime Environment)的技术方案，比如说，修改Android VM以支持类似标准JDK中的允许重新加载类的javaagent技术。</p><p>任何使用不同class loader加载同一个类的不同版本的技术方案都无法解决是这几个问题：</p><ul><li>类的问题 - Java语言中使用类的完全限定名以及加载该类的class loader来识别类(package name + simple class name)。所以相同完全限定名的类被不同的class loader加载后其实是不同的Java类，它们之间并不能强制转型，会出现ClassCastException</li><li>实例的问题 - 修改前的类的实例并不能作为修改后的类的实例来使用，新的实例是新的类的，这里也有混用时类型无法匹配的问题</li></ul><p>因此instant run的解决方案要考虑Java语言的内存模型以及类型系统的限制：</p><ol><li>类不能被重载 (译者注：JVM运行期间类不能被重载，reload)</li><li>类的实例必须都是同一类型，即使类的实现被修改</li><li>并不能真的创建更新后的类的实例(因为类之间的引用关系已经被JVM提前解析了，这种引用关系是不能变的)</li></ol><p>(译者注：这里讲到的限制都有一个前提，即并不重启JVM)</p><p>最终的解决方案有点难以置信地简单：不要想着类会变会被修改，所有实例都是最初的类的实例。如果一个类被更新了，它所有的方法实现重定向到新的实现即可。</p><p>换句话说，一旦类加载了，这个类的所有实例都来自唯一的FQCN(full qualitied class name，完全限定类名)+ class loader。一旦这个类更新了，它立马变成一个(保留字段值的)空壳，这个空壳用于重定向每个方法调用到新的方法实现。</p><p>当然，为了保证上述过程能成功进行，原始的类必须具备可更新的能力(即，可以重定向到新的方法实现)。而更新后的类也必须具备接收重定向方法调用的能力。通过这个例子来看看它的工作原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google.android.foo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> intField;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> intField;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让这个类可更新，将它增强为这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google.android.foo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> IncrementalChange $change = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> intField;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> ($change != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> $change.access$dispatch(<span class="string">"someMethod_()I"</span>, <span class="keyword">this</span>)</span><br><span class="line">           &#125;</span><br><span class="line">      <span class="keyword">return</span> intField;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，如果那个静态字段<code>$change</code>没被设置，类的行为并不会发生改变(当然，还是有一些影响，<code>if()</code>判断会带来轻微的性能损失)。还要注意的是，是这个增强后的类而不是原始的类被打包到初始的APK中。</p><p>现在假如用户修改了A的实现，构建系统会对A类进行必要的增强以让其成为修改前的类的新实现。由于修改后的类并不会被用来创建新的实例，所以增强过程中我们可以安全地移除它其中的全部实例字段和静态字段。此外，还可以将其所有方法转换成静态方法。</p><p>这是修改后的A类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google.android.foo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> intField;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> intField*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是增强后的A类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google.android.foo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>$<span class="title">Override</span> <span class="keyword">implements</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">someMethod</span><span class="params">(A sender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sender.intField*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">dispatch</span><span class="params">(A sender, String methodName, String signature)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (methodName.equals(<span class="string">"someMethod"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> someMethod(sender);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(译者注：注意区别两个不同的增强过程。一个增强过程是让初始的类具备可更新的能力，另一个增强过程是让修改的类可以作为原始类的代理)</p><p>现在要做的工作就是将<code>A$Override</code>类写入到A类的<code>$change</code>字段。这个工作是在运行期间使用新的classloader完成的(不妨称这个classloader为overriding classloader，它用于加载<code>A$Override</code>类)。overriding classloader的父加载器是原始的A类的classloader，所以<code>A$Override</code>对A可见(译者注：注意这里类的可见性问题)。运行时的关系图如下：</p><p><img src="https://coding.net/s/5416fc93-d7fe-432a-9389-44fbaaf851de" alt="overriding-class-loader"></p><h1 id="可支持的更新操作"><a href="#可支持的更新操作" class="headerlink" title="可支持的更新操作"></a>可支持的更新操作</h1><p>目前，Hot Swap支持修改任意方法实现(包括构造方法，静态方法以及实例方法)，以及结构变化(比如增加或删除一个方法，修改类结构，修改静态初始化块)，</p><p>这里涉及到两种插桩。一种是初始插桩，它将最初并不支持hot swap的类增强为可支持hot swap。另一种是增量插桩，它会对修改后的类进行增强，增强的类用于运行期间注入到类的<code>$change</code>字段。</p><h2 id="初始插桩"><a href="#初始插桩" class="headerlink" title="初始插桩"></a>初始插桩</h2><p>初始插桩用于准备可支持hot swap的类，这些类在VM生命周期中可以被更新。这种可更新能力带来的开销应当最小化，因为它影响应用中的每个方法和类。</p><h2 id="让方法可更新"><a href="#让方法可更新" class="headerlink" title="让方法可更新"></a>让方法可更新</h2><p>当一个方法被覆盖，其<code>$change</code>值被设置为当前的<code>$Override</code>类。每个方法调用都被重定向到新的方法实现，重定向过程会传递原始调用的参数并返回非void方法的返回结果。</p><p>在初始插桩期间，所有的静态方法及实例方法都会按照以下伪代码这种方式被增强：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($change != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Object[] parameters = <span class="keyword">new</span> Object[method.getTypeParameters().length];</span><br><span class="line">    parameters[<span class="number">0</span>] = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; method.getTypeParameters().length; i++) &#123;</span><br><span class="line">        parameters[i] = box(argsI);</span><br><span class="line">    &#125;</span><br><span class="line">    Object res = $change.access$dispatch(method.signature, parameters);</span><br><span class="line">    <span class="keyword">if</span> (method.getReturnType != Void) &#123;</span><br><span class="line">        <span class="keyword">return</span> unbox(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="让构造方法可被更新"><a href="#让构造方法可被更新" class="headerlink" title="让构造方法可被更新"></a>让构造方法可被更新</h2><p>基于以上相同的思路，构造方法也可插桩。注意以下几个难点：</p><ol><li>直到<code>super.&lt;init&gt;</code>方法被调用后才能在构造方法以外的地方使用<code>this</code>关键字，否则它未被初始化</li><li>只有构造方法代码才能调用<code>super.&lt;init&gt;</code>，这个调用不能放在其他类中进行</li><li>当用户有类似<code>super.A(Utils.myStaticMethod(&quot;a&quot;, &quot;b&quot;), 2+3)</code>这种代码时，一些代码才可以出现在<code>super.&lt;init&gt;</code>调用之前</li></ol><p>因此将构造方法分成3个阶段：</p><ol><li><code>super.&lt;init&gt;</code>之前的阶段，这个阶段只包括用于创建super构造方法参数列表的必要代码</li><li>使用参数来自上一步的参数调用<code>super.&lt;init&gt;</code></li><li><code>super.&lt;init&gt;</code>之后的阶段。(注意这个阶段可以在构造方法以外的地方使用<code>this</code>)</li></ol><p>以这段代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Public <span class="title">A</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(Utils.getContext(), i*j, str);</span><br><span class="line">    <span class="keyword">this</span>.intField = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持更新的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    Dispatch localChange = $change;</span><br><span class="line">    If (localChange != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[];</span><br><span class="line">        args[<span class="number">0</span>] = args;     <span class="comment">// so init$args implementation can change</span></span><br><span class="line">        <span class="comment">// the super parameter values.</span></span><br><span class="line">        args[<span class="number">1</span>] = box(i);</span><br><span class="line">        localChange.init$args(args);</span><br><span class="line">        <span class="comment">// push back arguments on the stack from the args as the</span></span><br><span class="line">        <span class="comment">// init$args function may have changed it.</span></span><br><span class="line">        a = args[<span class="number">1</span>];</span><br><span class="line">        b = args[<span class="number">2</span>];</span><br><span class="line">        c = args[<span class="number">3</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a = Utils.getContext();</span><br><span class="line">        b = i*j;</span><br><span class="line">        c = str</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.&lt;init&gt;(a, b, c);</span><br><span class="line">    <span class="keyword">if</span> (localChange != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[<span class="number">2</span>];</span><br><span class="line">        Args[<span class="number">0</span>] = <span class="keyword">this</span>;</span><br><span class="line">        Args[<span class="number">1</span>] = box(i);</span><br><span class="line">        localChange.init$body(args);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.intField = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用super"><a href="#调用super" class="headerlink" title="调用super"></a>调用super</h2><p>调用super方法也需要特殊处理。需要特殊处理的原因在于VM中的检查器会校验对invokdespecial指令对父类方法的调用是由包含目标方法的子类代码发起的。</p><p>进一步说，使用反射起作用。即使找到父类方法的引用并且调用它，生成的代码也只不过是对你传入的实例进行invokevirtual调用。所以invokevirtual会调用对象的实例方法而不是预期中的父类的方法。</p><p>为了解决这个问题，我们在可更新的类中生成一个跳转方法<code>access$super()</code>。这个方法提供对父类方法的访问。所以剩下要做的就是在incremental transformation过程将所有<code>super.method()</code>调用转换成对<code>access$super()</code>的调用。</p><p>跳转方法的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Object access$<span class="keyword">super</span>(String name, object[] args) &#123;</span><br><span class="line">  <span class="keyword">switch</span>(name) &#123;</span><br><span class="line">    <span class="string">"firstMethod.(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;"</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">super</span>.firstMethod((String)arg[<span class="number">0</span>], arg[<span class="number">1</span>]);</span><br><span class="line">    <span class="string">"secondMethod.(Ljava/lang/String;I)V"</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">super</span>.secondMethod((String)arg[<span class="number">0</span>], (<span class="keyword">int</span>)arg[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">           <span class="function">Throw new <span class="title">InstantRunException</span><span class="params">(<span class="string">"... not found"</span>)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字节码插桩"><a href="#字节码插桩" class="headerlink" title="字节码插桩"></a>字节码插桩</h1><h2 id="初始指插桩"><a href="#初始指插桩" class="headerlink" title="初始指插桩"></a>初始指插桩</h2><p>ASM Java bytecode visitor执行这种插桩，对类的修改如下：</p><ol><li>增加一个静态的<code>$change</code>字段</li><li>将所有的非private方法修改为public，以便它们可以被<code>$override</code>类直接访问而不是通过反射方式访问</li><li>修改所有方法的实现：先检查是否有新版本的实现被设置到<code>$change</code>字段，如果有的话将调用分发到<code>$change</code></li><li>将所有的非private字段修改为public，以便它们可以被<code>$override</code>类直接访问而不是通过反射方式访问)</li><li>提供<code>access$super</code>方法(细节见上文)</li><li>提供<code>access$constructor</code>(细节见上文)</li></ol><h2 id="增量插桩"><a href="#增量插桩" class="headerlink" title="增量插桩"></a>增量插桩</h2><p>ASM Java bytecode visitor创建<code>$override</code>类，引入如下变更：</p><ol><li>移除所有构造方法和字段声明。由于不会创建<code>$override</code>类的实例，所以用不到构造方法和字段</li><li>将所有方法修改为静态(因为这个类没有实例)</li><li>修改Dispatcher方法的实现逻辑</li><li>使用反射方式访问原始实例的private字段</li><li>使用调用<code>$Override.method</code>的方式来调用私有方法</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>(译)Instant Run</title>
      <link href="2018/10/26/instant-run/"/>
      <url>2018/10/26/instant-run/</url>
      
        <content type="html"><![CDATA[<p>从官方技术文档的视角来看Instant Run。<br><a id="more"></a><br>本文翻译自<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/README.md" target="_blank" rel="noopener">Instant Run</a></p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>Android应用构建工具应当提供更好的代码迭代体验。相对侧重于重新进行完整构建，工具应当以增量方式分发代码变更，可以对这些小的变更进行快速构建、安装和加载。更进一步说，简单的代码变更应当以补丁方式分发和加载到运行中的进程，以避免重新启动整个应用。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>提供字节码操作技术用于加载新版本的类文件，加载时不必重新启动运行中的Android应用(称之为hotswap)</li><li>提供运行时库用于加载更新后的Android资源(包括图标，布局等等)，加载时只需要重新启动Android Activity，不必重新启动运行中的Android应用(称之为warmswap)</li><li>对于代码或Android manifest变更导致无法对运行中的进程打补丁的情况，提供基于原始包构建最小差异包的方式来加快分发过程和进程重启过程(称之为coldswap)</li><li>最后，提供基于coldswap的增量分发机制用于发布变更到未运行的进程中，而不必重新构建和部署整个APK</li></ul><h1 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h1><p>尽管Gradle构建系统可以独立于IDE工作(它可以用命令行调用的方式完成从编译Java代码到打包最终可发布的APK的工作)，但instant run还是被设计成集成到IDE中。所以本文中没有关于在命令行中运行instant run的特性描述。</p><p>一个小的服务器被内嵌到Android设备上运行的应用中。这个服务器开启端口用于跟Android Studio通信。</p><p>当用户在Andriod Studio中修改代码并且重新运行时，Studio调用Gradle构建系统执行增量构建。构建系统会向Studio返回构建结果列表(以下有详细描述)。</p><p>hot swap或warm swap场景下，Studio中的instant run client向Android应用中的instant run server发送构建结果，之后instant run server会收到启动类型通知(不用重启，activity重启，进程重启)并并执行对应类型的启动。对于cold swap而言，新的apk通过<code>adb install-multiple -p</code>进行安装(注：有别于完整构建时的安装方式)。</p><h1 id="检查器"><a href="#检查器" class="headerlink" title="检查器"></a>检查器</h1><p>Android Studio调用Gradle构建后，它并不知道Gradle将产出何种编译结果。<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/gradle-core/src/main/java/com/android/build/gradle/internal/incremental/InstantRunBuildContext.java" target="_blank" rel="noopener">InstantRunBuilderContext</a>会跟踪检查verifier状态，这个状态会在构建过程中更新。构建结束后<code>InstantRunBuilderContext</code>将结果写入到构建信息文件(build-info.xml)中，包括所有的构建结果以及verifier状态，而Android Studio会读取构建信息文件(build-info.xml)进行相应部署。</p><p>检查器(verifier)可能被设置成以下几种方式：</p><ul><li>没有保存任何instant run状态时，设置为<code>INITIAL_BUILD</code></li><li>由Android Studio设置：Android Studio传<code>OptionalCompilationStep.FULL_APK</code>时设置为<code>FULL_BUILD_REQUESTED</code>，传<code>RESTART_ONLY</code>时设置为<code>COLD_SWAP_REQUESTED</code></li><li><code>InstantRunVerifierTransform</code>检查是否可以执行hot swap</li><li><code>NoChangesVerifierTransform</code>有两个实例，一个用于检查Java资源(<code>JAVA_RESOURCES_CHANGED</code>)，另一个用于检查依赖项目(<code>DEPENDENCY_CHANGED</code>)</li><li>manifest发生变化时，设置为<code>MANIFEST_FILE_CHANGED</code>。内联到编译后的manifest文件的resource ID发生变化时，设置为<code>BINARY_MANIFEST_FILE_CHANGED</code></li></ul><p>详细的检查状态列表见<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/instant-run-instrumentation/src/main/java/com/android/build/gradle/internal/incremental/InstantRunVerifierStatus.java" target="_blank" rel="noopener">InstantRunVerifierStatus</a>。根据补丁策略(<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/instant-run-instrumentation/src/main/java/com/android/build/gradle/internal/incremental/InstantRunPatchingPolicy.java" target="_blank" rel="noopener">InstantRunPatchingPolicy</a>，每个检查状态会映射到一个<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/instant-run-instrumentation/src/main/java/com/android/build/gradle/internal/incremental/InstantRunBuildMode.java" target="_blank" rel="noopener">InstantRunBuildMode</a>。比如Java资源变化时，在Lollipop以前的设备上会导致全量编译以及multidex，并使用cold swap方式对multi-apk进行部署。当有多个verifier检查结果时只保存一个，处理方式是将多个verifier检查结果组合成一个。比如<code>HOT_WARM</code>和<code>COLD</code>组合成<code>COLD</code>。</p><p>如果<code>InstantRunBuildMode</code>如果是<code>HOT_WARM</code>，则接下来的cold swap任务会在<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/gradle-core/src/main/java/com/android/build/gradle/tasks/PreColdSwapTask.java" target="_blank" rel="noopener">PreColdeSwapTask</a>任务中被禁用。如果构建模式是<code>FULL</code>，<code>InstantRunBuildContext</code>会将之前的构建结果收集到当前构建中来，所以Android Stuio知道要部署所有构建结果。</p><h1 id="Hot-swap"><a href="#Hot-swap" class="headerlink" title="Hot swap"></a>Hot swap</h1><h2 id="Instrmentation"><a href="#Instrmentation" class="headerlink" title="Instrmentation"></a>Instrmentation</h2><p>见<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/instant-run-instrumentation/README.md" target="_blank" rel="noopener">Instant run byte code instrumentation</a></p><h2 id="Hot-swap分发"><a href="#Hot-swap分发" class="headerlink" title="Hot swap分发"></a>Hot swap分发</h2><p>当构建系统确定上次构建后所有代码的变更支持hot swap，它会使用将发生变更的class文件(经过instant run instrmentation处理)打包成reload.dex。Android Studio使用instant run client将reload.dex发送到instant run server(这个server在Android应用中)。instant run server将dex文件写到磁盘，并创建类加载器加载更新后的类。当方法下次被调用时，调用会重定向到新的实现(译者注：从而实现hot swap，Android进程和Activity都不必重启)。</p><h1 id="Warm-swap"><a href="#Warm-swap" class="headerlink" title="Warm swap"></a>Warm swap</h1><p>当资源以兼容的变更时，用新的资源生成<code>resources._ap</code>文件</p><p>instant run server收到新的资源时会创建新的asset manager(这个asset manager中包含新资源)，并通过Java反射用新的asset manager替换掉已有的asset manager。这一过程的具体实现见<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-server/src/main/java/com/android/tools/fd/runtime/MonkeyPatcher.java" target="_blank" rel="noopener">MonkeyPatcher</a></p><p>(从技术角度讲)，warm swap中也可以包含hot swap变更。</p><h1 id="Cold-swap"><a href="#Cold-swap" class="headerlink" title="Cold swap"></a>Cold swap</h1><p>当代码的变更超出hot swap可以处理的范围时(比如，增加一个方法或删除一个方法)，这些变更被认为是不兼容的。这种场景下会执行cold swap。</p><p>cold swap的dexing和packaging任务，会从上次cold swap或全量构建中找到所有的变更(注意：上述hot swap和warm swap构建过程中dexing和packaging任务被禁用)。cold swap为发生变更的class生成split APK文件(发生变更是从上次cold swap构建或全量构建算起)。</p><p>Java类在Java package范围内共享，所以如果用户只在一个Java package下修改源文件，则只有一个split APK被创建。</p><p>split APK被push到设备上进行安装(译者注：使用的是<code>adb install-multiple -p</code>命令进行非完整安装)。</p><h2 id="Android-Studio-2-3之前"><a href="#Android-Studio-2-3之前" class="headerlink" title="Android Studio 2.3之前"></a>Android Studio 2.3之前</h2><p>(译者注：Android Studio 2.3之后instant run的实现原理有改进。目前Android Studio 3.2已发布，所以这一节的内容可以忽略。不过为了保持翻译的完整性，还是放上来)</p><p>Android Studio 2.3之前cold swap构建用于生成dex文件，我们使用classloader的黑科技将dex文件添加到应用的classpath中。</p><p>dex文件被推送到设备上，它被保存在app数据目录下的inbox中。重启后应用会找到这些dex文件，并用新的覆盖旧的。instant run用新的dex文件创建application classloader，之后使用代理方式调用原先的应用代码。</p><p>应用没有运行时会重新构建。接下来跟cold swap的场景是一样的，变更会累积起来直到用户最终部署和运行应用。当执行部署命令时，dex文件首先会拷贝到inbox，接着跟cold swap的流程一样，创建application classloader。在一些设备上，instant run功能不可用，这种情况下只能进行全量构建。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio是如何运行app的？</title>
      <link href="2018/10/19/dive-into-run/"/>
      <url>2018/10/19/dive-into-run/</url>
      
        <content type="html"><![CDATA[<p>你在Android Stuiod中点击绿色三角形图标(Run)时，背后发生了什么？点击黄色闪电图标(Apply Change)呢？<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们的Android项目有一个奇怪的问题：在Android Studio使用Instant Run运行时，无论修改一行代码还是几行代码，永远都是cold swap，没有见到传说中的hot swap或warm swap。</p><p>如果对instant run或hot swap这些概念不是太熟，可以快速浏览一下<a href="https://developer.android.com/studio/run/#instant-run" target="_blank" rel="noopener">官方文档</a>。</p><p>这个问题本身没有太多影响，无非是多增加几秒中的开发时间。但问题就是问题，不是吗？</p><p>我花了一些时间跟进这个问题。本文是从Android Studio如何运行应用的角度来看这个问题的，比较粗线条，一些细节还有待深入。</p><p>主要的参考资料是</p><ul><li><a href="https://github.com/JetBrains/android/blob/master/android/src/com/android/tools/idea/run/README.md" target="_blank" rel="noopener">android/README.md at master · JetBrains/android</a></li></ul><p>涉及到的代码包括</p><ul><li><a href="https://github.com/JetBrains/android" target="_blank" rel="noopener">JetBrains/android</a></li><li><a href="https://android.googlesource.com/platform/tools/base/" target="_blank" rel="noopener">Android Gradle Plugin</a></li></ul><h1 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h1><p>用户在Android Studio中点击Run或Apply Change运行应用的过程可以简单总结为如下几个阶段：</p><ul><li>用户点击Run按钮(pre build阶段)</li><li>开始Gradle构建(build阶段)</li><li>部署应用并启动(post build阶段)</li></ul><p>点一下按钮很简单，但背后的过程其实比较复杂：</p><ul><li>用户点击Run按钮(pre build阶段) - Android Studio调用<a href="https://github.com/JetBrains/android/blob/master/android/src/com/android/tools/idea/run/AndroidRunConfigurationBase.java" target="_blank" rel="noopener">AndroidRunConfigurationBase.getState()</a>方法，该方法创建<code>AndroidRunState</code>实例</li><li>开始Gradle构建(build阶段) - 跟普通的Gradle构建本质上一样，但Android Gradle Plugin提供了许多Android特定的Task，构建中会用到这些Task</li><li>部署应用并启动(post build阶段) - 这个阶段又回到Android Studio，Android Studio调用<code>AndroidRunState.execute()</code>方法，该方法执行一系列的<code>LaunchTasks</code>。<code>LaunchTasks</code>会调用<code>am</code>或<code>install</code>等adb命令安装apk或启动应用</li></ul><p>pre build阶段有几个重要的操作：</p><ul><li><code>InstantRunBuilder.computeBuildCause()</code> - 计算本次构建的原因(其中包含build mode)</li><li><code>InstantRunBuilder.getInstantRunArguments()</code> - 生成用于Gradle中InstantRun相关Task的参数</li><li><code>AndroidRunConfigurationBase.getState()</code> - <strong>保存build options到env</strong> 。build options最重要的参数是build mode。</li></ul><p>build阶段会从读取到上述build options，build options作为运行Gradle命令时的参数(比如，<code>android.optional.compilation</code>参数)。build阶段的结果会写入到<code>build-info.xml</code> 。</p><p>小提示: <code>build-info.xml</code>的两种查看方式</p><ul><li>项目的<code>/build/intermediates/build-info/debug/build-info.xml</code></li><li>Android Studio &gt; Show Log in Finder，然后在<code>flr</code>目录下找到<code>build-info.xml</code> (这里会有很多build-info.xml，分别对应于每一次构建)</li></ul><p>post build阶段读取<code>build-info.xml</code>，根据其内容决定如何部署和启动应用。</p><p>先用这张图简单总结一下，再来逐个分析。</p><p><img src="run-flow.png" alt></p><p>由于涉及到日常app开发中不常见的一些东西，为尽可能容易理解，对每个阶段都按这个套路进行分析。</p><ul><li>属于哪个阶段，涉及到的工具</li><li>对应的日志</li><li>对应的代码</li><li>相关的代码</li></ul><p>提示：一些代码很难完全看懂，但根据对应的日志不难猜出大概</p><h1 id="Pre-build"><a href="#Pre-build" class="headerlink" title="Pre build"></a>Pre build</h1><p>Pre build阶段发生在Android Studio中用户点击Run按钮时。</p><p>对应的重要日志见Android Studio的idea.log (日志位置 Android Studio &gt; Show Log in Finder)。日志如下，通过该日志可以知道当前构建的原因以及构建的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-10-17 14:27:33,770 [thread 476]   INFO - ools.idea.fd.InstantRunBuilder - BuildCause: APP_NOT_RUNNING, BuildMode: COLD</span><br></pre></td></tr></table></figure><p>对应的代码见：</p><ul><li><a href="https://github.com/JetBrains/android/blob/master/android/src/com/android/tools/idea/run/AndroidRunConfigurationBase.java" target="_blank" rel="noopener">AndroidRunConfigurationBase</a></li><li><a href="https://github.com/JetBrains/android/blob/master/android/src/com/android/tools/idea/fd/InstantRunBuilder.java#L231" target="_blank" rel="noopener">InstantRunBuilder</a></li></ul><p>这里只看三个较重要的方法。</p><p><code>AndroidRunConfigurationBase.getState()</code>主要有以下功能：</p><ul><li>选择手机或模拟器设备</li><li>保存build options</li></ul><p><img src="ir-pre-build.png" alt></p><p><a href="https://github.com/JetBrains/android/blob/master/android/src/com/android/tools/idea/run/README.md" target="_blank" rel="noopener">图片来源</a></p><p><code>InstantRunBuilder.computeBuildCause()</code>方法中计算<code>BuildCause</code>。<code>BuildCause</code>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> BuildCause &#123;</span><br><span class="line">  <span class="comment">// reasons for full build</span></span><br><span class="line">  NO_DEVICE(BuildMode.FULL),</span><br><span class="line">  APP_NOT_INSTALLED(BuildMode.FULL),</span><br><span class="line">  MISMATCHING_TIMESTAMPS(BuildMode.FULL),</span><br><span class="line">  API_TOO_LOW_FOR_INSTANT_RUN(BuildMode.FULL),</span><br><span class="line">  FIRST_INSTALLATION_TO_DEVICE(BuildMode.FULL), <span class="comment">// first installation in this Android Studio session</span></span><br><span class="line">  FREEZE_SWAP_REQUIRES_API21(BuildMode.FULL),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reasons for forced cold swap build</span></span><br><span class="line">  USER_REQUESTED_COLDSWAP(BuildMode.COLD), <span class="comment">// User pressed Run, and only Run button was enabled (name not ideal, but matches existing proto)</span></span><br><span class="line">  USER_CHOSE_TO_COLDSWAP(BuildMode.COLD),  <span class="comment">// Both Run and Hotswap were enabled, and user chose Run</span></span><br><span class="line">  APP_NOT_RUNNING(BuildMode.COLD),</span><br><span class="line">  APP_USES_MULTIPLE_PROCESSES(BuildMode.COLD),</span><br><span class="line">  ANDROID_TV_UNSUPPORTED(BuildMode.COLD),</span><br><span class="line">  MANIFEST_RESOURCE_CHANGED(BuildMode.COLD),</span><br><span class="line"></span><br><span class="line">  INCREMENTAL_BUILD(BuildMode.HOT),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在使用Instant Run过程中遇到问题或疑惑，或许可以从<code>computeBuildCause()</code>的代码找到答案。以这个精简后的代码为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BuildCause <span class="title">computeBuildCause</span><span class="params">(@Nullable IDevice device)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (manifestResourceChanged(device)) &#123;</span><br><span class="line">    <span class="keyword">return</span> BuildCause.MANIFEST_RESOURCE_CHANGED;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (myRunContext.isForceColdswap()) &#123;</span><br><span class="line">    <span class="keyword">return</span> myRunContext.couldHaveInvokedHotswap() ? BuildCause.USER_CHOSE_TO_COLDSWAP : BuildCause.USER_REQUESTED_COLDSWAP;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (myInstantRunContext.usesMultipleProcesses()) &#123;</span><br><span class="line">    <span class="keyword">return</span> BuildCause.APP_USES_MULTIPLE_PROCESSES;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码我们可以知道：</p><ul><li>修改应用的manifest后不可能进行hot swap，至少会是cold swap。因为修改manifest后返回<code>MANIFEST_RESOURCE_CHANGED</code>，它对应<code>BuildMode.COLD</code></li><li>多进程的应用不可能进程hot swap，至少会是cold swap。因为多进程应用时返回<code>APP_USES_MULTIPLE_PROCESSES</code>，它对应<code>BuildMode.COLD</code></li></ul><p>再看一下<code>InstantRunBuilder.getInstantRunArguments()</code>方法，它为build过程生成参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getInstantRunArguments</span><span class="params">(@NotNull BuildMode buildMode)</span> </span>&#123;</span><br><span class="line">  StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">50</span>);</span><br><span class="line">  sb.append(<span class="string">"-P"</span>);</span><br><span class="line">  sb.append(PROPERTY_OPTIONAL_COMPILATION_STEPS);</span><br><span class="line">  sb.append(<span class="string">"="</span>);</span><br><span class="line">  sb.append(OptionalCompilationStep.INSTANT_DEV.name());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (buildMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> HOT:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> COLD:</span><br><span class="line">      sb.append(<span class="string">","</span>).append(OptionalCompilationStep.RESTART_ONLY.name());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FULL:</span><br><span class="line">      sb.append(<span class="string">","</span>).append(OptionalCompilationStep.FULL_APK.name());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String compilationSteps = sb.toString();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Starting with Studio 2.3, we always do a split APK install on cold swaps</span></span><br><span class="line">  String coldSwapMode = AndroidGradleSettings.createProjectProperty(AndroidProject.PROPERTY_SIGNING_COLDSWAP_MODE, <span class="string">"MULTIAPK"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ImmutableList.of(compilationSteps, coldSwapMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的意思就是根据不同的buildMode，会生成不同的参数传给Gradle：</p><ul><li><code>HOT</code> - INSTANT_DEV， 传<code>-Pandroid.optional.complilation=INSTANT_DEV</code></li><li><code>COLD</code> - RESTART_ONLY， 传<code>-Pandroid.optional.complilation=INSTANT_DEV,RESTART_ONLY</code></li><li><code>FULL</code> - FULL_APK， 传<code>-Pandroid.optional.complilation=INSTANT_DEV,FULL_APK</code></li></ul><p>Gradle收到的参数不同，运行的Task也将有所不同。</p><h1 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h1><p>Build阶段发生在Gradle中。</p><p>对应的重要日志见<code>build.log</code> (日志位置 Android Studio &gt; Show Log in Finder， 然后找flr目录)。日志如下，通过该日志知道重新编译的class文件跟前一个版本是兼容的，所以接下来可以进行hot swap：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Receiving verifier result: COMPATIBLE. Current Verifier/Build mode is NO_CHANGES/HOT_WARM.</span><br><span class="line">Verifier result is now : COMPATIBLE. Build mode is now HOT_WARM.</span><br></pre></td></tr></table></figure><p>Build阶段还会生成一个重要的文件<code>build-info.xml</code> (日志位置 Android Studio &gt; Show Log in Finder， 然后找flr目录)</p><p>对应的代码见<code>com.android.build.gradle.internal.InstantRunBuildContext.setVerifierStatus()</code> <a href="https://github.com/JetBrains/android" target="_blank" rel="noopener">Github</a></p><p>相关的代码有：</p><ul><li><code>TaskManager.createPostCompilationTasks()</code></li><li><code>InstantRunTaskManager.createPreColdswapTask()</code>，这个方法会读取上述<code>android.optional.complilation</code>参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InstantRunTaskManager.java</span></span><br><span class="line"><span class="comment">/** Creates all InstantRun related transforms after compilation. */</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PreColdSwapTask <span class="title">createPreColdswapTask</span><span class="params">(@NonNull ProjectOptions projectOptions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TransformVariantScope transformVariantScope = variantScope.getTransformVariantScope();</span><br><span class="line">    InstantRunBuildContext context = variantScope.getInstantRunBuildContext();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transformVariantScope.getGlobalScope().isActive(OptionalCompilationStep.FULL_APK)) &#123;</span><br><span class="line">        context.setVerifierStatus(InstantRunVerifierStatus.FULL_BUILD_REQUESTED);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (transformVariantScope.getGlobalScope().isActive(</span><br><span class="line">            OptionalCompilationStep.RESTART_ONLY)) &#123;</span><br><span class="line">        context.setVerifierStatus(InstantRunVerifierStatus.COLD_SWAP_REQUESTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PreColdSwapTask preColdSwapTask =</span><br><span class="line">            taskFactory.create(</span><br><span class="line">                    <span class="keyword">new</span> PreColdSwapTask.ConfigAction(</span><br><span class="line">                            <span class="string">"preColdswap"</span>, transformVariantScope, variantScope));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verifierTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">        preColdSwapTask.dependsOn(verifierTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> preColdSwapTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InstantRunBuildContext.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the verifier status for the current build.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> verifierStatus</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVerifierStatus</span><span class="params">(@NonNull InstantRunVerifierStatus verifierStatus)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LOG.info(</span><br><span class="line">            <span class="string">"Receiving verifier result: &#123;&#125;. Current Verifier/Build mode is &#123;&#125;/&#123;&#125;."</span>,</span><br><span class="line">            verifierStatus,</span><br><span class="line">            currentBuild.getVerifierStatus(),</span><br><span class="line">            currentBuild.buildMode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the new build mode for this verifier status as it may change the one we</span></span><br><span class="line">    <span class="comment">// currently use.</span></span><br><span class="line">    InstantRunBuildMode newBuildMode =</span><br><span class="line">            currentBuild.buildMode.combine(</span><br><span class="line">                    verifierStatus.getInstantRunBuildModeForPatchingPolicy(patchingPolicy));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save the verifier status, even if it does not end up being used as the main status,</span></span><br><span class="line">    <span class="comment">// this can be useful to check later on that certain condition were not met.</span></span><br><span class="line">    currentBuild.allStatuses.add(verifierStatus);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if our current status is not set, or the new build mode is higher, reset everything.</span></span><br><span class="line">    <span class="keyword">if</span> (currentBuild.getVerifierStatus() == InstantRunVerifierStatus.NO_CHANGES</span><br><span class="line">            || currentBuild.getVerifierStatus() == InstantRunVerifierStatus.COMPATIBLE</span><br><span class="line">            || newBuildMode != currentBuild.buildMode) &#123;</span><br><span class="line">        currentBuild.verifierStatus = verifierStatus;</span><br><span class="line">        currentBuild.buildMode = newBuildMode;</span><br><span class="line">    &#125;</span><br><span class="line">    Preconditions.checkNotNull(</span><br><span class="line">            patchingPolicy, <span class="string">"setApiLevel should be called before setVerifierStatus"</span>);</span><br><span class="line"></span><br><span class="line">    LOG.info(</span><br><span class="line">            <span class="string">"Verifier result is now : &#123;&#125;. Build mode is now &#123;&#125;."</span>,</span><br><span class="line">            currentBuild.getVerifierStatus(),</span><br><span class="line">            currentBuild.buildMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Post-Build"><a href="#Post-Build" class="headerlink" title="Post Build"></a>Post Build</h1><p>Post Build阶段发生在Android Studio。</p><p>对应的代码见<a href="https://github.com/JetBrains/android/blob/master/android/src/com/android/tools/idea/run/AndroidLaunchTasksProviderFactory.java" target="_blank" rel="noopener">com.android.tools.idea.run.AndroidLaunchTasksProviderFactory</a>，它读取<code>build-info.xml</code>确定要执行的Task。</p><p>这里不展开分析，只上一张图</p><p><img src="ir-post-build.png" alt></p><p><a href="https://github.com/JetBrains/android/blob/master/android/src/com/android/tools/idea/run/README.md" target="_blank" rel="noopener">图片来源</a></p><p>注意：这张图跟最新的代码不完全对应，但不影响理解。</p><h1 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h1><p>这里记录一下分析问题过程中遇到的一些关键代码，以备查找。</p><h2 id="JetBrains-android"><a href="#JetBrains-android" class="headerlink" title="JetBrains/android"></a><a href="https://github.com/JetBrains/android" target="_blank" rel="noopener">JetBrains/android</a></h2><p>build相关：</p><ul><li><code>com.android.tools.idea.fd.BuildMode</code> - 构建模式。分为HOT, COLD, FULL三种</li><li><code>com.android.tools.idea.fd.BuildCause</code> - 构建原因</li><li><code>com.android.tools.idea.run.AndroidRunConfigurationBase</code> </li><li><code>com.android.tools.idea.run.AndroidRunConfiguration</code> </li><li><code>com.android.tools.idea.fd.InstantRunBuilder</code></li></ul><p>task相关：</p><ul><li><a href="https://github.com/JetBrains/android/blob/master/android/src/com/android/tools/idea/run/AndroidLaunchTasksProviderFactory.java" target="_blank" rel="noopener">com.android.tools.idea.run.AndroidLaunchTasksProviderFactory</a> - 读取build-info.xml</li><li><a href="https://github.com/JetBrains/android/blob/master/android/src/com/android/tools/idea/run/AndroidLaunchTasksProvider.java" target="_blank" rel="noopener">com.android.tools.idea.run.AndroidLaunchTasksProvider</a></li><li><a href="https://github.com/JetBrains/android/blob/master/android/src/com/android/tools/idea/run/tasks/NoChangesTask.java" target="_blank" rel="noopener">com.android.tools.idea.run.tasks.NoChangesTask</a></li><li><a href="https://github.com/JetBrains/android/blob/master/android/src/com/android/tools/idea/run/tasks/HotSwapTask.java" target="_blank" rel="noopener">com.android.tools.idea.run.tasks.HotSwapTask</a></li><li><a href="https://github.com/JetBrains/android/blob/master/android/src/com/android/tools/idea/run/tasks/SplitApkDeployTask.java" target="_blank" rel="noopener">com.android.tools.idea.run.tasks.SplitApkDeployTask</a></li></ul><h2 id="Android-Gradle-Plugin"><a href="#Android-Gradle-Plugin" class="headerlink" title="Android Gradle Plugin"></a><a href="https://android.googlesource.com/platform/tools/base/" target="_blank" rel="noopener">Android Gradle Plugin</a></h2><ul><li><code>com.android.build.gradle.internal.incremental.BuildInfoWriterTask</code> - 创建<code>build-info.xml</code></li><li><code>com.android.build.gradle.internal.incremental.InstantRunBuildContext</code> - 记录了构建相关的信息，这些信息将写入<code>build-info.xml</code></li><li><code>com.android.build.gradle.internal.transforms.InstantRunVerifierTransform</code> - 比较同一个class文件的两个版本是否支持instant run</li><li><code>com.android.build.gradle.internal.transforms.InstantRunTransform</code> - 比class进行增强，以支持instant run的hot swap</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>用户在Android Studio中点击Run或Apply Change运行应用时，Android Studio会保存build options并为Gradle生成参数。Gradle进行实际构建，构建结果记录在<code>build-info.xml</code>文件中。Android Studio分析构建结果后调用Android SDK相关工具部署并启动应用。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/JetBrains/android/blob/master/android/src/com/android/tools/idea/run/README.md" target="_blank" rel="noopener">android/README.md at master · JetBrains/android</a></p><p><a href="http://www.jetbrains.org/intellij/sdk/docs/basics/run_configurations.html" target="_blank" rel="noopener">Run Configurations / IntelliJ Platform SDK DevGuide</a></p><p><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/README.md" target="_blank" rel="noopener">Android Developer Tools - Instant Run</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(翻译)Gradle增量编译</title>
      <link href="2018/09/13/gradle-incremental-compilation/"/>
      <url>2018/09/13/gradle-incremental-compilation/</url>
      
        <content type="html"><![CDATA[<p>本文翻译自Gradle 3.4发布时官方发表的<a href="https://blog.gradle.org/incremental-compiler-avoidance" target="_blank" rel="noopener">技术博客</a>。虽然现在看来Gradle 3.4已经是很老的版本了，但这篇博客中干货满满，解答了我关于Gradle的不少疑问，所以很有必要翻译一下作为学习！</p><a id="more"></a><hr><p>这篇文章解答了以下几个问题：</p><ul><li>什么是增量编译?</li><li>Compile avoidance跟增量编译有何区别？</li><li>为什么修改常量会影响编译编译？</li><li>什么是annotation processor?</li><li>为什么annotation processor会影响增量编译？该如何解决？</li><li>为什么要用implementation和api替代compile，不然会有如下警告？</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Configuration &apos;compile&apos; is obsolete and has been replaced with &apos;implementation&apos; and &apos;api&apos;.</span><br><span class="line">It will be removed at the end of 2018. For more information see: http://d.android.com/r/tools/update-dependency-configurations.html</span><br></pre></td></tr></table></figure><p>这篇文章提到了几个有价值的知识点：</p><ul><li>Making a small change should never result in a long build</li><li>Compile avoidance is different from incremental compilation<ul><li>Compile avoidance - ABI不兼容的修改，需要重新编译；非ABI不兼容的修改，不需要重新编译</li><li>Incremental compilation - 分析类之间的依赖关系，只编译那些发生了变化的类</li></ul></li><li>Not all constants are born equal: a constant value of 0 is much more likely to trigger a full recompilation when changed, than a constant value 188847774</li><li>An annotation processor is a Java compiler plugin. It is triggered whenever the Java compiler recognizes an annotation that is handled by a processor</li><li>The dependencies of the annotation processor should never leak into your compile classpath</li><li>The api bucket is used to declare dependencies that should transitively be visible by downstream consumers when they are compiled. </li><li>The implementation bucket is used to declare dependencies which should not leak into the compile classpath of consumers (because they are purely internal details).</li></ul><p>好吧。开始翻译了。</p><hr><p>我们很自豪地宣布刚刚发布的Gradle 3.4已经为各种用户构建Java应用进行了非常大的改进。这篇博客将解释我们修复，改进以及增加的各种细节。我们着重关注：</p><ul><li>快速增量构建</li><li>消除compile classpath泄漏问题</li></ul><p>我们极大地改进了构建速度。这是我们的测量结果：</p><p><img src="gradle1.jpg" alt></p><p>这个基准测试是<a href="https://github.com/gradle/performance-comparisons" target="_blank" rel="noopener">公开的</a>，你自己可以动手试验一下。该基准测试项目是根据真实用户反馈的问题虚构的一个项目。在持续开发过程中增量构建很重要(即，小的改动不应导致长时间的构建)</p><p>以那些在单个项目中有很多源码的场景为例：</p><ul><li>修改庞大项目中的一个文件，重新编译项目</li><li>修改中型项目中的一个文件，重新编译项目</li></ul><p>以多项目构建为例：</p><ul><li>在子项目中以ABI兼容的方式进行修改(比如，修改了一个方法中的代码，但没有修改方法签名)，重新编译项目</li><li>在子项目中以ABI不兼容的方式进行修改(比如，修改了一个方法的签名)，重新编译项目</li></ul><p>对上述各个场景，Gradle 3.4构建速度快多了。接下来看看我们是如何做到的。</p><h1 id="Compile-avoidance"><a href="#Compile-avoidance" class="headerlink" title="Compile avoidance"></a>Compile avoidance</h1><p>对Java来说，升级到Gradle 3.4就可以享受到它最大的改进之一： <em>compile avoidance</em> 。Compile avoidance不同于增量编译，我们后面会详细解释。那么如何理解compile avoidance呢？很简单。假设你的<code>app</code>项目依赖<code>core</code>项目，而<code>core</code>项目本身又依赖<code>utils</code>项目。</p><p>在<code>app</code>项目中有以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        WordCount wc = <span class="keyword">new</span> WordCount();</span><br><span class="line">        wc.collect(<span class="keyword">new</span> File(args[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(<span class="string">"Word count: "</span> + wc.wordCount());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>core</code>项目中有以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;  <span class="comment">// WordCount lives in project `core`</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">collect</span><span class="params">(File source)</span> </span>&#123;</span><br><span class="line">       IOUtils.eachLine(source, WordCount::collectLine);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>utils</code>项目中有以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOUtils</span> </span>&#123; <span class="comment">// IOUtils lives in project `utils`</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eachLine</span><span class="params">(File file, Callable&lt;String&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file))) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，要修改<code>IOUtils</code>的实现。比如，修改<code>eachLine</code>方法，使用utf8编码而不是缺省编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOUtils</span> </span>&#123; <span class="comment">// IOUtils lives in project `utils`</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eachLine</span><span class="params">(File file, Callable&lt;String&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(file), <span class="string">"utf-8"</span>) )) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在重新构建<code>app</code>项目，会发生什么情况？<code>utils</code>需要重新编译，而由于依赖关系它又会触发<code>core</code>和<code>app</code>重新编译。乍一看，很合理。但真的合理吗？</p><p><code>IOUtils</code>的修改只是内部细节的改变。<code>eachLine</code>的实现变了，但它的公开API并没有变化。之前已经编译好的依赖<code>IOUtils</code>的class文件其实仍然有效。Gradle现在可以识别这一点了，这意味着当你修改<code>eachLine</code>时，Gradle只需要编译<code>utils</code>项目，不必再编译<code>core</code>和<code>app</code>了。这个例子看似简单，其实是一种很常见的模式：<code>core</code>项目通常被很多子项目共享，而每个子项目又依赖于其他子项目。<code>core</code>项目的改动会导致所有项目都要重新编译。Gradle 3.4中这种情况不存在了，即，Gradle可以判断是否ABI(Application Binary Interface)不兼容的修改，只有ABI不兼容的修改才会引起所有项目重新编译。</p><p>这就是我们所谓的compilation avoidance。即使一些情况下重新编译不可避免，Gradle 3.4的增量编译功能也会让编译速度更快。</p><h1 id="改进的增量编译"><a href="#改进的增量编译" class="headerlink" title="改进的增量编译"></a>改进的增量编译</h1><p>长久以来，Gradle有一个实验性的Java增量编译器。在Gradle 3.4中，这个编译器不仅被确定下来，而且我们增加了其稳定性并提升了性能。现在就开始使用增量编译吧：我们不久之后会缺省启用该功能。要使用增量编译，只需在compile选项中设置参数即可：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tasks.withType(JavaCompile) &#123;</span><br><span class="line">   options.incremental = <span class="literal">true</span> <span class="comment">// one flag, and things will get MUCH faster</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>core</code>项目中增加以下类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NGrams</span> </span>&#123;  <span class="comment">// NGrams lives in project `core`</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">collect</span><span class="params">(String source, <span class="keyword">int</span> ngramLength)</span> </span>&#123;</span><br><span class="line">       collectInternal(StringUtils.sanitize(source), ngramLength);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>utils</code>项目中增加以下类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringUtils</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> String <span class="title">sanitize</span><span class="params">(String dirtyString)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们修改了<code>StringUtils</code>类并且重新编译项目，很明显我们只需要重新编译<code>StringUtils</code>和<code>NGrams</code>类，而不必编译<code>WordCount</code>类。<code>NGrams</code>是独立于<code>StringUtils</code>的类。而<code>WordCount</code>并没有使用到<code>StringUtils</code>，那为什么要重新编译它呢？这就是增量编译要解决的问题：分析类之间的依赖关系，只编译那些本身发生改变的类，或者其依赖项发生改变的类。</p><p>你之前使用过Java增量编译器时可能发现它在处理带有常量的类的修改时并不那么智能。比如，这个类包含一个常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个类被修改，Gradle会重新编译项目中的所有类以及依赖这个项目的所有项目。原因是这样的：你要知道，Java编译器会对常量进行内联处理。当我们分析编译结果时，在字节码中会发现它包含字面量123，但无法知道这个字面量是在哪里定义的。可能是这个类自己定义的，也有可能是它的某个依赖定义的。Gradle 3.4开始，我们让这里的处理更为智能，即，只编译那些可能受影响的类。换句话说，如果只是这个类变了，而其中的常量并没有变，不需要重新编译所有类。类似地，如果是常量变了，如果依赖项的字节码中并不包含旧的常量值，那么也就不必对其重新编译：只编译那些包含旧常量值的依赖。这也意味着并不是所有的常量生而平等，修改一个值为0的常量比起修改一个值为188847774的常量，前者更可能触发全量编译。</p><p>增量编译器现在使用Gradle daemon中的内存缓存，所以速度比过去要快：从Java类中提取ABI是一个昂贵的操作，而过去只对其进行disk缓存。</p><p>所有这些增量编译改进再加上前面说到的compile avoidance，Gradle现在重新编译Java代码已经快多了。值得一提的是，这些改进对外部依赖也有效。假设你从<code>foo-1.0.0</code>升级到<code>foo-1.0.1</code>，如果这两个库之间的差异仅仅是修改bug，并没有改变API，那么compile avoidance也会起作用，所以外部依赖的变化并没有让你的代码重新编译。当然，如果是外部依赖中的API发生了变化，Gradle的增量编译器会在类级别上进行分析，只进行必要的重新编译。</p><h1 id="annotation-processor"><a href="#annotation-processor" class="headerlink" title="annotation processor"></a>annotation processor</h1><p>annotation processors是一种强大的机制，可以通过注解的方式生成代码。典型的使用场景包括依赖注入(比如<a href="https://google.github.io/dagger/" target="_blank" rel="noopener">Dagger</a>)，或者是减少样板代码(比如，<a href="https://projectlombok.org/" target="_blank" rel="noopener">Lombok</a>, <a href="https://github.com/google/auto/tree/master/value" target="_blank" rel="noopener">Autovalue</a>, <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">Butterknife</a>)。但是使用annotation processor对构建性能有很多负面影响。</p><h2 id="annotation-processor原理"><a href="#annotation-processor原理" class="headerlink" title="annotation processor原理"></a>annotation processor原理</h2><p>annotation processor基本上可以理解成一个Java编译器插件。在Java编译器识别到一个可被processor处理的注解时就会触发这个processor。从构建工具角度而言，它是一个墨盒：我们并不知道annotation processor到底做了什么操作，尤其是annotation processor生成了什么文件，这些文件放在哪里。</p><p>因此一旦annotation processor的实现发生了变化，Gradle需要重新编译所有东西。这不算太糟糕，因为不经常发生。但问题是没有明确声明annotation processor时Gradle只能关闭compile avoidance功能。我们来看一下是怎么回事。现在的annotation processor一般都被添加到compile classpath中。</p><p>当Gradle发现一个jar文件中包含annotation processor时，它没法判断compile classpath下的其他jar文件是否被那个annotation processor使用。要知道，annotation processor本身也可能是有依赖的。这意味着compile classpath的任何变化都可能以某种Gradle没法理解的方式影响到annotation processor的行为。所以compile classpath发生任何变化都会触发全量编译。</p><p>但这个问题有解决办法。</p><h2 id="明确声明annotation-processor-classpath"><a href="#明确声明annotation-processor-classpath" class="headerlink" title="明确声明annotation processor classpath"></a>明确声明annotation processor classpath</h2><p>annotation processor作为编译器插件，使用到外部依赖，一定会影响到compile classpath，不是吗？答案是否定的。annotation processor的依赖不应该影响到compile classpath。这也正是为什么<code>javac</code>会提供<code>-processorpath</code>选项的原因，它用来区别于<code>-classpath</code>。你可以使用如下方式在Gradle中声明<code>processorpath</code>。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">    apt</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// The dagger compiler and its transitive dependencies will only be found on annotation processing classpath</span></span><br><span class="line">    apt <span class="string">'com.google.dagger:dagger-compiler:2.8'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// And we still need the Dagger annotations on the compile classpath itself</span></span><br><span class="line">    compileOnly <span class="string">'com.google.dagger:dagger:2.8'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compileJava &#123;</span><br><span class="line">    options.annotationProcessorPath = configurations.apt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中创建了一个<code>apt</code>配置，它包含所有被使用的annotation processor以及annotation processor自身的依赖。然后将<code>apt</code>设置给<code>annotationProcessorPath</code>。它有几个作用：</p><ul><li>一是关闭了在compile classpath中自动检查annotation processor的功能，这会让任务启动速度变快(更快的up-to-date检查)</li><li>二是会用到Java编译器的<code>processorpath</code>选项，可以正确地将compile依赖跟annotation processor自身的依赖区分开来</li><li>三是会开启compile avoidance：通过明确声明annotation processor，就能确定classpath中找到的所有东西都是二进制接口(与annotation processor没半点关系)</li></ul><p>特别是，你会注意到<a href="https://google.github.io/dagger/" target="_blank" rel="noopener">Dagger</a>是如何明确地将其编译器与注解分离开来的：我们使用<code>dagger-compiler</code>作为annotation处理过程的依赖，而将<code>dagger</code>(即注解本身)作为<code>compile</code>依赖。</p><p>但是，有些annotation processor并没有将这些关注点恰当地分离(比如<a href="https://projectlombok.org/" target="_blank" rel="noopener">Lombok</a>)，所以导致其实现类被泄露到compile classpath中。但这种场景下compile avoidance仍然起作用：你只需要将同一个jar同时放在<code>apt</code>和<code>compileOnly</code>配置中。</p><h2 id="带annotation-processor的增量编译"><a href="#带annotation-processor的增量编译" class="headerlink" title="带annotation processor的增量编译"></a>带annotation processor的增量编译</h2><p>上面说过，有annotation processor时，Gradle并不知道它生成了什么文件，也不知道它基于什么条件在哪里生成了文件。所以有annotation processor时Gradle会关闭Java增量编译器，即使你像刚才那样明确地声明annotation processor。但其实优化这种场景，限制annotation processor的影响，让它只影响到那些真正用到annotation processor的源码。简而言之，你要声明一个不同的source set，这个source set有不同的compile task，会用到annotation processor，而其它的compile task没有任何annotation processor：</p><ul><li>对那些没有用到的annotation processor的类进行修改时，增量编译仍然有效</li><li>对那些有用到annotation processor的类进行修改时，会触发全量编译，但只对对应原source set进行全量编译</li></ul><p>这里是一个例子：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">    apt</span><br><span class="line">    aptCompile</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    apt <span class="string">'com.google.dagger:dagger-compiler:2.8'</span></span><br><span class="line">    aptCompile <span class="string">'com.google.dagger:dagger:2.8'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sourceSets &#123;</span><br><span class="line">   processed &#123;</span><br><span class="line">       java &#123;</span><br><span class="line">          compileClasspath += configurations.aptCompile</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   main &#123;</span><br><span class="line">       java &#123;</span><br><span class="line">          compileClasspath += processed.output</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compileProcessedJava &#123;</span><br><span class="line">    options.annotationProcessorPath = configurations.apt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然实践中是否容易进行source set隔离，还要看<code>main</code>在多大程度上依赖<code>processed</code>中的类。当然我们也在探索如何在有annotation processor时开启增量编译，所以今后它将不再是一个问题。</p><h1 id="Java库"><a href="#Java库" class="headerlink" title="Java库"></a>Java库</h1><p>很久以来Gradle就在解释为什么Maven依赖模块有问题，但没有具体例子的话很难认识这一点，因为用户已经习惯这个问题并且认为它是正常的。尤其是<code>pom.xml</code>文件既用于构建组件，也作为发布时的元数据。Gradle的方式有所不同，它有一个构建脚本用于构建组件以及发布组件，可将组件发布到Maven，Ivy或任何其它库。发布的文件中包括该如何使用的元数据，也就是说我们将用于构建组件的脚本跟该如何使用最终产物的元数据清晰地分离了。将这两个角色分离是非常重要的，这允许Gradle 3.4对Java依赖管理添加基础改进。用户可以从这个基础改进中获得其他好处。首先是性能改进，它是对上述其他性能特性的补充。额外其他好处也很多。</p><h2 id="一直在用错误的方式"><a href="#一直在用错误的方式" class="headerlink" title="一直在用错误的方式"></a>一直在用错误的方式</h2><p>当我们在构建Java项目时，有两件事情需要考虑：</p><ul><li>我要怎样编译项目</li><li>我要怎样运行项目</li></ul><p>所以我们很自然地想在在两种不同的范围里声明依赖：</p><ul><li><code>compile</code> - 编译项目时的依赖</li><li><code>runtime</code> - 运行项目时的依赖</li></ul><p>过去这些年Maven和Gradle都这么用。但我们一开始就知道这样做是错的。这种视角过于简化，因为它没有考虑你的项目的消费者。要强调的是，Java世界里至少有两种项目：</p><ul><li>应用，它是可以独立运行的，并且不向外暴露任何API</li><li>库，它被其他库或应用使用，用作构建软件的小部件，所以要向外暴露API</li></ul><p>这种只考虑两种配置(Gradle)或者说两种范围(Maven)的简单方式，其问题在于没有考虑到具体的实现跟公开的API是两码事。换句话说，作为组件，你却将自己的编译依赖泄漏出下游消费者了。</p><p>假设我们正在构建一个IoT应用<code>home-automation</code>，它依赖<code>heat-sensor</code>库。<code>heat-sensor</code>库的compile classpath中包含有<code>commons-math3.jar</code>和<code>guava.jar</code>。所以<code>home-automation</code>的compile classpath中也将包含<code>commons-math3.jar</code>和<code>guava.jar</code>。有以下几种结果：</p><ul><li><code>home-automation</code>可能会使用<code>commons-math3.jar</code>和<code>guava.jar</code>中的类，但没意识到这些类其实是<code>heat-sensor</code>的传递依赖(传递依赖泄漏)</li><li>导致<code>home-automation</code>的compile classpath变得更大：<ul><li>依赖解析，up-to-date检查，classpath分析，以及<code>javac</code>花费的时间变长</li><li>classpath发生变化的可能性变大，导致Gradle的compile avoidance功能失效的可能性变大。尤其是当你又使用了annotation processor，Gradle的增量编译不起作用。最终引起非常大的开销</li></ul></li><li>增加了依赖地狱的可能(dependency hell, classpath中包含同一依赖的不同版本)</li></ul><p>但最糟糕的问题其实是<code>guava.jar</code>纯粹是<code>heat-sensor</code>的内部细节，而<code>home-automation</code>使用<code>guava.jar</code>中的类仅仅是因为在compile classpath中找到了这些类。<code>heat-sensor</code>的改进和演化变得困难，因为会破坏它的消费者(译者注：这里其实是说，如果哪天发现<code>heat-sensor</code>其实没必要使用<code>guava.jar</code>，或者有比<code>guava.jar</code>更好的库了，但你没办法从<code>heat-sensor</code>中移除或替换<code>guava.jar</code>，因为<code>home-automation</code>也依赖<code>guava.jar</code>)。依赖泄漏是很可怕，它引起不必要的向后兼容问题，导致软件演化过程变得缓慢或是特性僵化。</p><p>我们知道自己一直做错了，现在是时间修复这个问题了。所以引入了新的Java Library Plugin。</p><h2 id="Java-Library-Plugin"><a href="#Java-Library-Plugin" class="headerlink" title="Java Library Plugin"></a>Java Library Plugin</h2><p>从Gradle 3.4开始，如果你构建Java library，表明目标是构建一个被其他组件消费的组件(即作为其他东西的依赖)，这时应该用<code>apply plugin: &#39;java-library&#39;</code>替代<code>apply plugin: &#39;java&#39;</code>。</p><p>它们基本相同。但<code>java-library</code>插件提供API的概念。现在我们对<code>heat-sensor</code>库进行迁移，它自身有两个依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   compile <span class="string">'org.apache.commons:commons-math3:3.6.1'</span></span><br><span class="line">   compile <span class="string">'com.google.guava:guava:21.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看了<code>heat-sensor</code>的代码后会发现，<code>commons-math3</code>用作公开的API，而<code>guava</code>只是单纯的内部实现。</p><p>这意味着假如明天<code>heat-sensor</code>想从Guava迁移到另一个集合库，它并不会对其消费者有任何影响。但实践中我们只有明确区分两种依赖才可能达到这一目的：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   api <span class="string">'org.apache.commons:commons-math3:3.6.1'</span></span><br><span class="line">   implementation <span class="string">'com.google.guava:guava:21.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>api</code>用于声明需要依赖传递，应当对下游消费者可见的依赖。而<code>implementation</code>用于声明不应该泄漏到消费者compile classpath的依赖(因为它们纯粹是内部细节)。</p><p>现在当编译<code>heat-sensor</code>的消费者时，它会发现compile classpath中可以找到<code>commons-math3.jar</code>，而没有<code>guava.jar</code>。如果<code>home-automation</code>想使用Guava库中的类，会发现有编译错误。作为消费者<code>home-automation</code>需要自己决定它是否真的需要引入Guava依赖。另一方面，如果<code>home-automation</code>想使用Apache Math3中的类，是可以的。</p><h2 id="更好的POMs"><a href="#更好的POMs" class="headerlink" title="更好的POMs"></a>更好的POMs</h2><p><code>implementation</code>什么时候有用呢？它只在运行时有用！这也是为什么现在选择发布到Maven库时Gradle生成的<code>pom.xml</code>要比Maven自己生成的<code>pom.xml</code>更清晰的原因。来看一下<code>maven-publish</code>插件生成的<code>heat-sensor</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.acme<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>heat-sensor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-math3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>21.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面就是发布的<code>pom.xml</code>文件，它被消费者使用。文件告诉我们什么呢？</p><ul><li><code>compile</code> classpath中需要有<code>commons-math3</code>，才能依赖<code>heat-sensor</code>进行编译</li><li><code>runtime</code> classpath中需要有<code>guava</code>，才能依赖<code>heat-sensor</code>运行</li></ul><p>这跟编译组件和消费组件时使用同一个<code>pom.xml</code>非常不同。因为编译<code>heat-sensor</code>时，<code>compile</code> classpath也要有<code>guava</code>才行。简单来说：相比Mavne，Gradle生成更好的POM文件，因为它准确区分生产者和消费者。</p><h2 id="更多场景"><a href="#更多场景" class="headerlink" title="更多场景"></a>更多场景</h2><p>你可能知道<a href="https://blog.gradle.org/introducing-compile-only-dependencies" target="_blank" rel="noopener">Gradle 2.12引入的compileOnly</a>，它用于声明那些只在编译组件时需要而在运行期不需要的依赖(典型的场景是将一个库嵌入到fat jar中，<a href="https://github.com/johnrengelman/shadow" target="_blank" rel="noopener">shadowed</a>)。<code>java-library</code>插件提供一个从<code>java</code>插件平滑迁移的路径：如果你是构建应用，继续使用<code>java</code>插件。否则，如果是library，使用<code>java-library</code>插件。但无论哪种情况都要遵守以下规则：</p><ul><li>使用<code>implementation</code>替代<code>compile</code></li><li>使用<code>runtimeOnly</code>替代<code>runtime</code></li><li>解析组件的runtime时，使用<code>runtimeClasspath</code>替代<code>runtime</code></li></ul><h2 id="对性能的影响"><a href="#对性能的影响" class="headerlink" title="对性能的影响"></a>对性能的影响</h2><p>为了演示对性能的影响，我们对两种场景添加了基准测试：</p><ul><li>在library中进行ABI兼容的修改，然后重新编译</li><li>在library中进行ABI不兼容的修改，然后重新编译</li></ul><p>只有Gradle 3.4才支持library的概念，所以在Gradle 3.4中使用Java Library Plugin。为了让结果更清晰，基准测试中不使用增量编译(增量编译更快)</p><p><img src="gradle2.jpg" alt></p><p>可以看到模型变好之外，性能也有很大提升！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Gradle 3.4为Java生态系统带来了巨大的改进。更好增量编译以及compile avoidance会大大提升你的生产率，而清晰地分离API依赖和实现依赖能避免意外的依赖泄漏，从而获得更好的软件模型。我们还会带来更多好处。特别是，分离API和实现是Java 9成功的关键 <a href="http://openjdk.java.net/projects/jigsaw/" target="_blank" rel="noopener">Project Jigsaw</a>。今后我们还会添加给API指定package的方法，以更接近Jigsaw的做法，且支持更老的JDK。</p><p>另外，Gradle 4.0将提供build cache，它也能从本文中描述的改进中受益：它是允许在本地机器或网络中复用和共享构建任务结果。典型的使用场景包括切换分支，或者check out一个已被同事或CI编译过的项目。换一种说法就是，如果你或者谁已经构建了某个你需要的东西，你可以从缓存中得到它，而不必在本地重新构建一次。而这要求build cache需要为java compile task生成cache key，key的生成与compile classpath相关。Gradle 3.4的改进会忽略跟消费者不相关的修改(除非是ABI不兼容的修改)，从而让cache key更容易命中。</p><p>我们鼓励现在就更新到Gradle 3.4，并且看下<a href="https://docs.gradle.org/current/userguide/java_library_plugin.html" target="_blank" rel="noopener">Java Library plugin的文档</a>，去看看你能用它干什么吧！</p><hr><p>更新：补充另外一些内容的翻译，内容来自<a href="https://docs.gradle.org/current/userguide/java_plugin.html#sec:incremental_compile" target="_blank" rel="noopener">Gradle 4.10文档</a></p><h1 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h1><h2 id="Java增量编译"><a href="#Java增量编译" class="headerlink" title="Java增量编译"></a>Java增量编译</h2><p>Gradle 4.10缺省开启一个复杂的Java增量编译器。</p><p>它有以下好处：</p><ul><li>增量构建速度更快</li><li>变更的class文件数量最小。不需要重新编译的类在输出目录中保持不变。一个场景是使用JRebel时，变更的类越少，JVM就能更快地使用变更后的类</li></ul><p>为了有助于理解增量编译是如何进行的，下面稍加总结：</p><ul><li>Gradle会重新编译所以被某个变更 <em>影响</em> 的类</li><li>一个类被修改，或者它依赖于一个受影响的类，就认为它受到 <em>影响</em> 。注意，不管依赖的类是在同一个项目，还是另一个项目或者外部库，规则都一样</li><li>类的依赖是根据字节码中的类型引用确定的</li><li>由于常量被内联，对常量进行任何修改都会导致Gradle重新编译所有代码。出于这个理由，你应该尽可能少用常量，或者将常量替换为静态方法</li><li>source-retention级别的注解在字节码中不可见，所以修改source-retention级别的注解会导致全量编译</li><li>通过使用好的软件设计法则，比如松耦合，可以改进增量编译性能。比如，在具体类和其使用者之间引入接口，只有当接口变化时使用者才会被重新编译，具体类变化时使用者并不需要重新编译</li><li>类分析结果保存在项目目录中，所以clean之后首次编译速度会比较慢。构建服务器上应当关闭增量编译功能</li></ul><h2 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h2><ul><li>如果一个由于编译错误导致compile task失败，Gradle下次会进行全量编译</li></ul><h2 id="增量annotation处理"><a href="#增量annotation处理" class="headerlink" title="增量annotation处理"></a>增量annotation处理</h2><p>从Gradle 4.7开始，增量编译器还支持增量annotation处理。Annotation processor需要根据这个特性进行优化，否则仍然会触发全量编译。</p><p>用户可以从<code>--info</code>日志(以<code>gradle --info</code>方式运行)中找到是哪个annotation processor触发全量编译的。在compile task中配置自定义的<code>executable</code>或<code>javaHome</code>，增量annotation处理会失效。</p><h2 id="让annotation-processor支持增量处理"><a href="#让annotation-processor支持增量处理" class="headerlink" title="让annotation processor支持增量处理"></a>让annotation processor支持增量处理</h2><p>(译者注：这一块的知识不是很了解，所以翻译得惨不忍睹，建议略过直接看<a href="https://docs.gradle.org/current/userguide/java_plugin.html#making_an_annotation_processor_incremental" target="_blank" rel="noopener">原文</a>)</p><p>请先阅读<a href="https://docs.gradle.org/current/userguide/java_plugin.html#sec:incremental_compile" target="_blank" rel="noopener">incremental Java compilation</a>相关内容，因为增量annotation是基于它的。</p><p>Gradle为两类anntation processor提供增量编译支持：”isolating”或”aggregating”。可以参考以下内容来确定你的annotation processor属于哪一种。</p><p>可以在processor的META-INF目录中使用文件注册processor。格式是每行一个processor，processor类全名以及它的类型，两者用逗号分开</p><p>例： 注册增量annotaion processor </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 所在文件 processor/src/main/resources/META-INF/gradle/incremental.annotation.processors</span><br><span class="line">EntityProcessor,isolating</span><br><span class="line">ServiceRegistryProcessor,dynamic</span><br></pre></td></tr></table></figure><p>如果只能在运行时确定是否增量处理，可以在META-INF描述文件中将其声明为”dynamic”，并且使用<a href="https://docs.oracle.com/javase/10/docs/api/javax/annotation/processing/Processor.html#getSupportedOptions(" target="_blank" rel="noopener">Processor#getSupportedOptions()</a>)方法在运行返回真正的类型。</p><p>例：动态注册增量annotation processor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processor/src/main/java/ServiceRegistryProcessor.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedOptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.singleton(<span class="string">"org.gradle.annotation.processing.aggregating"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论哪种类型，都应该遵守以下限制：</p><ul><li>它们必须使用<a href="https://docs.oracle.com/javase/10/docs/api/javax/annotation/processing/Filer.html" target="_blank" rel="noopener">Filer API</a>生成文件。使用任何其它方式生成文件都会引起后续的静默失败，因为生成的文件无法被正确清理干净。如果你的processor使用其它方式生成文件，那它就无法进行增量处理</li><li>它们不能依赖编译器特定的接口，比如<a href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/Trees.html" target="_blank" rel="noopener">com.sun.source.util.Trees</a>。Gradle包装了这些API，所以尝试强制转换到编译器特定类型时会失败。如果你的processor这么做，那它就无法进行增量处理</li><li>如果它们有使用<a href="https://docs.oracle.com/javase/10/docs/api/javax/annotation/processing/Filer.html#getResource(javax.tools.JavaFileManager.Location,java.lang.CharSequence,java.lang.CharSequence" target="_blank" rel="noopener">Filer#getResource</a>)，Gradle会全量编译。见<a href="https://docs.oracle.com/javase/10/docs/api/javax/annotation/processing/Filer.html#getResource(javax.tools.JavaFileManager.Location,java.lang.CharSequence,java.lang.CharSequence" target="_blank" rel="noopener">Filer#getResource</a>)</li><li>如果它们有使用<a href="https://docs.oracle.com/javase/10/docs/api/javax/annotation/processing/Filer.html#createResource(javax.tools.JavaFileManager.Location,java.lang.CharSequence,java.lang.CharSequence,javax.lang.model.element.Element..." target="_blank" rel="noopener">Filer#createResource</a>)，Gradle会全量编译。见<a href="https://github.com/gradle/gradle/issues/4702" target="_blank" rel="noopener">gradle/issues/4702</a></li></ul><p>“isolating” annotation processor</p><p>这是最快的一种类型，它们以隔离的方式寻找每个注解元素，为它生成文件或者验证信息。比如<code>EntityProcessor</code>可以为每个带有<code>@Entity</code>注解的类型生成<code>&lt;TypeName&gt;Repository</code>。</p><p>例：isolated annotation processor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processor/src/main/java/EntityProcessor.java</span></span><br><span class="line"></span><br><span class="line">Set&lt;? extends Element&gt; entities = roundEnv.getElementsAnnotatedWith(entityAnnotation);</span><br><span class="line"><span class="keyword">for</span> (Element entity : entities) &#123;</span><br><span class="line">    createRepository((TypeElement) entity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isolated annotation processor有以下限制：</p><ul><li>它们必须基于AST中的信息为注解元素做判断(代码生成，验证信息)。这意味着可以分析类型的父类，方法的返回值，注解等等。但不能根据不相关元素做判断。这么做会引起静默失败，因为后面几乎无法重新编译文件。如果processor需要根据其他不相关元素来联合进行判断，需要将processor标记为”aggregating”</li><li>它们必须为使用<code>Filer</code> API生成的每个文件提供一个originating element。如果是0个或多个，Gradle会全量编译</li></ul><p>如果一个源文件被重新编译，所有由这个文件生成的源文件也会被重新编译。当一个源文件被删除，所以由这个文件生成的源文件都会被删除。</p><p>“Aggregating” annotation processors</p><p>它们可以将多个源文件合并到一个或多个文件中。比如，<code>ServiceRegistryProcessor</code>可以使用一个方法为每个带<code>@Service</code>注解的类型创建一个单独的<code>ServiceRegistry</code></p><p>例：An aggregating annotation processor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processor/src/main/java/ServiceRegistryProcessor.java</span></span><br><span class="line"></span><br><span class="line">JavaFileObject serviceRegistry = filer.createSourceFile(<span class="string">"ServiceRegistry"</span>);</span><br><span class="line">Writer writer = serviceRegistry.openWriter();</span><br><span class="line">writer.write(<span class="string">"public class ServiceRegistry &#123;"</span>);</span><br><span class="line"><span class="keyword">for</span> (Element service : roundEnv.getElementsAnnotatedWith(serviceAnnotation)) &#123;</span><br><span class="line">    addServiceCreationMethod(writer, (TypeElement) service);</span><br><span class="line">&#125;</span><br><span class="line">writer.write(<span class="string">"&#125;"</span>);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure><p>“Aggregating” processor有以下限制：</p><ul><li>它们只能访问<code>CLASS</code>或<code>RUNTIME</code>注解</li><li>如果用户使用<code>-parameters</code>参数编译，它们只能读取参数名字</li></ul><p>Gradle总是重新处理(但是重新编译)所有的注解文件。Gradle总是重新编译processor生成的任何文件。</p><h2 id="Compile-avoidance-1"><a href="#Compile-avoidance-1" class="headerlink" title="Compile avoidance"></a>Compile avoidance</h2><p>如果被依赖的项目发生ABI兼容的修改(即只有private API改变)，则对应的java compilation task被认为是up-to-date的。这意味着如果<code>A</code>项目依赖<code>B</code>项目，<code>B</code>中的一个类发生ABI兼容的修改(通常是修改了一个方法中的代码)，那么Gradle不会重新编译<code>A</code>项目。</p><p>一些不影响公开API修改以及会被忽略的修改：</p><ul><li>修改方法中的代码</li><li>修改注释</li><li>添加，移除，修改private方法、字段或内部类</li><li>添加，移除，修改资源</li><li>修改classpath中的jar文件名或目录名</li><li>重命名参数</li></ul><p>如果compile classpath中包含annotation processor，compile avoidance功能会失效，因为对于annotation processor而言，代码的具体实现是有影响的。为了避免这种问题，annotation processor应该在<code>annotationProcessor</code>中声明。Gradle 5.0将忽略compile classpath中的annotation processor。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// build.gradle</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    // The dagger compiler and its transitive dependencies will only be found on annotation processing classpath</span><br><span class="line">    annotationProcessor &apos;com.google.dagger:dagger-compiler:2.8&apos;</span><br><span class="line"></span><br><span class="line">    // And we still need the Dagger library on the compile classpath itself</span><br><span class="line">    implementation &apos;com.google.dagger:dagger:2.8&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- https://stackoverflow.com/questions/26424759/what-is-sjavac-who-is-it-for-and-how-do-i-use-it -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Fragment权限问题的一个小坑</title>
      <link href="2018/09/10/fragment-permission/"/>
      <url>2018/09/10/fragment-permission/</url>
      
        <content type="html"><![CDATA[<p>记录Fragment中关于权限问题的一个小坑。<br><a id="more"></a></p><p>调用<code>ActivityCompat.requestPermissions()</code>方法，<code>Activity.onRequestPermissionsResult()</code>回调正常，而<code>Fragment.onRequestPermissionsResult()</code>不回调。</p><p>StackOverflow上找了两篇帖子</p><ul><li><a href="https://stackoverflow.com/questions/40760625/how-to-check-permission-in-fragment" target="_blank" rel="noopener">how-to-check-permission-in-fragment</a></li><li><a href="https://stackoverflow.com/questions/32890702/request-runtime-permissions-from-v4-fragment-and-have-callback-go-to-fragment" target="_blank" rel="noopener">request-runtime-permissions-from-v4-fragment-and-have-callback-go-to-fragment</a></li></ul><p>给出的答案都是这样：</p><ul><li>fragment v4 中需要使用 <code>Fragment.requestPermission(String[], int);</code></li><li>而Activity中需要使用 <code>AppCompat.requestPermission(Activity, String[], int)</code></li></ul><p>按给出的答案，将<code>ActivityCompat.requestPermissions()</code>修改成<code>Fragment.requestPermission(String[], int);</code>，<code>Activity.onRequestPermissionsResult()</code>及<code>Fragment.onRequestPermissionsResult()</code>都能正常回调。</p><p>这种设计还真是坑啊！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.coderzheaven.com/2016/10/12/onrequestpermissionsresult-not-called-on-fragments/" target="_blank" rel="noopener">onRequestPermissionsResult not called on Fragments in Android – CODERZHEAVEN</a>    </p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一个诡异响应码HTTP 411</title>
      <link href="2018/08/30/http-411/"/>
      <url>2018/08/30/http-411/</url>
      
        <content type="html"><![CDATA[<p>开发过程碰到http 411错误，记录并分析其原因。<br><a id="more"></a></p><h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><p>首先看看411是什么。<a href="411">MDN</a>给出的解释如下：</p><blockquote><p>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</p></blockquote><p>使用不带body的POST有点类似使用一个不带参数的方法，比如说<code>int post(void)</code>。虽然可行，但不是好的做法，而且要注意POST请求不带body时一定要带<code>Content-Length: 0</code>，不然某些代理会拒绝这个POST请求。</p><p>有如下一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    URL url = <span class="keyword">new</span> URL(<span class="string">"http://url"</span>);</span><br><span class="line">    HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">    httpURLConnection.setRequestMethod(<span class="string">"POST"</span>);</span><br><span class="line">    httpURLConnection.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">    httpURLConnection.setRequestProperty(<span class="string">"Charset"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">    httpURLConnection.setRequestProperty(<span class="string">"Content-Type"</span>, <span class="string">"multipart/form-data;boundary=******"</span>);</span><br><span class="line">    httpURLConnection.setRequestProperty(<span class="string">"Connection"</span>, <span class="string">"close"</span>);</span><br><span class="line"></span><br><span class="line">    httpURLConnection.setRequestProperty(<span class="string">"Cookie"</span>, <span class="string">"A=1; U=2; UT=1; "</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(httpURLConnection.getResponseCode());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; it : httpURLConnection.getHeaderFields().entrySet()) &#123;</span><br><span class="line">        System.out.println(it.getKey() + <span class="string">" "</span> + it.getValue().get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (httpURLConnection.getResponseCode() == HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">        InputStream is = httpURLConnection.getInputStream();</span><br><span class="line">        System.out.println(Okio.buffer(Okio.source(is)).readUtf8());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(Okio.buffer(Okio.source(httpURLConnection.getErrorStream())).readString(Charset.forName(<span class="string">"gb2312"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的运行结果非常诡异：</p><ul><li>在Genemotion上运行时会返回411，提示<code>Length Required</code></li><li>在PC返回200</li><li>在真机上返回200</li></ul><p>如果注释掉<code>httpURLConnection.setChunkedStreamingMode(128 * 1024)</code>这个调用后，在Genemotion, PC及真机上均返回200。</p><p>通常使用OkHttp或其他第三方库进行http访问，很少使用<code>HttpURLConnection</code>进行http访问，因为前者更方便。所以不太了解<code>HttpURLConnection.setChunkedStreamingMode()</code>方法的作用，另外还有一个类似的方法<code>HttpURLConnection.setFixedLengthStreamingMode()</code>。</p><p>查了下这两个方法的作用，如下：</p><ul><li><code>setFixedLengthStreamingMode()</code> - 用于事先知道content length的情况下启用http request body的流式处理而不使用内部的缓存机制。 如果应用尝试写入的数据大小超过指定的大小，或者在写入数据前关闭了OutputStream，方法会抛出异常。当启用流式处理时，不会自动处理authentication和redirection。需要authentication和redirection时会抛出HttpRetryException异常。<code>setFixedLengthStreamingMode()</code>方法应当在URLConnection连上之前调用。</li><li><code>setChunkedStreamingMode()</code> - 用于事先不知道content length的情况下http request body的流式处理而不使用内部的缓存机制。这种模式下，将使用chunked transfer encoding方式来发送请求体。注意，不是所有服务器都支持这一模式。当启用流式处理时，不会自动处理authentication和redirection。需要authentication和redirection时会抛出HttpRetryException异常。<code>setChunkedStreamingMode()</code>方法应当在URLConnection连上之前调用。</li></ul><p>这两个方法都是用于开启streaming模式，以提高性能，所以应该跟411 Length Required应该没有直接的关系。不太明白为什么调用<code>setChunkedStreamingMode()</code>之后就会有问题。</p><p>可以在发生411错误时打印出响应。响应中的错误信息表示的确很可能是缺少<code>Content-Length</code>请求头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Content-Length 1580</span><br><span class="line">Content-Type text/html</span><br><span class="line">Date Thu, 30 Aug 2018 06:49:37 GMT</span><br><span class="line">Server squid/2.7.STABLE9</span><br><span class="line">X-Android-Received-Millis 1534715103348</span><br><span class="line">X-Android-Response-Source NETWORK 411</span><br><span class="line">X-Android-Selected-Protocol http/1.1</span><br><span class="line">X-Android-Sent-Millis 1534715103343</span><br><span class="line">X-Cache MISS from SK-SQUIDDEV-114</span><br><span class="line">X-Cache-Lookup NONE from SK-SQUIDDEV-114:8080</span><br><span class="line">X-Squid-Error ERR_INVALID_REQ 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;HTML&gt;&lt;HEAD&gt;</span><br><span class="line">&lt;META HTTP-EQUIV=&quot;Content-Type&quot; CONTENT=&quot;text/html; charset=gb2312&quot;&gt; </span><br><span class="line">&lt;TITLE&gt;错误：您所请求的网址（URL）无法获取&lt;/TITLE&gt;</span><br><span class="line">&lt;STYLE type=&quot;text/css&quot;&gt;&lt;!--BODY&#123;background-color:#ffffff;font-family:verdana,sans-serif&#125;PRE&#123;font-family:sans-serif&#125;--&gt;&lt;/STYLE&gt;</span><br><span class="line">&lt;/HEAD&gt;&lt;BODY&gt;</span><br><span class="line">&lt;H1&gt;错误&lt;/H1&gt;</span><br><span class="line">&lt;H2&gt;您所请求的网址（URL）无法获取&lt;/H2&gt;</span><br><span class="line">&lt;HR noshade size=&quot;1px&quot;&gt;</span><br><span class="line">&lt;P&gt;</span><br><span class="line">当尝试进行以下请求时：</span><br><span class="line">&lt;PRE&gt;</span><br><span class="line">POST /xxx.php HTTP/1.1</span><br><span class="line">Charset: UTF-8</span><br><span class="line">Content-Type: multipart/form-data;boundary=******</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: A=1; U=2; UT=1;</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">User-Agent: Dalvik/2.1.0 (Linux; U; Android 7.0; Google Nexus 5X - 7.0.0 - API 24 - 1080x1920 Build/NRD90M)</span><br><span class="line">Host: url</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">&lt;/PRE&gt;</span><br><span class="line">&lt;P&gt;</span><br><span class="line">发生了下列的错误：</span><br><span class="line">&lt;UL&gt;</span><br><span class="line">&lt;LI&gt;</span><br><span class="line">&lt;STRONG&gt;</span><br><span class="line">Invalid Request</span><br><span class="line">&lt;BR&gt;</span><br><span class="line">无效的请求</span><br><span class="line">&lt;/STRONG&gt;</span><br><span class="line">&lt;/UL&gt;</span><br><span class="line">&lt;P&gt;</span><br><span class="line">Some aspect of the HTTP Request is invalid.  Possible problems:</span><br><span class="line">&lt;BR&gt;</span><br><span class="line">HTTP 请求的某些方面是无效的。可能是下列问题：</span><br><span class="line">&lt;UL&gt;</span><br><span class="line">&lt;LI&gt;Missing or unknown request method</span><br><span class="line">&lt;BR&gt;缺少请求方式或未知的请求方式</span><br><span class="line">&lt;LI&gt;Missing URL</span><br><span class="line">&lt;BR&gt;缺少网址</span><br><span class="line">&lt;LI&gt;Missing HTTP Identifier (HTTP/1.0)</span><br><span class="line">&lt;BR&gt;缺少 HTTP 标识（HTTP/1.0）</span><br><span class="line">&lt;LI&gt;Request is too large</span><br><span class="line">&lt;BR&gt;请求命令过长</span><br><span class="line">&lt;LI&gt;Content-Length missing for POST or PUT requests</span><br><span class="line">&lt;BR&gt;POST 或 PUT 请求缺少内容长度</span><br><span class="line">&lt;LI&gt;Illegal character in hostname; underscores are not allowed</span><br><span class="line">&lt;BR&gt;主机名称中包含不合法的字符；下划线是不允许的。</span><br><span class="line">&lt;/UL&gt;</span><br><span class="line">&lt;/P&gt;</span><br><span class="line">&lt;P&gt;本缓存服务器管理员：&lt;A HREF=&quot;mailto:SK-SQUIDDEV-114&quot;&gt;SK-SQUIDDEV-114&lt;/A&gt;. </span><br><span class="line">&lt;/BODY&gt;&lt;/HTML&gt;</span><br></pre></td></tr></table></figure><p>如何打印出请求呢？我的做法很简单，使用Node + Express搭一个web服务，用同一份代码访问这个服务，观察请求头。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(cookieParser());</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'content-length: '</span>, req.headers[<span class="string">'content-length'</span>]);</span><br><span class="line">        res.send(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.post(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'content-length: '</span>, req.headers[<span class="string">'content-length'</span>]);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'user-agent: '</span>, req.headers[<span class="string">'user-agent'</span>]);</span><br><span class="line">        res.send(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">7654</span>, <span class="string">'127.0.0.1'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 7654!'</span>));</span><br></pre></td></tr></table></figure><ul><li>当调用了<code>setChunkedStreamingMode()</code>方法后(无论参数是否-1)，web服务无法收到请求，错误响应跟上述错误类似</li><li>当没有调用<code>setChunkedStreamingMode()</code>方法，web服务正常收到请求，显示<code>content-length:  0</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Genemotion</span><br><span class="line">content-length:  0</span><br><span class="line">user-agent:  Dalvik/2.1.0 (Linux; U; Android 7.0; Google Nexus 5X - 7.0.0 - API 24 - 1080x1920 Build/NRD90M)</span><br><span class="line">content-length:  0</span><br><span class="line">user-agent:  Dalvik/2.1.0 (Linux; U; Android 7.0; Google Nexus 5X - 7.0.0 - API 24 - 1080x1920 Build/NRD90M)</span><br><span class="line">// Postman</span><br><span class="line">content-length:  0</span><br><span class="line">user-agent:  Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36</span><br><span class="line">content-length:  0</span><br><span class="line">user-agent:  Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36</span><br><span class="line">// Java</span><br><span class="line">content-length:  0</span><br><span class="line">user-agent:  Java/1.8.0_73</span><br><span class="line">content-length:  0</span><br><span class="line">user-agent:  Java/1.8.0_73</span><br></pre></td></tr></table></figure><p>推测411大概是这样发生的：Genemotion虚拟上的HttpURLConnection实现有bug，导致调用<code>setChunkedStreamingMode()</code>方法后没有body的POST请求中缺少<code>Content-Length</code>请求头，所以这个请求被代理(squid/2.7.STABLE9)拦下来了，拦截原因正是<code>411  Length Required</code>。</p><h1 id="HttpURLConnection"><a href="#HttpURLConnection" class="headerlink" title="HttpURLConnection"></a>HttpURLConnection</h1><p>为加深对HttpURLConnection的了解，这里将Android SDK中HttpURLConnection的注释文档翻译了一遍。</p><p>HttpURLConnection是用于支持HTTP特性的URLConnection，具体参考<a href="http://www.w3.org/pub/WWW/Protocols/" target="_blank" rel="noopener">HTTP</a>。</p><p>它的使用方式如下：</p><ul><li>调用<code>URL.openConnection()</code>来获取一个新的<code>HttpURLConnection</code>对象，并将其强制转型为HttpURLConnection</li><li>准备请求。请求的最重要属性是其URI。请求头可能包括诸如credentials, preferred content types, session cookies之类的元数据</li><li>请求体(可选)。如果包括请求体，则必须调用<code>HttpURLConnection.setDoOutput(true)</code>。通过写入<code>getOutputStream()</code>返回的输出流的方式来传输数据</li><li>读取响应。响应头通常包括请求体content type, content length, modified date, session cookies之类的元数据。响应体可以从<code>getInputStream()</code>返回的输入流中读取。如果没有响应体，<code>getInputStream()</code>返回一个空的流</li><li>断开连接。一旦读取响应体完毕，需要调用<code>disconnect()</code>来关闭HttpURLConnection。断开连接可以释放相关资源</li></ul><p>以访问<a href="http://www.android.com/" target="_blank" rel="noopener">http://www.android.com/</a>网站为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.android.com/"</span>);</span><br><span class="line">HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InputStream in = <span class="keyword">new</span> BufferedInputStream(urlConnection.getInputStream());</span><br><span class="line">readStream(in);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">urlConnection.disconnect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>在以”https”开头的URL上调用<code>URL.openConnection()</code>时会返回HttpsURLConnection，可以覆盖缺省的<code>HostnameVerifier</code>和<code>SSLSocketFactory</code>。从<code>SSLContext</code>创建的<code>SSLSocketFactory</code>可以提供自定义的<code>X509TrustManager</code>用于验证证书链，而自定义的<code>X509KeyManager</code>可以提供客户端证书。</p><h2 id="资源处理"><a href="#资源处理" class="headerlink" title="资源处理"></a>资源处理</h2><p>HttpURLConnection允许5次HTTP重定向。它会从原始服务器重定向到另一个，但不支持从HTTPS重定向到HTTP或从HTTP重定向到HTTP。</p><p>如果HTTP响应中有错误发生，<code>getInputStream()</code>方法会抛出IOException。使用<code>getErrorStream()</code>读取错误响应。而响应头可以使用正常的<code>getHeaderFields()</code>获取。</p><h2 id="发送内容"><a href="#发送内容" class="headerlink" title="发送内容"></a>发送内容</h2><p>向web服务器上传数据时，需要调用<code>setDoOutput(true)</code>进行配置。</p><p>为了达到最好的性能，在事先知道请求体长度时应当调用<code>setFixedLengthStreamingMode()</code>，而事先无法知道请求体长度时调用<code>setChunkedStreamingMode()</code>。否则HttpURLConnection会被发送数据前在内存中为整个请求体分配缓冲区，浪费内存甚至可能引起OOM，并且导致数据发送延迟。</p><p>看个上传数据的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  urlConnection.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">  urlConnection.setChunkedStreamingMode(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  OutputStream out = <span class="keyword">new</span> BufferedOutputStream(urlConnection.getOutputStream());</span><br><span class="line">  writeStream(out);</span><br><span class="line"></span><br><span class="line">  InputStream in = <span class="keyword">new</span> BufferedInputStream(urlConnection.getInputStream());</span><br><span class="line">  readStream(in);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  urlConnection.disconnect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>HttpURLConnection返回的输入流和输出流都没有缓冲。多数调用者应当使用<code>BufferedInputStream</code>或<code>BufferedOutputStream</code>包装httpURLConnection返回的流。只做块读写的调用方可以忽略缓冲。</p><p>向服务器大量上传或下载数据时，使用流方式可以避免一次占用过多内存。除非你需要将body一次性放进内存，否则应该以流的方式进行处理(也就是说不要将整个body保存为byte数据或String)</p><p>为减少延迟，HttpURLConnection可能会为多次请求复用同一个底层的Socket。复用的结果是HTTP连接保持的时间比实际需要的时间要长一些。调用<code>disconnect()</code>会将Socket放回连接池。</p><p>缺省情况下HttpURLConnection要求服务器端使用gzip压缩，它能自动为<code>getInputStream()</code>调用方解压数据。这种情况下Content-Encoding和Content-Length两个响应头会被清除。在请求头中添加”Accept-Encoding: identity”来关闭gzip压缩。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urlConnection.setRequestProperty(<span class="string">"Accept-Encoding"</span>, <span class="string">"identity"</span>);</span><br></pre></td></tr></table></figure><p>指定明确的”Accept-Encoding”请求头会关闭自动解压，不会修改原始的响应头。调用方必须自己根据响应头中的Content-Type头进行必要的解压。</p><p><code>getContentLength()</code>返回传输的字节数，不能作为已压缩的输入流<code>getInputStream()</code>中可读取的字节数。相反的，应该一直读取输入流直到数据耗尽，即<code>InputStream.read()</code>返回-1。</p><h2 id="处理网络登录"><a href="#处理网络登录" class="headerlink" title="处理网络登录"></a>处理网络登录</h2><p>一些WiFi网络会阻止用户访问，直到用户点击某个登录页面。通常是通过HTTP重定向来展示登录页。可以使用<code>getURL()</code>来测试连接是否被重定向。当然，这种测试只有在收到响应头后才有效，你可以调用<code>getInputStream()</code>或<code>getHeaderFields()</code>来触发响应。下面的例子在检查响应是否有被重定向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  InputStream in = <span class="keyword">new</span> BufferedInputStream(urlConnection.getInputStream());</span><br><span class="line">  <span class="keyword">if</span> (!url.getHost().equals(urlConnection.getURL().getHost())) &#123;</span><br><span class="line">    <span class="comment">// we were redirected! Kick the user out to the browser to sign on?</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  urlConnection.disconnect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTTP认证"><a href="#HTTP认证" class="headerlink" title="HTTP认证"></a>HTTP认证</h2><p>HttpURLConnection支持<a href="http://www.ietf.org/rfc/rfc2617" target="_blank" rel="noopener">HTTP basic authentication</a>。使用<code>Authenticator</code>来设置JVM全局的 authentication handler:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Authenticator.setDefault(<span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(username, password.toCharArray());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>除非同时使用了HTTPS，不建议将其作为用户认证机制。特别要说明的是，用户名、密码、请求以及响应都是在网络上明文传输的。</p><h2 id="Session-cookie"><a href="#Session-cookie" class="headerlink" title="Session cookie"></a>Session cookie</h2><p>为了在客户端和服务器端建立和维护一个长期的会话，HttpURLConnection自带一个可扩展的cookie manager。使用CookieHandler和CookieManager来管理JVM全局的cookie：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CookieManager cookieManager = new CookieManager();</span><br><span class="line">CookieHandler.setDefault(cookieManager);</span><br></pre></td></tr></table></figure><p>缺省情况下CookieManager只接受来自原始服务器的cookie <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec1.html" target="_blank" rel="noopener">rfc2616</a>。另外两种策略是<code>CookiePolicy.ACCEPT_ALL</code>和<code>CookiePolicy.ACCEPT_NONE</code>。实现<code>CookiePolicy</code>来自定义cookie策略。</p><p>缺省情况下CookieManager只将cookie保存在内存中。当退出JVM时会清空cookie。通过实现CookieStore来自定义如何存储cookie。</p><p>除了可以接收HTTP响应的cookie，还可以通过程序设置cookie。HTTP请求头中的cookie必须指定domain和path。</p><p>缺省情况下HttpCookie实例能用于支持<a href="http://www.ietf.org/rfc/rfc2965.txt" target="_blank" rel="noopener">RFC 2965</a>的服务器。而很多web服务器只支持老的规范，<a href="http://www.ietf.org/rfc/rfc2109.txt" target="_blank" rel="noopener">RFC 2109</a>。为了兼容大多数web服务器，需要将cookie版本设置为0。</p><p>举例来说，想访问法语版本的<a href="http://www.twitter.com" target="_blank" rel="noopener">twitter</a>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpCookie cookie = <span class="keyword">new</span> HttpCookie(<span class="string">"lang"</span>, <span class="string">"fr"</span>);</span><br><span class="line">cookie.setDomain(<span class="string">"twitter.com"</span>);</span><br><span class="line">cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">cookie.setVersion(<span class="number">0</span>);</span><br><span class="line">cookieManager.getCookieStore().add(<span class="keyword">new</span> URI(<span class="string">"http://twitter.com/"</span>), cookie);</span><br></pre></td></tr></table></figure><h2 id="HTTP-Methods"><a href="#HTTP-Methods" class="headerlink" title="HTTP Methods"></a>HTTP Methods</h2><p>缺省时HttpURLConnection使用<code>GET</code>方法。如果调用<code>setDoOutput(true)</code>方法，它将使用<code>POST</code>方法。还支持其他几种method，包括：<code>OPTIONS</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code>和<code>TRACE</code>，可以通过<code>setRequestMethod()</code>方法来进行设置。</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>缺省时HttpURLConnection直接连接<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec1.html" target="_blank" rel="noopener">原始服务器</a>。也可以通过<code>HTTP</code>代理或<code>SOCKS</code>代理连接原始服务器。使用代理的方式是这样：调用<code>URL.openConnection(Proxy)</code>方法创建连接。</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>HttpURLConnection支持IPv6。对于既有IPv4地址又有IPv6地址的服务器，它会尝试所有地址直到连接成功。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>对于Android平台来说：Android 4.0开始添加了响应绊缓存。如何为app开启缓存可以参考<code>android.net.http.HttpResponseCache</code>。</p><h2 id="相关的类"><a href="#相关的类" class="headerlink" title="相关的类"></a>相关的类</h2><ul><li>Authenticator</li><li>CookieManager</li><li>CookieHandler</li><li>CookieStore</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="noopener">411</a></p><p><a href="https://yanbin.blog/why-http-get-cannot-sent-data-with-reuqest-body/" target="_blank" rel="noopener">谁说 HTTP GET 就不能通过 Body 来发送数据呢？</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" target="_blank" rel="noopener">POST - HTTP | MDN</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记一次网页中文乱码问题</title>
      <link href="2018/08/28/http-missing-content-type/"/>
      <url>2018/08/28/http-missing-content-type/</url>
      
        <content type="html"><![CDATA[<p>记一次网页中文乱码问题。问题产生的原因是Web服务器自动添加的Content-Type中的字符编码不正确。<br><a id="more"></a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Apache2中通过ProxyPass方式转发请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// apache2/conf/vhosts.d/xxx.conf</span><br><span class="line">&lt;IfModule mod_proxy.c&gt;</span><br><span class="line">    ProxyPass         /xmerger/  http://localhost:8888/</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><p>Apache服务器上添加以上配置，将请求代理到8888端口的web服务。代理方式访问8888端口的web服务时出现乱码，而直接访问则不会有乱码。</p><p>一开始以为是HTML页面中没有指定正确的字符编码，检查后发现已指定charset为”utf-8”：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用Chrome开发者工具对比发现两种访问方式的区别在于HTTP的Response Header:</p><ul><li>代理方式访问(ProxyPass)时 <code>Content-Type: text/html; charset=GB18030</code></li><li>直接访问时 <code>Content-Type: text/plain;charset=utf-8</code></li></ul><p>推测乱码原因是因为Apache服务器修改了<code>Content-Type</code>。</p><p><code>find . | xargs grep &#39;GB18030&#39;</code>搜索后发现<code>apache2/conf/vhosts.d/xxx.conf</code>有如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddDefaultCharset GB18030</span><br></pre></td></tr></table></figure><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>原来的ProxyPass配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_proxy.c&gt;</span><br><span class="line">    ProxyPass         /xmerger/  http://localhost:8888/</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><p>将其修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_proxy.c&gt;</span><br><span class="line">    &lt;Location &quot;/xmerger/&quot;&gt;</span><br><span class="line">        ProxyPass &quot;http://localhost:8888/&quot;</span><br><span class="line">        AddDefaultCharset UTF-8</span><br><span class="line">    &lt;/Location&gt;</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><p>重启Apache服务器，返回后通过代理方式访问也能收到正确的响应头：<code>Content-Type: text/html; charset=UTF-8</code>，中文乱码问题解决。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://httpd.apache.org/docs/2.4/mod/mod_proxy.html#proxypass" target="_blank" rel="noopener">proxypass</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Javac的source参数</title>
      <link href="2018/08/27/javac-source/"/>
      <url>2018/08/27/javac-source/</url>
      
        <content type="html"><![CDATA[<p>介绍了javac的source参数和target参数用法。<br><a id="more"></a></p><p>javac命令支持<code>-source</code>和<code>-target</code>参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  blog git:(hexo) ✗ javac</span><br><span class="line">用法: javac &lt;options&gt; &lt;source files&gt;</span><br><span class="line">  -source &lt;发行版&gt;              提供与指定发行版的源兼容性</span><br><span class="line">  -target &lt;发行版&gt;              生成特定 VM 版本的类文件</span><br></pre></td></tr></table></figure><p>那这两个参数如何使用呢？</p><p>先来看一个问题。我开发了一个Java程序，这个Java程序使用了一些第三方库。这个程序在我的电脑上运行得很正常。但公司的服务器上运行出错，提示<code>Unsupported major.minor version 52.0</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar abc.jar</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedClassVersionError : Unsupported major.minor version 52.0</span><br></pre></td></tr></table></figure><p>使用<code>java -version</code>可以看到我的电脑上装的是JDK 8，而公司的服务器上装的OpenJDK 6。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java version &quot;1.8.0_73&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_73-b02)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.73-b02, mixed mode)</span><br><span class="line"></span><br><span class="line">java version &quot;1.6.0_22&quot;</span><br><span class="line">OpenJDK Runtime Environment (IcedTea6 1.10.6) (rhel-1.43.1.10.6.el6_2-x86_64)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 20.0-b11, mixed mode)</span><br></pre></td></tr></table></figure><p>你可能说这个问题很简单呀，给公司的服务器升级到JDK 8不就解决问题了。嗯，这个嘛… 我们还是把关注点放在<code>Unsupported major.minor version 52.0</code></p><p>对任何一个java类文件执行<code>javap -v &lt;class名&gt; | grep version</code>操作都会有如下输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minor version: 0</span><br><span class="line">major version: 51</span><br></pre></td></tr></table></figure><p>实际输出根据实际情况可能有所不同。这里列出了各版本JDK使用的major值：</p><ul><li>Java 1.2 uses major version 46</li><li>Java 1.3 uses major version 47</li><li>Java 1.4 uses major version 48</li><li>Java 5 uses major version 49</li><li>Java 6 uses major version 50</li><li>Java 7 uses major version 51</li><li>Java 8 uses major version 52</li><li>Java 9 uses major version 53</li><li>Java 10 uses major version 54</li></ul><p>到这里，我们不难明白<code>Unsupported major.minor version 52.0</code>的原因。我用JDK 8编译出一个类(Java程序本质上是由一系列类文件打包在一起，简单起见这里假设我们的程序只有一个类)，类的版本是52.0。当你输入<code>java &lt;class名&gt;</code>将程序跑起来时，JVM先要将指定的类加载进来。这时类的版本就发生作用了。我的电脑上装的是JDK 8(自带JVM 8)，它认识版本为52.0的类，以及更早的类。而公司服务器上装的是OpenJDK 6(自带JVM 6)，很不幸它只认识版本为50.0的类，以及更早版本的类。</p><p>怎么办？<code>-source</code>和<code>-target</code>就派上用场了，先上图。</p><img src="/2018/08/27/javac-source/javac.png" width="1418" height="720" title="给javac指定不同的source参数和target参数"><p>编译java类时指定<code>-source 1.6 -target 1.6</code>，生成的类可以在指定版本的JVM上运行。如果你不喜欢那个警告的话，记得使用<code>-bootclasspath</code>指定对应的启动类文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -source 1.6 -target 1.6 Hello.java -bootclasspath /path/to/rt.jar</span><br></pre></td></tr></table></figure><p><code>javac -source 1.6 -target 1.6 Hello.java</code>编译代码时，如果<code>Hello.java</code>中用到了Java 6之后才支持的新语法，会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面这个代码会报错 “Hello.java:4: 错误: -source 1.6 中不支持 diamond 运算符  (请使用 -source 7 或更高版本以启用 diamond 运算符)”。</p><p>那么是否可以使用<code>java -source 1.7 -target 1.6 Hello.java</code>这种形式的呢？验证发现不行，提示”javac: 源发行版 1.8 需要目标发行版 1.8”</p><p>在gradle中这样配置source和target参数</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sourceCompatibility = <span class="number">1.6</span></span><br><span class="line">targetCompatibility = <span class="number">1.6</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/JeffChen/archive/2008/01/16/1041783.html" target="_blank" rel="noopener">javac命令详解</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一个不错的Hexo主题</title>
      <link href="2018/08/12/blog-tools/"/>
      <url>2018/08/12/blog-tools/</url>
      
        <content type="html"><![CDATA[<p>最近又折腾了一下博客的主题以及HTTPS，记录一下。<br><a id="more"></a></p><h1 id="next主题"><a href="#next主题" class="headerlink" title="next主题"></a>next主题</h1><p>首先是关于博客主题。上周看到一个超级对眼的主题，<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">next</a>，赶紧将自己的博客主题替换成next了。它很简单，看起来也舒服，简单让我有了更多动力写博客。</p><h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><h2 id="letsencrypt"><a href="#letsencrypt" class="headerlink" title="letsencrypt"></a>letsencrypt</h2><p>Chrome现在直接将HTTP网站标记为不安全，所以我的博客也不得不支持HTTPS。原本抱着简单省事的心态打算上阿里云自己买一个，发现价格居然高达几千。作为个人博客，当然没必要买这么贵的啦。</p><p>那就找免费的吧。<a href="https://community.letsencrypt.org/" target="_blank" rel="noopener">Let’s encrypt</a>是大家推荐得最多的免费SSL证书提供者。一方面是，很多第三方web托管服务支持<a href="https://community.letsencrypt.org/" target="_blank" rel="noopener">Let’s encrypt</a>，见<a href="https://community.letsencrypt.org/t/web-hosting-who-support-lets-encrypt/6920" target="_blank" rel="noopener">这里</a>，当然，其中包括我们熟知的Github Pages。我自己的博客也是直接放Github。另一方面，letsencrypt提供了非常便捷的自动化工具<a href="https://certbot.eff.org/" target="_blank" rel="noopener">certbot</a>来简化申请HTTPS证书的过程，降低使用门槛。letsencrypt有90天的使用期限，到期后必须续期才能继续使用，这一点稍显不便。不过，对于免费的东西我们要求也不能过高。</p><p>这里有几篇关于letsencrypt使用参考：</p><ul><li><a href="https://blog.csdn.net/xs18952904/article/details/79262646" target="_blank" rel="noopener">让网站永久拥有HTTPS - 申请免费SSL证书并自动续期</a></li><li><a href="https://blog.csdn.net/andylau00j/article/details/54603975" target="_blank" rel="noopener">Let’s Encrypt 给网站加 HTTPS 完全指南</a></li></ul><h2 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h2><p>Github Pages一直在改进(不得不赞)。Github Pages在2009年时就开始支持自定义域名，2016年开始<code>*.github.io</code>域名开始支持HTTPS，2018年5月1日自定义域名也开始支持HTTPS。<a href="https://blog.github.com/2018-05-01-github-pages-custom-domains-https/" target="_blank" rel="noopener">参考</a>。</p><p>所以托管在Github博客想要支持HTTPS其实很简单。</p><p>首先，为你的站点勾选“Enforce HTTPS”</p><p><img src="enforce-https.png" alt></p><p>然后，更新A记录</p><p>185.199.108.153<br>185.199.109.153<br>185.199.110.153<br>185.199.111.153</p><p>两步即让你的博客支持HTTPS了，简单吧。据称，这几个新的IP不仅能让你的博客支持HTTPS，而且由于它们提供CDN功能，所以博客访问速度会变快。另外，还提供保护避免DDoS攻击。</p><p>mixed content的问题。现在你的博客由HTTP访问切换到HTTPS了，但博客中免不了可能有HTTP链接资源，如图片，CSS文件，Javascript文件等等。所以你的站点变成了mixed content站点，加载资源时可能失败导致页面解析问题。解决办法就是将HTTP链接修改成HTTPS链接。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p><a href="https://www.jianshu.com/p/3884e5cb63e5" target="_blank" rel="noopener">hexo定制&amp;优化 - 简书</a></p><p>优化方法是使用gulp对各种资源进行压缩。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean    //清除public文件夹</span><br><span class="line">hexo g     //编译文章，生成public文件夹</span><br><span class="line">gulp build    //压缩js、css、img文件</span><br><span class="line">hexo d    //部署到github</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/3884e5cb63e5" target="_blank" rel="noopener">hexo定制&amp;优化 - 简书</a></p><p><a href="https://www.cnblogs.com/jarson-7426/p/5660424.html" target="_blank" rel="noopener">hexo博客－性能优化 - luckykun - 博客园</a></p><p><a href="https://yq.aliyun.com/articles/8608" target="_blank" rel="noopener">Hexo折腾记——性能优化篇-博客-云栖社区-阿里云</a></p><h1 id="post-目录"><a href="#post-目录" class="headerlink" title="_post 目录"></a>_post 目录</h1><p>所有已发布的文章都放在 _post 目录下。_post 目录下文件数会越来越多，导致编辑和查找变得困难。解决办法如下：</p><ul><li>修改 <code>_config.xml</code> 配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_post_name: :year-:month-:day-:title.md # File name of new posts</span><br></pre></td></tr></table></figure><p>修改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_post_name: :year/:month-:day-:title.md # File name of new posts</span><br></pre></td></tr></table></figure><ul><li>将 <code>_post</code> 目录下的文件移到 <code>_post/2019</code>, <code>_post/2018</code>, <code>_post/2017</code></li><li>将文件名中的年份去掉。 <code>2019-05-22-a-blog.md</code> 改成 <code>05-22-a-blog.md</code></li></ul><h1 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h1><h2 id="gitment"><a href="#gitment" class="headerlink" title="gitment"></a>gitment</h2><p>2019-06-25 更新: gitment 不可用</p><p>主要参考 <a href="https://segmentfault.com/a/1190000016286358" target="_blank" rel="noopener">hexo加入gitment评论功能</a></p><ul><li>Github 注册 application，并获取 Client ID 和 Client Secret。<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">注册地址</a><ul><li>Homepage URL 填域名</li><li>Authorization callback URL 填域名</li></ul></li><li>Github 上创建一个新的公开 repo，用于存储评论数据</li><li>Next 主题直接支持 gitment，配置即可</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Gitment</span></span><br><span class="line"><span class="comment"># Introduction: https://imsun.net/posts/gitment-introduction/</span></span><br><span class="line"><span class="comment"># You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;</span></span><br><span class="line"><span class="attr">gitment:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mint:</span> <span class="literal">true</span> <span class="comment"># RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># Show comments count in post meta area</span></span><br><span class="line">  <span class="attr">lazy:</span> <span class="literal">false</span> <span class="comment"># Comments lazy loading with a button</span></span><br><span class="line">  <span class="attr">cleanly:</span> <span class="literal">true</span> <span class="comment"># Hide 'Powered by ...' on footer, and more</span></span><br><span class="line">  <span class="attr">language:</span> <span class="comment"># Force language, or auto switch by theme</span></span><br><span class="line">  <span class="attr">github_user:</span> <span class="number">10010</span> <span class="comment"># MUST HAVE, Your Github ID</span></span><br><span class="line">  <span class="attr">github_repo:</span> <span class="string">abc</span> <span class="comment"># MUST HAVE, The repo you use to store Gitment comments</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">5fa35f83ad3a055bc1af</span> <span class="comment"># MUST HAVE, Github client id for the Gitment</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">abcdefg</span> <span class="comment"># EITHER this or proxy_gateway, Github access secret token for the Gitment</span></span><br><span class="line">  <span class="attr">proxy_gateway:</span> <span class="comment"># Address of api proxy, See: https://github.com/aimingoo/intersect</span></span><br><span class="line">  <span class="attr">redirect_protocol:</span> <span class="comment"># Protocol of redirect_uri with force_redirect_protocol when mint enabled</span></span><br></pre></td></tr></table></figure><p>遇到以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;message&quot;: &quot;API rate limit exceeded for 203.205.141.52. (But here&apos;s the good news: Authenticated requests get a higher rate limit. Check out the documentation for more details.)&quot;,</span><br><span class="line">  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3/#rate-limiting&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="gitalk"><a href="#gitalk" class="headerlink" title="gitalk"></a>gitalk</h2><ul><li><a href="https://github.com/iissnan/hexo-theme-next/pull/1814/files" target="_blank" rel="noopener">参考</a></li><li><a href="https://github.com/gitalk/gitalk/issues/115" target="_blank" rel="noopener">hexo next 主题配置 gitalk 评论后无法初始化创建 issue · Issue #115 · gitalk/gitalk</a></li><li><a href="https://github.com/mzlogin/mzlogin.github.io/issues/63" target="_blank" rel="noopener">发布的新文章提示“未找到相关的 Issues 进行评论，请联系xxx初始化创建</a></li><li><a href="https://iochen.com/2018/01/06/use-gitalk-in-hexo/" target="_blank" rel="noopener">Hexo中Gitalk配置使用教程-可能是目前最详细的教程 | ioChen’s Blog</a></li></ul><p>主要的坑在于中文文章名 url 编码过长导致调用 Github API 时出现 <code>Error: Validation Failed</code>，原因是 Github issue 不支持超过 50 个字符的 label。</p><p>出现错误时 Github API 的接口响应如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"Validation Failed"</span>,</span><br><span class="line">  <span class="attr">"errors"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"value"</span>: <span class="string">"/2018/02/03/%E2%80%9C%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95%E2%80%9D%E6%80%9D%E6%83%B3%E8%BF%90%E7%94%A8/"</span>,</span><br><span class="line">      <span class="attr">"resource"</span>: <span class="string">"Label"</span>,</span><br><span class="line">      <span class="attr">"field"</span>: <span class="string">"name"</span>,</span><br><span class="line">      <span class="attr">"code"</span>: <span class="string">"invalid"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"documentation_url"</span>: <span class="string">"https://developer.github.com/v3/issues/#create-an-issue"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方案一 - 使用 <code>md5()</code> 方法得到当前页面 url 的 MD5</li><li>方案二 - <a href="https://github.com/mzlogin/mzlogin.github.io/commit/5ef353c011b21c04193df19096bc67a7b7140bec" target="_blank" rel="noopener">截取标题前50个字符</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/Cowry5/article/details/80310052" target="_blank" rel="noopener">GitHub Pages自定义域名如何支持https - CSDN博客</a></li><li><a href="https://help.github.com/articles/setting-up-an-apex-domain/" target="_blank" rel="noopener">如何添加A记录 Setting up an apex domain - User Documentation</a></li><li><a href="https://blog.csdn.net/u011244202/article/details/57106544/" target="_blank" rel="noopener">让个人域名下GithubPage完美支持https - CSDN博客</a></li><li><a href="https://help.github.com/articles/securing-your-github-pages-site-with-https/" target="_blank" rel="noopener">Securing your GitHub Pages site with HTTPS - User Documentation</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>curl用法小记</title>
      <link href="2018/08/07/work-tips/"/>
      <url>2018/08/07/work-tips/</url>
      
        <content type="html"><![CDATA[<p>今天处理一个将TCP接口转换成HTTP接口的任务，get到一点零碎的知识点。<br><a id="more"></a></p><h1 id="curl用法"><a href="#curl用法" class="headerlink" title="curl用法"></a>curl用法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8888/90900 -H @appmap.properties -d</span><br></pre></td></tr></table></figure><ul><li>-X - 指定请求方法</li><li>-H - 在文件中指定header</li><li>-d - 指定post data</li></ul><p>使用curl发送json数据时不用担心格式的问题。这里有一个小技巧，输完<code>-d &#39;</code>回车(注意-d后有个空格和 <strong>单引号</strong> )，然后粘贴你的json数据，再输入一个<code>&#39;</code> (单引号)，最后回车发送数据。</p><h1 id="Jackson用法"><a href="#Jackson用法" class="headerlink" title="Jackson用法"></a>Jackson用法</h1><p>感觉jackson使用起来不如 org.json 直观。后者提供了很简单明了的 <a href>JSONObject</a>和<a href>JSONArray</a>，而jackson中就麻烦很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JsonNode root = objectMapper.readTree(body);</span><br><span class="line">JsonNode body = root.get(<span class="string">'body'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将json字符串转换成指定类型的对象</span></span><br><span class="line">Object obj = objectMapper.readValue(<span class="string">"&#123;&#125;"</span>, clazz)</span><br><span class="line"><span class="comment">// 将json node转换成指定类型的对象</span></span><br><span class="line">Object obj = objectMapper.convertValue(body, clazz)</span><br></pre></td></tr></table></figure><p><a href="https://spin.atomicobject.com/2016/07/01/custom-serializer-jackson/?utm_source=stack-overflow-ao&amp;utm_medium=referral&amp;utm_campaign=custom-serializer-jackson" target="_blank" rel="noopener">How To Write a Custom Serializer with Jackson</a></p><p><a href="https://stackoverflow.com/questions/7161638/how-do-i-use-a-custom-serializer-with-jackson" target="_blank" rel="noopener">java - How do I use a custom Serializer with Jackson? - Stack Overflow</a></p><h1 id="scp用法"><a href="#scp用法" class="headerlink" title="scp用法"></a>scp用法</h1><p>Mac terminal向远程机器上传，使用rz老是卡住，只能使用<code>scp</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp  &lt;source file&gt; &lt;user&gt;@&lt;host&gt;:&lt;dest file&gt;</span><br></pre></td></tr></table></figure><h1 id="查看端口进程"><a href="#查看端口进程" class="headerlink" title="查看端口进程"></a>查看端口进程</h1><p>lsof -i:8080 查看8080端口占用</p><p>netstat –apn</p><h1 id="vim中文乱码"><a href="#vim中文乱码" class="headerlink" title="vim中文乱码"></a>vim中文乱码</h1><p>set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936<br>set termencoding=utf-8<br>set encoding=utf-8</p><p><a href="https://blog.csdn.net/zhengwish/article/details/78749151" target="_blank" rel="noopener">解决Mac环境下vim中文乱码&amp;转码问题 - CSDN博客</a></p><h1 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h1><p><a href="https://www.cnblogs.com/myvic/p/7703973.html" target="_blank" rel="noopener">linux 下ab压力测试 - myvic - 博客园</a></p><h1 id="ssh代理"><a href="#ssh代理" class="headerlink" title="ssh代理"></a>ssh代理</h1><p>代理配置在<code>~/.ssh/config</code>文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxyCommand=corkscrew dev-proxy.oa.com 8080 %h %p</span><br></pre></td></tr></table></figure><p><a href="http://mtu.net/~engstrom/ssh-through-http-proxy/" target="_blank" rel="noopener">corkscrew</a></p><h1 id="ssh后台运行程序"><a href="#ssh后台运行程序" class="headerlink" title="ssh后台运行程序"></a>ssh后台运行程序</h1><p>使用screen命令。</p><h2 id="安装screen"><a href="#安装screen" class="headerlink" title="安装screen"></a>安装screen</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install screen</span><br></pre></td></tr></table></figure><h2 id="后台运行命令"><a href="#后台运行命令" class="headerlink" title="后台运行命令"></a>后台运行命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; screen (回车)</span><br><span class="line">&gt; java viewer.jar</span><br><span class="line">&gt; (先 Ctrl + A，再 d)</span><br></pre></td></tr></table></figure><p>通过screen运行命令后，ssh会话断开也不会影响命令的运行</p><h2 id="命令切到前台"><a href="#命令切到前台" class="headerlink" title="命令切到前台"></a>命令切到前台</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; screen -ls</span><br><span class="line">&gt; (找到session id)</span><br><span class="line">&gt; screen -r &lt;session id&gt; (回车)</span><br><span class="line">&gt; (命令被切回前台)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.zhihu.com/question/20709809" target="_blank" rel="noopener">Linux ssh状态下如何后台运行程序？</a><br><a href="https://blog.csdn.net/laven54/article/details/45569617" target="_blank" rel="noopener">如何在关闭ssh连接的情况下，让程序继续在后台运行？</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Glide缓存分析</title>
      <link href="2018/07/27/glide-cache/"/>
      <url>2018/07/27/glide-cache/</url>
      
        <content type="html"><![CDATA[<p>Glide的缓存有多大，其缓存策略是怎样的？<br><a id="more"></a></p><h1 id="缓存和对象池的大小"><a href="#缓存和对象池的大小" class="headerlink" title="缓存和对象池的大小"></a>缓存和对象池的大小</h1><p>缓存是一个复杂的话题。Glide缓存有几个主要考虑因素：</p><ul><li>一是机器的内存有多大。缓存过大的话，导致内存压力大。缓存过小的话，无法充分利用内存提升性能。所以应当根据内存大小来分配适当大小的缓存。另外，高端机上可以分多分配一些，低端机上则应少分配一些。</li><li>二是屏幕大小。Glide分配多少缓存会基于图片数量来考虑。假设一张图片占满足一屏，那应当分配几屏的缓存？</li></ul><p>如何判断是否低端机(内存较小的机型)？API level 19以上根据<code>ActivityManager.isLowMemoryDevice()</code>判断。</p><blockquote><p>如果是低内存机器返回true。一台设备是否低内存最终由设备配置决定，目前而言通常指512MB内存、屏幕分辨率为800*480或更少。</p></blockquote><p>另一个方法是<code>ActivityManager.getMemoryClass()</code>。它也很有用。</p><blockquote><p>返回当前设备上每个应用大概的内存值。这个值让你了解为了让系统运行良好自己的应用内存占用限值是大概多少。返回值的单位是MB。最少的是16MB(跟这些设备上Java Heap大小相同)。内存较大的设备返回24或更大。</p></blockquote><p><code>MemorySizeCalculator</code>用于计算缓存大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MEMORY_CACHE_TARGET_SCREENS = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BITMAP_POOL_TARGET_SCREENS = <span class="number">4</span>;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> MAX_SIZE_MULTIPLIER = <span class="number">0.4f</span>;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOW_MEMORY_MAX_SIZE_MULTIPLIER = <span class="number">0.33f</span>;</span><br><span class="line">   <span class="comment">// 4MB.</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_POOL_SIZE_BYTES = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺省时memoryCacheScreens为2, 即缓存两屏图片</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> memoryCacheScreens = MEMORY_CACHE_TARGET_SCREENS;</span><br><span class="line"><span class="comment">// 缺省时bitmapPoolScreens为4，即对象池大小为4屏图片</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> bitmapPoolScreens = BITMAP_POOL_TARGET_SCREENS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> maxSizeMultiplier = MAX_SIZE_MULTIPLIER;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> lowMemoryMaxSizeMultiplier = LOW_MEMORY_MAX_SIZE_MULTIPLIER;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> arrayPoolSizeBytes = ARRAY_POOL_SIZE_BYTES;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> MemorySizeCalculator(Context context, ActivityManager activityManager,</span><br><span class="line">     ScreenDimensions screenDimensions, <span class="keyword">float</span> memoryCacheScreens, <span class="keyword">float</span> bitmapPoolScreens,</span><br><span class="line">     <span class="keyword">int</span> targetArrayPoolSize, <span class="keyword">float</span> maxSizeMultiplier, <span class="keyword">float</span> lowMemoryMaxSizeMultiplier) &#123;</span><br><span class="line">   <span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="comment">// 缺省时arrayPoolSizeBytes为4MB, 但低内存机器上为2MB</span></span><br><span class="line">   arrayPoolSize =</span><br><span class="line">       isLowMemoryDevice(activityManager)</span><br><span class="line">           ? targetArrayPoolSize / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR</span><br><span class="line">           : targetArrayPoolSize;</span><br><span class="line">   <span class="comment">// 当前应用的内存限值(内存最大值, 注意这只是一个建议)</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> maxSize = getMaxSize(activityManager, maxSizeMultiplier, lowMemoryMaxSizeMultiplier);</span><br><span class="line">   <span class="comment">// 一屏数据占用的内存大小</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> screenSize = screenDimensions.getWidthPixels() * screenDimensions.getHeightPixels()</span><br><span class="line">       * BYTES_PER_ARGB_8888_PIXEL;</span><br><span class="line">   <span class="comment">// Bitmap对象池大小</span></span><br><span class="line">   <span class="keyword">int</span> targetPoolSize = Math.round(screenSize * bitmapPoolScreens);</span><br><span class="line">   <span class="comment">// Bitmap缓存大小</span></span><br><span class="line">   <span class="keyword">int</span> targetMemoryCacheSize = Math.round(screenSize * memoryCacheScreens);</span><br><span class="line">   <span class="comment">// 剩余可用内存</span></span><br><span class="line">   <span class="keyword">int</span> availableSize = maxSize - arrayPoolSize;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// (Bitmap对象池大小 + Bitmap缓存大小)超过剩余可用内存时进行适当调整</span></span><br><span class="line">   <span class="keyword">if</span> (targetMemoryCacheSize + targetPoolSize &lt;= availableSize) &#123;</span><br><span class="line">     memoryCacheSize = targetMemoryCacheSize;</span><br><span class="line">     bitmapPoolSize = targetPoolSize;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">float</span> part = availableSize / (bitmapPoolScreens + memoryCacheScreens);</span><br><span class="line">     memoryCacheSize = Math.round(part * memoryCacheScreens);</span><br><span class="line">     bitmapPoolSize = Math.round(part * bitmapPoolScreens);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>MemorySizeCalculator会输出最终的缓存参数。如果看不到MemorySizeCalculator日志，adb shell中执行<code>setprop log.tag.MemorySizeCalculator VERBOSE</code>。我的机器输出如下(为便于查看稍微调整了下格式)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">07-26 03:06:09.062 5193-5193/com.example.demo_glide D/MemorySizeCalculator: Calculation complete, Calculated </span><br><span class="line">memory cache size: 11.47 MB, </span><br><span class="line">pool size: 22.93 MB, </span><br><span class="line">byte array size: 4.00 MB, </span><br><span class="line">memory class limited? true, </span><br><span class="line">max size: 38.40 MB, </span><br><span class="line">memoryClass: 96, </span><br><span class="line">isLowMemoryDevice: false</span><br></pre></td></tr></table></figure><p>手动校验一遍。</p><p>targetMemoryCacheSize: 15500160 = 1080 (width) <em> 1794 (height) </em> 4 (每像素占用内存) <em> 2 (缓存屏数)<br>targetPoolSize: 31000320 = 1080 (width) </em> 1794 (height) <em> 4 (每像素占用内存) </em> 2 (对象池屏数)<br>maxSize: 40265320 = 96 (memory class) <em> 1024 </em> 1024 <em> 0.4 (maxSizeMultiplier)<br>arrayPoolSize: 4194304 = 4 </em> 1024 * 1024 (缺省的arrayPoolSize)<br>availableSize: 36071016 = 40265320(maxSize) - 4194304 (arrayPoolSize)</p><p>由于targetMemoryCacheSize与targetPoolSize之和超过availableSize，所以实际的缓存大小和BitmapPool大小需要重新调整一下。调整原则很简单，按比例分就行。</p><p>part: 6011836 = 36071016(availableSize) / (2 + 4)<br>memoryCacheSize: 12023672 = 6011836 <em> 2<br>bitmapPoolSize: 24047344 = 6011836 </em> 4</p><p>换算成MB。</p><p>memoryCacheSize 12023672B = 11.47MB<br>bitmapPoolSize 24047344B = 22.93MB<br>arrayPoolSize 4MB<br>maxSize 40265320 = 38.40MB</p><p>跟日志输出一致。</p><p>TODO Glide的缓存大小是否合理？</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>memoryCacheSize，bitmapPoolSize，arrayPoolSize三个参数值确定后，就该真正的主角出场了。</p><p>GlideBuilder允许自定义缓存策略。如果没有自定义缓存策略，使用内置的缓存策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GlideBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Glide <span class="title">build</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (memorySizeCalculator == <span class="keyword">null</span>) &#123;</span><br><span class="line">          memorySizeCalculator = <span class="keyword">new</span> MemorySizeCalculator.Builder(context).build();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (bitmapPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> size = memorySizeCalculator.getBitmapPoolSize();</span><br><span class="line">          bitmapPool = <span class="keyword">new</span> LruBitmapPool(size);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (arrayPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">          arrayPool = <span class="keyword">new</span> LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (memoryCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">          memoryCache = <span class="keyword">new</span> LruResourceCache(memorySizeCalculator.getMemoryCacheSize());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (diskCacheFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">          diskCacheFactory = <span class="keyword">new</span> InternalCacheDiskCacheFactory(context);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        ...</span><br><span class="line">        engine = <span class="keyword">new</span> Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor,</span><br><span class="line">              GlideExecutor.newUnlimitedSourceExecutor());</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        RequestManagerRetriever requestManagerRetriever = <span class="keyword">new</span> RequestManagerRetriever(</span><br><span class="line">            requestManagerFactory);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Glide(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内置的缓存策略包括。</p><table><thead><tr><th>类</th><th>功能</th><th>大小</th><th>备注</th></tr></thead><tbody><tr><td>LruResourceCache</td><td>resource内存缓存(为什么不是bitmap缓存?)</td><td>memoryCacheSize</td><td><a href="https://developer.android.com/topic/performance/graphics/cache-bitmap" target="_blank" rel="noopener">cache-bitmap</a></td></tr><tr><td>LruBitmapPool</td><td>bitmap池</td><td>bitmapPoolSize</td><td><a href="https://www.youtube.com/watch?v=_ioFW3cyRV0" target="_blank" rel="noopener">bitmap复用</a>，<a href="https://developer.android.com/topic/performance/graphics/manage-memory" target="_blank" rel="noopener">manage-memory</a></td></tr><tr><td>LruArrayPool</td><td>byte数组池</td><td>arrayPoolSize</td><td>防止图片操作导致内存抖动和频繁GC</td></tr><tr><td>DiskCache.Factory</td><td>disk缓存</td><td>-</td><td><a href="https://developer.android.com/topic/performance/graphics/cache-bitmap" target="_blank" rel="noopener">cache-bitmap</a></td></tr></tbody></table><p><img src="glide-cache.png" alt></p><h2 id="Memory缓存"><a href="#Memory缓存" class="headerlink" title="Memory缓存"></a>Memory缓存</h2><p>从缓存中加载图片的流程如下。</p><p><img src="load-from-cache.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Engine.java</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key, <span class="keyword">boolean</span> isMemoryCacheable) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMemoryCacheable) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cached.acquire();</span><br><span class="line">      activeResources.put(key, <span class="keyword">new</span> ResourceWeakReference(key, cached, getReferenceQueue()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line">    Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EngineResource&lt;?&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) &#123;</span><br><span class="line">      <span class="comment">// Save an object allocation if we've cached an EngineResource (the typical case).</span></span><br><span class="line">      result = (EngineResource&lt;?&gt;) cached;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = <span class="keyword">new</span> EngineResource&lt;&gt;(cached, <span class="keyword">true</span> <span class="comment">/*isMemoryCacheable*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>还有以下几个相关方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEngineJobComplete</span><span class="params">(Key key, EngineResource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class="line">  Util.assertMainThread();</span><br><span class="line">  <span class="comment">// A null resource indicates that the load failed, usually due to an exception.</span></span><br><span class="line">  <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">    resource.setResourceListener(key, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resource.isCacheable()) &#123;</span><br><span class="line">      activeResources.put(key, <span class="keyword">new</span> ResourceWeakReference(key, resource, getReferenceQueue()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> should this check that the engine job is still current?</span></span><br><span class="line">  jobs.remove(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReleased</span><span class="params">(Key cacheKey, EngineResource resource)</span> </span>&#123;</span><br><span class="line">  Util.assertMainThread();</span><br><span class="line">  activeResources.remove(cacheKey);</span><br><span class="line">  <span class="keyword">if</span> (resource.isCacheable()) &#123;</span><br><span class="line">    cache.put(cacheKey, resource);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resourceRecycler.recycle(resource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceRemoved</span><span class="params">(<span class="keyword">final</span> Resource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class="line">  Util.assertMainThread();</span><br><span class="line">  resourceRecycler.recycle(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向缓存添加图片的流程如下</p><p><img src="glide-cache-arch.png" alt></p><p>有一个很重要的点：跟之前预想的不同，完成解码的图片resource并不是一开始就被添加到cache，而是先添加到active resource。当resource被释放时，如果可缓存则添加到cache，如果不可缓存则经由recycler回收至bitmapPool</p><h2 id="Disk缓存"><a href="#Disk缓存" class="headerlink" title="Disk缓存"></a>Disk缓存</h2><p>disk缓存相对memory缓存不那么直观。对disk缓存的访问分散在几个不同的阶段。</p><p>一个是在DecodeJob快结束阶段</p><p><img src="decode-job.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeferredEncodeManager</span>&lt;<span class="title">Z</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(DiskCacheProvider diskCacheProvider, Options options)</span> </span>&#123;</span><br><span class="line">    TraceCompat.beginSection(<span class="string">"DecodeJob.encode"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      diskCacheProvider.getDiskCache().put(key,</span><br><span class="line">          <span class="keyword">new</span> DataCacheWriter&lt;&gt;(encoder, toEncode, options));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      toEncode.unlock();</span><br><span class="line">      TraceCompat.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个是在DataFetcherGenerator.startNext()阶段</p><p>DataFetcherGenerator有三个子类</p><ul><li>SourceGenerator</li><li>DataCacheGenerator</li><li>ResourceCacheGenerator</li></ul><p>这三个子类在<code>DecodeJob.runGenerators()</code>中均有被用到。<code>runGenerators()</code>按下面的状态图运行(DecodeJob.Stage)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Where we're trying to decode data from.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> Stage &#123;</span><br><span class="line">  <span class="comment">/** The initial stage. */</span></span><br><span class="line">  INITIALIZE,</span><br><span class="line">  <span class="comment">/** Decode from a cached resource. */</span></span><br><span class="line">  RESOURCE_CACHE,</span><br><span class="line">  <span class="comment">/** Decode from cached source data. */</span></span><br><span class="line">  DATA_CACHE,</span><br><span class="line">  <span class="comment">/** Decode from retrieved source. */</span></span><br><span class="line">  SOURCE,</span><br><span class="line">  <span class="comment">/** Encoding transformed resources after a successful load. */</span></span><br><span class="line">  ENCODE,</span><br><span class="line">  <span class="comment">/** No more viable stages. */</span></span><br><span class="line">  FINISHED,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="stage.png" alt></p><p>ResourceCacheGenerator和DataCacheGenerator均有<code>DiskCache.get()</code>操作，而SourceGenerator有<code>DiskCache.put()</code>操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceCacheGenerator</span> <span class="keyword">implements</span> <span class="title">DataFetcherGenerator</span>,</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  @<span class="title">Override</span></span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">boolean</span> <span class="title">startNext</span>() </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      currentKey = <span class="keyword">new</span> ResourceCacheKey(sourceId, helper.getSignature(), helper.getWidth(),</span><br><span class="line">          helper.getHeight(), transformation, resourceClass, helper.getOptions());</span><br><span class="line">      cacheFile = helper.getDiskCache().get(currentKey);</span><br><span class="line">      <span class="keyword">if</span> (cacheFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sourceKey = sourceId;</span><br><span class="line">        modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class="line">        modelLoaderIndex = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataCacheGenerator</span> <span class="keyword">implements</span> <span class="title">DataFetcherGenerator</span>,</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  @<span class="title">Override</span></span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">boolean</span> <span class="title">startNext</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (modelLoaders == <span class="keyword">null</span> || !hasNextModelLoader()) &#123;</span><br><span class="line">      ...</span><br><span class="line">      Key sourceId = cacheKeys.get(sourceIdIndex);</span><br><span class="line">      Key originalKey = <span class="keyword">new</span> DataCacheKey(sourceId, helper.getSignature());</span><br><span class="line">      cacheFile = helper.getDiskCache().get(originalKey);</span><br><span class="line">      <span class="keyword">if</span> (cacheFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sourceKey = sourceId;</span><br><span class="line">        modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class="line">        modelLoaderIndex = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SourceGenerator</span> <span class="keyword">implements</span> <span class="title">DataFetcherGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dataToCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Object data = dataToCache;</span><br><span class="line">      dataToCache = <span class="keyword">null</span>;</span><br><span class="line">      cacheData(data);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheData</span><span class="params">(Object dataToCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(dataToCache);</span><br><span class="line">      DataCacheWriter&lt;Object&gt; writer =</span><br><span class="line">          <span class="keyword">new</span> DataCacheWriter&lt;&gt;(encoder, dataToCache, helper.getOptions());</span><br><span class="line">      originalKey = <span class="keyword">new</span> DataCacheKey(loadData.sourceKey, helper.getSignature());</span><br><span class="line">      helper.getDiskCache().put(originalKey, writer);</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      loadData.fetcher.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sourceCacheGenerator =</span><br><span class="line">        <span class="keyword">new</span> DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h1><p>跟缓存相比，BitmapPool和ArrayPool使用简单明了很多。容易理解，BitmapPool出现在有Bitmap回收需求的地方，而ArrayPool则出现在有解码需求的地方。</p><p>比如，BitmapResource和BitmapDrawableResource都有一个BitmapPool成员。<code>Resource.recycle()</code>时相关的Bitmap不是被抛弃而是放回BitmapPool。<code>Downsampler</code>并不是真的生成新的Bitmap，有可能是从BitmapPool拿到的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapDrawableResource</span> <span class="keyword">extends</span> <span class="title">DrawableResource</span>&lt;<span class="title">BitmapDrawable</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Initializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BitmapPool bitmapPool;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BitmapDrawableResource</span><span class="params">(BitmapDrawable drawable, BitmapPool bitmapPool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(drawable);</span><br><span class="line">    <span class="keyword">this</span>.bitmapPool = bitmapPool;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapResource</span> <span class="keyword">implements</span> <span class="title">Resource</span>&lt;<span class="title">Bitmap</span>&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">Initializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Bitmap bitmap;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BitmapPool bitmapPool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Downsampler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BitmapPool bitmapPool;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setInBitmap</span><span class="params">(BitmapFactory.Options options, BitmapPool bitmapPool, <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.</span></span><br><span class="line">    options.inBitmap = bitmapPool.getDirty(width, height, options.inPreferredConfig);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而StreamGifDecoder和StreamBitmapDecoder都有一个ArrayPool成员。解码过程中需要用到byte[]，但不是直接new byte[]，而是调用<code>ArrayPool.get()</code>从对象池中拿，用完了归还。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamGifDecoder</span> <span class="keyword">implements</span> <span class="title">ResourceDecoder</span>&lt;<span class="title">InputStream</span>, <span class="title">GifDrawable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ImageHeaderParser&gt; parsers;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResourceDecoder&lt;ByteBuffer, GifDrawable&gt; byteBufferDecoder;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ArrayPool byteArrayPool;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StreamGifDecoder</span><span class="params">(List&lt;ImageHeaderParser&gt; parsers, ResourceDecoder&lt;ByteBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">      GifDrawable&gt; byteBufferDecoder, ArrayPool byteArrayPool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parsers = parsers;</span><br><span class="line">    <span class="keyword">this</span>.byteBufferDecoder = byteBufferDecoder;</span><br><span class="line">    <span class="keyword">this</span>.byteArrayPool = byteArrayPool;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamBitmapDecoder</span> <span class="keyword">implements</span> <span class="title">ResourceDecoder</span>&lt;<span class="title">InputStream</span>, <span class="title">Bitmap</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Downsampler downsampler;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ArrayPool byteArrayPool;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StreamBitmapDecoder</span><span class="params">(Downsampler downsampler, ArrayPool byteArrayPool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.downsampler = downsampler;</span><br><span class="line">    <span class="keyword">this</span>.byteArrayPool = byteArrayPool;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Handler问题记录</title>
      <link href="2018/07/26/handler-sync-barrier/"/>
      <url>2018/07/26/handler-sync-barrier/</url>
      
        <content type="html"><![CDATA[<p>为什么onStart()不被回调，主线程在忙什么？<br><a id="more"></a></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近项目中碰到一个诡异的问题，现象如下：</p><ol><li>IdleHandler机制失效了</li><li>onStart()居然不回调了 (其实会被回调，但延时非常大，跟<a href="http://km.oa.com/articles/show/373058?kmref=home_recommend_read" target="_blank" rel="noopener">onStop()居然需要 10s 才会被执行</a>中提到的现象类似)</li></ol><p>由于IdleHandler和<code>onStart()</code>中有一些初始化逻辑，不及时执行会引起问题，导致出现一些奇怪的bug。最后定位出来这个诡异问题的原因是因为某段代码使用Handler不当，发送了大量Message，导致主线程负载过重。(主线程负载很重却又未出现明显卡顿)</p><p>分析问题过程中绕了很多弯，等到快得到结论时发现其实快速定位原因的方法居然很简单：通过<code>Looper.setMessageLogging()</code>方法监听主线程MessageQueue上的Message日志，观察日志很容易揪出那个不正常的家伙。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">07-25 22:53:33.345 12819-12819/com.xxx.yyy I/IndexActivity: println: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (com.xxx.yyy.view.common.widget.yyyTextSwitchView$ViewHandler) &#123;2cefb4d&#125; null: 1</span><br><span class="line">    println: &lt;&lt;&lt;&lt;&lt; Finished to Handler (com.xxx.yyy.view.common.widget.yyyTextSwitchView$ViewHandler) &#123;2cefb4d&#125; null</span><br><span class="line">    println: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (com.xxx.yyy.view.common.widget.yyyTextSwitchView$ViewHandler) &#123;2cefb4d&#125; null: 1</span><br><span class="line">    println: &lt;&lt;&lt;&lt;&lt; Finished to Handler (com.xxx.yyy.view.common.widget.yyyTextSwitchView$ViewHandler) &#123;2cefb4d&#125; null</span><br><span class="line">    println: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (com.xxx.yyy.view.common.widget.yyyTextSwitchView$ViewHandler) &#123;2cefb4d&#125; null: 1</span><br><span class="line">    println: &lt;&lt;&lt;&lt;&lt; Finished to Handler (com.xxx.yyy.view.common.widget.yyyTextSwitchView$ViewHandler) &#123;2cefb4d&#125; null</span><br><span class="line">    println: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (com.xxx.yyy.view.common.widget.yyyTextSwitchView$ViewHandler) &#123;2cefb4d&#125; null: 1</span><br><span class="line">    println: &lt;&lt;&lt;&lt;&lt; Finished to Handler (com.xxx.yyy.view.common.widget.yyyTextSwitchView$ViewHandler) &#123;2cefb4d&#125; null</span><br><span class="line">    println: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (com.xxx.yyy.view.common.widget.yyyTextSwitchView$ViewHandler) &#123;2cefb4d&#125; null: 1</span><br></pre></td></tr></table></figure><p>上面的日志中<code>yyyTextSwitchView$ViewHandler</code>短时间内大量出现，必然有问题，围绕着它继续分析肯定能找出原因。细节这里就略过了。</p><p>而<code>Looper.setMessageLogging()</code>具体用法在<a href="http://www.sunmoonblog.com/2017/12/15/looper-log/">Android之输出Handler日志</a>中有讨论，这里不再展开。</p><p>我绕了不少弯，有些知识点是以前未掌握的，所以记录下来很有意义。</p><h1 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h1><h2 id="IdleHandler简介"><a href="#IdleHandler简介" class="headerlink" title="IdleHandler简介"></a>IdleHandler简介</h2><p>应用中有些任务很重要必须被执行，但时机上又没有那么迫切。于是便有了IdleHandler，它最适合处理这种场景，既能充分利用CPU但又不跟紧急任务争夺CPU。当线程没有message需要处理而阻塞时(简单来说就是线程空闲)，<code>IdleHandler.queueIdle()</code>被回调。<code>queueIdle()</code>返回false时将自动从MessageQueue中清理当前IdleHandler。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IdleHandler用法非常简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(<span class="keyword">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"queueIdle after onPause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面这段代码输出 <strong>1次</strong> <code>queueIdle after onPause</code>。不过要是将<code>return false</code>改成<code>return true</code>，则会在空闲时间多次输出<code>queueIdle after onPause</code>，直到将这个IdleHandler移除。</p><p>Android系统中也有用到IdleHandler。见<a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/app/ActivityThread.java#L2192" target="_blank" rel="noopener">ActivityThread.scheduleGcIdler()</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GcIdler</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span>.<span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doGcIfNeeded();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleGcIdler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mGcIdlerScheduled) &#123;</span><br><span class="line">        mGcIdlerScheduled = <span class="keyword">true</span>;</span><br><span class="line">        Looper.myQueue().addIdleHandler(mGcIdler);</span><br><span class="line">    &#125;</span><br><span class="line">    mH.removeMessages(H.GC_WHEN_IDLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unscheduleGcIdler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mGcIdlerScheduled) &#123;</span><br><span class="line">        mGcIdlerScheduled = <span class="keyword">false</span>;</span><br><span class="line">        Looper.myQueue().removeIdleHandler(mGcIdler);</span><br><span class="line">    &#125;</span><br><span class="line">    mH.removeMessages(H.GC_WHEN_IDLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>看看<code>MessageQueue.next()</code>方法是如何处理IdleHandler的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前有需要处理的message, 这里直接返回message</span></span><br><span class="line">        <span class="comment">// return message;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// pendingIdleHandlerCount &lt; 0 表示当前是for循环的第1个迭代</span></span><br><span class="line">        <span class="comment">// mMessages == null           表示没有需要处理的message(消息队列是空的)</span></span><br><span class="line">        <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">            pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有IdleHandler, 继续循环</span></span><br><span class="line">            mBlocked = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行IdleHandler</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 自动删除不被保留的IdleHandler</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如文档所述，IdleHandler仅在线程空闲时才被执行。</p><ul><li>如果队列中有消息，不会执行IdleHandler</li><li>每次<code>next()</code>调用时IdleHandler最多只有一次被执行的机会</li></ul><p>回到我们的问题，为什么IdleHandler不被执行？当然是因为队列中的消息太多，每次<code>next()</code>调用时都能找到一个待处理的Message，所以IdleHandler根本没有出场的机会。</p><p>队列中有哪些消息呢？Helper工具类可用于观察队列中的消息。代码整理自<a href="http://km.oa.com/articles/show/373058" target="_blank" rel="noopener">Activity 的 onStop 居然需要 10s 才会被执行？记一次艰辛的问题排查</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Helper</span> <span class="keyword">implements</span> <span class="title">Choreographer</span>.<span class="title">FrameCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"IndexHelper"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Field messagesField;</span><br><span class="line">    <span class="keyword">private</span> Field nextField;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Helper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagesField = MessageQueue.class.getDeclaredField("mMessages");</span><br><span class="line">            messagesField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            nextField = Message.class.getDeclaredField("next");</span><br><span class="line">            nextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = Looper.myQueue();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Message msg = (Message) messagesField.get(queue);</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(msg.toString());</span><br><span class="line">                sb.append(<span class="string">"\n"</span>);</span><br><span class="line">                msg = (Message) nextField.get(msg);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.i(TAG, sb.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">        Choreographer.getInstance().postFrameCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        printMessages();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>Choreographer.getInstance().postFrameCallback(new Helper())</code>，将输出每一帧队列中的消息。</p><h1 id="barrier消息"><a href="#barrier消息" class="headerlink" title="barrier消息"></a>barrier消息</h1><p>打印出所有Message后，发现一个非常奇怪的消息。它没有target，字符串形式为<code>{ when=-1ms barrier=105 }</code>。所以不妨称之为barrier消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">07-26 01:10:06.083 23987-23987/com.xxx.yyy I/IndexHelper: &#123; when=-1ms barrier=105 &#125;</span><br><span class="line">    &#123; when=+1s132ms callback=android.view.View$ScrollabilityCache target=android.view.ViewRootImpl$ViewRootHandler &#125;</span><br></pre></td></tr></table></figure><p><code>MessageQueue.next()</code>中关于barrier消息的处理很特别。for循环中找下一条消息时，如果发现了barrier消息，会忽略之后所有的同步消息(当然，异步消息仍然正常处理)，不进行任务实际处理。也就是说，同步消息一直被保留在消息队列中没被处理。这种情况下，IdleHandler更没机会被执行！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    ...</span><br><span class="line">    nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">    ...</span><br><span class="line">    Message msg = mMessages;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prevMsg = msg;</span><br><span class="line">            msg = msg.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 如果当前有需要处理的message, 这里直接返回message</span></span><br><span class="line">    <span class="comment">// return msg;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#">Activity 的 onStop 居然需要 10s 才会被执行？记一次艰辛的问题排查</a>中提到了barrier消息问题。接下来看看到底什么是barrier消息。</p><h2 id="什么是barrier消息"><a href="#什么是barrier消息" class="headerlink" title="什么是barrier消息"></a>什么是barrier消息</h2><p>先找到发出barrier消息的地方，<code>MessageQueue.postSyncBarrier()</code>。</p><p><code>MessageQueue.postSyncBarrier()</code>方法注释文档中对此有比较清楚的描述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Posts a synchronization barrier to the Looper's message queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Message processing occurs as usual until the message queue encounters the</span></span><br><span class="line"><span class="comment"> * synchronization barrier that has been posted.  When the barrier is encountered,</span></span><br><span class="line"><span class="comment"> * later synchronous messages in the queue are stalled (prevented from being executed)</span></span><br><span class="line"><span class="comment"> * until the barrier is released by calling &#123;<span class="doctag">@link</span> #removeSyncBarrier&#125; and specifying</span></span><br><span class="line"><span class="comment"> * the token that identifies the synchronization barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method is used to immediately postpone execution of all subsequently posted</span></span><br><span class="line"><span class="comment"> * synchronous messages until a condition is met that releases the barrier.</span></span><br><span class="line"><span class="comment"> * Asynchronous messages (see &#123;<span class="doctag">@link</span> Message#isAsynchronous&#125; are exempt from the barrier</span></span><br><span class="line"><span class="comment"> * and continue to be processed as usual.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This call must be always matched by a call to &#123;<span class="doctag">@link</span> #removeSyncBarrier&#125; with</span></span><br><span class="line"><span class="comment"> * the same token to ensure that the message queue resumes normal operation.</span></span><br><span class="line"><span class="comment"> * Otherwise the application will probably hang!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A token that uniquely identifies the barrier.  This token must be</span></span><br><span class="line"><span class="comment"> * passed to &#123;<span class="doctag">@link</span> #removeSyncBarrier&#125; to release the barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译总结一下：</p><blockquote><p>该方法向Looper的MessageQueue发送一个同步barrier消息。没有遇到barrier消息时一切按正常方式处理。遇到barrier消息时，队列中晚一些的同步消息被挂起，直到barrier消息被<code>removeSyncBarrier()</code>方法移除<br>该方法用于立刻延迟所有同步消息，直到某个条件被满足时释放该barrier。异步消息不受barrier消息影响，仍然正常处理<br><code>postSyncBarrier()</code>调用一定要跟<code>removeSyncBarrier()</code>一同调用，并且使用同一个token参数，以保证MessageQueue中的消息可以恢复到正常处理状态。否则 <strong>应用很可能被挂起</strong></p></blockquote><p><img src="barrier-msg.png" alt></p><p><code>postSyncBarrier()</code>是一个隐藏的(@hide)方法，应用无法直接调用，通常应由Android系统调用。</p><h2 id="谁在发送barrier消息"><a href="#谁在发送barrier消息" class="headerlink" title="谁在发送barrier消息"></a>谁在发送barrier消息</h2><p>如何找到谁在发送barrier消息？方法很简单，在<code>MessageQueue.postSyncBarrier()</code>方法处断点调试。这个技巧参考自<a href="http://km.oa.com/articles/show/373058" target="_blank" rel="noopener">Activity 的 onStop 居然需要 10s 才会被执行？记一次艰辛的问题排查</a>。</p><p><code>MessageQueue.postSyncBarrier()</code>被调用时，会在断点处停下来。我们可以沿着调度信息找到调用方。</p><p><img src="post-barrier.png" alt></p><p>是ViewRootImpl.scheduleTraversals()方法发出了barrier消息，有点出乎我们意料？<a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/ViewRootImpl.java" target="_blank" rel="noopener">ViewRootImpl</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.startMethodTracing(<span class="string">"ViewAncestor"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        performTraversals();</span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.stopMethodTracing();</span><br><span class="line">            mProfile = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下ViewRootImpl.scheduleTraversals()为什么会发送barrier消息。</p><blockquote><p>为了让View能够有快速的布局和绘制，android中定义了一个Barrier的概念，当View在绘制和布局时会向Looper中添加了Barrier(监控器)，这样后续的消息队列中的同步的消息将不会被执行，以免会影响到UI绘制 参考自<a href="https://blog.csdn.net/degwei/article/details/50602445" target="_blank" rel="noopener">Android Barrier</a> <a href="https://www.cnblogs.com/dasusu/p/8311324.html" target="_blank" rel="noopener">Android 屏幕刷新机制</a></p></blockquote><h1 id="onStart和onStop"><a href="#onStart和onStop" class="headerlink" title="onStart和onStop"></a>onStart和onStop</h1><p>出于多种原因考虑，ActivityThread并不是立即回调<code>onStart()</code>或<code>onStop()</code>，而是在<a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/app/ActivityThread.java#L1464" target="_blank" rel="noopener">ActivityThread.H</a>这个Hander中回调<code>onStart()</code>和<code>onStop()</code>。</p><p><a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/app/ActivityThread.java" target="_blank" rel="noopener">ActivityThread.handleStopActivity()</a>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleStopActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> show, <span class="keyword">int</span> configChanges, <span class="keyword">int</span> seq)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Schedule the call to tell the activity manager we have</span></span><br><span class="line">    <span class="comment">// stopped.  We don't do this immediately, because we want to</span></span><br><span class="line">    <span class="comment">// have a chance for any other pending work (in particular memory</span></span><br><span class="line">    <span class="comment">// trim requests) to complete before you tell the activity</span></span><br><span class="line">    <span class="comment">// manager to proceed and allow us to go fully into the background.</span></span><br><span class="line">    info.activity = r;</span><br><span class="line">    info.state = r.state;</span><br><span class="line">    info.persistentState = r.persistentState;</span><br><span class="line">    mH.post(info);</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很不幸，这个Handler和我们在主线程中创建的Handler共享同一个MessageQueue。大量向MessageQueue中发送消息时，会影响到<code>onStart()</code>或<code>onStop()</code>的处理速度。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结一下。</p><ul><li>本文中提到的几个知识点：<ul><li>ActivityThread.H(Hander)中回调<code>onStart()</code>和<code>onStop()</code> </li><li>ActivityThread.H和主线程中创建的Handler共享同一个MessageQueue</li><li>向MessageQueue发送大量消息时，可能影响到<code>onStart()</code>或<code>onStop()</code>的响应速度</li><li>IdleHandler可以用来处理一些不紧急的任务，比如ActivityThread使用它来执行gc任务</li><li><code>Looper.setMessageLogging()</code>方法用于打印消息日志</li></ul></li><li>最初提到的<code>onStart()</code>不回调问题的原因<ul><li>Hander用法错误，向MessageQueue中发送大量消息，影响到<code>onStart()</code>或<code>onStop()</code>的响应速度</li></ul></li></ul><p>解决方案</p><ul><li><code>Looper.setMessageLogging()</code>方法打印消息日志，观察是否有异常消息 </li><li>使用上述Helper类打印当前MessageQueue中的所有Message，观察是否有异常消息</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://km.oa.com/articles/show/373058" target="_blank" rel="noopener">Activity 的 onStop 居然需要 10s 才会被执行？记一次艰辛的问题排查</a></li><li><a href="https://blog.dreamtobe.cn/2016/03/11/android_handler_looper/" target="_blank" rel="noopener">Android Handler Looper机制 | Jacks Blog</a></li><li><a href="https://my.oschina.net/youranhongcha/blog/492591" target="_blank" rel="noopener">聊一聊Android的消息机制 - 悠然红茶的个人页面 - 开源中国</a></li><li><a href="https://blog.csdn.net/cdecde111/article/details/54670136" target="_blank" rel="noopener">android 利用Handler机制中SyncBarrier的特性实现预加载 - CSDN博客</a></li><li><a href="https://blog.dreamtobe.cn/2016/03/11/android_handler_looper/" target="_blank" rel="noopener">Android Handler Looper机制 | Jacks Blog</a></li><li><a href="https://segmentfault.com/a/1190000002982318" target="_blank" rel="noopener">Android应用程序消息处理机制 - 点点滴滴 - SegmentFault 思否</a></li><li><a href="https://www.kancloud.cn/alex_wsc/android-deep2/413394" target="_blank" rel="noopener">2.3.3 nativePollOnce函数分析 · 深入理解Android：卷2 · 看云</a></li><li><a href="https://www.jianshu.com/p/9849026e7232" target="_blank" rel="noopener">Android消息循环机制（二）Looper性能检测的缺陷 - 简书</a></li><li><a href="https://blog.csdn.net/degwei/article/details/50602445" target="_blank" rel="noopener">Android Barrier - CSDN博客</a></li><li><a href="https://www.cnblogs.com/dasusu/p/8311324.html" target="_blank" rel="noopener">Android 屏幕刷新机制 - 请叫我大苏 - 博客园</a></li></ul><!-- http://km.oa.com/articles/show/373058?kmref=home_recommend_read -->]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Glide的Registry和GlideModule</title>
      <link href="2018/07/24/glide-registry/"/>
      <url>2018/07/24/glide-registry/</url>
      
        <content type="html"><![CDATA[<p>Glide的Registry和GlideModule机制非常强大。我们可以给Glide添加自定义的GlideModule，更灵活更精细地控制应用中的图片加载流程。<br><a id="more"></a></p><h1 id="使用OkHttp加载图片"><a href="#使用OkHttp加载图片" class="headerlink" title="使用OkHttp加载图片"></a>使用OkHttp加载图片</h1><p>理解Registry和GlideModule机制前先来看看用法。</p><ul><li>实现ModelLoader</li><li>实现ModelLoaderFactory</li><li>实现DataFetcher</li></ul><p>三者的关系如下图所示。</p><p><img src="glide-okhttp-loader.png" alt></p><p>再来看具体代码。</p><ul><li>完整代码见<a href="https://github.com/410063005/FragmentLifeCircle/blob/master/demo-glide/src/main/java/com/example/demo_glide/okhttploader/OkHttpGlideUrlLoaderActivity.java" target="_blank" rel="noopener">OkHttpGlideUrlLoaderActivity</a></li><li>更多用法请参考<a href="http://bumptech.github.io/glide/doc/configuration.html#applications" target="_blank" rel="noopener">Glide v4 : Configuration</a></li><li>官方示例<ul><li><a href="https://github.com/bumptech/glide/tree/master/samples/flickr" target="_blank" rel="noopener">flickr</a></li><li><a href="https://github.com/bumptech/glide/tree/master/integration/okhttp3" target="_blank" rel="noopener">okhttp3</a></li><li><a href="https://github.com/bumptech/glide/tree/master/integration/volley" target="_blank" rel="noopener">volley</a></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpGlideUrlLoader</span> <span class="keyword">implements</span> <span class="title">ModelLoader</span>&lt;<span class="title">GlideUrl</span>, <span class="title">InputStream</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OkHttpGlideUrlLoader</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoadData&lt;InputStream&gt; <span class="title">buildLoadData</span><span class="params">(GlideUrl glideUrl, <span class="keyword">int</span> width, <span class="keyword">int</span> height, Options options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoadData&lt;&gt;(glideUrl, <span class="keyword">new</span> OkHttpStreamFetcher(client, glideUrl));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">ModelLoaderFactory</span>&lt;<span class="title">GlideUrl</span>, <span class="title">InputStream</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ModelLoader&lt;GlideUrl, InputStream&gt; <span class="title">build</span><span class="params">(MultiModelLoaderFactory multiFactory)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> OkHttpGlideUrlLoader(client);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpStreamFetcher</span> <span class="keyword">implements</span> <span class="title">DataFetcher</span>&lt;<span class="title">InputStream</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"OkHttpStreamFetcher"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GlideUrl url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InputStream inputStream;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Call call;</span><br><span class="line">    <span class="meta">@Synthetic</span></span><br><span class="line">    <span class="keyword">private</span></span><br><span class="line">    ResponseBody responseBody;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OkHttpStreamFetcher</span><span class="params">(OkHttpClient client, GlideUrl url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(Priority priority, <span class="keyword">final</span> DataCallback&lt;? <span class="keyword">super</span> InputStream&gt; callback)</span> </span>&#123;</span><br><span class="line">        Request.Builder requestBuilder = <span class="keyword">new</span> Request.Builder().url(url.toStringUrl());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; headerEntry : url.getHeaders().entrySet()) &#123;</span><br><span class="line">            String key = headerEntry.getKey();</span><br><span class="line">            requestBuilder.addHeader(key, headerEntry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Request request = requestBuilder.build();</span><br><span class="line"></span><br><span class="line">        call = client.newCall(request);</span><br><span class="line">        call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, IOException e)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"onFailure: OkHttp failed to obtain result"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                callback.onLoadFailed(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                responseBody = response.body();</span><br><span class="line">                <span class="keyword">if</span> (response.isSuccessful()) &#123;</span><br><span class="line">                    <span class="keyword">long</span> contentLength = responseBody.contentLength();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"onResponse: contentLength="</span> + contentLength);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    inputStream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);</span><br><span class="line">                    callback.onDataReady(inputStream);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    callback.onLoadFailed(<span class="keyword">new</span> HttpException(response.message(), response.code()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将<code>OkHttpGlideUrlLoader</code>注册到Glide当中。这样理解<code>registry.replace()</code>这段代码：使用OkHttpGlideUrlLoader从GlideUrl类型的Model中加载InputStream类型的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GlideModule</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpGlideModule</span> <span class="keyword">extends</span> <span class="title">AppGlideModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerComponents</span><span class="params">(Context context, Glide glide, Registry registry)</span> </span>&#123;</span><br><span class="line">        registry.replace(GlideUrl<span class="class">.<span class="keyword">class</span>, <span class="title">InputStream</span>.<span class="title">class</span>, <span class="title">new</span> <span class="title">OkHttpGlideUrlLoader</span>.<span class="title">Factory</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isManifestParsingEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return super.isManifestParsingEnabled();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>OkHttpStreamFetcher.loadData()</code>中会打印出contentLength。如果一切正常，点击button加载图片时logcat中可以看到如下日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">07-15 14:22:59.312 20636-2114/com.example.demo_glide D/OkHttpStreamFetcher: onResponse: contentLength=52341</span><br></pre></td></tr></table></figure><p>如果你想监听Glide从是否从网络下载了过大的图片，<code>contentLength</code>可以作为监控指标。</p><h1 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h1><p>Glide中<code>Registry</code>用于管理组件的注册工作。不过Glide中的组件相当多，比如各种ModelLoader、Encoder、ResourceDedecoder、Transcoder等等。Registry一人实在应付不来，于是它当大管家，实际管理组件的工作交给下面的人去做。例如，对ModelLoader的管理工作，实际上由ModelLoaderRegistry完成。</p><p><img src="glide-registry2.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Model, Data&gt; <span class="function">Registry <span class="title">append</span><span class="params">(Class&lt;Model&gt; modelClass, Class&lt;Data&gt; dataClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    ModelLoaderFactory&lt;Model, Data&gt; factory)</span> </span>&#123;</span><br><span class="line">  modelLoaderRegistry.append(modelClass, dataClass, factory);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;Model, Data&gt; <span class="function">Registry <span class="title">replace</span><span class="params">(Class&lt;Model&gt; modelClass, Class&lt;Data&gt; dataClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    ModelLoaderFactory&lt;Model, Data&gt; factory)</span> </span>&#123;</span><br><span class="line">  modelLoaderRegistry.replace(modelClass, dataClass, factory);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;Model&gt; List&lt;ModelLoader&lt;Model, ?&gt;&gt; getModelLoaders(Model model) &#123;</span><br><span class="line">  List&lt;ModelLoader&lt;Model, ?&gt;&gt; result = modelLoaderRegistry.getModelLoaders(model);</span><br><span class="line">  <span class="keyword">if</span> (result.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoModelLoaderAvailableException(model);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一类组件不一定唯一存在。比如可以同时有多个ModelLoader，你可以调用<code>append()</code>添加ModelLoader，调用<code>replace()</code>替换成新的ModelLoader。<code>getModelLoaders()</code>返回处理可以加载某种指定类型Model的ModelLoader。</p><p>Glide内置的组件相当之多。创建Glide实例时对这些组件进行注册管理。代码如下(有省略)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> Glide(</span><br><span class="line">     Context context,</span><br><span class="line">     Engine engine, ...) &#123;</span><br><span class="line">   registry.register(ByteBuffer<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">ByteBufferEncoder</span>())</span></span><br><span class="line"><span class="class">       .<span class="title">register</span>(<span class="title">InputStream</span>.<span class="title">class</span>, <span class="title">new</span> <span class="title">StreamEncoder</span>(<span class="title">arrayPool</span>))</span></span><br><span class="line"><span class="class">       /* <span class="title">Bitmaps</span> */</span></span><br><span class="line"><span class="class">       .<span class="title">append</span>(<span class="title">ByteBuffer</span>.<span class="title">class</span>, <span class="title">Bitmap</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">           <span class="title">new</span> <span class="title">ByteBufferBitmapDecoder</span>(<span class="title">downsampler</span>))</span></span><br><span class="line"><span class="class">       .<span class="title">append</span>(<span class="title">InputStream</span>.<span class="title">class</span>, <span class="title">Bitmap</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">           <span class="title">new</span> <span class="title">StreamBitmapDecoder</span>(<span class="title">downsampler</span>, <span class="title">arrayPool</span>))</span></span><br><span class="line"><span class="class">       .<span class="title">append</span>(<span class="title">ParcelFileDescriptor</span>.<span class="title">class</span>, <span class="title">Bitmap</span>.<span class="title">class</span>, <span class="title">new</span> <span class="title">VideoBitmapDecoder</span>(<span class="title">bitmapPool</span>))</span></span><br><span class="line"><span class="class">       .<span class="title">register</span>(<span class="title">Bitmap</span>.<span class="title">class</span>, <span class="title">new</span> <span class="title">BitmapEncoder</span>())</span></span><br><span class="line"><span class="class">...</span></span><br><span class="line"><span class="class">   <span class="title">glideContext</span> </span>= <span class="keyword">new</span> GlideContext(context, registry, ...)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="registry-detail.png" alt></p><p>ModelLoaderFactory类型太多，故图中省略。</p><h1 id="加载自定义Module"><a href="#加载自定义Module" class="headerlink" title="加载自定义Module"></a>加载自定义Module</h1><p>上文中我们知道内置组件和自定义组件均由Registry管理。那么自定义组件如何被加载和管理呢？</p><h2 id="GlideModule注解"><a href="#GlideModule注解" class="headerlink" title="GlideModule注解"></a>GlideModule注解</h2><p>首先需要了解的是GlideModule注解。GlideModule注解的定义非常简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GlideModule &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the name of the class that will be used as a replacement for</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> com.bumptech.glide.Glide&#125; in Applications that depend on Glide's generated code.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">glideName</span><span class="params">()</span> <span class="keyword">default</span> "GlideApp"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码我们知道以下几点：</p><ul><li>这个注解用于类、接口或者enum类型。这个注解会被javac编译器忽略</li><li>缺省会生成GlideApp类，建议使用GlideApp作为Glide库的调用入口</li><li>Glide的注解处理器会在编译期将带有GlideModule注解的LibraryGlideModule和AppGlideModule子类作为组件注册到Glide</li></ul><p>注意，除了要给LibraryGlideModule和AppGlideModule子类添加@GlideModule注解外，<code>build.gradle</code>中还要添加相应的依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-kapt'</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// annotationProcessor 'com.github.bumptech.glide:compiler:4.0.0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 项目中有Kotlin代码的话, 使用kapt而不是annotationProcessor</span></span><br><span class="line"><span class="comment">// 如果使用kapt出错，记得要使用'kotlin-kapt'插件  apply plugin: 'kotlin-kapt'</span></span><br><span class="line">    kapt <span class="string">'com.github.bumptech.glide:compiler:4.0.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Glide注解生成器生成的类包括</p><ul><li>GlideApp - Glide库调用入口</li><li>GeneratedRequestManagerFactory - 不用关注</li><li>GeneratedAppGlideModuleImpl - GeneratedAppGlideModule的子类，方法调用会代理到我们自定义的OkHttpGlideModule</li></ul><p><img src="generated-app-glidemodule.png" alt></p><p>Glide注解处理器的好处包括：</p><ul><li>GlideApp作为Glide库入口，GlideApp只提供核心的方法。终于告别敲完”Glide.”后一堆方法提示让你不知所措的日子</li><li>不必在AndroidManifest.xml添加<code>&lt;meta-data /&gt;</code>。感觉<code>&lt;meta-data&gt;</code>很容易出错</li></ul><p>Glide注解处理器只能生成一个组件，而在AndroidManifest.xml中可以添加多个。不过多数情况下，这不是问题。</p><h2 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h2><p>分析Glide代码不难理解加载自定义组件的整个过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeGlide</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">   Context applicationContext = context.getApplicationContext();</span><br><span class="line">   <span class="comment">// 找到生成的GeneratedAppGlideModuleImpl类实例</span></span><br><span class="line">   GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();</span><br><span class="line">   List&lt;GlideModule&gt; manifestModules = Collections.emptyList();</span><br><span class="line">   <span class="comment">// 找不到GeneratedAppGlideModuleImpl对象或对象允许解析manifest时，尝试从manifest中寻找Glide组件</span></span><br><span class="line">   <span class="keyword">if</span> (annotationGeneratedModule == <span class="keyword">null</span> || annotationGeneratedModule.isManifestParsingEnabled()) &#123;</span><br><span class="line">     manifestModules = <span class="keyword">new</span> ManifestParser(applicationContext).parse();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// excluded module classes机制 </span></span><br><span class="line">   <span class="keyword">if</span> (annotationGeneratedModule != <span class="keyword">null</span></span><br><span class="line">       &amp;&amp; !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) &#123;</span><br><span class="line">     Set&lt;Class&lt;?&gt;&gt; excludedModuleClasses =</span><br><span class="line">         annotationGeneratedModule.getExcludedModuleClasses();</span><br><span class="line">     <span class="keyword">for</span> (Iterator&lt;GlideModule&gt; iterator = manifestModules.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">       GlideModule current = iterator.next();</span><br><span class="line">       <span class="keyword">if</span> (!excludedModuleClasses.contains(current.getClass())) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       iterator.remove();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">   GlideBuilder builder = <span class="keyword">new</span> GlideBuilder()...;</span><br><span class="line">...</span><br><span class="line">   <span class="keyword">if</span> (annotationGeneratedModule != <span class="keyword">null</span>) &#123;</span><br><span class="line">     annotationGeneratedModule.applyOptions(applicationContext, builder);</span><br><span class="line">   &#125;</span><br><span class="line">   Glide glide = builder.build(applicationContext);</span><br><span class="line">...</span><br><span class="line">   <span class="keyword">if</span> (annotationGeneratedModule != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 这里的registerComponents()是不是很熟悉？</span></span><br><span class="line">  <span class="comment">// 对, annotationGeneratedModule就是OkHttpGlideModule</span></span><br><span class="line">     <span class="comment">// 所以实际调用的是OkHttpGlideModule.registerComponents()方法</span></span><br><span class="line">     annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);</span><br><span class="line">   &#125;</span><br><span class="line">   Glide.glide = glide;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> GeneratedAppGlideModule <span class="title">getAnnotationGeneratedGlideModules</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   GeneratedAppGlideModule result = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     Class&lt;GeneratedAppGlideModule&gt; clazz =</span><br><span class="line">         (Class&lt;GeneratedAppGlideModule&gt;)</span><br><span class="line">             Class.forName(<span class="string">"com.bumptech.glide.GeneratedAppGlideModuleImpl"</span>);</span><br><span class="line">     result = clazz.newInstance();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">...</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面的<code>annotationGeneratedModule.registerComponents()</code>方法会调用到我们自定义的OkHttpGlideModule。回顾一下其代码，加深理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GlideModule</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpGlideModule</span> <span class="keyword">extends</span> <span class="title">AppGlideModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerComponents</span><span class="params">(Context context, Glide glide, Registry registry)</span> </span>&#123;</span><br><span class="line">        registry.replace(GlideUrl<span class="class">.<span class="keyword">class</span>, <span class="title">InputStream</span>.<span class="title">class</span>, <span class="title">new</span> <span class="title">OkHttpGlideUrlLoader</span>.<span class="title">Factory</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isManifestParsingEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return super.isManifestParsingEnabled();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://bumptech.github.io/glide/doc/configuration.html#applications" target="_blank" rel="noopener">Glide v4 : Configuration</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Glide生命周期绑定</title>
      <link href="2018/07/23/glide-lifecycle/"/>
      <url>2018/07/23/glide-lifecycle/</url>
      
        <content type="html"><![CDATA[<p>Glide中如何实现生命周期绑定呢？<br><a id="more"></a></p><h1 id="添加RequestManagerFragment"><a href="#添加RequestManagerFragment" class="headerlink" title="添加RequestManagerFragment"></a>添加RequestManagerFragment</h1><p>RequestManagerFragment是实现Glide生命周期的关键。RequestManagerFragment是一个没有界面的Fragment，用于存放RequestManager。RequestManagerFragment可以管理(包括启动和停止)它自身所在的Fragment或Activity中的Target上关联的Glide Request。</p><p>当你调用<code>Glide.with(activity)</code>时，Glide已经偷偷在这个activity中添加了一个RequestManagerFragment。</p><p>注意：Android中系统内置了一种Activity，support库提供了另一种Activity(FragmentActivity)。为了兼容不同的Activity，<code>Glide.with()</code>方法有几个重载版本，对前者而言是<code>Glide.with(android.app.Activity)</code>，对后者是<code>Glide.with(android.support.v4.app.FragmentActivity)</code>。不同的<code>Glide.with()</code>方法添加的Fragment有所不同。</p><table><thead><tr><th>Activity类型</th><th>添加的Fragment类型</th></tr></thead><tbody><tr><td>android.support.v4.app.FragmentActivity</td><td>SupportRequestManagerFragment</td></tr><tr><td>android.app.Activity</td><td>RequestManagerFragment</td></tr></tbody></table><p>Glide已经注意到其中的差异，它并不会弄混。我们只要知道其中的差异即可。下文的讨论中关注的重点是Glide”偷偷”添加Fragment的流程，而忽略了Fragment类型的差异。</p><p><code>Glide.with()</code>最终会调用到<code>RequestManagerRetriever.get()</code>方法。<code>RequestManagerRetriever.get()</code>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// RequestManagerRetriever.java</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">   android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">   <span class="keyword">return</span> fragmentGet(activity, fm, <span class="keyword">null</span> <span class="comment">/*parentHint*/</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> RequestManager <span class="title">fragmentGet</span><span class="params">(Context context, android.app.FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">     android.app.Fragment parentHint)</span> </span>&#123;</span><br><span class="line">   RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);</span><br><span class="line">   RequestManager requestManager = current.getRequestManager();</span><br><span class="line">   <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">     Glide glide = Glide.get(context);</span><br><span class="line">     requestManager =</span><br><span class="line">         factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode());</span><br><span class="line">     current.setRequestManager(requestManager);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> requestManager;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">RequestManagerFragment <span class="title">getRequestManagerFragment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">final</span> android.app.FragmentManager fm, android.app.Fragment parentHint)</span> </span>&#123;</span><br><span class="line">   RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">   <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">     current = pendingRequestManagerFragments.get(fm);</span><br><span class="line">     <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">       current = <span class="keyword">new</span> RequestManagerFragment();</span><br><span class="line">       current.setParentFragmentHint(parentHint);</span><br><span class="line">       pendingRequestManagerFragments.put(fm, current);</span><br><span class="line">       fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">       handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> current;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从代码可以看到调用<code>Glide.with(activity)</code>时Glide的确添加了Fragment。很容易用以下代码验证是否真的添加了Fragment。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FRAGMENT_TAG = <span class="string">"com.bumptech.glide.manager"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_target);</span><br><span class="line"></span><br><span class="line">    Glide.with(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    findViewById(R.id.button).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            Fragment fragment = getSupportFragmentManager().findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">            <span class="keyword">if</span> (fragment <span class="keyword">instanceof</span> SupportRequestManagerFragment) &#123;</span><br><span class="line">                System.out.println(fragment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击Button输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">07-15 03:53:37.272 26036-26036/? I/System.out: SupportRequestManagerFragment&#123;ccdb477 #0 com.bumptech.glide.manager&#125;&#123;parent=null&#125;</span><br></pre></td></tr></table></figure><h1 id="RequestManagerFragment生命周期"><a href="#RequestManagerFragment生命周期" class="headerlink" title="RequestManagerFragment生命周期"></a>RequestManagerFragment生命周期</h1><p><img src="glide-lifecycle.png" alt></p><ul><li>RequestManagerFragment - 有一个类型为ActivityFragmentLifecycle的lifecycle成员。RequestManagerFragment生命周期事件会通知给lifecycle相应的方法。</li><li>ActivityFragmentLifecycle - 有一个类型为Set<lifecyclelistener>的lifecycleListeners成员。onStart/onStop/onDestroy被调用时会回调lifecycleListeners中的每个listener。</lifecyclelistener></li><li>RequestManager - 它实现了LifecycleListener接口，有一个类型为TargetTracker的成员。RequestManager的onStart/onStop/onDestroy被调用时会通知TargetTracker。RequestManager自身作为LifecycleListener被添加到ActivityFragmentLifecycle。</li><li>TargetTracker - 它实现了LifecycleListener接口，用于管理多个Target。TargetTracker的onStart/onStop/onDestory被调用时会通知Target。</li><li>Target - Target继承自LifecycleListener。</li></ul><p>UI上有一个ImageView，调用Glide给这个ImageView加载一张图片，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>).load(...).into(imageView);</span><br></pre></td></tr></table></figure><p><code>into()</code>方法原型是<code>RequestBuilder.into(ImageView)</code>。这个方法中，ImageView会被封装成BitmapImageViewTarget。然后调用<code>RequestBuilder.into(Target)</code>方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(@NonNull Y target)</span> </span>&#123;</span><br><span class="line">  Util.assertMainThread();</span><br><span class="line">  Preconditions.checkNotNull(target);</span><br><span class="line">  <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must call #load() before calling #into()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Request previous = target.getRequest();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">    requestManager.clear(target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  requestOptions.lock();</span><br><span class="line">  Request request = buildRequest(target);</span><br><span class="line">  target.setRequest(request);</span><br><span class="line">  requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整理出来的流程是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Glide.with() -&gt;</span><br><span class="line">RequestManagerRetriever.get() -&gt;</span><br><span class="line">RequestManager.load() -&gt;</span><br><span class="line">RequestBuilder.into() -&gt;</span><br><span class="line">RequestManager.track() -&gt;</span><br><span class="line">TargetTracker.track() -&gt;</span><br></pre></td></tr></table></figure><p>通过应用中的一个场景来理解RequestManagerFragment生命周期过程。假设用户按Home键退出应用中某个正在加载图片的页面，有以下流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RequestManagerFragment.onStop() -&gt;</span><br><span class="line">ActivityFragmentLifecycle.onStop() -&gt;</span><br><span class="line">RequestManager.onStop() -&gt;</span><br><span class="line">TargetTracker.onStop() -&gt;</span><br><span class="line">Target.onStop() -&gt;</span><br></pre></td></tr></table></figure><p>ActivityFragmentLifecycle如何跟RequestManager关联上的呢？关键在于这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> RequestManager <span class="title">fragmentGet</span><span class="params">(Context context, android.app.FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">      android.app.Fragment parentHint)</span> </span>&#123;</span><br><span class="line">    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// TODO(b/27524013): Factor out this Glide.get() call.</span></span><br><span class="line">      Glide glide = Glide.get(context);</span><br><span class="line">      requestManager =</span><br><span class="line">          factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode());</span><br><span class="line">      current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RequestManagerFactory DEFAULT_FACTORY = <span class="keyword">new</span> RequestManagerFactory() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestManager <span class="title">build</span><span class="params">(Glide glide, Lifecycle lifecycle,</span></span></span><br><span class="line"><span class="function"><span class="params">        RequestManagerTreeNode requestManagerTreeNode)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestManager(glide, lifecycle, requestManagerTreeNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestManagerFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ActivityFragmentLifecycle lifecycle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RequestManagerFragment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> ActivityFragmentLifecycle());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RequestManagerFragment(ActivityFragmentLifecycle lifecycle) &#123;</span><br><span class="line">    <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ActivityFragmentLifecycle <span class="title">getGlideLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lifecycle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>梳理一下我们不难发现，RequestManager的lifecycle成员跟RequestManagerFragment的lifecycle是同一个对象！</p><h1 id="RequestManagerFragment的数量"><a href="#RequestManagerFragment的数量" class="headerlink" title="RequestManagerFragment的数量"></a>RequestManagerFragment的数量</h1><ol><li>有几个RequestManagerFragment? </li><li>有几个RequestManager？</li><li>多个RequestManagerFragment之间是什么关系?</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestManagerRetriever</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Map&lt;FragmentManager, SupportRequestManagerFragment&gt; pendingSupportRequestManagerFragments =</span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> RequestManager <span class="title">fragmentGet</span><span class="params">(Context context, android.app.FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">      android.app.Fragment parentHint)</span> </span>&#123;</span><br><span class="line">    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// TODO(b/27524013): Factor out this Glide.get() call.</span></span><br><span class="line">      Glide glide = Glide.get(context);</span><br><span class="line">      requestManager =</span><br><span class="line">          factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode());</span><br><span class="line">      current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来回答前两个问题。有n个Activity/Fragment使用Glide加载图片的话，则有n个RequestManagerFragment和n个RequestManager。即，每个Activity/Fragment中会被添加一个TAG为”com.bumptech.glide.manager”的RequestManageFragment，RequestManageFragment和RequestManager是一一对应关系。</p><p>第3个问题稍麻烦一点。考虑这样一种情况，一个Activity中有两个Fragment，它们都在使用Glide加载图片。一共有3个RequestManagerFragment，它们的关系如下：</p><p><img src="rmf.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestManagerFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;RequestManagerFragment&gt; childRequestManagerFragments =</span><br><span class="line">      <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span> <span class="keyword">private</span> RequestManagerFragment rootRequestManagerFragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Glide-如何触发-onTrimMemory"><a href="#Glide-如何触发-onTrimMemory" class="headerlink" title="Glide 如何触发 onTrimMemory()"></a>Glide 如何触发 onTrimMemory()</h1><p>流程如下图：</p><p><img src="glide-ontrim.png" alt></p><h1 id="Glide-如何触发-onStop"><a href="#Glide-如何触发-onStop" class="headerlink" title="Glide 如何触发 onStop()"></a>Glide 如何触发 onStop()</h1><p><img src="glide-onstop.png" alt></p><p>其他事件的传递过程也类似。如下图：</p><p><img src="glide_life_control.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Glide基础</title>
      <link href="2018/07/22/glide-basic/"/>
      <url>2018/07/22/glide-basic/</url>
      
        <content type="html"><![CDATA[<p>截至<a href="https://github.com/bumptech/glide/tree/v4.0.0/library" target="_blank" rel="noopener">Glide 4.0版本</a>，其代码量已经相当多了。所以学习Glide源码前很有必要了解Glide中几个关键概念，并从整体上理解这些关键概念之间的关系，否则很容易迷失在代码的实现细节中。<br><a id="more"></a></p><h1 id="Glide简介"><a href="#Glide简介" class="headerlink" title="Glide简介"></a>Glide简介</h1><p>Glide涉及到的知识点很多，包括Bitmap重用，Bitmap缓存，生命周期管理，数据加载，资源解码，图片变换，线程调度，等等。另外Glide充分解耦，大量使用接口、泛型以及各种设计模式，并支持外部HttpClient和模块配置。所以学习Glide源码前很有必要了解Glide中几个关键概念，并从整体上理解这些关键概念之间的关系，否则很容易迷失在代码的实现细节中。</p><p>注意，下文中的分析均基于<a href="https://github.com/bumptech/glide/tree/v4.0.0/library" target="_blank" rel="noopener">Glide 4.0版本</a>。</p><p>下面分别从代码视角和包结构视角看看Glide的关键概念以及它们之间的关系。</p><h2 id="代码视角"><a href="#代码视角" class="headerlink" title="代码视角"></a>代码视角</h2><p>一个典型的Glide调用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context).asBitmap().apply().load(model).into(target)</span><br></pre></td></tr></table></figure><p>看似简单的调用实际上包含相当丰富的信息量。</p><p>简单来说，Glide加载(load)模型(Model)，将返回的数据解码(decode)成资源(Resource)，并将资源设置到Target中。</p><table><thead><tr><th>方法</th><th>功能</th><th>对应的接口和类</th></tr></thead><tbody><tr><td>with(context)</td><td>生命周期管理</td><td>Lifecycle</td></tr><tr><td>asBitmap()</td><td>数据解码</td><td>Resource, ResourceDecoder</td></tr><tr><td>apply()</td><td>缓存等等</td><td>TODO</td></tr><tr><td>load(model)</td><td>数据加载</td><td>ModelLoader, ModelLoaderFactory, DataFetcher</td></tr><tr><td>into(target)</td><td>资源的显示</td><td>Target</td></tr></tbody></table><p>Resouce, Data, Source的区分</p><ul><li>Resouce (Data) - 已解码的资源(已解码，采样，或转换)</li><li>(Source) Data - 原始的数据(未解码), ResourceDecoder.decode(data)得到Resource</li><li>Source - 原始的数据源，ModelLoad.load(model)得到(Source) Data</li></ul><p>如何理解Encode操作？ TODO, load, fetch, cache, decode, transcode都好理解</p><h2 id="包结构视角"><a href="#包结构视角" class="headerlink" title="包结构视角"></a>包结构视角</h2><p>Glide作为图片加载库，其工作分为核心部分和其他部分。Glide清晰的包结构体现了这种划分：</p><p><strong>核心工作</strong></p><p><img src="rel1.png" alt></p><p>engine负责load指定的model, 并将得到的data解码成resource。</p><p><img src="rel2.png" alt></p><p>对resource进行某种transition操作后将其显示到target。</p><p><strong>其他工作</strong></p><p><img src="rel2.png" alt></p><ul><li>manager - 负责各种管理工作，包括生命周期，网络连接以及网络请求</li><li>module和provider - 为Glide的模块配置提供支持</li></ul><h1 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h1><p>Glide使用LifecycleListener监听Fragment和Activity的生命周期。<code>LifecycleListener</code>接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleListener</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详见<a href="https://www.sunmoonblog.com/2018/07/23/glide-lifecycle/">Glide生命周期管理</a>。</p><h1 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h1><p>Target可以理解为Resource的最终载体，如ImageView。<code>Target</code>接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span>&lt;<span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">LifecycleListener</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onLoadStarted</span><span class="params">(@Nullable Drawable placeholder)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(@Nullable Drawable errorDrawable)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(R resource, Transition&lt;? <span class="keyword">super</span> R&gt; transition)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onLoadCleared</span><span class="params">(@Nullable Drawable placeholder)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSize</span><span class="params">(SizeReadyCallback cb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeCallback</span><span class="params">(SizeReadyCallback cb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setRequest</span><span class="params">(@Nullable Request request)</span></span>;</span><br><span class="line"><span class="function">Request <span class="title">getRequest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>load resource过程中Target会经历对应的生命周期事件，包括：</p><ul><li>onLoadStarted()</li><li>onResourceReady()</li><li>onLoadCleared()</li><li>onLoadFailed()</li></ul><p>典型的生命周期过程如下：</p><p>onLoadStarted -&gt; onResourceReady -&gt; onLoadCleared<br>onLoadStarted -&gt; onLoadFailed -&gt; onLoadCleared</p><p>注意：不保证一定执行某些方法。比如，如果可以在memory中找到resource，或者mode对象为null，都会导致<code>onLoadStarted()</code>不被执行。</p><p>Target接口的实现类非常多：</p><p><img src="target.png" alt></p><p>这些类的层级关系是这样的：</p><p><img src="target-arch.png" alt></p><p>FutureTarget有点特别，其行为跟<code>Future</code>类似。(注意FutureTarget.get()方法必须在工作线程中调用！)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FutureTarget&lt;Bitmap&gt; futureTarget =</span><br><span class="line">    Glide.with(fragment)</span><br><span class="line">      .load(<span class="string">"http://goo.gl/1asf12"</span>)</span><br><span class="line">      .asBitmap()</span><br><span class="line">      .into(<span class="number">250</span>, <span class="number">250</span>);</span><br><span class="line">Bitmap myBitmap = futureTarget.get();</span><br><span class="line"> ... <span class="comment">// do things with bitmap and then release when finished:</span></span><br><span class="line">futureTarget.cancel(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>RequestFutureTarget是FutureTarget的实现类。可以使用RequestFutureTarget实现下载图片文件的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> FutureTarget&lt;File&gt; target = <span class="keyword">null</span>;</span><br><span class="line"> RequestManager requestManager = Glide.with(context);</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> target = requestManager</span><br><span class="line">.downloadOnly()</span><br><span class="line">.load(model)</span><br><span class="line">.submit();</span><br><span class="line">File downloadedFile = target.get();</span><br><span class="line"><span class="comment">// ... do something with the file (usually throws IOException)</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException | InterruptedException | IOException e) &#123;</span><br><span class="line"><span class="comment">// ... bug reporting or recovery</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// make sure to cancel pending operations and free resources</span></span><br><span class="line"><span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">target.cancel(<span class="keyword">true</span>); <span class="comment">// mayInterruptIfRunning</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Resource和ResourceDecoder"><a href="#Resource和ResourceDecoder" class="headerlink" title="Resource和ResourceDecoder"></a>Resource和ResourceDecoder</h1><p>Resource对某些类型的数据进行包装，以便池化和重用。<code>Resource</code>接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span>&lt;<span class="title">Z</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Class&lt;Z&gt; <span class="title">getResourceClass</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Z <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体来说，Resource包括以下类型：</p><ul><li>File</li><li>Bitmap</li><li>Drawable</li><li>BitmapDrawable</li><li>GifDrawable</li><li>Bytes</li></ul><p>(你可能会注意到RequestManager中有对应的asFile(), asBitmap(), asGif(), asDrawable()等方法)</p><p>以下类实现了Resource接口：</p><p><img src="resource.png" alt></p><p>这些类的层级关系是这样的：</p><p><img src="resource-arch.png" alt></p><p>ResourceDecoder</p><p>以下类实现了ResourceDecoder接口：</p><p><img src="resource-decoder.png" alt></p><ul><li>VideoBitmapDecoder - 从一个包含视频文件的ParcelFileDescriptor中解码出一帧Bitmap</li><li>StreamGifDecoder  - 一个不太高效的GifDrawable解码器</li><li>StreamBitmapDecoder - 从InputStream中解码出Bitmap</li><li>GifFrameResourceDecoder - 从一个表示Gif图片的GifDecoder解码出一帧</li><li>FileDecoder - 从文件创建FileResource</li><li>TODO</li></ul><h1 id="Model和ModelLoader"><a href="#Model和ModelLoader" class="headerlink" title="Model和ModelLoader"></a>Model和ModelLoader</h1><p>Model可以理解为待加载的数据。比如网络图片的url地址或者Android工程的图片id，都是Model。</p><p>Glide没有将Model封装成新的类，而是直接使用已存在的数据类型，包括：</p><ul><li>String</li><li>Uri</li><li>File</li><li>int (resourceId)</li><li>URL</li><li>byte[]</li></ul><p><code>RequestBuilder</code>对每一种Model类型都有一个<code>loadXXX()</code>方法。</p><p>ModelLoader用于加载Model。ModelLoader可以将任意复杂的数据模型转换成具体的数据类型，以便DataFetcher可以获取为Resource获取代表Model的数据。<code>ModelLoader</code>接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ModelLoader</span>&lt;<span class="title">Model</span>, <span class="title">Data</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">LoadData&lt;Data&gt; <span class="title">buildLoadData</span><span class="params">(Model model, <span class="keyword">int</span> width, <span class="keyword">int</span> height, Options options)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">handles</span><span class="params">(Model model)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ModelLoader中有一个静态类LoadData</li><li>buildLoadData() - 根据指定的Model, width, height, options等条件返回一个能够对数据进行加载的LoadData</li><li>handles() - 判断是否能够加载指定model类型的数据</li></ul><p>ModelLoader接口有两个作用： </p><ol><li>用于将特定的Model转换成可解码为Resource的数据</li><li>允许Model根据View的大小获取特定尺寸的Resource</li></ol><p>ModelLoader是抽象的，具体实现的子类中都会实现自己的ModelLoaderFactory。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpGlideUrlLoader</span> <span class="keyword">implements</span> <span class="title">ModelLoader</span>&lt;<span class="title">GlideUrl</span>, <span class="title">InputStream</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoadData&lt;InputStream&gt; <span class="title">buildLoadData</span><span class="params">(GlideUrl model, <span class="keyword">int</span> width, <span class="keyword">int</span> height, Options options)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handles</span><span class="params">(GlideUrl model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">ModelLoaderFactory</span>&lt;<span class="title">GlideUrl</span>, <span class="title">InputStream</span>&gt; </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DataFetcher"><a href="#DataFetcher" class="headerlink" title="DataFetcher"></a>DataFetcher</h1><p>ModelLoader并不是直接加载资源，而是每次加载资源时都会创建一个新的DataFetcher，由DataFetcher延迟加载数据。</p><p><code>DataFetcher</code>接口定义如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataFetcher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadData</span><span class="params">(Priority var1, DataFetcher.DataCallback&lt;? <span class="keyword">super</span> T&gt; var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getDataClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DataSource <span class="title">getDataSource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataCallback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(@Nullable T var1)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(Exception var1)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>见<a href="glide-registry">Glide的Registry和GlideModule</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/yxz329130952/article/details/65447622" target="_blank" rel="noopener">Glide源码分析（二）——磁盘缓存实现 - CSDN博客</a></p><p><a href="http://www.lightskystreet.com/2015/10/12/glide_source_analysis/" target="_blank" rel="noopener">Glide源码分析 | lightSky’Blog</a></p><!-- http://km.oa.com/group/31047/articles/show/315884?kmref=search&from_page=1&no=1&loginParam=disposed&length=35&lengh=35&sessionKey=A64C691AE6E6D0676C7DBF8B30A7341903A66732363194626679AF92377B0D30 --><!--Modelloader和DataFetcher两者结合起来构成了Glide的数据加载核心。当缓存中给定的数据不存在的时候，Glide就会通过指定的Modelloader和DataFetcher进行数据加载，这些数据可能来自文件、网络、byte数组等地方-->]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次减少过度绘制实战</title>
      <link href="2018/06/21/app-overdraw-1/"/>
      <url>2018/06/21/app-overdraw-1/</url>
      
        <content type="html"><![CDATA[<p>去掉不必要的背景是减少过度绘制的一种简单的方式。如何在实际项目应该该技巧呢？<br><a id="more"></a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://developer.android.com/topic/performance/rendering/overdraw?hl=zh-cn#fixing" target="_blank" rel="noopener">官方</a>提供了几个减少过度绘制的常见策略：</p><ul><li>Removing unneeded backgrounds in layouts.</li><li>Flattening the view hierarchy.</li><li>Reducing transparency.</li></ul><p>其中第一个策略简单易用，主要涉及到的开发工具包括：</p><ul><li>GPU呈现模式分析 (Profile GPU Rendering)</li><li>调试GPU过度绘制</li><li>Layout Inspector</li></ul><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>分析app过度绘制问题时发现应用中的某个页面过度绘制次数比预期中的多一次。见下图中的蓝色区域。</p><p><img src="merc-1-overdraw.png" alt></p><p>多次检查该页面未发现问题原因。于是重新写一个完全为空的页面，不妨称之EmptyActivity，发现有如下现象：</p><ul><li>如果EmptyActivity直接继承自AppCompatActivity，过度绘制次数为0，符合预期。</li><li>如果EmptyActivity继承自我们自定义的BaseActivity，过度绘制次数为1，比预期中多一次。</li></ul><p>见对比结果</p><div align="center"><br><img src="no-overdraw.png" width="50%" alt="图片说明"><img src="1-overdraw.png" width="50%" alt="图片说明"><br></div><p>预期应该是左图，没有过度绘制(无颜色)。但实际却是右图，有一次过度绘制(蓝色)。推测问题是由BaseActivity引起。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>EmptyActivity是空白页面，所以从它开始分析BaseActivity的问题还是相当方便的。很快就找到问题，BaseActivity以id为common_base_activity_layout的LinearLayout作为根布局，子类提供的实际布局通过<code>setSubContentView()</code>被添加到根布局。而<code>setSubContentView()</code>会给根布局设置一个默认的背景色。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinearLayout mLayout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.base_activity);</span><br><span class="line">        mLayout = (LinearLayout) findViewById(R.id.common_base_activity_layout);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setSubContentView</span><span class="params">(View view, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (color != <span class="number">0</span>) &#123;</span><br><span class="line">            mLayout.setBackgroundColor(color);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        view.setLayoutParams(<span class="keyword">new</span> LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT, <span class="number">1</span>));</span><br><span class="line">        mLayout.addView(view);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Layout Inspector中很容易看到上述根布局的背景色：</p><p><img src="layout-inspector.png" alt></p><p>而app的主题中也通过<code>android:windowBackground</code>属性给所有的Window添加了一个默认背景色，所以不可避免地多出一次过度绘制。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>Window的背景色和根布局的背景色，我们可以只取其一。考虑到主题中设置Window背景色更直观易维护，所以去掉了根布局的背景色。</p><div align="center"><br><img src="layout-inspector.png" width="50%" alt="图片说明"><img src="layout-inspector2.png" width="50%" alt="图片说明"><br></div><p>还记得过度绘制的颜色规则么？参考自<a href="https://developer.android.com/studio/profile/inspect-gpu-rendering?hl=zh-cn" target="_blank" rel="noopener">官网</a></p><ul><li>真彩色： 没有过度绘制</li><li>蓝色： 过度绘制 1 次</li><li>绿色： 过度绘制 2 次</li><li>粉色： 过度绘制 3 次</li><li>红色： 过度绘制 4 次或更多</li></ul><p><strong>去掉了根布局的背景色，为App整体上减少一次不必要的过度绘制。</strong> 所以你会发现优化后app里原先的蓝色变成了无色，绿色变成了蓝色，粉色变成了绿色。</p><p><img src="merc-1-overdraw.png" alt><br><img src="merc-0-overdraw.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个小的技术问题</title>
      <link href="2018/06/04/tech-problems/"/>
      <url>2018/06/04/tech-problems/</url>
      
        <content type="html"><![CDATA[<p>最近一次技术分享中遗留的两个疑问。分享时并不完全了解，下来后简单整理了一下，记录之。<br><a id="more"></a></p><h1 id="Java中调用Kotlin的扩展方法"><a href="#Java中调用Kotlin的扩展方法" class="headerlink" title="Java中调用Kotlin的扩展方法"></a>Java中调用Kotlin的扩展方法</h1><p>Kotlin中分别给Int和String添加如下扩展函数<code>cm()</code>。完整代码见<a href="https://github.com/410063005/FragmentLifeCircle/blob/master/demo-arch/src/test/java/com/example/cm/demo_arch/ExtensionDemoTest.java" target="_blank" rel="noopener">这里</a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExtensionDemo.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">cm</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"<span class="variable">$this</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">toInt</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">        Integer.parseInt(<span class="keyword">this</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何在Java代码中调用？形式是否能像Kotlin中那样简洁？</p><p><strong>答案是否</strong>。Java代码调用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExtensionDemoKt.cm(<span class="number">1</span>);</span><br><span class="line">    ExtensionDemoKt.toInt(<span class="string">"123"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看Kotlin生成的Java代码就容易明白为什么要这样调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Metadata</span>(</span><br><span class="line">   mv = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">7</span>&#125;,</span><br><span class="line">   bv = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>&#125;,</span><br><span class="line">   k = <span class="number">2</span>,</span><br><span class="line">   d1 = &#123;<span class="string">"\u0000\u0012\n\u0000\n\u0002\u0010\u0002\n\u0002\u0010\b\n\u0000\n\u0002\u0010\u000e\n</span></span><br><span class="line"><span class="string">   \u0000\u001a\n\u0010\u0000\u001a\u00020\u0001*\u00020\u0002\u001a\n\u0010\u0003\u001a\u00020</span></span><br><span class="line"><span class="string">   \u0002*\u00020\u0004¨\u0006\u0005"</span>&#125;,</span><br><span class="line">   d2 = &#123;<span class="string">"cm"</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"toInt"</span>, <span class="string">""</span>, <span class="string">"test sources for module demo-arch"</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtensionDemoKt</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">cm</span><span class="params">(<span class="keyword">int</span> $receiver)</span> </span>&#123;</span><br><span class="line">      String var1 = <span class="string">""</span> + $receiver;</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">toInt</span><span class="params">(@NotNull String $receiver)</span> </span>&#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull($receiver, <span class="string">"$receiver"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> var1;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         var1 = Integer.parseInt($receiver);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">         var1 = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> var1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：Kotlin的扩展函数本质上是生成以被扩展类的对象作为”receiver”参数的static方法。所以，在Java中调用Kotlin扩展函数就只能以调用普通static方法的方式进行。</p><h1 id="Lifecycle的顺序问题"><a href="#Lifecycle的顺序问题" class="headerlink" title="Lifecycle的顺序问题"></a>Lifecycle的顺序问题</h1><p>有一个LifecycleObserver，它的<code>test5()</code>响应<code>Lifecycle.Event.ON_CREATE</code>事件。在Activity.onCreate()期间执行addObserver()添加这个LifecycleObserver，<code>test5()</code>会被正确执行吗(能否输出”test5: ON_CREATE”吗) 完整代码见<a href="https://github.com/410063005/FragmentLifeCircle/blob/master/demo-arch/src/main/java/com/example/cm/demo_arch/lifecycle/MyLifecycleObserver.java" target="_blank" rel="noopener">这里</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleOwnerActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> MyLifecycleObserver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLifecycleObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyLifecycleObserver"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_CREATE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"test5: ON_CREATE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是 <strong>可以正确输出</strong>。由于<code>getLifecycle().addObserver()</code>最终会执行到<code>android.arch.lifecycle.LifecycleRegistry.addObserver()</code>方法，所以对<code>LifecycleRegistry.addObserver()</code>源码进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.arch.lifecycle.LifecycleRegistry.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(@NonNull LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">    ObserverWithState statefulObserver = <span class="keyword">new</span> ObserverWithState(observer, initialState);</span><br><span class="line">    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// it is null we should be destroyed. Fallback quickly</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isReentrance = mAddingObserverCounter != <span class="number">0</span> || mHandlingEvent;</span><br><span class="line">    State targetState = calculateTargetState(observer);</span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    <span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">        popParentState();</span><br><span class="line">        <span class="comment">// mState / subling may have been changed recalculate</span></span><br><span class="line">        targetState = calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">        <span class="comment">// we do sync only on the top level.</span></span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWithState</span> </span>&#123;</span><br><span class="line">    State mState;</span><br><span class="line">    GenericLifecycleObserver mLifecycleObserver;</span><br><span class="line"></span><br><span class="line">    ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class="line">        mLifecycleObserver = Lifecycling.getCallback(observer);</span><br><span class="line">        mState = initialState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class="line">        State newState = getStateAfter(event);</span><br><span class="line">        mState = min(mState, newState);</span><br><span class="line">        mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">        mState = newState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，addObserver()会将原始的observer包装成带状态的statefulObserver。由于是在Activity.onCreate()方法调用addObserver()，所以statefulObserver的当前状态是<code>INITIALIZED</code>。</p><p><code>upEvent(statefulObserver.mState)</code>根据当前状态生成Event对象，这个对象被<code>statefulObserver.dispatchEvent()</code>方法分发给mLifecycleObserver(注意它是另一个对原始observer的包装)。</p><p>分发Event后statefulObserver进入下一状态，<code>CREATED</code>。更多状态变化见下图。</p><p><img src="lifecycle-states.png" alt></p><p>而<code>ObserverWithState.mLifecycleObserver</code>是通过<code>Lifecycling.getCallback()</code>静态方法获取到的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GenericLifecycleObserver mLifecycleObserver = Lifecycling.getCallback(observer)</span><br></pre></td></tr></table></figure><p>正是通过<code>Lifecycling.getCallback()</code>方法，我们可一览<code>LifecycleObserver</code>家族全貌。其中，除<code>LifecycleObserver</code>接口对外公开之外，全部是lifecycle内部使用的类。</p><ul><li>LifecycleObserver</li><li>FullLifecycleObserver</li><li>GenericLifecycleObserver</li><li>FullLifecycleObserverAdapter</li><li>SingleGeneratedAdapterObserver</li><li>CompositeGeneratedAdaptersObserver</li><li>ReflectiveGenericLifecycleObserver</li></ul><p>对于我们的<code>MyLifecycleObserver</code>，<code>Lifecycling.getCallback(observer)</code>方法将其包装成ReflectiveGenericLifecycleObserver。而ReflectiveGenericLifecycleObserver的关键在于CallbackInfo和ClassesInfoCache。代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReflectiveGenericLifecycleObserver</span> <span class="keyword">implements</span> <span class="title">GenericLifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mWrapped;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallbackInfo mInfo;</span><br><span class="line"></span><br><span class="line">    ReflectiveGenericLifecycleObserver(Object wrapped) &#123;</span><br><span class="line">        mWrapped = wrapped;</span><br><span class="line">        mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Event event)</span> </span>&#123;</span><br><span class="line">        mInfo.invokeCallbacks(source, event, mWrapped);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;Lifecycle.Event, List&lt;MethodReference&gt;&gt; mEventToHandlers;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;MethodReference, Lifecycle.Event&gt; mHandlerToEvent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难理解<code>ClassesInfoCache.createInfo(Class klass, @Nullable Method[] declaredMethods)</code>方法的作用是：</p><p>解析其klass参数，找到带有<code>OnLifecycleEvent</code>注解的方法，将这些方法包装成<code>MethodReference</code>。最后，MethodReference会保存在mEventToHandlers。</p><p>最后梳理一下，整个调用顺序是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LifecycleRegistry.addObserver()</span><br><span class="line"></span><br><span class="line">ObserverWithState.dispatchEvent()</span><br><span class="line"></span><br><span class="line">ReflectiveGenericLifecycleObserver.onStateChanged()</span><br><span class="line"></span><br><span class="line">CallbackInfo.invokeCallbacks()</span><br><span class="line"></span><br><span class="line">MethodReference.invokeCallback()</span><br><span class="line"></span><br><span class="line">Method.invoke()</span><br></pre></td></tr></table></figure><p>这里的Method，正是<code>MyLifecycleObserver.test5()</code>方法，它以反射的方法被lifecycle库调用。</p><h1 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h1><p><code>LifecycleOwner</code>是一个接口，实现该接口的类具有生命周期<code>Lifecycle</code>。<a href="https://developer.android.com/reference/android/support/v4/app/Fragment" target="_blank" rel="noopener">Fragment</a>和<a href="https://developer.android.com/reference/android/support/v7/app/AppCompatActivity.html" target="_blank" rel="noopener">AppCompatActivity</a>实现了<code>LifecycleOwner</code>接口，具有生命周期。</p><p>实现了<code>LifecycleObserver</code>接口的组件可以跟<code>LifecycleOwner</code>协同工作，因为它能观察<code>LifecycleOwner</code>的<code>Lifecycle</code>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">lifecycle</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记support库兼容性相关的一个bug</title>
      <link href="2018/05/31/support-library-26-0-0/"/>
      <url>2018/05/31/support-library-26-0-0/</url>
      
        <content type="html"><![CDATA[<p>26.0.0版本的support库对min SDK version的要求是至少14，所以一些用于兼容14以下的代码直接从support库中移除了，比如AnimatorCompatHelper类。Android开发中使用第三方库时要注意是否有依赖的support库版本不统一的问题，避免运行时找不到support库中的类引起crash。<br><a id="more"></a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>应用中出现了一个如下crash，Didn’t find class “android.support.v4.animation.AnimatorCompatHelper”。日志如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassNotFoundException: Didn&apos;t find class &quot;android.support.v4.animation.AnimatorCompatHelper&quot; on path: ...</span><br><span class="line">java.lang.NoClassDefFoundError:Failed resolution of: Landroid/support/v4/animation/AnimatorCompatHelper;</span><br><span class="line">android.support.v7.widget.DefaultItemAnimator.resetAnimation(Unknown Source)</span><br><span class="line">......</span><br><span class="line">java.lang.ClassNotFoundException:Didn&apos;t find class &quot;android.support.v4.animation.AnimatorCompatHelper&quot; on path: ...</span><br><span class="line">dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:56)</span><br><span class="line">java.lang.ClassLoader.loadClass(ClassLoader.java:380)</span><br><span class="line">java.lang.ClassLoader.loadClass(ClassLoader.java:312)</span><br><span class="line">android.support.v7.widget.DefaultItemAnimator.resetAnimation(Unknown Source)</span><br><span class="line">android.support.v7.widget.DefaultItemAnimator.animateMove(Unknown Source)</span><br><span class="line">android.support.v7.widget.DefaultItemAnimator.animateChange(Unknown Source)</span><br><span class="line">android.support.v7.widget.SimpleItemAnimator.animateChange(Unknown Source)</span><br><span class="line">android.support.v7.widget.RecyclerView.animateChange(Unknown Source)</span><br><span class="line">android.support.v7.widget.RecyclerView.dispatchLayoutStep3(Unknown Source)</span><br><span class="line">android.support.v7.widget.RecyclerView.dispatchLayout(Unknown Source)</span><br><span class="line">android.support.v7.widget.RecyclerView.onLayout(Unknown Source)</span><br><span class="line">android.view.View.layout(View.java:17702)</span><br><span class="line">android.view.ViewGroup.layout(ViewGroup.java:5631)</span><br><span class="line">android.widget.FrameLayout.layoutChildren(FrameLayout.java:325)</span><br><span class="line">android.widget.FrameLayout.onLayout(FrameLayout.java:261)</span><br><span class="line">android.view.View.layout(View.java:17702)</span><br><span class="line">android.view.ViewGroup.layout(ViewGroup.java:5631)</span><br><span class="line">com.dependency.phoenix.PullToRefreshView.void onLayout(boolean,int,int,int,int)(Unknown Source)</span><br></pre></td></tr></table></figure><p>异常信息非常明确，是Adapter数据更新时出现问题。</p><p>Adapter中一条数据更新时，我们会调用<code>Adapter.notifyItemChanged()</code>通知界面更新。该方法执行时系统会有一个默认的动画效果，动画效果用到了<code>AnimatorCompatHelper</code>，而<code>AnimatorCompatHelper</code>来自support library库，具体的类是android/support/v4/animation/AnimatorCompatHelper。</p><p>但是我们的应用中正确地添加了support库的，而生成的APK在运行时却无法加载<code>AnimatorCompatHelper</code>类，非常奇怪。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>一开始以为是因为RecyclerView和Adapter的用法不正确引起的偶现问题。尝试修改代码逻辑，强行让应用每次都可以执行<code>Adapter.notifyItemChanged()</code>，复现问题了，而且必现的。仍然输出类似日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">05-31 02:01:56.965 3102-3102/com.aaa.bbb E/eup: sys default last handle start!</span><br><span class="line">05-31 02:01:56.965 3102-3102/com.aaa.bbb E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">                                                                 Process: com.aaa.bbb, PID: 3102</span><br><span class="line">                                                                 java.lang.NoClassDefFoundError: Failed resolution of: Landroid/support/v4/animation/AnimatorCompatHelper;</span><br><span class="line">                                                                     at android.support.v7.widget.DefaultItemAnimator.resetAnimation(DefaultItemAnimator.java:515)</span><br><span class="line">                                                                     at android.support.v7.widget.DefaultItemAnimator.animateChange(DefaultItemAnimator.java:322)</span><br><span class="line">                                                                     at android.support.v7.widget.SimpleItemAnimator.animateChange(SimpleItemAnimator.java:149)</span><br><span class="line">                                                                     at android.support.v7.widget.RecyclerView.animateChange(RecyclerView.java:3790)</span><br><span class="line">                                                                     at android.support.v7.widget.RecyclerView.dispatchLayoutStep3(RecyclerView.java:3597)</span><br><span class="line">                                                                     at android.support.v7.widget.RecyclerView.dispatchLayout(RecyclerView.java:3277)</span><br><span class="line">                                                                     at android.support.v7.widget.RecyclerView.onLayout(RecyclerView.java:3798)</span><br><span class="line">                                                                     at android.view.View.layout(View.java:17519)</span><br><span class="line">                                                                     at android.view.ViewGroup.layout(ViewGroup.java:5612)</span><br><span class="line">                                                                     at android.widget.RelativeLayout.onLayout(RelativeLayout.java:1079)</span><br><span class="line">                                                                     at android.view.View.layout(View.java:17519)</span><br><span class="line">                                                                     at android.view.ViewGroup.layout(ViewGroup.java:5612)</span><br><span class="line">                                                                     at android.widget.FrameLayout.layoutChildren(FrameLayout.java:323)</span><br><span class="line">                                                                     at android.widget.FrameLayout.onLayout(FrameLayout.java:261)</span><br><span class="line">                                                                     at android.view.View.layout(View.java:17519)</span><br><span class="line">                                                                     at android.view.ViewGroup.layout(ViewGroup.java:5612)</span><br><span class="line">                                                                     at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1741)</span><br><span class="line">                                                                     at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1585)</span><br><span class="line">                                                                     at android.widget.LinearLayout.onLayout(LinearLayout.java:1494)</span><br><span class="line">                                                                     at android.view.View.layout(View.java:17519)</span><br><span class="line">                                                                     at android.view.ViewGroup.layout(ViewGroup.java:5612)</span><br><span class="line">                                                                     at android.widget.FrameLayout.layoutChildren(FrameLayout.java:323)</span><br><span class="line">                                                                     at android.widget.FrameLayout.onLayout(FrameLayout.java:261)</span><br><span class="line">                                                                     at android.view.View.layout(View.java:17519)</span><br><span class="line">                                                                     at android.view.ViewGroup.layout(ViewGroup.java:5612)</span><br><span class="line">                                                                     at android.widget.RelativeLayout.onLayout(RelativeLayout.java:1079)</span><br><span class="line">                                                                     at android.view.View.layout(View.java:17519)</span><br><span class="line">                                                                     at android.view.ViewGroup.layout(ViewGroup.java:5612)</span><br><span class="line">                                                                     at com.dependency.phoenix.PullToRefreshView.onLayout(PullToRefreshView.java:407)</span><br><span class="line">                                                                     at android.view.View.layout(View.java:17519)</span><br></pre></td></tr></table></figure><p>全局搜索代码，上面提到一共有7处<code>Adapter.notifyItemChanged()</code>调用。其他地方的调用会不会报错？仍然通过修改代码的方式，强行让应用执行其他一处 <code>Adapter.notifyItemChanged()</code>，发现居然也崩溃了。可以排除RecyclerView和Adapter的用法不正确这一推测。</p><p>在Android Studio中可以看到我们项目引用的库是support库版本是 25.2.0，其中的确有 AnimatorCompatHelper，但错误日志又表明APK包中是没有这个类的。 一个说有，一个说没有，到底有没有？ 反编译APK包看一看。</p><p><img src="v7.png" alt></p><p><img src="v4.png" alt></p><p>反编译后可以看到APK包中有RecyclerView，没有AnimatorCompatHelper。所以可以确定原因： <strong>应用中少了AnimatorCompatHelper类</strong></p><p>分别反编译混淆前的APK包以及混淆前的APK包，观察是否混淆代码导致APK包中的AnimatorCompatHelper类被移除。发现无论混淆与否，APK中都找不到AnimatorCompatHelper。排除混淆的问题。</p><p><a href="http://www.goluck.top/2017/12/03/Android%20%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/" target="_blank" rel="noopener">Android 开发中遇到的一些疑难杂症 | 幸运码渊</a>中提到</p><blockquote><p>Caused by: java.lang.ClassNotFoundException: Didn’t find class “android.support.v4.animation.AnimatorCompatHelper” 这一般是引入了多个三方库，版本不统一导致的</p></blockquote><p>库版本不统一，这种情形是比较容易理解的。第三方库自己通常也会依赖别的库。假如项目中使用第三方库A和B，而A和B都依赖C。但A依赖C v1.0，而B依赖C v2.0。Gradle也不清楚该如何 <strong>正确</strong> 处理。所以Gradle除了给出一条警告，它本着优先使用高版本的原则，最终会选择使用C v2.0库。</p><p>Gradle默认优先选择高版本的策略是合理的。高版本中通常会有新的功能特性，C v2.0比 C v1.0会多不少东西。选择C v2.0，大概率可以保证A不会出问题。而选择C v1.0，没法保证B不出问题。</p><p>但还有一种可能就是高版本中减少功能特性，删除过期的代码。这时选择高版本的策略就未必正确了。很不幸，support库(android.support.v4)真的充当了我们这里所说的C。</p><p>对比 25.2.0 和 26.1.0 版本的support库，发现两个版本变化特别大。26.1.0的support库中根本就没有<code>android.support.v4.animation</code>这个包。Android官方给出原因：</p><p><a href="https://stackoverflow.com/questions/47350681/android-support-v4-animation-missing-in-api-26" target="_blank" rel="noopener">android.support.v4.animation missing in API 26 - Stack Overflow</a>和<a href="https://developer.android.com/topic/libraries/support-library/revisions.html#26-0-0-alpha1" target="_blank" rel="noopener">这里</a>提到原因：</p><blockquote><p>Note: The minimum SDK version has been increased to 14. As a result, many APIs that existed only for API &lt; 14 compatibility have been deprecated. Clients of these APIs should migrate to their framework equivalents as noted in the reference page for each deprecated API.</p></blockquote><p>26.0.0版本开始，support库对min SDK version的要求是至少14，所以一些用于兼容14以下的代码直接从support库中移除了。</p><p>使用<code>./gradlew :app:dependencies</code>分析我们项目的依赖关系，发现<code>android.arch.lifecycle:extensions</code>依赖了26.0.1的support库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">---- android.arch.lifecycle:extensions:1.1.1</span><br><span class="line">     +--- android.arch.lifecycle:runtime:1.1.1 (*)</span><br><span class="line">     +--- android.arch.core:common:1.1.1 (*)</span><br><span class="line">     +--- android.arch.core:runtime:1.1.1</span><br><span class="line">     |    +--- com.android.support:support-annotations:26.1.0</span><br><span class="line">     |    \--- android.arch.core:common:1.1.1 (*)</span><br><span class="line">     +--- com.android.support:support-fragment:26.1.0 (*)</span><br><span class="line">     +--- android.arch.lifecycle:common:1.1.1 (*)</span><br><span class="line">     +--- android.arch.lifecycle:livedata:1.1.1</span><br><span class="line">     |    +--- android.arch.core:runtime:1.1.1 (*)</span><br><span class="line">     |    +--- android.arch.lifecycle:livedata-core:1.1.1</span><br><span class="line">     |    |    +--- android.arch.lifecycle:common:1.1.1 (*)</span><br><span class="line">     |    |    +--- android.arch.core:common:1.1.1 (*)</span><br><span class="line">     |    |    \--- android.arch.core:runtime:1.1.1 (*)</span><br><span class="line">     |    \--- android.arch.core:common:1.1.1 (*)</span><br><span class="line">     \--- android.arch.lifecycle:viewmodel:1.1.1</span><br><span class="line">          \--- com.android.support:support-annotations:26.1.0</span><br></pre></td></tr></table></figure><p>这个依赖导致实际编译时用的support库是26.0.1版本而非我们自己指定的25.2.0版本，导致生成的APK包中缺少AnimatorCompatHelper最终报错。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>一种解决办法是升级项目中的support库26.0.2版本。</p><p>另一种解决办法是更严格地指定使用25.2.0版本的support库。 <a href="https://stackoverflow.com/questions/43320496/noclassdeffounderror-android-support-v4-animation-animatorcompathelper" target="_blank" rel="noopener">来源</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt;</span><br><span class="line">        def requested = details.requested</span><br><span class="line">        if (requested.group == &apos;com.android.support&apos;) &#123;</span><br><span class="line">            if (!requested.name.startsWith(&quot;multidex&quot;)) &#123;</span><br><span class="line">                details.useVersion &apos;25.2.0&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>26.0.0版本的support库对min SDK version的要求是至少14，所以一些用于兼容14以下的代码直接从support库中移除了。Android开发中使用第三方库时要注意是否有support库版本不统一的问题，避免运行时找不到support库中的类引起crash。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.goluck.top/2017/12/03/Android%20%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/" target="_blank" rel="noopener">Android 开发中遇到的一些疑难杂症</a><br><a href="https://stackoverflow.com/questions/47350681/android-support-v4-animation-missing-in-api-26" target="_blank" rel="noopener">android.support.v4.animation missing in API 26 - Stack Overflow</a><br><a href="https://blog.csdn.net/xx326664162/article/details/71488551" target="_blank" rel="noopener">support中v4 v7库版本错误详解 - CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin中thread的用法</title>
      <link href="2018/05/24/kotlin-thread/"/>
      <url>2018/05/24/kotlin-thread/</url>
      
        <content type="html"><![CDATA[<p>Kotlin中可以使用<code>thread()</code>方法创建新的线程，指定的语句块将在新线程中运行。语法简单，十分易用。<br><a id="more"></a></p><h1 id="Kotlin线程"><a href="#Kotlin线程" class="headerlink" title="Kotlin线程"></a>Kotlin线程</h1><p>在Kotlin中很容易创建新的线程。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"hello from <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    thread &#123;</span><br><span class="line">        println(<span class="string">"hello from <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello from main</span><br><span class="line">hello from Thread-0</span><br></pre></td></tr></table></figure><p>用法够简单吧。你会好奇<code>thread {}</code>到底是什么黑科技，其实很简单，语法糖而已。</p><p><code>thread()</code>是一个方法，其定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">thread</span><span class="params">(start: <span class="type">Boolean</span> = <span class="literal">true</span>, isDaemon: <span class="type">Boolean</span> = <span class="literal">false</span>, contextClassLoader: <span class="type">ClassLoader</span>? = <span class="literal">null</span>, name: <span class="type">String</span>? = <span class="literal">null</span>, priority: <span class="type">Int</span> = <span class="number">-1</span>, block: () -&gt; <span class="type">Unit</span>)</span></span>: Thread &#123;</span><br><span class="line">    <span class="keyword">val</span> thread = <span class="keyword">object</span> : Thread() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            block()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isDaemon)</span><br><span class="line">        thread.isDaemon = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (priority &gt; <span class="number">0</span>)</span><br><span class="line">        thread.priority = priority</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">null</span>)</span><br><span class="line">        thread.name = name</span><br><span class="line">    <span class="keyword">if</span> (contextClassLoader != <span class="literal">null</span>)</span><br><span class="line">        thread.contextClassLoader = contextClassLoader</span><br><span class="line">    <span class="keyword">if</span> (start)</span><br><span class="line">        thread.start()</span><br><span class="line">    <span class="keyword">return</span> thread</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>thread()</code>方法具体实现跟我们在Java代码中<code>new Thread()</code>方式创建线程本质上没有任何区别。</p><p>不过实际Android项目中使用<code>thread {}</code>随意创建线程是不合适的，很可能带来混乱。我们最好根据任务的特点来使用不同的线程池。比如，将耗时的DB操作提交到<code>Executors.newSingleThreadExecutor()</code>是非常合适的。</p><p>那我们能不能定义一个跟<code>thread()</code>类似的<code>ioThread()</code>方法呢？答案是肯定的。代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> IO_EXECUTOR = Executors.newSingleThreadExecutor()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Utility method to run blocks on a dedicated background thread, used for io/database work.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ioThread</span><span class="params">(f : () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    IO_EXECUTOR.execute(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"hello from <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    thread &#123;</span><br><span class="line">        println(<span class="string">"hello from <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ioThread &#123;</span><br><span class="line">        println(<span class="string">"hello from <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一回的输出是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello from main</span><br><span class="line">hello from Thread-0</span><br><span class="line">hello from pool-1-thread-1</span><br></pre></td></tr></table></figure><p>从使用上来说，你根本感觉不到<code>ioThread {}</code>是用户自定义的，对不对？</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/googlesamples/android-architecture-components/blob/master/PagingSample/app/src/main/java/paging/android/example/com/pagingsample/Executors.kt#L21" target="_blank" rel="noopener">PagingSample Executors</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈Kotlin中的Map</title>
      <link href="2018/05/23/kotlin-map/"/>
      <url>2018/05/23/kotlin-map/</url>
      
        <content type="html"><![CDATA[<p>Kotlin的Map相对于Java的Map在设计上有更好的”不变性”，在使用上也更加方便。<br><a id="more"></a></p><h1 id="Java-Map介绍"><a href="#Java-Map介绍" class="headerlink" title="Java Map介绍"></a>Java Map介绍</h1><p>谈Kotlin的Map前，首先看看Java的Map。先看看Map是什么。</p><p><img src="array-vs-map.png" alt></p><p>可以将Map理解成一个广义上的数组。普通数组的索引只能是数字，0、1、2，普通数组在物理上是连续的。而Map的索引可以是任何具有不变性的对象，比如可以是字符a、b、c。</p><p>在Java中Map具体指<code>java.util.Map</code>。<code>java.util.Map</code>是接口，实际中最常用的类是<code>java.util.HashMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; m = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">m.put(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">m.put(<span class="number">2</span>, <span class="string">"b"</span>);</span><br></pre></td></tr></table></figure><p><code>java.util.HashMap</code>常被用来作为最简单的内存缓存。一个典型的场景是先检查缓存中是否有结果，没有的话重新计算并更新缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object value = cache.get(key);</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    value = doWork();</span><br><span class="line">    cache.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而学习Kotlin时发现似乎官方更推荐使用<code>mapOf()</code>或<code>mutableMapOf()</code>，而不是直接使用HashMap()。原因有两点</p><p>一方面是<code>mapOf()</code>和<code>mutableMapOf()</code>写起来更简单。下面这个例子用HashMap写的话，显然繁琐很多。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> m = mapOf(<span class="number">1</span> to <span class="string">"a"</span>, <span class="number">2</span> to <span class="string">"b"</span>)</span><br><span class="line"><span class="keyword">val</span> m2 = mutableMapOf(<span class="number">1</span> to <span class="string">"a"</span>, <span class="number">2</span> to <span class="string">"b"</span>)</span><br></pre></td></tr></table></figure><p>更重要的是，Kotlin的Map在设计上考虑得更全面。</p><h1 id="Java-Map的问题"><a href="#Java-Map的问题" class="headerlink" title="Java Map的问题"></a>Java Map的问题</h1><p>我们知道，编程中准确地控制<code>HashMap</code>是否可以只读，可以减少意外写操作的风险。这通常意味着代码中更少的bug。</p><p>比如，一个<code>HashMap</code>是只读的(也可以说是不可写的、不能修改的)，假如你意外地修改了它的值，代码编译期就会报错，而不是等到运行期间出现某些难以跟踪的bug，世界是不是更美好。(可能你会说，谁会蠢到不小心去修改Map中的值。可是，哪个bug归根结底不是愚蠢的)</p><p>很可惜这种看似理解当然的结果，在Java世界却并非如此。Java的确在<code>java.util.Collections</code>工具类中提供了大量的<code>unmodifiableXXX()</code>方法用于生成不可修改的集合，其中包括<code>unmodifiableMap()</code>，以解决只读Map的问题。可惜这些小的修补并不完美</p><p>请看这段代码。它在运行时抛出异常，<code>java.lang.UnsupportedOperationException at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsupportedOperationException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, String&gt; modifiableMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, String&gt; unmodifiableMap = Collections.unmodifiableMap(modifiableMap);</span><br><span class="line">    unmodifiableMap.put(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">foo</span><span class="params">(Map&lt;Integer, String&gt; map)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>你能容易地判断modifiableMap和unmodifiableMap是否只读的吗？ 不能</li><li>你能容易地判断foo()的map参数是否只读的吗？ 不能</li><li>unmodifiableMap.put(1, “a”)在编译期会报错吗？不会</li></ul><p>三个问题都是因为Java中的Map接口在设计上并没有考虑变(可写)与不变(只读)的问题。结果，你无法用Java的Map设计清晰、明确的API，你只能等到运行时眼睁睁地看Java的Map抛出UnsupportedOperationException。</p><p>是不是很搞笑，早知会UnsupportedOperationException，何必提供<code>put()</code>操作？ (当然，不得不承认运行期的UnsupportedOperationException好过运行期的bug)</p><p>于是，Kotlin改进了Java中Map的设计。</p><h1 id="Kotlin中的Map"><a href="#Kotlin中的Map" class="headerlink" title="Kotlin中的Map"></a>Kotlin中的Map</h1><p>如果我看得比别人更远些，那是因为我站在巨人的肩膀上。 ————牛顿</p><p>如果Kotlin的Map比Java的更好，同样也是因为它站在了Java的肩膀上。Kotlin并没有将Java的Map全部推倒重来，相反，它大量使用Java代码。Kotlin中仍然可以使用<code>java.util.HashMap</code>。而且由于Kotlin给<code>java.util.HashMap</code>定义了别名，使用起来反而省去了import的繁琐。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 kotlin.collections.TypeAliases.kt</span></span><br><span class="line"><span class="meta">@file:kotlin</span>.jvm.JvmVersion</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> kotlin.collections</span><br><span class="line"></span><br><span class="line"><span class="meta">@SinceKotlin(<span class="meta-string">"1.1"</span>)</span> <span class="keyword">public</span> <span class="keyword">typealias</span> RandomAccess = java.util.RandomAccess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SinceKotlin(<span class="meta-string">"1.1"</span>)</span> <span class="keyword">public</span> <span class="keyword">typealias</span> ArrayList&lt;E&gt; = java.util.ArrayList&lt;E&gt;</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="meta-string">"1.1"</span>)</span> <span class="keyword">public</span> <span class="keyword">typealias</span> LinkedHashMap&lt;K, V&gt; = java.util.LinkedHashMap&lt;K, V&gt;</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="meta-string">"1.1"</span>)</span> <span class="keyword">public</span> <span class="keyword">typealias</span> HashMap&lt;K, V&gt; = java.util.HashMap&lt;K, V&gt;</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="meta-string">"1.1"</span>)</span> <span class="keyword">public</span> <span class="keyword">typealias</span> LinkedHashSet&lt;E&gt; = java.util.LinkedHashSet&lt;E&gt;</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="meta-string">"1.1"</span>)</span> <span class="keyword">public</span> <span class="keyword">typealias</span> HashSet&lt;E&gt; = java.util.HashSet&lt;E&gt;</span><br></pre></td></tr></table></figure><p>在Kotlin中使用HashMap的例子如下，可以看到没有 import java.util.HashMap</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">kotlinJavaMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> m = HashMap&lt;<span class="built_in">Int</span>, String&gt;()</span><br><span class="line">    println(m.javaClass.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：虽然Kotlin中可以使用HashMap，并不建议直接使用HashMap。</p><h2 id="更好的设计"><a href="#更好的设计" class="headerlink" title="更好的设计"></a>更好的设计</h2><p>Kotlin对Java Map的最大改进在于严格地定义了不变性。kotlin.collections.Collections.kt中定义了如下接口</p><p><img src="mutable-map.png" alt></p><p>可以看到对可迭代接口以及所有的集合接口，Kotlin都区分了可变与不可变。我们这里只关注Map和MutableMap，其他接口类似。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="type">K, out V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">containsKey</span><span class="params">(key: <span class="type">K</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">containsValue</span><span class="params">(value: @<span class="type">UnsafeVariance</span> <span class="type">V</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">K</span>)</span></span>: V?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MutableMap</span>&lt;<span class="type">K, V</span>&gt; : <span class="type">Map</span>&lt;<span class="type">K, V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(key: <span class="type">K</span>, value: <span class="type">V</span>)</span></span>: V?</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(key: <span class="type">K</span>)</span></span>: V?</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(key: <span class="type">K</span>, value: <span class="type">V</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="comment">// See default implementation in JDK sources</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">putAll</span><span class="params">(from: <span class="type">Map</span>&lt;<span class="type">out</span> <span class="type">K</span>, V&gt;)</span></span>: <span class="built_in">Unit</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">clear</span><span class="params">()</span></span>: <span class="built_in">Unit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看到，Map接口少了一个很关键的<code>put()</code>方法，这是有意为之，一切修改Map的方法都被移到MutableMap中去了。所以Map是只读的，MutableMap继承自Map的，可读可写。</p><p>这是<code>unsupportedOperationException()</code>的Kotlin版本，更新只读HashMap会在编译期立马报错。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">noUnsupportedOperationException</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> unmodifiableMap = mapOf(<span class="number">1</span> to <span class="string">"a"</span>)</span><br><span class="line">    <span class="comment">// 更新只读HashMap会在编译期报错</span></span><br><span class="line">    <span class="comment">// unmodifiableMap[1] = "b"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> modifiableMap = mutableMapOf(<span class="number">1</span> to <span class="string">"a"</span>)</span><br><span class="line">    modifiableMap[<span class="number">1</span>] = <span class="string">"b"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="map.png" alt></p><p>更新只读HashMap会在编译期立马报错，可以很直观地看到IDE的报错提示。</p><hr><p>有人会抬杠，Kotlin的设计是完美的吗，真的无法修改unmodifiableMap？其实也不是</p><p>最后，由于可以区分MutableMap跟Map接口，很容易设计更为清晰的API。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(<span class="keyword">val</span> map: <span class="type">MutableMap</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">(<span class="keyword">val</span> map: <span class="type">Map</span>)</span></span></span><br></pre></td></tr></table></figure><h2 id="更方便的方法"><a href="#更方便的方法" class="headerlink" title="更方便的方法"></a>更方便的方法</h2><p><a href="https://github.com/googlesamples/android-architecture-components/tree/master/PagingWithNetworkSample" target="_blank" rel="noopener">PagingWithNetworkSample</a>的<a href="https://github.com/googlesamples/android-architecture-components/blob/master/PagingWithNetworkSample/app/src/test-common/java/com/android/example/paging/pagingwithnetwork/repository/FakeRedditApi.kt#L33" target="_blank" rel="noopener">FakeRedditApi.kt</a>中的一段代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FakeRedditApi</span> : <span class="type">RedditApi &#123;</span></span></span><br><span class="line">    <span class="comment">// subreddits keyed by name</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> model = mutableMapOf&lt;String, SubReddit&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addPost</span><span class="params">(post: <span class="type">RedditPost</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> subreddit = model.getOrPut(post.subreddit) &#123;</span><br><span class="line">            SubReddit(items = arrayListOf())</span><br><span class="line">        &#125;</span><br><span class="line">        subreddit.items.add(post)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得本文开头Java中使用HashMap作为缓存的示例代码吗？改写成Kotlin代码大约是这样的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> value = cache.getOrPut(key) &#123; doWork() &#125;</span><br></pre></td></tr></table></figure><p>嗯，没错，<strong>一行Kotlin代码</strong>。</p><p>相比Java，Kotlin给Map添加了许多非常实用的方法，这里简单列举几个。更多方法可参考源码或<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html" target="_blank" rel="noopener">文档</a>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mapUsage</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> map = mapOf(<span class="number">1</span> to <span class="string">"a"</span>, <span class="number">2</span> to <span class="string">"b"</span>, <span class="number">3</span> to <span class="string">"c"</span>)</span><br><span class="line"></span><br><span class="line">    println(map.getOrDefault(<span class="number">20</span>, <span class="string">"NONE"</span>))</span><br><span class="line">    println(map.filter &#123; it.key % <span class="number">2</span> != <span class="number">0</span> &#125;)</span><br><span class="line">    map.forEach &#123; k, v -&gt; println(<span class="string">"<span class="variable">$k</span> -&gt; <span class="variable">$v</span>"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NONE</span><br><span class="line">&#123;1=a, 3=c&#125;</span><br><span class="line">1 -&gt; a</span><br><span class="line">2 -&gt; b</span><br><span class="line">3 -&gt; c</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>对于不可变的Map，Kotlin中使用<code>mapOf()</code></li><li>对于可变的Map，Kotlin中使用<code>mutableMapOf()</code></li><li>坚持要用HashMap的话，Kotlin中使用<code>hashMapOf()</code> (<code>mutableMapOf()</code>并不是HashMap，而是LinkedHashMap)</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://kotlinlang.org/docs/reference/collections.html" target="_blank" rel="noopener">Kotlin collections介绍</a><br><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html" target="_blank" rel="noopener">Kotlin collections文档</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Kotlin Android Extensions时碰到的一个问题</title>
      <link href="2018/04/28/kotlin-view-binding-ext-bug/"/>
      <url>2018/04/28/kotlin-view-binding-ext-bug/</url>
      
        <content type="html"><![CDATA[<p>本文记录了使用kotlin android extions时遇到的小问题以及对应的解决方法。<br><a id="more"></a></p><h1 id="Kotlin-Android-Extensions"><a href="#Kotlin-Android-Extensions" class="headerlink" title="Kotlin Android Extensions"></a>Kotlin Android Extensions</h1><p><a href="https://kotlinlang.org/docs/tutorials/android-plugin.html" target="_blank" rel="noopener">Kotlin Android Extensions</a>是用于Kotlin android开发的插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;kotlin-android-extensions&apos;</span><br></pre></td></tr></table></figure><p>借助该插件我们在Kotlin代码中不必再使用<code>findViewById()</code>，直接通过view id访问相应View即可。例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_main.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.content_main_clip.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">btn_clip_demo.setOnClickListener &#123;&#125;</span><br><span class="line">iv_demo.setImageDrawable(ContextCompat.getDrawable(<span class="keyword">this</span>, R.color.colorAccent))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对Java代码中繁琐的<code>findViewById()</code>方便许多，对吧。</p><p>更多用法可以参考<a href="https://antonioleiva.com/kotlin-android-extensions/" target="_blank" rel="noopener">这篇文章</a>。</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>很不幸，使用<a href="https://kotlinlang.org/docs/tutorials/android-plugin.html" target="_blank" rel="noopener">Kotlin Android Extensions</a>时遇到一个奇怪的问题。布局和代码如下：</p><p>activity_main.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">"com.example.cm.drawabledemo.MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/fl_container"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"300dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/btn_clip_demo"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"clip demo"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">"@+id/btn_gravity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.constraint.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>content_main_clip.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:padding</span>=<span class="string">"2dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/iv_demo"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"92dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"78dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginEnd</span>=<span class="string">"24dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"104dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.constraint.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MainActivity.kt</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        btn_clip_demo.setOnClickListener &#123;</span><br><span class="line">            fl_container.removeAllViews()</span><br><span class="line">            layoutInflater.inflate(R.layout.content_main_clip, fl_container)</span><br><span class="line">iv_demo.setImageDrawable(ContextCompat.getDrawable(<span class="keyword">this</span>, R.color.colorAccent))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码功能：点击<code>btn_clip_demo</code>后，将<code>content_main_clip</code>中的内容(其中有一个id为<code>iv_demo</code>的ImageView)重新添加到<code>fl_container</code>，并且将<code>iv_demo</code>设置为红色。</p><p>问题描述：第一次点击<code>btn_clip_demo</code>，<code>iv_demo</code>被设置成红色。<font color="red">但之后再点击btn_clip_demo，iv_demo没有被设置成红色</font>。</p><p><img src="koltin-android-ext1.gif" alt></p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>Android Studio查看Kotlin对应Java代码的方式： Tools -&gt; Kotlin -&gt; Show Kotlin Bytecode -&gt; Decompile</p><p>上述kotlin代码对应的Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> HashMap _$_findViewCache;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      <span class="keyword">this</span>.setContentView(<span class="number">2131296283</span>);</span><br><span class="line">      ((Button)<span class="keyword">this</span>._$_findCachedViewById(id.btn_clip_demo)).setOnClickListener((OnClickListener)(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View it)</span> </span>&#123;</span><br><span class="line">            ((FrameLayout)M.<span class="keyword">this</span>._$_findCachedViewById(id.fl_container)).removeAllViews();</span><br><span class="line">            M.<span class="keyword">this</span>.getLayoutInflater().inflate(<span class="number">2131296285</span>, (FrameLayout)M.<span class="keyword">this</span>._$_findCachedViewById(id.fl_container));</span><br><span class="line">            ((ImageView)M.<span class="keyword">this</span>._$_findCachedViewById(id.iv_demo)).setImageDrawable(ContextCompat.getDrawable((Context)M.<span class="keyword">this</span>, <span class="number">2130968614</span>));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> View _$_findCachedViewById(<span class="keyword">int</span> var1) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>._$_findViewCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache = <span class="keyword">new</span> HashMap();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      View var2 = (View)<span class="keyword">this</span>._$_findViewCache.get(Integer.valueOf(var1));</span><br><span class="line">      <span class="keyword">if</span>(var2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">         var2 = <span class="keyword">this</span>.findViewById(var1);</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache.put(Integer.valueOf(var1), var2);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> var2;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> _$_clearFindViewByIdCache() &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>._$_findViewCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache.clear();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高大上的Kotlin Android Extensions生成的代码其实非常简单，要点如下：</p><ul><li>View cache策略<ul><li>自动生成一个HashMap类型的findViewCache，用于缓存访问过的View</li><li>自动生成findCachedViewById()和clearFindViewByIdCache()方法</li></ul></li><li>Kotlin代码中对view id的直接访问被转换成相应的findCachedViewById()调用</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">btn_clip_demo.setOnClickListener &#123;</span><br><span class="line">    fl_container.removeAllViews()</span><br><span class="line">    layoutInflater.inflate(R.layout.content_main_clip, fl_container)</span><br><span class="line">    iv_demo.setImageDrawable(ContextCompat.getDrawable(<span class="keyword">this</span>, R.color.colorAccent))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对照代码不难理解问题的原因在于：</p><p>第一次点击<code>btn_clip_demo</code>时，view cache策略并不生效，所以一切正常。第二次点击<code>btn_clip_demo</code>时，view cache策略生效。但view cache策略对我们的场景是错误的(从另一角度讲，可能是我的用法有误？)。从view cache中拿到的<code>iv_demo</code>对象是旧的。关键是，它已经从屏幕上移除，是不可见的。我们给它设置红色当然不起作用！而<code>inflate()</code>操作新添加到布局中的、在屏幕上可见的那个<code>iv_demo</code>，实际上被我们晾在一边。</p><p>所以这里我们不得不使用<code>findViewById</code>来获取那个被晾在一边的新的<code>iv_demo</code>。以下是修改后的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn_clip_demo.setOnClickListener &#123;</span><br><span class="line">    fl_container.removeAllViews()</span><br><span class="line">    layoutInflater.inflate(R.layout.content_main_clip, fl_container)</span><br><span class="line"><span class="keyword">val</span> ivDemoNew = findViewById&lt;ImageView&gt;(R.id.iv_demo)</span><br><span class="line">    ivDemoNew.setImageDrawable(ContextCompat.getDrawable(<span class="keyword">this</span>, R.color.colorAccent))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="koltin-android-ext2.gif" alt></p><p>这回，无论我们如何点击按钮，<code>iv_demo</code>永远会被正确地设置为红色。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一个多线程并发读写HashMap时遇到的问题</title>
      <link href="2018/03/30/map-sync-problem/"/>
      <url>2018/03/30/map-sync-problem/</url>
      
        <content type="html"><![CDATA[<p>HashMap并非线程安全的。多线程中使用HashMap时，应当注意数据同步问题。本文记录并分析了我在实际项目中遇到的一个关于HashMap数据不同步问题。<br><a id="more"></a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>AppMap用于保存应用的登录态。</p><ul><li>请求后台接口时从AppMap读取登录态</li><li>登录、退出登录、以及刷新微信access token时会更新登录态</li></ul><p>AppMap是单例, 它的内部使用HashMap保存数据。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppMap.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppMap instance = <span class="keyword">new</span> AppMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppMap <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; m1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">snapshot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableMap(m1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        m1.clear();</span><br><span class="line">        m1.putAll(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Demo.java</span></span><br><span class="line">HashMap m2 = appMap.snapshot();</span><br></pre></td></tr></table></figure><ul><li><code>update()</code>方法用于更新登录态，更新登录态是写操作。<code>AppMap.update()</code>直接更改其内部的Map</li><li><code>snapshot()</code>方法用于获取登录态，获取登录态是读操作。为避免调用方意外修改登录态，<code>AppMap.snapshot()</code>返回了一个不可修改的Map</li></ul><p>由于某些历史原因，应用运行时可能出现这样一个多线程并发访问HashMap的场景：</p><p><img src="flow.png" alt></p><p> <strong>线程A更新登录态，它向<code>m1</code>中写入数据；同时，线程B获取登录态以发送网络请求，它从<code>m2</code>中读取数据</strong>。</p><p>线程B获取登录态发送网络请求的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">net</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!m2.containsKey(<span class="string">"someKey"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">String someValue = m2.get(<span class="string">"someKey"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] data = someValue.getBytes();</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很不幸，<code>byte[] data = someValue.getBytes()</code>这行代码抛出了NullPointerException，提示<code>someValue</code>为<code>null</code>。怎么可能？<code>someKey</code>明明存在啊，却拿不到<code>someValue</code>？</p><p><code>m2</code>是通过<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/util/Collections.java#Collections.unmodifiableMap%28java.util.Map%29" target="_blank" rel="noopener">Collections.unmodifiableMap</a>方法得到的，它是一个不可变的map。<code>m2</code>本质上是共享<code>m1</code>的数据。代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; original = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">original.put(<span class="string">"a"</span>, <span class="string">"A"</span>);</span><br><span class="line">Map&lt;String, String&gt; unmodifiable = Collections.unmodifiableMap(original);</span><br><span class="line"><span class="keyword">int</span> oldSize = unmodifiable.size();</span><br><span class="line">original.put(<span class="string">"b"</span>, <span class="string">"B"</span>);</span><br><span class="line"><span class="keyword">int</span> newSize = unmodifiable.size();</span><br><span class="line"><span class="comment">// old size=1, new size=2</span></span><br><span class="line"><span class="comment">// 向original中添加数据, unmodifiable中的数据也跟着变化</span></span><br><span class="line"><span class="comment">// unmodifiable共享original的数据</span></span><br><span class="line">System.out.println(<span class="string">"old size="</span> + oldSize + <span class="string">", new size="</span> + newSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Collections.unmodifiableMap()为原始数据提供了一个不可变的视角</span></span><br><span class="line"><span class="comment">// 下面这一行抛出 UnsupportedOperationException</span></span><br><span class="line"><span class="comment">// unmodifiable.put("b", "B");</span></span><br></pre></td></tr></table></figure><p>稍加分析就能明白，上图中多线程并发访问<code>HashMap</code>，读写操作序列是不确定的。按以下中这种读写序列执行时，线程A中会出现”someKey”存在，但拿不到”someValue”的奇怪现象，最终引起NullPointerException。</p><p><img src="thread.png" alt></p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>如何避免线程B出现NullPointerException呢？修复方案很简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">net</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String someValue = m2.get(<span class="string">"someKey"</span>);</span><br><span class="line"><span class="keyword">if</span> (someValue == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span>[] data = someValue.getBytes();</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的代码的确避免了NPE。这里给出测试代码，<code>npe()</code>是修复前的代码，<code>noNpe()</code>是修复后的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"uid"</span>, <span class="string">"cm"</span>);</span><br><span class="line"></span><br><span class="line">        AppMap appMap = AppMap.getInstance();</span><br><span class="line">        appMap.update(map);</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                        map.put(<span class="string">"uid"</span>, <span class="string">"cm"</span> + <span class="keyword">new</span> Random().nextInt());</span><br><span class="line">                        appMap.update(map);</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        loop++;</span><br><span class="line">                        Map&lt;String, String&gt; unmodifiable = appMap.snapshot();</span><br><span class="line">                        npe(unmodifiable);</span><br><span class="line">                        <span class="comment">// noNpe(unmodifiable);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">                    System.err.println(<span class="string">"NPE occurred after "</span> + (System.currentTimeMillis() - now) + <span class="string">"ms, "</span> + loop + <span class="string">" loops"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">npe</span><span class="params">(Map&lt;String, String&gt; unmodifiable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (unmodifiable.containsKey(<span class="string">"uid"</span>)) &#123;</span><br><span class="line">            String value = unmodifiable.get(<span class="string">"uid"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] data = value.getBytes();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">noNpe</span><span class="params">(Map&lt;String, String&gt; unmodifiable)</span> </span>&#123;</span><br><span class="line">        String value = unmodifiable.get(<span class="string">"uid"</span>);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = value.getBytes();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行修复前后的代码发现，<code>npe()</code>会输出如下<code>NPE occurred after 327ms, 4415532 loops</code>(具体数据可能有所不同)，而<code>noNpe()</code>不会输出该日志。证有修复方法是有效的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dzone.com/articles/concurrency-and-hashmap" target="_blank" rel="noopener">Concurrency and HashMap</a><br><a href="http://javabypatel.blogspot.in/2016/01/infinite-loop-in-hashmap.html" target="_blank" rel="noopener">Infinite loop in HashMap | JavaByPatel</a><br><a href="https://stackoverflow.com/questions/11050539/using-hashmap-in-multithreaded-environment" target="_blank" rel="noopener">java - Using HashMap in multithreaded environment - Stack Overflow</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gradle学习笔记</title>
      <link href="2018/03/20/gradle-groovy-note/"/>
      <url>2018/03/20/gradle-groovy-note/</url>
      
        <content type="html"><![CDATA[<p>Gradle学习笔记，记录一些零散的知识点。<br><a id="more"></a></p><p>总结如下：</p><ul><li>project实例跟<code>build.gradle</code>是一一对应的</li><li>settings实例跟<code>settings.gradle</code>是一一对应的</li><li>project是由一系列task组成的</li><li>task是由一系列action组成的</li><li>task之间可能有依赖关系和顺序关系</li><li>所有的脚本都实现了<code>Script</code>接口</li><li>build script的代理对象是<code>project</code></li><li>initialization script的代理对象是<code>gradle</code></li></ul><h1 id="Project"><a href="#Project" class="headerlink" title="Project"></a><a href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.api.Project.html#org.gradle.api.Project:configurations(groovy.lang.Closure)" target="_blank" rel="noopener">Project</a></h1><blockquote><p>There is a one-to-one relationship between a Project and a build.gradle file.  A project is essentially a collection of Task objects.</p></blockquote><p>project实例跟<code>build.gradle</code>是一一对应的，使用build.gradle对相应的Project实例进行配置。<br>project是由一系列task组成的。</p><h2 id="project的依赖"><a href="#project的依赖" class="headerlink" title="project的依赖"></a>project的依赖</h2><ul><li>依赖管理</li><li>配置管理</li><li>artifact管理</li><li>仓库管理</li></ul><p><img src="project-dependency.png" alt></p><h2 id="project的层级"><a href="#project的层级" class="headerlink" title="project的层级"></a>project的层级</h2><blockquote><p>Projects are arranged into a hierarchy of projects. A project has a name, and a fully qualified path which uniquely identifies it in the hierarchy.</p></blockquote><p><img src="project-hierarchy.png" alt></p><p>这个项目的project hierarchy如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  demo ./gradlew  projects -q</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Root project &apos;demo&apos;</span><br><span class="line">+--- Project &apos;:sub1&apos;</span><br><span class="line">\--- Project &apos;:sub2&apos;</span><br></pre></td></tr></table></figure><h2 id="project的属性和方法"><a href="#project的属性和方法" class="headerlink" title="project的属性和方法"></a>project的属性和方法</h2><blockquote><p>A project has 5 property ‘scopes’, which it searches for properties. </p></blockquote><p>project的动态属性有5种不同的scope</p><p><img src="project-property.png" alt></p><blockquote><p>A project has 5 method ‘scopes’, which it searches for methods</p></blockquote><p>project的动态method有5种不同的scope</p><p><img src="project-method.png" alt></p><p>Ext属性</p><blockquote><p>All extra properties must be created through the “ext” namespace</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project.ext.prop1 = <span class="string">'test'</span></span><br></pre></td></tr></table></figure><h1 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a><a href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.api.initialization.Settings.html" target="_blank" rel="noopener">Settings</a></h1><blockquote><p>There is a one-to-one correspondence between a Settings instance and a settings.gradle settings file. </p></blockquote><p>settings实例跟<code>settings.gradle</code>是一一对应的，使用settings.gradle对相应的Settings实例进行配置<br>使用<code>Settings.include()</code>方法指定需要构建的project</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">':sub1'</span>, <span class="string">':sub2'</span></span><br></pre></td></tr></table></figure><h1 id="Script"><a href="#Script" class="headerlink" title="Script"></a><a href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.api.Script.html" target="_blank" rel="noopener">Script</a></h1><blockquote><p>Generally, a Script object will have a delegate object attached to it </p></blockquote><p>编译后的脚本对应的类都实现了<code>Script</code>接口。这个接口定义了Gradle特定的方法，可以直接在脚本中使用这些方法。</p><p><code>Script</code>实例都带有一个代理对象。比如build script有<code>project</code>代理对象，而initialization script有<code>gradle</code>代理对象。</p><p><code>apply</code>和<code>buildscript</code>这两个我们经常使用的方法其实是来自<code>Script</code>接口。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">buildscript &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Task"><a href="#Task" class="headerlink" title="Task"></a><a href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.api.Task.html" target="_blank" rel="noopener">Task</a></h1><blockquote><p>A Task represents a single atomic piece of work for a build. Each task belongs to a Project. A Task is made up of a sequence of Action objects. </p></blockquote><p>task可能对其他task有依赖，并且对执行顺序有要求<br>task是由一系列action组成的</p><h1 id="理解Gradle文档"><a href="#理解Gradle文档" class="headerlink" title="理解Gradle文档"></a>理解Gradle文档</h1><p>Gradle的文档结构跟JDK的文档稍稍有所不同。JDK文档中通常只包括<code>Properties</code>和<code>Methods</code>，而Gradle文档还列出了一些特有的部分，具体如下：</p><ul><li>Dynamic Properties - 动态属性， 这里的属性可能是插件添加进来的</li><li>Dynamic Methods - 动态方法，这里的方法可能是插件添加进来的</li><li>Properties</li><li>Methods</li><li>Script blocks - 闭包</li></ul><p>另外Gradle的类和接口可以划分成以下四大类：</p><ul><li>Build script blocks</li><li>Core types</li><li>Container types</li><li>Task types</li></ul><h1 id="理解Groovy代理"><a href="#理解Groovy代理" class="headerlink" title="理解Groovy代理"></a>理解Groovy代理</h1><p>TODO</p><!--# 思考Gradle官方文档中提到> Dynamic properties will eventually be removed entirely, meaning that this will be a fatal error in future versions of Gradle. See Extra Properties to learn how to add properties dynamically.文档中的意思是未来将完全去掉project的动态属性？个人也感觉动态属性非常复杂，可能引起很多问题。-->]]></content>
      
      
      
        <tags>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解Groovy闭包委托</title>
      <link href="2018/03/08/gradle-groovy-closure/"/>
      <url>2018/03/08/gradle-groovy-closure/</url>
      
        <content type="html"><![CDATA[<p>[TODO]<br><a id="more"></a><br><a href="https://github.com/groovy/groovy-core/blob/master/src/main/groovy/lang/Closure.java#L97" target="_blank" rel="noopener">Closure</a>代码</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="thisObject-owner-delegate"><a href="#thisObject-owner-delegate" class="headerlink" title="thisObject, owner, delegate"></a>thisObject, owner, delegate</h1><p>Closure有三个属性，分别是 thisObject, owner, delegate。通常delegate被设置为owner。  <a href="https://stackoverflow.com/questions/8120949/what-does-delegate-mean-in-groovy" target="_blank" rel="noopener">来源</a></p><p>Idea的Groovy Console中运行代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> testClosure(closure) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line">testClosure() &#123;</span><br><span class="line">    println <span class="string">"this is "</span> + thisObject + <span class="string">", super:"</span> + <span class="keyword">this</span>.getClass().superclass.name</span><br><span class="line">    println <span class="string">"owner is "</span> + owner + <span class="string">", super:"</span> + owner.getClass().superclass.name</span><br><span class="line">    println <span class="string">"delegate is "</span> + delegate + <span class="string">", super:"</span> + delegate.getClass().superclass.name</span><br><span class="line"></span><br><span class="line">    testClosure() &#123;</span><br><span class="line">        println <span class="string">"this is "</span> + thisObject + <span class="string">", super:"</span> + <span class="keyword">this</span>.getClass().superclass.name</span><br><span class="line">        println <span class="string">"owner is "</span> + owner + <span class="string">", super:"</span> + owner.getClass().superclass.name</span><br><span class="line">        println <span class="string">"delegate is "</span> + delegate + <span class="string">", super:"</span> + delegate.getClass().superclass.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this is ideaGroovyConsole@710636b0, super:groovy.lang.Script</span><br><span class="line">owner is ideaGroovyConsole@710636b0, super:groovy.lang.Script</span><br><span class="line">delegate is ideaGroovyConsole@710636b0, super:groovy.lang.Script</span><br><span class="line">this is ideaGroovyConsole@710636b0, super:groovy.lang.Script</span><br><span class="line">owner is ideaGroovyConsole$_run_closure1@4e5ed836, super:groovy.lang.Closure</span><br><span class="line">delegate is ideaGroovyConsole$_run_closure1@4e5ed836, super:groovy.lang.Closure</span><br></pre></td></tr></table></figure><h1 id="resolveStrategy"><a href="#resolveStrategy" class="headerlink" title="resolveStrategy"></a>resolveStrategy</h1><h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gradle之Groovy基础</title>
      <link href="2018/03/08/gradle-groovy-basic/"/>
      <url>2018/03/08/gradle-groovy-basic/</url>
      
        <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/sbsujjbcy/article/details/52079413" target="_blank" rel="noopener">Gradle系列之从init.gradle说起 - CSDN博客</a><br><a href="http://www.flysnow.org/categories/Android/" target="_blank" rel="noopener">Android | 飞雪无情的博客</a><br><a href="http://km.oa.com/group/22112/articles/show/332186?kmref=search&amp;from_page=1&amp;no=6" target="_blank" rel="noopener">Gradle完全解析 - Android 同学会 - KM平台</a></p><p>Gradle脚本对Java程序员来说非常简单易懂，我们甚至可以直接在Gradle脚本中写Groovy代码甚至Java代码。但不了解Groovy和Gradle DSL的话，你会发现Gradle脚本其实地方让人很疑惑。<br><a id="more"></a></p><h1 id="关于Gradle脚本的疑问"><a href="#关于Gradle脚本的疑问" class="headerlink" title="关于Gradle脚本的疑问"></a>关于Gradle脚本的疑问</h1><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">26</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.example.kingcmchen.myapplication"</span></span><br><span class="line">        minSdkVersion <span class="number">15</span></span><br><span class="line">        targetSdkVersion <span class="number">26</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">        vectorDrawables.useSupportLibrary = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="string">dir:</span> <span class="string">'libs'</span>, <span class="string">include:</span> [<span class="string">'*.jar'</span>])</span><br><span class="line">    implementation <span class="string">'com.android.support:appcompat-v7:26.1.0'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task someTask &lt;&lt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个典型的Gradle脚本。就这个脚本而言，我有两个疑问：</p><ul><li>第一，<code>apply plugin: &#39;com.android.application&#39;</code>的语法形式怪怪的，这里有个”:”。Gradle脚本中什么时候会出现”:”，什么时候又不需要”:”？</li><li>第二，<code>defaultConfig {}</code>中<code>minSdkVersion 15</code>和<code>vectorDrawables.useSupportLibrary = true</code>的语法形式并不一致。Gradle脚本中什么时候会出现”=”，什么时候又不需要”=”？</li></ul><p>要清楚地答这两个问题，需要从Groovy语言和Gradle DSL入手。</p><h1 id="Groovy基础"><a href="#Groovy基础" class="headerlink" title="Groovy基础"></a>Groovy基础</h1><p>掌握Gradle需要了解的Groovy基础知识如下：</p><p><img src="groovy-basic.png" alt></p><p><a href="http://www.flysnow.org/2016/05/22/groovy-basis.html" target="_blank" rel="noopener">Groovy基础</a>一文对Groovy有一个非常简明的介绍，我画了一张图对其内容进行总结。</p><p>下面结合上图以及我的问题，有针对性的了解一些Groovy基础内容，包括</p><ul><li>Groovy的GString</li><li></li></ul><h2 id="String与GString"><a href="#String与GString" class="headerlink" title="String与GString"></a>String与GString</h2><p>GString给我们提供了强大的格式化能力。有了GString，完全可以避免使用Java的<code>String.format()</code>来格式化输出。看看示例。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> version = <span class="number">2.4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Java String, 单引号中的是普通字符串</span></span><br><span class="line"><span class="keyword">def</span> javaString = <span class="string">'Java'</span></span><br><span class="line"><span class="keyword">def</span> javaString2 = <span class="string">'Java $version'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Groovy String, 双引号中且有未被转义的$的是GString, 允许使用占位符</span></span><br><span class="line"><span class="keyword">def</span> groovyString = <span class="string">"Groovy v$version"</span></span><br><span class="line"><span class="comment">// Java String, 双引号中、有被转义的$是普通字符串</span></span><br><span class="line"><span class="keyword">def</span> nonGroovyString = <span class="string">"Groovy v\$version"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output: Java class java.lang.String</span></span><br><span class="line">println javaString + <span class="string">' '</span> + javaString.getClass().toString()</span><br><span class="line"><span class="comment">// output: Java $version class java.lang.String</span></span><br><span class="line">println javaString2 + <span class="string">' '</span> + javaString2.getClass().toString()</span><br><span class="line"><span class="comment">// output: Groovy v2.4 class org.codehaus.groovy.runtime.GStringImpl</span></span><br><span class="line">println groovyString + <span class="string">' '</span> + groovyString.getClass().toString()</span><br><span class="line"><span class="comment">// output: Groovy v$version class java.lang.String</span></span><br><span class="line">println nonGroovyString + <span class="string">' '</span> + nonGroovyString.getClass().toString()</span><br></pre></td></tr></table></figure><p>通过以上例子不难明白普通字符串与GString的区别。现在不妨看看<a href="https://github.com/square/leakcanary/blob/master/leakcanary-android/build.gradle" target="_blank" rel="noopener">这段Gradle脚本</a>中<code>buildConfigField</code>这一行，考查下自己是否掌握GString的用法。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.library'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> gitSha() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'git rev-parse --short HEAD'</span>.execute().text.trim()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  defaultConfig &#123;</span><br><span class="line">    minSdkVersion versions.minSdk</span><br><span class="line">...</span><br><span class="line">    buildConfigField <span class="string">"String"</span>, <span class="string">"GIT_SHA"</span>, <span class="string">"\"$&#123;gitSha()&#125;\""</span></span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析如下：</p><ul><li>首先，这个字符串是双引号且有未被转义的$</li><li>其次，${gitSha()}将调用<code>gitSha()</code>方法并将其结果作为字符串的值。<code>{}</code>中可以是任意合法的groovy表达式</li></ul><h2 id="Groovy方法"><a href="#Groovy方法" class="headerlink" title="Groovy方法"></a>Groovy方法</h2><p>调用Groovy方法时可以省略括号，并且Groovy方法支持命名参数。</p><h3 id="省略括号"><a href="#省略括号" class="headerlink" title="省略括号"></a>省略括号</h3><p>省略括号可以让代码更简短，比如<code>output()</code>方法：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> output(a) &#123;</span><br><span class="line">    println a</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完整写法 Output: 1</span></span><br><span class="line">output(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 省略括号的写法 Output: 1</span></span><br><span class="line">output <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果方法有两个或两个以上的参数呢？</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> add(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完整写法</span></span><br><span class="line">sum = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 省略括号的写法</span></span><br><span class="line">sum2 = add <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">assert</span> sum == sum2</span><br></pre></td></tr></table></figure><p> 注意：<code>add 1,2</code>的确是<code>add(1,2)</code>省略括号的写法， <code>1,2</code>表示两个整形参数， 而不是一个包含两个整数的列表或数组，或别的什么东西。</p><h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><p>Groovy方法支持命名参数。当然，跟Python中的命名参数不同，Groovy命名参数并不是真正意义上的命名参数。实际上，Groovy仅仅是在让方法的map参数的key可以在方法中直接使用而已(以map.key这种方式来访问参数)。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> add(map) &#123;</span><br><span class="line">    <span class="comment">// 为所有参数设置默认值</span></span><br><span class="line">    [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].each &#123; map.get(it, <span class="number">0</span>)&#125;</span><br><span class="line">    println <span class="string">"a = $map.a, b = $map.b"</span></span><br><span class="line">    <span class="keyword">return</span> map.a + map.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: a = 1, b = 2</span></span><br><span class="line">add(<span class="string">b:</span><span class="number">2</span>, <span class="string">a:</span><span class="number">1</span>)</span><br><span class="line"><span class="comment">// Output: a = 1, b = 2</span></span><br><span class="line">add(<span class="string">a:</span><span class="number">1</span>, <span class="string">b:</span><span class="number">2</span>)</span><br><span class="line"><span class="comment">// Output: a = 1, b = 0</span></span><br><span class="line">add(<span class="string">a:</span><span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略括号的写法</span></span><br><span class="line">add <span class="string">a:</span><span class="number">1</span>, <span class="string">b:</span><span class="number">2</span></span><br><span class="line">add <span class="string">a:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="Groovy集合"><a href="#Groovy集合" class="headerlink" title="Groovy集合"></a>Groovy集合</h2><p>集合不是我们关注重点，这里只简单提一下。字面量形式的list和map使用非常方便。另外list和map均提供each()方法用于便捷访问。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">println list[<span class="number">0</span>]</span><br><span class="line">list.each &#123; println it &#125;</span><br><span class="line"></span><br><span class="line">[<span class="string">'w'</span>:<span class="number">1024</span>, <span class="string">'h'</span>:<span class="number">768</span>].each &#123;</span><br><span class="line">    println <span class="string">"$it.key $it.value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Groovy闭包"><a href="#Groovy闭包" class="headerlink" title="Groovy闭包"></a>Groovy闭包</h2><p>为方便对上述第二个问题展开讨论，我们必须Groovy闭包。闭包是Groovy最强大的特性。</p><h3 id="闭包介绍"><a href="#闭包介绍" class="headerlink" title="闭包介绍"></a>闭包介绍</h3><p>什么是闭包呢？简单来讲，Groovy的闭包可以理解为”代码块”，它本质也是一个对象，所以也可以被引用、被传递以及被执行。(可以类比C中的函数指针以及Java 8的方法引用）Groovy中，”代码块”对象具体来说是<a href="http://docs.groovy-lang.org/latest/html/api/groovy/lang/Closure.html" target="_blank" rel="noopener">Closure</a>的对象。</p><p>为什么需要闭包呢？我们经常遇到单方法接口，比如Java中的<code>FileFilter</code>或Android中的<code>OnClickListener</code>，前者只定义了一个方法<code>accept(File)</code>，后者只定义了一个方法<code>onClick(View)</code>。这种代码组织方式对于单方法接口非常繁琐，我们不得不为一些很简单的操作定义类，导致类数量膨胀。闭包能在一定程度上解决这个问题。</p><p>还是上代码，看代码可能会更直观地了解闭包。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> accept(Integer integer) &#123;</span><br><span class="line">        println <span class="string">"for each "</span> + integer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].each &#123; println <span class="string">"each "</span> + it &#125;</span><br></pre></td></tr></table></figure><p>代码的功能是逐个打印列表中的元素。分别使用单方法接口的方式和闭包的方式来完成功能。显而易见后一个方法更可读，尤其当你习惯这种写法之后。该语句的各个元素如下：</p><p><img src="what-is-closure.png" alt></p><p><code>each()</code>方法接收一个闭包(<a href="http://docs.groovy-lang.org/latest/html/api/groovy/lang/Closure.html" target="_blank" rel="noopener">Closure</a>)作为参数。<a href="http://docs.groovy-lang.org/latest/html/api/groovy/lang/Closure.html" target="_blank" rel="noopener">Closure</a>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Closure表示Groovy中的闭包对象，它是一个普通的Java类。Groovy允许Closure以如下形式被调用：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> c = &#123; a &#125;</span><br><span class="line"><span class="keyword">assert</span> c() == <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> c.call() == <span class="number">1</span></span><br></pre></td></tr></table></figure><p>简单来说，一个闭包是被包装为一个对象的代码块。下面的代码</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">log = <span class="string">''</span></span><br><span class="line"><span class="comment">// 使用赋值的方式声明闭包</span></span><br><span class="line">Closure c = &#123; counter -&gt; log += counter&#125;</span><br><span class="line">(<span class="number">1.</span><span class="number">.10</span>).each(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接声明闭包</span></span><br><span class="line">(<span class="number">1.</span><span class="number">.10</span>).each(&#123; counter -&gt; log += counter &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包的缩写定义，省略了方法调用时的括号</span></span><br><span class="line">(<span class="number">1.</span><span class="number">.10</span>).each &#123; counter -&gt; log += counter&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包的缩写定义，使用隐式参数it</span></span><br><span class="line">(<span class="number">1.</span><span class="number">.10</span>).each &#123; log += it &#125;</span><br></pre></td></tr></table></figure><h3 id="闭包委托"><a href="#闭包委托" class="headerlink" title="闭包委托"></a>闭包委托</h3><blockquote><p>Groovy闭包的强大之处在于它支持闭包方法的委托。Groovy的闭包有thisObject、owner、delegate三个属性，当你在闭包内调用方法时，由他们来确定使用哪个对象来处理。默认情况下delegate和owner是相等的，但是delegate是可以被修改的，这个功能是非常强大的，Gradle中的很闭包的很多功能都是通过修改delegate实现的 <a href="http://www.flysnow.org/2016/05/22/groovy-basis.html" target="_blank" rel="noopener">来源</a></p></blockquote><p>更多内容见<a href="/2018/03/08/gradle-groovy-closure/" title="理解Groovy闭包委托">理解Groovy闭包委托</a></p><p>了解闭包之后再来看本文开头出现的Gradle脚本，这里只选取关键部分</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">26</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion <span class="number">15</span></span><br><span class="line">        vectorDrawables.useSupportLibrary = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析如下</p><ul><li><code>android {}</code>其实是一个方法调用，方法形式为<code>android(Closure)</code> (还记得方法括号可省略，方法最后一个参数如果是闭包，闭包可以放到括号外面的规则吗？)</li><li><code>minSdkVersion 26</code>也是一个方法调用，方法形式为<code>minSdkVersion(int)</code>，所以它的完整形式其实是<code>minSdkVersion(26)</code> (仍然是方法括号可省略的规则)</li><li><code>vectorDrawables.useSupportLibrary = true</code>是对属性赋值</li></ul><p>不难使用闭包委托实现自己的DSL。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> android(Closure&lt;Android&gt; closure) &#123;</span><br><span class="line">    Android a = <span class="keyword">new</span> Android()</span><br><span class="line">    closure.delegate = a</span><br><span class="line">    <span class="comment">//委托模式优先</span></span><br><span class="line">    closure.setResolveStrategy(Closure.DELEGATE_FIRST)</span><br><span class="line">    closure(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Android</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> compileSdkVersion(sdkVersion) &#123;</span><br><span class="line">        println <span class="string">"in compileSdkVersion(). compileSdkVersion=$sdkVersion"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> defaultConfig(Closure&lt;Config&gt; closure) &#123;</span><br><span class="line">        Config c = <span class="keyword">new</span> Config()</span><br><span class="line">        closure.delegate = c</span><br><span class="line">        <span class="comment">//委托模式优先</span></span><br><span class="line">        closure.setResolveStrategy(Closure.DELEGATE_FIRST)</span><br><span class="line">        closure(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> &#123;</span></span><br><span class="line">    VD vectorDrawables = <span class="keyword">new</span> VD()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> minSdkVersion(sdkVersion) &#123;</span><br><span class="line">        println <span class="string">"in minSdkVersion(). minSdkVersion=$sdkVersion"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">VD</span> &#123;</span></span><br><span class="line">    <span class="keyword">boolean</span> useSupportLibrary</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己实现的DSL</span></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// in compileSdkVersion(). compileSdkVersion=26</span></span><br><span class="line"><span class="comment">// in minSdkVersion(). minSdkVersion=15</span></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">26</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        vectorDrawables.useSupportLibrary = <span class="literal">true</span></span><br><span class="line">        minSdkVersion <span class="number">15</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上述DSL的完整形式是这样的</span></span><br><span class="line"><span class="comment">//android(&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    a.compileSdkVersion(26)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    a.defaultConfig(&#123;</span></span><br><span class="line"><span class="comment">//        c.minSdkVersion(15)</span></span><br><span class="line"><span class="comment">//        c.vectorDrawables.put('useSupportLibrary', true)</span></span><br><span class="line"><span class="comment">//    &#125;)</span></span><br><span class="line"><span class="comment">//&#125;)</span></span><br></pre></td></tr></table></figure><p>至此你应该明白为什么<code>defaultConfig {}</code>中<code>minSdkVersion 15</code>和<code>vectorDrawables.useSupportLibrary = true</code>，一个有”=”一个没有”=”了吧。</p><h1 id="Gradle解惑"><a href="#Gradle解惑" class="headerlink" title="Gradle解惑"></a>Gradle解惑</h1><p>上面代码中的<code>add a: 100</code>不仅不会怪怪的，还很眼熟，对吧。嗯，<code>apply plugin: &#39;com.android.library&#39;</code>就是这么来的。当然<code>apply()</code>方法远比我们这里的<code>add()</code>方法要复杂，<code>apply()</code>方法的完整形式是<a href="https://docs.gradle.org/current/dsl/org.gradle.api.plugins.PluginAware.html#org.gradle.api.plugins.PluginAware:apply(java.util.Map" target="_blank" rel="noopener"><code>Project.apply(map)</code></a>)。这里不展开说明，后面的文章中我会详细讨论。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回头来看Groovy中关于方法的一些规则其实是有意为之，这些小规则再加上Groovy的闭包委托功能，可以非常方便地实现Gradle DSL。要点总结如下：</p><ul><li>闭包的委托优先模式</li><li>方法调用可以省略括号；方法的最后一个参数是闭包，则闭包可以放在括号外面</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.flysnow.org/categories/Android/" target="_blank" rel="noopener">Android | 飞雪无情的博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何发布自己的Java库</title>
      <link href="2018/02/08/how-to-publish-your-lib/"/>
      <url>2018/02/08/how-to-publish-your-lib/</url>
      
        <content type="html"><![CDATA[<p>使用Gradle构建工具非常方便，我们可以快速地添加第三方库依赖。那么如何发布自己的库？</p><a id="more"></a><p>实际项目中又分成两种情况。一种是将自己的库发布到第三方搭建的Maven库(比如公司内部Maven库)，另一种情况是发布到官网(比如jCenter)。下面分别讨论。</p><h1 id="发布到第三方库"><a href="#发布到第三方库" class="headerlink" title="发布到第三方库"></a>发布到第三方库</h1><p>这里以发布到我们公司内部的Maven库为例，发布到其他第三方Maven库应该类似。</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="使用maven-publish插件发布"><a href="#使用maven-publish插件发布" class="headerlink" title="使用maven-publish插件发布"></a>使用maven-publish插件发布</h3><p>在待发布的module的<code>build.gradle</code>中添加配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 添加maven-publish plugin</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'maven-publish'</span></span><br><span class="line"></span><br><span class="line">publishing &#123;</span><br><span class="line">    publications &#123;</span><br><span class="line">        <span class="comment">// 2. 指定要发布的内容</span></span><br><span class="line">        mavenJava(MavenPublication) &#123;</span><br><span class="line">            from components.java</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            <span class="comment">// 3. 指定Maven库的用户名密码</span></span><br><span class="line">            credentials &#123;</span><br><span class="line">                username <span class="string">"$mavenUser"</span></span><br><span class="line">                password <span class="string">"$mavenPassword"</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// change to point to your repo, e.g. http://my.org/repo</span></span><br><span class="line">            url &#123;</span><br><span class="line">                <span class="comment">// 4. 指定Maven库的地址 你甚至可以在这里指定为本地文件 "$buildDir/repo"</span></span><br><span class="line">                <span class="string">"http://my.org/repo"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第3点，<a href="https://docs.gradle.org/current/userguide/publishing_maven.html" target="_blank" rel="noopener">参考</a> <a href="https://stackoverflow.com/questions/12749225/where-to-put-gradle-configuration-i-e-credentials-that-should-not-be-committe" target="_blank" rel="noopener">参考</a></li><li>第4点，<a href="http://km.oa.com/group/29073/articles/show/299976" target="_blank" rel="noopener">参考</a></li></ul><p>配好之后运行<code>gradle publish</code>即可将生成的内容上传到指定的Maven库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gradlew publish</span><br><span class="line">Parallel execution is an incubating feature.</span><br><span class="line"></span><br><span class="line">Upload http://my.org/repo/com/test/viky-test/1.0-SNAPSHOT/viky-test-1.0-20180206.111742-6.jar</span><br><span class="line">Upload http://my.org/repo/com/test/viky-test/1.0-SNAPSHOT/viky-test-1.0-20180206.111742-6.jar.sha1</span><br><span class="line">Upload http://my.org/repo/com/test/viky-test/1.0-SNAPSHOT/viky-test-1.0-20180206.111742-6.jar.md5</span><br><span class="line">Upload http://my.org/repo/com/test/viky-test/1.0-SNAPSHOT/viky-test-1.0-20180206.111742-6.pom</span><br><span class="line">Upload http://my.org/repo/com/test/viky-test/1.0-SNAPSHOT/viky-test-1.0-20180206.111742-6.pom.sha1</span><br><span class="line">Upload http://my.org/repo/com/test/viky-test/1.0-SNAPSHOT/viky-test-1.0-20180206.111742-6.pom.md5</span><br><span class="line">Upload http://my.org/repo/com/test/viky-test/1.0-SNAPSHOT/maven-metadata.xml</span><br><span class="line">Upload http://my.org/repo/com/test/viky-test/1.0-SNAPSHOT/maven-metadata.xml.sha1</span><br><span class="line">Upload http://my.org/repo/com/test/viky-test/1.0-SNAPSHOT/maven-metadata.xml.md5</span><br><span class="line">Upload http://my.org/repo/com/test/viky-test/maven-metadata.xml</span><br><span class="line">Upload http://my.org/repo/com/test/viky-test/maven-metadata.xml.sha1</span><br><span class="line">Upload http://my.org/repo/com/test/viky-test/maven-metadata.xml.md5</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 3s</span><br><span class="line">4 actionable tasks: 4 executed</span><br></pre></td></tr></table></figure><p>注意：不要忘记在<code>gradle.properties</code>中配置Maven库的用户名密码:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mavenUser=your_username</span><br><span class="line">mavenPassword=your_password</span><br></pre></td></tr></table></figure><p>否则可能出现类似下面这样的未授权问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &apos;:publishMavenJavaPublicationToMavenRepository&apos;.</span><br><span class="line">&gt; Failed to publish publication &apos;mavenJava&apos; to repository &apos;maven&apos;</span><br><span class="line">   &gt; Could not write to resource &apos;http://my.org/repo/com/test/viky-test/1.0-SNAPSHOT/viky-test-1.0-20180206.093919-5.jar&apos;.</span><br><span class="line">      &gt; Could not PUT &apos;http://my.org/repo/com/test/viky-test/1.0-SNAPSHOT/viky-test-1.0-20180206.093919-5.jar&apos;. Received status code 401 from server: Unauthorized</span><br></pre></td></tr></table></figure><h3 id="使用maven插件发布"><a href="#使用maven插件发布" class="headerlink" title="使用maven插件发布"></a>使用maven插件发布</h3><p>也可以直接使用maven插件而不是maven-publish插件。maven插件配置起来可能相对更简单。</p><p>首先在module的<code>build.gradle</code>中添加maven plugin。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'maven-publish'</span></span><br></pre></td></tr></table></figure><p>然后在<code>build.gradle</code>中添加一个新的task<code>uploadArchives</code>。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(<span class="string">url:</span> <span class="string">'http://my.org/repo'</span>)&#123;</span><br><span class="line">                authentication(<span class="string">userName:</span> <span class="string">'your_username'</span>, <span class="string">password:</span> <span class="string">'your_password'</span>)</span><br><span class="line">                pom.groupId = <span class="string">'com.yourcompany.yourpackage'</span></span><br><span class="line">                pom.artifactId = <span class="string">'yourart'</span></span><br><span class="line">                pom.version = <span class="string">'1.0.0-SNAPSHOT'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>gradle uploadArchives</code>将生成的内容上传到指定的Maven库。</p><h2 id="使用自己发布的库"><a href="#使用自己发布的库" class="headerlink" title="使用自己发布的库"></a>使用自己发布的库</h2><p>在<code>repositories</code>中添加了Maven库地址后，我们就可以像使用第三方库一样引用自己发布的库了。</p><p>添加仓库：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            <span class="comment">// 注意, 这里的地址仅用于演示, 实际的下载地址可能跟上传时指定的地址有所不同</span></span><br><span class="line">            url <span class="string">"http://my.org/repo"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.yourcompany.yourpackage:yourart:1.0.0-SNAPSHOT&apos;</span><br></pre></td></tr></table></figure></p><h1 id="发布到jCenter"><a href="#发布到jCenter" class="headerlink" title="发布到jCenter"></a>发布到jCenter</h1><p>jCenter是由bintray.com维护的Maven仓库。</p><p><a href="http://www.devtf.cn/?p=760" target="_blank" rel="noopener">如何使用Android Studio把自己的Android library分发到jCenter和Maven Central | 开发技术前线</a>一文中有比较详情的描述，但是我按照文中提到的方法尝试很久仍然不能成功将自己的库发布到jCenter。所以建议直接使用<a href="https://github.com/bintray/bintray-examples" target="_blank" rel="noopener">bintray-plugin</a>提供的例子来实践，但操作前一定要把<a href="https://github.com/bintray/gradle-bintray-plugin#readme" target="_blank" rel="noopener">README</a>多看几遍，否则可能踩坑。</p><h2 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h2><p>首先下载<a href="https://github.com/bintray/bintray-examples/blob/master/gradle-aar-example/build.gradle" target="_blank" rel="noopener">bintray-examples</a>代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/bintray/bintray-examples.git</span><br></pre></td></tr></table></figure><p>注意，官方的例子更新并不及时。以examples中的<code>gradle-aar-example</code>为例，它使用的gradle版本是2.2.1，所以按照<a href="https://github.com/bintray/gradle-bintray-plugin#step-2-apply-the-plugin-to-your-gradle-build-script" target="_blank" rel="noopener">官网说明</a>我们应当将对<code>build.gradle</code>脚本的buildscript部分用到<code>bintray-plugin</code>的地方进行修改，否则后续操作可能失败。</p><p>修改前的代码<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:1.0.0'</span></span><br><span class="line">        classpath <span class="string">'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0'</span></span><br><span class="line">        classpath <span class="string">'com.github.dcendents:android-maven-plugin:1.2'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改后的代码<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:1.0.0'</span></span><br><span class="line">        classpath <span class="string">'com.github.dcendents:android-maven-plugin:1.2'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">"com.jfrog.bintray"</span> version <span class="string">"1.7.3"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="申请bintray账号"><a href="#申请bintray账号" class="headerlink" title="申请bintray账号"></a>申请bintray账号</h2><p>具体步骤在些略过，可以参考<a href="http://www.devtf.cn/?p=760" target="_blank" rel="noopener">如何使用Android Studio把自己的Android library分发到jCenter和Maven Central | 开发技术前线</a>第一部分。</p><p>我们会用到bintray的账号名以及API Key。可以在 Edit Profit 中找到 API Key：</p><p><img src="/images/1518062768362.webp" alt></p><h2 id="配置bintray插件"><a href="#配置bintray插件" class="headerlink" title="配置bintray插件"></a>配置bintray插件</h2><p>修改<code>build.gradle</code>中的<code>bintray</code>部分。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bintray &#123;</span><br><span class="line">    user = <span class="string">"chen410063005"</span></span><br><span class="line">    key = <span class="string">"**************"</span></span><br><span class="line"></span><br><span class="line">    configurations = [<span class="string">'archives'</span>] <span class="comment">//When uploading configuration files</span></span><br><span class="line">    pkg &#123;</span><br><span class="line">        repo = <span class="string">'tt'</span></span><br><span class="line">        name = <span class="string">'wee'</span></span><br><span class="line">        userOrg = <span class="string">'sunmoon'</span></span><br><span class="line">        desc = <span class="string">'Bintray aar publishing example'</span></span><br><span class="line">        websiteUrl = siteUrl</span><br><span class="line">        issueTrackerUrl = <span class="string">'https://github.com/bintray/bintray-examples/issues'</span></span><br><span class="line">        vcsUrl = gitUrl</span><br><span class="line">        licenses = [<span class="string">'Apache-2.0'</span>]</span><br><span class="line">        labels = [<span class="string">'aar'</span>, <span class="string">'android'</span>, <span class="string">'example'</span>]</span><br><span class="line">        publicDownloadNumbers = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>user - 你的bintray用户名</li><li>key - 你的API Key</li><li>repo - Repo name</li><li>name - Package name</li><li>userOrg - 你的bintray账号所属的组织</li></ul><p>以上几个字段需要跟你的bintray账号相对应。以我的账号为例，截图如下：</p><p><img src="/images/1518063073227.webp" alt></p><h2 id="发布-1"><a href="#发布-1" class="headerlink" title="发布"></a>发布</h2><p>配置无误后<code>gradle bintrayUpload</code>即可将aar文件上传到bintray</p><p><img src="/images/1518063238354.webp" alt></p><p>记得要在bintray中将新上传的文件状态修改为发布状态才能正常下载。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>添加仓库：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        url  <span class="string">"https://sunmoon.bintray.com/tt"</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加依赖：<br><code>compile &#39;com.bintray.example:gradle-aar-example:1.1&#39;</code></p><p>容易忘记如何添加仓库和添加依赖。不用担心，bintray网站中有详情的引导告诉我们如何操作，见这里的截图。</p><ul><li>添加仓库。点”set me up” -&gt; “Resolving artifacts using Gradle”</li></ul><p><img src="/images/1518063711773.webp" alt></p><ul><li>添加依赖。在”Maven build settings”中将Maven切换到Gradle<br><img src="/images/1518063762982.webp" alt></li></ul><p>这个进度条是不是很熟悉？<code>build.gradle</code>脚本变动后gradle正在下载我自己上传的库文件，说明我们可以从jCenter找到自己发布的库了！</p><p><img src="/images/1518064033209.webp" alt></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.devtf.cn/?p=760" target="_blank" rel="noopener">如何使用Android Studio把自己的Android library分发到jCenter和Maven Central | 开发技术前线</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeakCanary实战</title>
      <link href="2018/02/02/leakcanary-application/"/>
      <url>2018/02/02/leakcanary-application/</url>
      
        <content type="html"><![CDATA[<p>LeakCanary的傻瓜式配置在实际项目中其实是不够用的，本文讨论了如何对LeakCanary进行自定义配置以便更好应用。<br><a id="more"></a></p><p>如何使用LeakCanary呢？按照<a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">官网</a>说明简单配置即可。</p><p>在<code>build.gradle</code>中添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  debugCompile 'com.squareup.leakcanary:leakcanary-android:1.5.4'</span><br><span class="line">  releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.4'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Application</code>类中添加代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    <span class="keyword">if</span> (LeakCanary.isInAnalyzerProcess(<span class="keyword">this</span>)) &#123;</span><br><span class="line">      <span class="comment">// This process is dedicated to LeakCanary for heap analysis.</span></span><br><span class="line">      <span class="comment">// You should not init your app in this process.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LeakCanary.install(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// Normal app init code...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置好之后我们就可以检测内存泄漏了。非常好用，完全傻瓜式的。很快就找到了不少内存泄漏，得意地向小伙伴秀一下。</p><p>可以就此打住吗？可以啊，为什么不可以。(之前就是停留在这个层面，于是被问到LeakCanary原理时一脸懵逼)</p><p>有兴趣往下看的话，先问自己几个问题：</p><ul><li>为什么LeakCanary总是报Activity泄漏，Fragment不会泄漏吗? 其他对象不会泄漏吗？</li><li>LeakCanary工作时很耗资源容易导致应用卡顿，即使debug包也我们倾向于关闭它(也就是根本不使用)，有优化方案吗？</li><li>LeakCanary检查结果可以上报到后台吗？实际中往往有比内存泄漏优先级更高的任务要处理，我们最好能保存结果供后续分析</li></ul><p>上面问题的答案是Fragment也会泄漏，所有对象都可能泄漏。Activity和Fragment的生命周期非常明确，所以我们通常是检查它们存在内存泄漏。而其他对象，只要有明确的生命周期，也是可以检查是否有内存泄漏的。</p><p>具体如何做呢？对LeakCanary进行自定义配置即可。<a href="https://github.com/square/leakcanary/wiki/Customizing-LeakCanary" target="_blank" rel="noopener">官网</a>有提供方案，接下来我们尝试将这些方式整合到实际项目中。</p><p>注：本文关注LeakCanary的应用，所以略过了LeakCanary的很多细节。更多细节请参考<a href="https://github.com/square/leakcanary/wiki/" target="_blank" rel="noopener">LeakCanary wiki</a></p><p>注：本文中提供的方案参考整理自<a href="https://github.com/square/leakcanary/wiki/" target="_blank" rel="noopener">LeakCanary wiki</a>，我的工作是如何将这些方案整合并应用于实际工程项目。</p><h1 id="RefWatcher和HeapDumper"><a href="#RefWatcher和HeapDumper" class="headerlink" title="RefWatcher和HeapDumper"></a>RefWatcher和HeapDumper</h1><p>要实现LeakCanary开关功能，先要看看<a href="https://github.com/square/leakcanary/blob/master/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java" target="_blank" rel="noopener">RefWatcher</a>和<a href="https://github.com/square/leakcanary/blob/master/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java" target="_blank" rel="noopener">HeapDumper</a>。</p><p><a href="https://github.com/square/leakcanary/blob/master/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java" target="_blank" rel="noopener">RefWatcher</a>是LeakCanary的核心类。见名知义，它用于监视对象引用，当它发现某个弱引用指向的对象应当是只能由弱引用可达而事实并非如此，将触发<a href="https://github.com/square/leakcanary/blob/master/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java" target="_blank" rel="noopener">HeapDumper</a>开始工作。 (When the link RefWatcher detects that a reference might not be weakly reachable when it should, it triggers the HeapDumper 原文是这样的，我翻译得很绕口。简单点说就是某个对象应该是弱引用的，但由于某个强引用导致它不能回收，就出现我们所说的内存泄漏啦)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HeapDumper</span> </span>&#123;</span><br><span class="line">    HeapDumper NONE = <span class="keyword">new</span> HeapDumper() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> File <span class="title">dumpHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> RETRY_LATER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    File RETRY_LATER = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">File <span class="title">dumpHeap</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HeapDumper</code>接口仅有<code>dumpHeap()</code>方法，我们实现自己的 <strong>可开关</strong> HeapDumper 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TogglableHeapDumper</span> <span class="keyword">implements</span> <span class="title">HeapDumper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HeapDumper defaultDumper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TogglableHeapDumper</span><span class="params">(HeapDumper defaultDumper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultDumper = defaultDumper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toggle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        enabled = !enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> File <span class="title">dumpHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enabled? defaultDumper.dumpHeap() : HeapDumper.RETRY_LATER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后自定义<code>RefWatcher</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RefWatcher <span class="title">installLeakCanary</span><span class="params">(Context application)</span> </span>&#123;</span><br><span class="line">    LeakDirectoryProvider leakDirectoryProvider = <span class="keyword">new</span> DefaultLeakDirectoryProvider(application);</span><br><span class="line">    AndroidHeapDumper defaultDumper = <span class="keyword">new</span> AndroidHeapDumper(application, leakDirectoryProvider);</span><br><span class="line">    heapDumper = <span class="keyword">new</span> TogglableHeapDumper(defaultDumper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build a customized RefWatcher</span></span><br><span class="line">    <span class="keyword">return</span> LeakCanary.refWatcher(application)</span><br><span class="line">            .heapDumper(heapDumper)</span><br><span class="line">            .buildAndInstall();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App中添加开关入口控制<code>TogglableHeapDumper</code>的开启状态即可。</p><h2 id="buildType问题"><a href="#buildType问题" class="headerlink" title="buildType问题"></a>buildType问题</h2><p>Gradle打包时分不同的buildType，缺省包括<code>debug</code>和<code>release</code>。</p><p>实际工程中可能会遇到<code>release</code>包找不到LeakCanary中某些类而无法编译的问题。这是正常的，因为<code>release</code>包依赖的是<code>leakcanary-android-no-op</code>，<code>leakcanary-android-no-op</code>中只有<code>RefWatcher</code>和<code>LeakCanary</code>两个空类，并不包含那些可以用于自定义<code>RefWatcher</code>和<code>HeapDumper</code>的辅助类，所以我们需要通过gradle的build type特性解决这个问题。可以参考<a href="https://github.com/square/leakcanary/wiki/Customizing-LeakCanary#using-the-no-op-dependency" target="_blank" rel="noopener">官网</a>。本文提供基于同一思路采用如下方式实现。</p><p>注意到<code>build.gradle</code>中有这样几行注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        // Move the build types to build-types/&lt;type&gt;</span><br><span class="line">        // For instance, build-types/debug/java, build-types/debug/AndroidManifest.xml, ...</span><br><span class="line">        // This moves them out of them default location under src/&lt;type&gt;/... which would</span><br><span class="line">        // conflict with src/ being used by the main source set.</span><br><span class="line">        // Adding new build types or product flavors should be accompanied</span><br><span class="line">        // by a similar customization.</span><br><span class="line">        debug.setRoot(&apos;build-types/debug&apos;)</span><br><span class="line">        release.setRoot(&apos;build-types/release&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们为<code>debug</code>和<code>release</code>分别封装不同的<code>LeakCanaryWrapper</code>即可。</p><p><img src="/images/1517477051927.webp" alt></p><p>debug版本的<code>LeakCanaryWrapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakCanaryWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RefWatcher <span class="title">installLeakCanary</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Build a customized RefWatcher</span></span><br><span class="line">        RefWatcher refWatcher = LeakCanary.refWatcher(application)</span><br><span class="line">                .watchDelay(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">                .buildAndInstall();</span><br><span class="line">        <span class="keyword">return</span> refWatcher;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>release版本的<code>LeakCanaryWrapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakCanaryWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RefWatcher <span class="title">installLeakCanary</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RefWatcher.DISABLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码参考自<a href="https://github.com/square/leakcanary/wiki/Customizing-LeakCanary" target="_blank" rel="noopener">官网</a></p><h1 id="Fragment内存泄漏"><a href="#Fragment内存泄漏" class="headerlink" title="Fragment内存泄漏"></a>Fragment内存泄漏</h1><p>Fragment同样也会内存泄漏。为什么LeakCanary可以自动检测Activity的内存泄漏却没有自动检查Fragment内存泄漏？部分原因在于，Fragment跟Activity关联，如果Fragment出现泄漏，最终一定会导致Activity泄漏。所以某种程度上，我们只需要检测Activity的泄漏即可。</p><p>但如果想自动检查Fragment内存泄漏，该怎么做？我们先来看看LeakCanary是如何实现自动检测Activity的内存泄漏的。关键在于<a href="https://github.com/square/leakcanary/blob/master/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java#L80" target="_blank" rel="noopener"><code>ActivityRefWatcher.watchActivities()</code></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Application.ActivityLifecycleCallbacks lifecycleCallbacks =</span><br><span class="line">    <span class="keyword">new</span> Application.ActivityLifecycleCallbacks() &#123;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 这里代码有省略</span></span><br><span class="line">      </span><br><span class="line">   <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        ActivityRefWatcher.<span class="keyword">this</span>.onActivityDestroyed(activity);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchActivities</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure you don't get installed twice.</span></span><br><span class="line">  stopWatchingActivities();</span><br><span class="line">  application.registerActivityLifecycleCallbacks(lifecycleCallbacks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>watchActivities()</code>方法给<code>application</code>对象注册了一个用于监听Activity生命的回调接口，可以很方便地监听每一个Activity对象的<code>onDestroyed()</code>回调。这里有一个基本前提就是<code>onDestroyed()</code>回调后的Activity应该是可以GC回收掉的，如果没有，那一定是这个Activity发生泄漏了。</p><p>有没有类似<code>Application.registerActivityLifecycleCallbacks()</code>的方法可以用来实现自动检测Fragment的内存泄漏呢？答案是有的。</p><p><a href="https://developer.android.com/topic/libraries/support-library/rev-archive.html#25-2-0" target="_blank" rel="noopener">Support Library 25.2.0</a>中将<a href="https://developer.android.com/reference/android/support/v4/app/FragmentManager.FragmentLifecycleCallbacks.html" target="_blank" rel="noopener">FragmentManager.FragmentLifecycleCallbacks</a>修改成static类。从25.2.0版本开始，开发者很方便就能使用<code>FragmentLifecycleCallbacks</code>。它的用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> RefWatcher refWatcher = MyApplication.getRefWatcher(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// initialization code</span></span><br><span class="line">    getSupportFragmentManager()</span><br><span class="line">            .registerFragmentLifecycleCallbacks(<span class="keyword">new</span> FragmentLifecycleCallbacks() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFragmentDestroyed</span><span class="params">(FragmentManager fm, Fragment f)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.onFragmentDestroyed(fm, f);</span><br><span class="line">                    refWatcher.watch(f);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFragmentViewDestroyed</span><span class="params">(FragmentManager fm, Fragment f)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.onFragmentViewDestroyed(fm, f);</span><br><span class="line">                    refWatcher.watch(f.getView());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果提示<code>android.support.v4.app.Fragment is not an enclosing class</code>，请检查你的 SupportLibrary 版本是否低于25.2.0。</p><p><code>Fragment.onDestory()</code>和<code>Fragment.onDestoryView()</code>中分别如何检查内存泄漏可能容易让人混淆。<a href="https://github.com/square/leakcanary/issues/806" target="_blank" rel="noopener">issue 806</a>中提到正确的做法是在<code>onDestroy()</code>中检查<code>Fragment</code>这个对象是否有泄漏，在<code>onDestroyView()</code>中检查<code>Fragment.getView()</code>返回的对象是否有泄漏。</p><p>由于25.2.0及之后的SupportLibrary库才能方便地调用<code>FragmentManager.registerFragmentLifecycleCallbacks()</code>方法，兼容性不好，这应该是LeakCanary官方没有实现<code>FragmentRefWatcher</code>的另一个原因。我们如何检查Fragment是否内存泄漏呢？</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>一种容易想到的方法在<a href="https://github.com/square/leakcanary/wiki/FAQ#how-do-i-use-it" target="_blank" rel="noopener">官网</a>中有提到，即改造<code>BaseFragment</code>。这种方法的不足之处在于不能保证App中所有的Fragment都继承自<code>BaseFragment</code>。比方说，很可能<code>DialogFragment</code>或<code>BottomSheetDialogFragment</code>更好用、更适合我的需求，很显然我会继承自它们而不是<code>BaseFragment</code>。该怎么办？或许可以使用<code>BaseFragment</code>类似的方式定义<code>BaseDialogFragment</code>和<code>BottomSheetDialogFragment</code>，整体上还是非常繁琐的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    RefWatcher refWatcher = ExampleApplication.getRefWatcher(getActivity());</span><br><span class="line">    refWatcher.watch(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(更新于 2019-01-31)</p><p>LeakCanary 在 2018-10-17 合入了这个 pull request，见 <a href="https://github.com/square/leakcanary/pull/1061" target="_blank" rel="noopener">Detect fragment view leaks #1061</a>。</p><p>做法跟我的一模一样，唉，下次我也提个 PR。不过这个 PR 有几点比我做得好，值得学习：</p><ul><li>如何解决 SupportLibrary 版本问题 (不过考虑到目前 SupportLibrary V25.2.0 已经是很旧的版本的，版本问题其实不必担心)<ul><li>将 Fragment 内存泄漏检查独立成 <code>leakcanary-support-fragment</code> 模块</li><li>使用反射机制检查是否有 <code>leakcanary-support-fragment</code> 模块</li><li>提供 <code>AndroidRefWatcherBuilder.watchFragments(boolean)</code> 接口让开发者自行选择是否要使用这个模块。</li></ul></li><li>它写了 TestCase！</li></ul><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>修改LeakCanary的源码。<a href="https://github.com/square/leakcanary/blob/master/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java#L38" target="_blank" rel="noopener">ActivityRefWatcher</a>代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Application.ActivityLifecycleCallbacks lifecycleCallbacks =</span><br><span class="line">    <span class="keyword">new</span> Application.ActivityLifecycleCallbacks() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (activity <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">FragmentActivity fa = (FragmentActivity) activity;</span><br><span class="line">fa.getSupportFragmentManager().registerFragmentLifecycleCallbacks(<span class="keyword">new</span> FragmentLifecycleCallbacks() &#123;</span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        ActivityRefWatcher.<span class="keyword">this</span>.onActivityDestroyed(activity);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>但是这么改的话就让LeakCanary产生兼容性问题，使用25.2.0及以上版本的SupportLibrary的应用才能使用LeakCanary。虽然截止到2018年2月2日最新的SupportLibrary是2017年11月份发布的<a href="https://developer.android.com/topic/libraries/support-library/revisions.html" target="_blank" rel="noopener">27.0.2</a>，25.2.0已经是比较旧的版本了，但LeakCanary作为一个library却对应用的依赖有额外要求显然不合适。</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>在<code>BaseActivity</code>中进行Fragment内存泄漏检查。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">final</span> RefWatcher refWatcher = MyApplication.getRefWatcher(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// initialization code</span></span><br><span class="line">        getSupportFragmentManager()</span><br><span class="line">                .registerFragmentLifecycleCallbacks(<span class="keyword">new</span> FragmentLifecycleCallbacks() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFragmentDestroyed</span><span class="params">(FragmentManager fm, Fragment f)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">super</span>.onFragmentDestroyed(fm, f);</span><br><span class="line">                        refWatcher.watch(f);</span><br><span class="line">                    &#125;</span><br><span class="line">    </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFragmentViewDestroyed</span><span class="params">(FragmentManager fm, Fragment f)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">super</span>.onFragmentViewDestroyed(fm, f);</span><br><span class="line">                        refWatcher.watch(f.getView());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对比后可以看到上述第三种方式对采用了25.0.2及以上版本的SupportLibrary的应用来说是最合理的方案，可以简单有效地检查Fragment内存泄漏问题，不像方案一那么复杂，也不会像方案二那样导致LeakCanary库兼容性降低。所以我们应用中采用这一方案。</p><h1 id="Heap上传"><a href="#Heap上传" class="headerlink" title="Heap上传"></a>Heap上传</h1><p>前面提到过有时我们并不会立即去分析LeakCanary的检查结果，原因可能是手头有更重要的任务，也可能是内存泄漏并不是发生在你自己的设备上。所以有必要让实现LeakCanary检查结果上传功能。对此<a href="https://github.com/square/leakcanary/wiki/Customizing-LeakCanary#uploading-to-a-server" target="_blank" rel="noopener">LeakCanary wiki</a>仍有提供解决方案。</p><p>我们可以创建自己的<code>AbstractAnalysisResultService</code>来调整LeakCanary的缺省行为，将原来的分析heap dump修改成上传leak trace和heap dump到后台服务器。不过没必要从头开始创建<code>AbstractAnalysisResultService</code>。建议的做法是继承<code>DisplayLeakService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakUploadService</span> <span class="keyword">extends</span> <span class="title">DisplayLeakService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterDefaultHandling</span><span class="params">(HeapDump heapDump, AnalysisResult result, String leakInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!result.leakFound || result.excludedLeak) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    myServer.uploadLeakBlocking(heapDump.heapDumpFile, leakInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要忘记在<code>AndroidManifest.xml</code>中配置这个service。如何实现这里的上传service呢？热心网友直接给出了<a href="https://gist.github.com/pyricau/06c2c486d24f5f85f7f0" target="_blank" rel="noopener">源码</a>。不过源码中使用的是<a href="https://slack.com/" target="_blank" rel="noopener">Slack Channel</a>或<a href="https://www.atlassian.com/software/hipchat" target="_blank" rel="noopener">HipChat</a>。这两个看起来更为高大上，但考虑在我们应用的用户主要是在国内，所以还是使用比较接地气的腾讯云对象存储服务(COS)。</p><p>粗略地看了下COS的文档，可以选择API的方式接入或SDK方式。使用API更轻量，使用SDK更简单。不过有个问题需要注意：对于大文件(超过20MB)是采用分片上传方式，所以调用的API跟小文件上传有所不同，较为繁琐。又有一个问题需要注意：LeakCanary的heap dump文件有多大呢？保存在哪里？</p><h2 id="HeapDump文件"><a href="#HeapDump文件" class="headerlink" title="HeapDump文件"></a>HeapDump文件</h2><p>具体代码见<a href="https://github.com/square/leakcanary/blob/master/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java" target="_blank" rel="noopener">DefaultLeakDirectoryProvider</a></p><p>HeapDump文件，即hprof文件，保存的位置是<code>Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)</code>目录。具体的策略是：</p><ol><li>优先使用<code>externalStorageDirectory()</code>返回的目录</li><li>其次是<code>appStorageDirectory()</code>返回的目录</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> File <span class="title">externalStorageDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  File downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> File(downloadsDirectory, <span class="string">"leakcanary-"</span> + context.getPackageName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> File <span class="title">appStorageDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  File appFilesDirectory = context.getFilesDir();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> File(appFilesDirectory, <span class="string">"leakcanary"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/images/1517369532736.webp" width="30%" height="30%"><img src="/images/1517369491050.webp" width="30%" height="30%"><br></div><ol><li>两张图中的保存位置分别是<code>Download\leakcanary\detected_leaks</code>和<code>Download\leakcanary-&lt;包名&gt;\</code></li><li>上面第一张图中的hprof大小居然是170MB，暗示该应用可能存在比较严重的内存泄漏</li></ol><p>另外，对每一个hprof文件会有一个对应的result文件。hprof文件一般较大，其大小通常就是heap dump操作时应用占用的内存数量。你会发现hprof和result文件数并不多，最多一共14个。这是因为<code>DefaultLeakDirectoryProvider.DEFAULT_MAX_STORED_HEAP_DUMPS</code>值限制了hprof文件的数量，默认为7。我们可以根据自己的需求调整这个值。当然考虑到hprof文件可能较大，如果我们把<code>DEFAULT_MAX_STORED_HEAP_DUMPS</code>调整到很高，最后可能会占用很多存储空间。</p><h2 id="上传到COS"><a href="#上传到COS" class="headerlink" title="上传到COS"></a>上传到COS</h2><p>好吧，heap dump文件可能非常大，如果要上传COS的话，还是乖乖使用<a href="https://github.com/tencentyun/qcloud-sdk-android/releases" target="_blank" rel="noopener">COS SDK</a>。这里提供一个基于COS Android SDK封装的<a href="https://gist.github.com/410063005/d0e75c5e5bfe21ea62e11ba3db129c52" target="_blank" rel="noopener"><code>CosClient</code></a>。最后的上传service如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakUploadService</span> <span class="keyword">extends</span> <span class="title">DisplayLeakService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterDefaultHandling</span><span class="params">(HeapDump heapDump, AnalysisResult result, String leakInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.leakFound || result.excludedLeak) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            CosClient cosClient = CosClient.create(getApplicationContext(), getAssets().open(<span class="string">"heap.json"</span>));</span><br><span class="line">             cosClient.upload(heapDump.heapDumpFile, heapDump.heapDumpFile.getName(), <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建<code>RefWatcher</code>时指定<code>LeakUploadService</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RefWatcher refWatcher = LeakCanary.refWatcher(<span class="keyword">this</span>)</span><br><span class="line">  .listenerServiceClass(LeakUploadService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  .buildAndInstall();</span><br></pre></td></tr></table></figure><p><img src="/images/1517556169211.webp" alt></p><p>注：考虑到heap dump文件实在太大，而简单的leak info常常也足够分析出内存泄漏问题，所以实际上我只上传了leak info。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最终我对LeakCanary做了自定义配置，比起最简单的傻瓜式配置它有几个额外的好处：</p><ul><li>使用方便<ul><li>Debug包中有开关控制LeakCanary的开启，默认是关闭状态。但必要时，我们可以随时打开开关检查内存泄漏问题</li><li>内存泄漏问题上传后台，可以合理安排时间进行统一集中的处理</li></ul></li><li>检查更为全面。除了能自动检查Activity内存泄漏，还可以自动检查Fragment内存泄漏</li></ul><p>但是，这里仍然有问题没有解决。由于LeakCanary的heap dump以及heap analysis非常耗时耗资源，所以官方要求一定不要用在release包中以免影响性能。这么做的结果是我们在无法对真实用户的设备监测内存泄漏问题。</p><p>我的理解是，weak reference可达性检测才是检查内存泄漏最为关键的一步，而这一步对性能的影响可能较小(仅触发一次GC而已)。而heap dump及后续的heap analysis不过是计算 <strong>shortest strong reference path to the GC Roots</strong> ，一来确认前一步weak reference可达性的正确性，二来方便我们快速定位问题。如果不去计算 shortest strong reference path to the GC roots会怎样呢？一是检查的准确性降低，二是定位问题相对不方便，但同时也减少性能风险。基于此，应该可以设计一种内存泄漏检查方案，该方案特点如下：</p><ul><li>对性能影响小，可用于relase包检查用户真实设备上的内存泄漏问题</li><li>内存泄漏检查得足够准，但不提供详情的reference path辅助定位内存泄漏问题 (全靠人肉分析)</li></ul><p>怎么实现，容我再想想。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/square/leakcanary/wiki" target="_blank" rel="noopener">LeakCanary wiki</a></p><p><a href="https://www.liaohuqiu.net/cn/posts/leak-canary-read-me/" target="_blank" rel="noopener">LeakCanary 中文使用说明</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android项目构建环境优化</title>
      <link href="2018/02/01/build-opt-series/"/>
      <url>2018/02/01/build-opt-series/</url>
      
        <content type="html"><![CDATA[<p>[TODO] 我不知道标题名是否不准确。个人理解Android项目构建环境同样重要，也需要不断清理和优化，保证快的编译速度，提高开发效率。</p><a id="more"></a><h1 id="debugCompile的使用"><a href="#debugCompile的使用" class="headerlink" title="debugCompile的使用"></a>debugCompile的使用</h1><p>我们经常使用<code>compile</code>来添加依赖。但是有些依赖在debug包中才使用，而在release包中完全没有必要。这时其实使用<code>debugCompile</code>就足够了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在Android中获取对象大小</title>
      <link href="2018/01/30/leakcanary-get-object-size/"/>
      <url>2018/01/30/leakcanary-get-object-size/</url>
      
        <content type="html"><![CDATA[<p>[TODO] 如何在Android中获取对象大小。<br><a id="more"></a></p><h1 id="如何在Java中获取对象大小"><a href="#如何在Java中获取对象大小" class="headerlink" title="如何在Java中获取对象大小"></a>如何在Java中获取对象大小</h1><h2 id="instrumentation"><a href="#instrumentation" class="headerlink" title="instrumentation"></a>instrumentation</h2><p>一种方式是使用<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/instrument/Instrumentation.html" target="_blank" rel="noopener">instrumentation</a>，该方法在<a href="https://stackoverflow.com/questions/9368764/calculate-size-of-object-in-java" target="_blank" rel="noopener">Calculate size of Object in Java</a>和<a href="https://stackoverflow.com/questions/52353/in-java-what-is-the-best-way-to-determine-the-size-of-an-object" target="_blank" rel="noopener">In Java, what is the best way to determine the size of an object?</a>中均有介绍</p><p>但这种方式最终需要以如下较为繁琐的方式调用：</p><p>java -javaagent:ObjectSizeFetcherAgent.jar C</p><p>其中jar包包含检查对象大小的代码，而C是待测试的对象。</p><h2 id="ObjectGraphMeasurer"><a href="#ObjectGraphMeasurer" class="headerlink" title="ObjectGraphMeasurer"></a>ObjectGraphMeasurer</h2><p><a href="https://github.com/DimitrisAndreou/memory-measurer" target="_blank" rel="noopener">https://github.com/DimitrisAndreou/memory-measurer</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> objectexplorer.ObjectGraphMeasurer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Measurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; hashset = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      hashset.add(random.nextInt());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(ObjectGraphMeasurer.measure(hashset));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ObjectSizeCalculator"><a href="#ObjectSizeCalculator" class="headerlink" title="ObjectSizeCalculator"></a>ObjectSizeCalculator</h2><p>jdk.nashorn.internal.ir.debug.ObjectSizeCalculator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ObjectSizeCalculator.getObjectSize(<span class="keyword">new</span> gnu.trove.map.hash.TObjectIntHashMap&lt;String&gt;(<span class="number">12000</span>, <span class="number">0.6f</span>, -<span class="number">1</span>)));</span><br><span class="line">System.out.println(ObjectSizeCalculator.getObjectSize(<span class="keyword">new</span> HashMap&lt;String, Integer&gt;(<span class="number">100000</span>)));</span><br><span class="line">System.out.println(ObjectSizeCalculator.getObjectSize(<span class="number">3</span>));</span><br><span class="line">System.out.println(ObjectSizeCalculator.getObjectSize(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;));</span><br><span class="line">System.out.println(ObjectSizeCalculator.getObjectSize(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>]));</span><br></pre></td></tr></table></figure><p>164192<br>48<br>16<br>48<br>416</p><h2 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h2><h3 id="jol"><a href="#jol" class="headerlink" title="jol"></a>jol</h3><p><a href="http://openjdk.java.net/projects/code-tools/jol/" target="_blank" rel="noopener">jol</a></p><h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><p><a href="http://sourceforge.net/projects/sizeof" target="_blank" rel="noopener">sizeof</a></p><p><a href="http://www.javaworld.com/javaworld/javaqa/2003-12/02-qa-1226-sizeof.html" target="_blank" rel="noopener">an article on determining the size of composite and potentially nested Java objects</a></p><h3 id="ObjectSizer"><a href="#ObjectSizer" class="headerlink" title="ObjectSizer"></a>ObjectSizer</h3><p><a href="http://www.javapractices.com/topic/TopicAction.do?Id=83" target="_blank" rel="noopener">ObjectSizer</a></p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化(但有些人不推荐这种做法)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Serializable ser;</span><br><span class="line">ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream oos = new ObjectOutputStream(baos);</span><br><span class="line">oos.writeObject(ser);</span><br><span class="line">oos.close();</span><br><span class="line">return baos.size();</span><br></pre></td></tr></table></figure><h1 id="如何在Android中获取对象大小"><a href="#如何在Android中获取对象大小" class="headerlink" title="如何在Android中获取对象大小"></a>如何在Android中获取对象大小</h1><p>貌似没有好的解决办法。但是LeakCanary中可以输出类似日志。它是如何获取对象大小的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In com.sunmoonblog.memperf:1.0:1.</span><br><span class="line">            * com.sunmoonblog.memperf.Box has leaked:</span><br><span class="line">            * GC ROOT static com.sunmoonblog.memperf.Docker.container</span><br><span class="line">            * leaks com.sunmoonblog.memperf.Box instance</span><br><span class="line">            </span><br><span class="line">            * Retaining: 20 B.</span><br><span class="line">            * Reference Key: 04d239b5-2409-48f5-bc54-2432d6eabe61</span><br><span class="line">            * Device: Genymotion Android Google Nexus 5X - 7.0.0 - API 24 - 1080x1920 vbox86p</span><br><span class="line">            * Android Version: 7.0 API: 24 LeakCanary: 1.5.4 74837f0</span><br><span class="line">            * Durations: watch=5001ms, gc=104ms, heap dump=5136ms, analysis=19166ms</span><br></pre></td></tr></table></figure><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p><a href="https://stackoverflow.com/questions/9009544/android-dalvik-get-the-size-of-an-object" target="_blank" rel="noopener">来源</a></p><p>建议翻一下Dalvik VM源码。对象的大小存储在 <code>ClassObject::objectSize : size_t</code>, 源码见 <code>dalvik/vm/oo/Object.h</code></p><p>建议从 <code>dalvik/vm/alloc/Alloc.cpp</code> 的 <code>dvmTrackAllocation()</code>开始看起。 <code>new</code>操作符会调用到这个方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)使用LeakCanary检查内存泄漏</title>
      <link href="2018/01/30/leakcanary-detect-all-memory-leaks/"/>
      <url>2018/01/30/leakcanary-detect-all-memory-leaks/</url>
      
        <content type="html"><![CDATA[<p>答辩时被问到LeakCanary内存检测泄漏原理，没能答上来。原本答辩前是计划看这一块的内容的，结果时间紧没有去翻相关资料。好吧，我是在找借口。知识有欠缺就是有欠缺，找借口不如赶紧恶补。<br><a id="more"></a></p><p>本文翻译自<a href="https://medium.com/square-corner-blog/leakcanary-detect-all-memory-leaks-875ff8360745" target="_blank" rel="noopener">LeakCanary: Detect all memory leaks! – Square Corner Blog – Medium</a>。</p><blockquote><p>java.lang.OutOfMemoryError<br>       at android.graphics.Bitmap.nativeCreate(Bitmap.java:-2)<br>       at android.graphics.Bitmap.createBitmap(Bitmap.java:689)<br>       at com.squareup.ui.SignView.createSignatureBitmap(SignView.java:121)</p></blockquote><h1 id="没人喜欢OOM"><a href="#没人喜欢OOM" class="headerlink" title="没人喜欢OOM"></a>没人喜欢OOM</h1><p>在Square的注册界面，我们在Bitmap cache上绘制用户签名。该Bitmap的尺寸大小跟屏幕大小一致，创建该Bitmap时出现很多OOM(OutOfMemoryError)。</p><p><img src="https://cdn-images-1.medium.com/max/2000/0*TpsPt3DHu_aMeoa2.webp" alt></p><p>我们尝试以上解决方法，没有一个能解决问题：</p><ul><li>使用<code>Bitmap.Config.ALPHA_8</code>减少内存占用(用户签名不需要颜色)</li><li>捕获OOM并强制GC后再来重试几次(灵感来自于<a href="https://android.googlesource.com/platform/packages/inputmethods/LatinIME/+/ics-mr1/java/src/com/android/inputmethod/latin/Utils.java" target="_blank" rel="noopener">GCUtils</a>)</li><li>我们没有想过在Java堆以外分配Bitmap。好在那时还没有<a href="https://github.com/facebook/fresco" target="_blank" rel="noopener">Fresco</a>。(？ We didn’t think of allocating bitmaps off the Java heap. Lucky for us, Frescodidn’t exist yet.)</li></ul><h1 id="我们使用错误的方式看问题"><a href="#我们使用错误的方式看问题" class="headerlink" title="我们使用错误的方式看问题"></a>我们使用错误的方式看问题</h1><p>Bitmap大小并不是问题。当内存快满时，OOM可能在任何地方发生。而它更倾向于发生在创建大对象的地方，比如Bitmap。OOM象征着另一个更深层次的问题：<strong>内存泄漏</strong>。</p><h1 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h1><p>对象生命周期有限。一些对象完成其工作之后，本应该被垃圾回收。如果一个引用链在某个对象生命周期完成后仍然持有访对象，会导致内存泄漏。当内存泄漏不断累积，应用就会内存不足。</p><p>比如，<code>Activity.onDestroy()</code>回调后，该Activity，Activity的View树，以及相应的Bitmap应该是可以垃圾回收的。如果后台某个线程持有该Activity的引用，那么对应的内存就不能被回收。它最终会导致OOM崩溃。</p><h1 id="找到内存泄漏"><a href="#找到内存泄漏" class="headerlink" title="找到内存泄漏"></a>找到内存泄漏</h1><p>寻找内存泄漏是一个手动过程，Raizlab的<a href="http://www.raizlabs.com/dev/2014/03/wrangling-dalvik-memory-management-in-android-part-1-of-2/" target="_blank" rel="noopener">Wrangling Dalvik</a>系列中对此有很好的描述。</p><p>关键步骤如下：</p><ol><li>通过<a href="https://bugsnag.com/" target="_blank" rel="noopener">Bugsnag</a>, <a href="https://try.crashlytics.com/" target="_blank" rel="noopener">Crashlytics</a>, <a href="https://play.google.com/apps/publish/" target="_blank" rel="noopener">Developer Console</a>(译者注，或其他某些crash上报工具)了解应用中OOM的具体情况</li><li>尝试复现问题。需要一部出现OOM崩溃的手机来复现问题，你可以去买、借甚至偷(^_^)  (并不是所有的设备都会出现内存泄漏！) 你还需要弄清楚哪种操作流程会导致内存泄漏，可能需要通过暴力方式强制内存泄漏</li><li>发生OOM时导出heap (<a href="https://gist.github.com/pyricau/4726389fd64f3b7c6f32" target="_blank" rel="noopener">这里总结了做法</a>)</li><li>使用<a href="http://eclipse.org/mat/" target="_blank" rel="noopener">MAT</a>或<a href="https://www.yourkit.com/" target="_blank" rel="noopener">YourKit</a>分析上一步得到的heap，并找到一个应当被回收却没有回收的对象</li><li>计算从GC roots到该对象最短的强引用路径</li><li>弄清楚该路径中哪个引用不应当存在，修复该内存泄漏问题</li></ol><p>如果有一个库可以在发生OOM之前帮你完成这些工作，而你只用集中精力修复内存泄漏那该有多好！</p><h1 id="LeakCanary介绍"><a href="#LeakCanary介绍" class="headerlink" title="LeakCanary介绍"></a>LeakCanary介绍</h1><p><a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCanary</a>是一个用于检测内存泄漏的Java开源库。</p><p>看这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">  Cat hiddenCat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Docker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Box container;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Box box = <span class="keyword">new</span> Box();</span><br><span class="line">Cat schrodingerCat = <span class="keyword">new</span> Cat();</span><br><span class="line">box.hiddenCat = schrodingerCat;</span><br><span class="line">Docker.container = box;</span><br></pre></td></tr></table></figure><p>可以创建<code>RefWatcher</code>实例来监控一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We expect schrodingerCat to be gone soon (or not), let's watch it.</span></span><br><span class="line">refWatcher.watch(schrodingerCat);</span><br></pre></td></tr></table></figure><p>当检查到泄漏时，会自动出现内存泄漏trace:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* GC ROOT static Docker.container</span><br><span class="line">* references Box.hiddenCat</span><br><span class="line">* leaks Cat instance</span><br></pre></td></tr></table></figure><p>我们知道你忙于给应用写功能，所以让整个配置过程非常简单。只用一行代码，LeakCanary就会自动检查Activity泄漏：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    LeakCanary.install(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会看到Notification提示框以及图形化的展示：</p><p><img src="https://cdn-images-1.medium.com/max/2000/0*5zhG12WlfCp1nIlc.webp" alt></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>启用LeakCanary后我们发现并修复了我们应用当中许多内存泄漏。我们甚至发现少量<a href="[leaks in the Android SDK](https://github.com/square/leakcanary/blob/master/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java">Android SDK中的内存泄漏</a>)</p><p>结果让人吃惊。我们将OOM crash降低了94%。</p><p><img src="https://cdn-images-1.medium.com/max/2000/0*8DpD5hZX4R4O4Vvr.webp" alt></p><p>如果你想消除OOM崩溃，赶紧<a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">现在就安装LeakCanary</a>吧！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能优化实战</title>
      <link href="2018/01/30/my-app-performance-opt-series/"/>
      <url>2018/01/30/my-app-performance-opt-series/</url>
      
        <content type="html"><![CDATA[<p>[TODO] 总结了我们应用关于性能优化的具体做法。每个优化，无论都小都给出了测试结果证明优化是有效的。<br><a id="more"></a><br><a href="#">Application之多进程的坑</a><br><a href="#">Application之延迟初始化</a><br><a href="#">Application之优化初始化</a><br><a href="#">Fragment之延迟初始化</a><br><a href="#">Activity之onTrimMemeory</a><br><a href="#">TCPConnection之减少内存分配</a>  性能如何度量<br><a href="#">TCPConnection之使用Buffer代替byte数组</a>  性能如何度量<br><a href="#">TCPConnection之连接池</a><br><a href="#">布局优化之使用ViewStub</a><br><a href="#">布局优化之使用ConstraintLayout</a><br><a href="#">内存优化之LeakCanaray应用及原理</a><br><a href="#">内存优化之LeakCanaray高级应用</a><br><a href="#">内存优化之LeakCanaray上传heap</a><br><a href="#">内存优化之内存泄漏检测原理</a><br><a href="#">内存优化之ArrayMap</a><br><a href="#">内存优化之池化技术</a><br><a href="#">内存优化之Bitmap</a><br><a href="#">Glide之大图监测</a><br><a href="#">统计之GC统计</a><br><a href="#">统计之内存统计</a><br><a href="#">统计之日志上报策略</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转LeakCanary</title>
      <link href="2018/01/30/leakcanary-series/"/>
      <url>2018/01/30/leakcanary-series/</url>
      
        <content type="html"><![CDATA[<p>[TODO] 总结了LeakCanary原理及用法。<br><a id="more"></a></p><ul><li><a href="/2018/01/30/leakcanary-detect-all-memory-leaks/" title="(译)为什么要使用LeakCanary">(译)为什么要使用LeakCanary</a></li><li><a href="/2018/01/30/leakcanary-get-object-size/" title="LeakCanary之如何获取对象大小">LeakCanary之如何获取对象大小</a></li><li><a href="#">LeakCanary简介</a></li><li><a href="#">LeakCanary原理</a></li><li><a href="#">LeakCanary高级用法</a></li><li><a href="/2018/02/02/leakcanary-application/" title="LeakCanary实战">LeakCanary实战</a></li></ul><h1 id="如何使用LeakCanary"><a href="#如何使用LeakCanary" class="headerlink" title="如何使用LeakCanary"></a>如何使用LeakCanary</h1><p><code>LeakCanary.install()</code>返回一个预先配置好的<code>RefWatcher</code>。该方法同时还会自动使用<code>ActivityRefWatcher</code>，这个对象自动检测<code>Activity.onDestroy()</code>后activity是否有泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RefWatcher <span class="title">getRefWatcher</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    ExampleApplication application = (ExampleApplication) context.getApplicationContext();</span><br><span class="line">    <span class="keyword">return</span> application.refWatcher;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> RefWatcher refWatcher;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    <span class="keyword">if</span> (LeakCanary.isInAnalyzerProcess(<span class="keyword">this</span>)) &#123;</span><br><span class="line">      <span class="comment">// This process is dedicated to LeakCanary for heap analysis.</span></span><br><span class="line">      <span class="comment">// You should not init your app in this process.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    refWatcher = LeakCanary.install(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>RefWatcher</code>用到检查应当被GC的引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RefWatcher refWatcher = &#123;...&#125;;</span><br><span class="line"></span><br><span class="line">// We expect schrodingerCat to be gone soon (or not), let&apos;s watch it.</span><br><span class="line">refWatcher.watch(schrodingerCat);</span><br></pre></td></tr></table></figure><p>可以使用<code>RefWatcher</code>检查fragment的泄漏情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    RefWatcher refWatcher = ExampleApplication.getRefWatcher(getActivity());</span><br><span class="line">    refWatcher.watch(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><ol><li><code>RefWatcher.watch()</code>创建指向被检查对象的<a href="https://github.com/square/leakcanary/blob/master/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java" target="_blank" rel="noopener">KeyedWeakReference</a></li><li>之后，在后台线程中检查引用是否被清除，如果没有的话GC一下</li><li>如果引用仍然没有清除，则导出heap到<code>.hprof</code>文件，并保存到文件系统</li><li>一个独立的进程启动<code>HeapAnalyzerService</code>，<code>HeapAnalyzer</code>使用<a href="https://github.com/square/haha" target="_blank" rel="noopener">HAHA</a>解析heap dump</li><li><code>HeapAnalyzer</code>在使用key在heap dump中找到<code>KeyedWeakReference</code>，定位到泄漏的引用</li><li><code>HeapAnalyzer</code>计算 <em>到GC根节点的最短强引用</em> 以确定是否有内存泄漏，然后重新构建导致内存泄漏的引用链</li><li>分析结果发送到应用进程的<code>DisplayLeakService</code>，并且通过notification进行提示</li></ol><!-- Dalvik Other  http://km.oa.com/group/16523/articles/show/331466?kmref=related_post --><!-- Dalvik Other http://km.oa.com/group/16523/articles/show/331465?kmref=home_recommend_read --> ]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转Retrofit</title>
      <link href="2018/01/30/retrofit-series/"/>
      <url>2018/01/30/retrofit-series/</url>
      
        <content type="html"><![CDATA[<p>[TODO] 总结了Retrofit原理和用法，讨论了如果添加TCP支持、自定义Converter和自定义CallAdapter。<br><a id="more"></a></p><p><a href="#">玩转Retrofit之简介</a><br><a href="#">玩转Retrofit之动态代理</a><br><a href="#">玩转Retrofit之自定义Converter</a><br><a href="#">玩转Retrofit之自定义CallAdapter</a><br><a href="#">玩转Retrofit之Defered</a><br><a href="#">玩转Retrofit之TCP支持</a><br><a href="#">玩转Retrofit之OkHttp拦截器</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转Glide</title>
      <link href="2018/01/30/glide-series/"/>
      <url>2018/01/30/glide-series/</url>
      
        <content type="html"><![CDATA[<p>[TODO] 总结了Glide的用法。</p><a id="more"></a><p><a href="#">Glide之大图监测</a><br><a href="#">Glide之缓存监测</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计启动时间</title>
      <link href="2018/01/12/app-start-time-stat/"/>
      <url>2018/01/12/app-start-time-stat/</url>
      
        <content type="html"><![CDATA[<a href="/2017/12/21/app-launch-time/" title="(译)Android之应用启动速度">(译)Android之应用启动速度</a>中提到启动慢通常出现在创建Application和Activity阶段，具体来说就是<code>Application.onCreate()</code>和<code>Activity.onCreate()</code>。这两个方法负载过重，导致启动时间长。优化启动速度的第一步是统计启动时间，如何统计呢？<br><a id="more"></a><h1 id="统计启动时间"><a href="#统计启动时间" class="headerlink" title="统计启动时间"></a>统计启动时间</h1><p>需要说明的是，应当使用关闭了debug模式的APK进行测试，否则统计结果可能跟真实情况差别很大。</p><h2 id="Displayed关键字"><a href="#Displayed关键字" class="headerlink" title="Displayed关键字"></a>Displayed关键字</h2><p>一个简单的统计启动时间的办法是在logcat日志中搜索<code>Displayed</code>关键字，可以看到类似这样的日志：</p><p><img src="/images/1515746480768.webp" alt></p><p>这里可以看到我们应用首页的启动时间。测试是在在x86模拟器进行的，使用的是关闭了debug模式的包，一共测试了三次，每次都是杀死进程后重启启动的(冷启动)</p><h2 id="adb命令"><a href="#adb命令" class="headerlink" title="adb命令"></a>adb命令</h2><p>另一种统计办法是使用adb命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb [-d|-e|-s &lt;serialNumber&gt;] shell am start -S -W</span><br><span class="line">com.example.app/.MainActivity</span><br><span class="line">-c android.intent.category.LAUNCHER</span><br><span class="line">-a android.intent.action.MAIN</span><br></pre></td></tr></table></figure><p><img src="/images/1515747098555.webp" alt></p><ul><li>ThisTime - 当前Activity启动的耗时，这个时间跟上文说到的logat <code>Displayed</code>日志中的第一个时间是对应的</li><li>TotalTime - 总的耗时，从App进程启动开始算起</li><li>WaitTime - (不清楚，待求证?)</li></ul><h1 id="更准确的统计"><a href="#更准确的统计" class="headerlink" title="更准确的统计"></a>更准确的统计</h1><p>直观上感觉我们应用的启动速度并不快。我想优化启动速度，但不清楚到底是哪段代码拖慢了启动速度。如何找到瓶颈所在呢？</p><p>前文说过启动慢通常发生在<code>Application.onCreate()</code>和<code>Activity.onCreate()</code>。所以重点关注<code>App</code>，<code>SplashActivity</code>，<code>IndexActivity</code>三个对象<code>onCreate()</code>中各个方法调用的具体耗时：</p><ul><li><code>App</code> - App是应用入口，它是<code>android.app.Application</code>的子类。我们在<code>App.onCreate()</code>有大量初始化代码，或许某些代码很慢</li><li><code>SplashActivity</code> - SplashActivity是应用的闪屏页，闪屏页通常没有太多代码，可能不是性能瓶颈。但最好先看数据再下结论</li><li><code>IndexActivity</code> - IndexActivity是应用的首页，首页有4个Tab，分别会加载四个不同的Fragment</li></ul><h2 id="TimingLogger"><a href="#TimingLogger" class="headerlink" title="TimingLogger"></a>TimingLogger</h2><p>确定 <em>统计对象</em> 后再来看看 <em>统计工具</em> 。<a href="https://developer.android.com/reference/android/util/TimingLogger.html" target="_blank" rel="noopener">android.util.TimingLogger</a>非常适合我们需求场景，它是Android SDK提供的工具类，用于统计方法耗时。用法比较简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TimingLogger timings = <span class="keyword">new</span> TimingLogger(<span class="string">"TAG"</span>, <span class="string">"methodA"</span>);</span><br><span class="line"><span class="comment">// ... do some work A ...</span></span><br><span class="line">timings.addSplit(<span class="string">"work A"</span>);</span><br><span class="line"><span class="comment">// ... do some work B ...</span></span><br><span class="line">timings.addSplit(<span class="string">"work B"</span>);</span><br><span class="line"><span class="comment">// ... do some work C ...</span></span><br><span class="line">timings.addSplit(<span class="string">"work C"</span>);</span><br><span class="line">timings.dumpToLog();</span><br></pre></td></tr></table></figure><p>上面代码在logcat的输出类似这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D/TAG     ( 3459): methodA: begin</span><br><span class="line">D/TAG     ( 3459): methodA:      9 ms, work A</span><br><span class="line">D/TAG     ( 3459): methodA:      1 ms, work B</span><br><span class="line">D/TAG     ( 3459): methodA:      6 ms, work C</span><br><span class="line">D/TAG     ( 3459): methodA: end, 16 ms</span><br></pre></td></tr></table></figure><p>注意：<code>TimingLogger</code>的实现依赖于<code>Log.isLoggable()</code>方法。我们知道，需要将对应tag的日志级别至少设置为VERBOSE级别<code>Log.isLoggable()</code>才生效。设置方法是<code>adb shell setprop log.tag.TAG &lt;Level&gt;</code>，使用<code>TimingLogger</code>前需要调用这个命令设置一下。但某些机器上<code>TimingLogger</code>不起作用，比如小米，推测是厂商修改ROM关闭这个功能。</p><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><p>我们分别在模拟器和OPPO手机上测试，得到两份数据。具体数据见<a href="timing-log-emualtor.txt">模拟器日志</a>和<a href="timing-log-oppo.txt">OPPO手机日志</a>。OPPO手机日志用于做实际分析，模拟器日志仅仅用作对比验证。</p><p>每个方法调用都会消耗CPU时间，我们优先关注耗时最多的那些方法。从OPPO手机日志中找到那些耗时超过 <strong>50ms</strong> 的方法调用(当然50ms只是个经验值，这个值可根据实际情况调整)：</p><p>先是<code>App.onCreate()</code>中耗时超过50ms的方法调用</p><ul><li>LoginHelper.getInstance() - 397ms</li><li>QbSdk.initX5Environment() - 102ms</li><li>Bugly.init() - 91ms</li><li>ChannelUtils.initChannel() - 72ms</li></ul><p>然后是<code>IndexActivity.onCreate()</code>中耗时超过50ms的方法调用</p><ul><li>IndexActivity.setSubContentView() - 87ms</li><li>MyPresenter.attach() - 81ms</li><li>IndexActivity.setupView() - 246ms</li></ul><p><code>SplashActivity.onCreate()</code>中并没有出现耗时超过50ms的方法调用，我们可以忽略它。</p><p>不过我们从日志文件看到一个奇怪的现象————某些日志出次了多次，看起来就像是代码重复执行。比如这段日志出现了三次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D/cm-perf: App.onCreate2(): begin</span><br><span class="line">D/cm-perf: App.onCreate2():      31 ms, ChannelUtils.initChannel</span><br><span class="line">D/cm-perf: App.onCreate2():      2 ms, StatUtils.getQIMEI</span><br><span class="line">D/cm-perf: App.onCreate2():      1 ms, Logger.setDebuggable</span><br><span class="line">D/cm-perf: App.onCreate2():      0 ms, Env.initEnv</span><br><span class="line">D/cm-perf: App.onCreate2(): end, 34 ms</span><br></pre></td></tr></table></figure><p>下面逐一对上述数据和现象进行初步分析，并对某些耗时操作给出了大致的解决方案</p><ul><li>LoginHelper.getInstance() </li></ul><p>腾讯WTLogin SDK初始化，非常非常慢。不仅在OPPO真机上慢，在性能较高的<a href="timing-log-emualtor.txt">模拟器</a>上也是一如继往的慢。对这个方法调用慢的问题，暂时没想到好的解决办法，总不能不登录吧？</p><ul><li>QbSdk.initX5Environment()</li></ul><p><a href="https://x5.tencent.com/tbs/" target="_blank" rel="noopener">腾讯浏览服务SDK(x5内核)</a>初始化。x5内核用于替换Android原生的WebView，以提高应用内h5页面性能。很显然没必要在应用启动时就初始化x5内核，毕竟真实用户很可能根本就不会打开h5，在用户真正使用打开h5时再初始化x5内核才是合理的。当然，需要注意的是<code>QbSdk.initX5Environment()</code>内部会启动一个新的线程做异步初始化。所以<code>QbSdk.initX5Environment()</code>返回并不表示初始化完成！使用没有初始化成功的x5内核，可能会出现一些奇怪的bug，比如WebView黑屏之类的。(是的，我被这个问题坑到了，后面再讲)</p><ul><li>Bugly.init()</li></ul><p><a href="https://bugly.qq.com/v2/" target="_blank" rel="noopener">腾讯Bugly SDK</a>初始化。能否将这个初始化延后？</p><ul><li>ChannelUtils.initChannel()</li></ul><p>初始化渠道号。这个方法中有IO操作！具体来说就是拿到当前应用对应的APK文件，然后解析其中的渠道号文件，所以耗时多。有没有办法避免这里的IO操作？</p><ul><li>IndexActivity.setSubContentView()</li></ul><p>这个方法加载布局而已，耗时却很多。推测是布局过于复杂引起的。</p><ul><li>MyPresenter.attach() (注：这里的实际操作是调用Retrofit)</li></ul><p>这里耗时多就比较出乎意料。正常来说它应当是一个很轻的操作，不至于慢。但仔细分析就容易明白：MyPresenter中用到了Retrofit生成的Service类，而Service是通过<a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit2/Retrofit.java#L133" target="_blank" rel="noopener">Java动态代理</a>生成的，这个生成过程非常慢。不过Retrofit有做缓存，之后的访问速度会变快。</p><ul><li>IndexActivity.setupView()</li></ul><p>这里耗时多是因为在其中初始化<a href="https://cloud.tencent.com/product/im" target="_blank" rel="noopener">腾讯云IM SDK</a>。</p><ul><li>某些日志输出多次的问题</li></ul><p>我们应用是多进程的，包括主进程、IM进程和网络进程。<code>App.onCreate()</code>中的部分初始化代码不不幸遇到<a href="http://yifeng.studio/2017/06/16/android-multi-process-things/" target="_blank" rel="noopener">Android多进程的坑</a>。那些输出日志的代码在三个进程中被执行，所以能看到三次日志输出。执行不必要的代码肯定会在某种程度上降低启动速度，解决方法是 <strong>根据当前进程功能只做必要的初始化</strong> 。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如[Android之应用启动速度](2017-12-21-app-launch-time.md]中提到的那样，应用启动慢通常出现在创建Application和Activity的阶段。而<code>TimingLogger</code>可以方便地统计方法耗时，通过方法耗时数据可以清楚地看到性能瓶颈所在。</p><p>我们基本弄清楚启动慢的原因，接下来就是如何优化启动速度了。优化的策略不外乎这几个：</p><ul><li>减少不需要的初始化<ul><li>某些旧的没用的代码可能没有删除，它们会引起不必要的初始化</li><li>多进程应用中很容易出现不必要的初始化，具体可参考<a href="http://yifeng.studio/2017/06/16/android-multi-process-things/" target="_blank" rel="noopener">这里</a></li></ul></li><li>延迟初始化/延迟加载<ul><li>事情分轻重缓急，真的不需要在应用入口做完所有的初始化</li><li>最好是延迟到要使用时才初始化，或者在负载较轻时再初始化</li></ul></li><li>避免IO操作</li><li>简化布局</li><li>缓存</li></ul><p>当然说起容易做起来难，真正优化时其实很容易踩坑，比如上面提到的x5 WebView黑屏问题。如何有效优化的同时又避免踩坑呢？未完待续，敬请期待。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在ActionBar上显示引导提示</title>
      <link href="2018/01/11/tips-on-action-bar/"/>
      <url>2018/01/11/tips-on-action-bar/</url>
      
        <content type="html"><![CDATA[<p>你一定在微信朋友圈见过弹出来指向右上角的箭头，”诱导”你去分享。通常来说，弹出来的箭头只能指向右上角，没法指”进”右上角。有没有办法实现实现指”进”右上角的效果呢？微信中h5应该是没有办法的，但App原生代码中是可以实现的，来看看怎么做的吧。</p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>视觉上要求在ActionBar的OptionMenu上弹出一个提示：</p><p><img src="/images/1515671077336.webp" alt></p><p>内心的感受是~!^%$#@!!!#))*。 但抛开需求或设计上的合理性不谈，那到底如何实现这种效果呢？要知道，那个小圆点可是跑到ActionBar上面去了啊！</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>实际项目中，一般都会定义BaseActivity用于统一控制页面结构。比如我们项目的BaseActivity结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:id=&quot;@+id/common_base_activity_layout&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--action bar--&gt;</span><br><span class="line">    &lt;android.support.v7.widget.Toolbar</span><br><span class="line">        android:id=&quot;@+id/common_base_activity_toolbar&quot;</span><br><span class="line">        android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">        android:layout_height=&quot;50dp&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--content被添加到这里了--&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>id为<code>common_base_activity_toolbar</code>的ToolBar会添加如下View作为ActionBar(标题栏)，而布局文件中定义的内容会添加到标题栏下方。</p><p><img src="/images/1515673781733.webp" alt></p><p>BaseActivity统一处理上述逻辑。通常情况下这种方式工作得很好，大家都很happy，因为继承自BaseActivity的页面处理标题栏很省事。但同时，由于BaseActivity加载了上述结构的布局文件，设计缺少灵活性，如果有页面要使用特殊的标题栏就非常麻烦了。</p><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>考虑到BaseActivity的限制，一种容易想到的解决办法是绕开BaseActivity另起炉灶。由于不继承BaseActivity，一切从头开始，所以上述实现上述视觉效果并不存在困难。但不继承BaseActivity可能给项目造成混乱。</p><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>Android设置<code>android:clipChildren</code>可以让View超出父View的边界，从而达到的特殊UI效果。这里是一个<a href="http://blog.csdn.net/zhangphil/article/details/48655411" target="_blank" rel="noopener">例子</a>。简单尝试后失败，可能的原因如下：</p><ul><li>要让<code>andorid:clipChildren</code>属性生效，必须设置在准确的View上，而我们的布局比例子中要复杂，这个准确的节点应该是位置BaseActivity的布局中</li><li>只有固定大小的View才可以超出父View (?待求证)</li></ul><h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h2><p>BaseActivity的布局文件中的<code>LinearLayout</code>其实并不是页面最终的根节点，真正的根节点是Android系统添加的<code>FrameLayout</code>。这个特别的<code>FrameLayout</code> id是<code>android.R.id.content</code>。通过<code>findViewById(android.R.id.content)</code>不难找到这个<code>FrameLayout</code>，我们可以将视觉需求中的那个提示控件添加到<code>FrameLayout</code>上，从而实现要求的效果。关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showHint</span><span class="params">(<span class="keyword">int</span> topMargin, <span class="keyword">int</span> layoutId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取FrameLayout</span></span><br><span class="line">    ViewGroup activityContent = (ViewGroup) findViewById(android.R.id.content);</span><br><span class="line">    <span class="comment">// 生成hint</span></span><br><span class="line">    View hintView = getLayoutInflater().inflate(layoutId, mActivityContent, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 调整布局参数</span></span><br><span class="line">    FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) hintView.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (params != <span class="keyword">null</span>) &#123;</span><br><span class="line">        params.topMargin = topMargin;</span><br><span class="line">        hintView.setLayoutParams(params);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加并显示hint</span></span><br><span class="line">    activityContent.addView(hintView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Layout Inspector可以很直观地看到上述代码对布局的修改。</p><p><img src="/images/1515672774540.webp" alt></p><h2 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h2><p>我还脑洞大开地想出了这个方案，</p><p><img src="/images/1515674263401.webp" alt></p><p><img src="/images/1515674523010.webp" alt></p><p>弹出提示和没有弹出提示时分别使用不同的图标，通过”欺骗”用户的方式实现最终效果，只是代码会写得很扯。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>方案三以比较简单低成本的方式实现了需求。暂时没想到更好的实现方法。如果你有，可以告诉我。</p><p>如果BaseActivity一开始是这样设计的，可能具有更多的灵活性：</p><ul><li>BaseActivity是抽象的，统一完成对标题栏的处理</li><li>BaseActivity不直接加载布局，由子类加载布局</li><li>子类加载的布局文件可以使用include方式使用公共的ActionBar，也可以自定义不同的ActionBar，只要保证ActionBar中View的id一致即可</li></ul><p>Java代码和布局文件分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">contentView();</span><br><span class="line">setupActionBar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupActionBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置标题栏</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">contentView</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contentView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">setContentView(R.layout.activity_demo);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- activity_demo.xml --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/common_base_activity_layout"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--action bar--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- include公共的ActionBar 也可以自己自定义ActionBar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/common_toolbar"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--content--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FitNesse试用</title>
      <link href="2018/01/09/fitnesse-demo/"/>
      <url>2018/01/09/fitnesse-demo/</url>
      
        <content type="html"><![CDATA[<p>FitNesse用于集成测试，非常适用于测试接口。但感觉使用并不广泛。试用一下，并记录用法。<br><a id="more"></a></p><h1 id="安装和运行"><a href="#安装和运行" class="headerlink" title="安装和运行"></a>安装和运行</h1><p>从<a href="http://fitnesse.org/FitNesseDownload" target="_blank" rel="noopener">FitNesseDownload</a>下载jar包。目前最新包是release 20161106。</p><p>命令行中使用<code>java  -jar fitnesse-standalone.jar -p 9999</code>启动fitnesse server。</p><p><img src="/images/1515405168646.webp" alt></p><p>fitnesse server启动后，我们可以通过浏览器访问，截图如下：</p><p><img src="/images/1515405277765.webp" alt></p><h1 id="用法简介"><a href="#用法简介" class="headerlink" title="用法简介"></a>用法简介</h1><p>感觉FitNesse文档过于简单，不过它提供了<a href="http://fitnesse.org/FitNesse.UserGuide.TwoMinuteExample" target="_blank" rel="noopener">A Two-Minute Example</a>的例子。我们直接看例子。</p><p>例子用于测试一个计算器程序中的除法运算。比如，对于10除以2，你期望返回5。FitNesse中使用 <strong>input</strong> 和 <strong>expected output</strong> 数据表来表示 test。类似这样：</p><p><img src="/images/1515413862042.webp" alt></p><p>FitNesse中这里的表格称为<a href="http://localhost:9999/FitNesse.UserGuide.WritingAcceptanceTests.SliM.DecisionTable" target="_blank" rel="noopener">Decision Table</a>，例子中的每行数据代表一个完整的场景。”numerator”和”denominator”列表示input，而”quotient?”的问号告诉FitNesse这一列表示是 expected output(期望的输出值)。以”10/2 = 5.0”为例，可将其理解为一个问句：”如果使用10除以2，我能否得到5?”</p><p>如何运行测试呢，很简单。点击FitNesse logo旁边的 <strong>Test</strong> 按钮即可。</p><p><img src="/images/1515462902359.webp" alt></p><p>运行后结果如下：</p><p><img src="/images/1515462989612.webp" alt></p><p>红色表示代码返回了正确的期望值。而红色表示代码返回了跟期望值不同的值，这里可以看到两个值，分别是 <strong>expected value</strong> 和 <strong>actual value</strong></p><p>另外注意这里用于比较的符号：</p><ul><li>22/7 ~= 3.14 22/7约等于3.14</li><li>9/3 &lt; 5      9/3的结果小于5</li><li>11/2 4&lt;_6    11/2的结果在4和6之间</li></ul><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>当用户点击Test按钮时发生什么呢？</p><ul><li>首先，FitNesse将test表格提交到<a href="http://fitnesse.org/FitNesse.UserGuide.WritingAcceptanceTests.SliM" target="_blank" rel="noopener">Slim</a>，即底层的测试系统(该系统包含实际执行测试所需要的代码)</li><li>Slim找到跟test表格对应的fixture代码并运行</li><li>fixture代码调用应用代码，得到运行结果</li><li>Slim向FitNesse返回fixture代码的运行结果</li><li>FitNesse根据运行结果给test表格中标记相应的颜色</li></ul><p>那Fixture Code又是什么呢？下面是一个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> eg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Division</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> numerator, denominator;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumerator</span><span class="params">(<span class="keyword">double</span> numerator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.numerator = numerator;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDenominator</span><span class="params">(<span class="keyword">double</span> denominator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.denominator = denominator;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quotient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numerator/denominator;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/1515413862042.webp" alt></p><ul><li><code>eg</code> - Java包名</li><li><code>Division</code> - Java类</li></ul><p>Slim运行fixture代码的流程是这样的：</p><ul><li>Slim从左到右处理表格中的每一行数据</li><li>对每一行，Slim调用对应的setter将输入数据保存到对应字段中。比如对”numerator”会调用<code>Division.setNumerator()</code></li><li>然后，Slim会调用<code>Decision.quotient()</code>方法得到输出数据</li></ul><p>以第一行测试数据为例，几个方法调用的顺序如下：</p><ol><li>division.setNumerator(10)</li><li>division.setDenominator(2)</li><li>division.quotient()</li></ol><p>如果返回值和期望值匹配，FitNesse将格子显示为绿色。如果返回值和期望值不匹配，FitNesse将格子显示为红色并显示期望值和返回值。如果Slim遇到异常或者找不到fixture代码，FitNesse将格子显示为黄色并显示相应的堆栈信息。</p><p>实际中的fixture代码不应当做任何实际操作，而是代理到应用代码。即，fixture代码应当 <strong>越”薄”越好</strong> ， 最好是充当FitNesse表格和实际应用代码之间的 <strong>管道</strong> 。更多关于fixture代码的内容请参考<a href="http://fitnesse.org/FitNesse.FullReferenceGuide.UserGuide.WritingAcceptanceTests.FixtureCode" target="_blank" rel="noopener">这里</a>。</p><h1 id="Decision-Table"><a href="#Decision-Table" class="headerlink" title="Decision Table"></a>Decision Table</h1><p>使用一种简单的标记语言创建上文中提到的Decision Table，包括表头，文本加粗，下划线，斜体，无序列表，以及其他一些简单的格式化。具体参考<a href="http://fitnesse.org/FitNesse.UserGuide.FitNesseWiki" target="_blank" rel="noopener">FitNesse.UserGuide.FitNesseWiki</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|eg.Division|</span><br><span class="line">|numerator|denominator|quotient?|</span><br><span class="line">|10       |2          |5        |</span><br><span class="line">|12.6     |3          |4.2      |</span><br><span class="line">|100      |4          |33       |</span><br></pre></td></tr></table></figure><p>上面的标记文本可生成如下表格：</p><p><img src="/images/1515413862042.webp" alt></p><h1 id="Hello-FitNesse"><a href="#Hello-FitNesse" class="headerlink" title="Hello FitNesse"></a>Hello FitNesse</h1><p>现在我们自己动手添加一个FitNesse测试。</p><h2 id="应用代码"><a href="#应用代码" class="headerlink" title="应用代码"></a>应用代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fixture代码"><a href="#Fixture代码" class="headerlink" title="Fixture代码"></a>Fixture代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> anotherNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnotherNumber</span><span class="params">(<span class="keyword">int</span> anotherNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.anotherNumber = anotherNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Calculator().add(number, anotherNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/1515465864078.webp" alt></p><p>代码路径<code>/Users/kc/wd/unitTest/lib1/out/production/classes</code></p><h2 id="添加FitNesse测试页面"><a href="#添加FitNesse测试页面" class="headerlink" title="添加FitNesse测试页面"></a>添加FitNesse测试页面</h2><p>点击”Add”下拉菜单，选择”Test Page”，并在页面中添加以下内容并保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">!path /Users/kc/wd/unitTest/lib1/out/production/classes</span><br><span class="line">!define TEST_SYSTEM &#123;slim&#125;</span><br><span class="line"></span><br><span class="line">|demo.CalculatorDemo      |</span><br><span class="line">|number|anotherNumber|sum?|</span><br><span class="line">|1     |1            |2   |</span><br><span class="line">|0     |3            |3   |</span><br><span class="line">|100   |4            |104 |</span><br></pre></td></tr></table></figure><p><img src="/images/1515466040741.webp" alt></p><ul><li>第1行<code>!path</code>指定了类路径</li><li>第2行<code>!define</code>指定当前为slim测试</li><li>第4行<code>demo.CalculatorDemo</code>指定了完整的类名</li><li>第5行指定了输入数据和输出数据</li><li>第6行及以后为实际测试数据</li></ul><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><video src="fitnesse.mp4" type="video/mp4" controls="controls" width="100%" height="100%"><br></video><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个试用感觉FitNesse还不错，wiki形式的测试易理解易于团队成员间沟通，非常适用于后台接口测试。后续我将用FitNesse对后台接口进行测试，看看效果如何。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Android之应用启动速度</title>
      <link href="2017/12/21/app-launch-time/"/>
      <url>2017/12/21/app-launch-time/</url>
      
        <content type="html"><![CDATA[<p>译自Android官方的<a href="https://developer.android.google.cn/topic/performance/launch-time.html?hl=zh-cn" target="_blank" rel="noopener">应用启动性能</a>。文章讨论了应用启动过程，如何分析启动性能，以及常见的启动性能问题。非常值得学习。<br><a id="more"></a></p><p>用户期望应用快速响应和加载。启动缓慢的应用不符合用户这种预期，会让用户感到失望。糟糕的启动速度会导致用户差评，甚至卸载你的应用。</p><p>这篇文章讨论了如何优化应用启动性能。文章首先解释了启动过程内部是如何运作的。然后，讨论了该如何分析启动性能。最后，文章给出了一些常见的启动问题，以及若干如何解决这些问题的建议。</p><h1 id="Launch-Internals"><a href="#Launch-Internals" class="headerlink" title="Launch Internals"></a>Launch Internals</h1><p>应用启动有三种可能的状态，这些状态会对应用启动时间产生影响。启动状态分为：cold start, warm start, lukewarm start。在cold start中，应用是完全从头启动。而其他两种启动状态，系统只需要将应用从后台调到前台。建议你基于cold start来进行优化。对cold start启动速度进行优化，也会提升warm start和lukewarm启动速度。</p><p>理解应用启动时在系统及应用层面发生了什么，以及每种启动状态下系统和应用是如何交互的，有助于优化应用启动速度。</p><h2 id="Cold-start"><a href="#Cold-start" class="headerlink" title="Cold start"></a>Cold start</h2><p>cold start是指应用从头启动：在系统中应用进程不存在，直到应用启动并创建进程。cold start发生于设备启动后第一次启动应用，或系统已杀死了应用进程。优化这种状态的启动速度挑战最大，因为系统和应用要比其他启动状态下做更多的事情。</p><p>在cold start的开始阶段，系统有三个任务，分别是：</p><ol><li>加载并启动应用</li><li>启动后立刻显示一个空白窗口</li><li>创建应用进程</li></ol><p>系统创建应用进程后，应用进程负责接下来的任务，包括：</p><ol><li>创建application对象</li><li>启动主线程</li><li>创建主activity</li><li>加载布局</li><li>Layout</li><li>Draw</li></ol><p>一旦应用进程完成第一次绘制，系统将使用主activity替换原先的空白窗口。到这时，用户可以使用应用了。</p><p><img src="https://developer.android.google.cn/topic/performance/images/cold-launch.png?hl=zh-cn" alt></p><p>性能问题可能出现在application创建阶段或activity创建阶段。</p><h3 id="Application-creation"><a href="#Application-creation" class="headerlink" title="Application creation"></a>Application creation</h3><p>从启动应用到系统完成应用第一次绘制，屏幕上会一直显示空白的启动窗口。应用进程完成第一次绘制，系统将使用主activity替换原先的启动窗口，允许用户跟应用交互。</p><p>如果重载<a href="https://developer.android.google.cn/reference/android/app/Application.html?hl=zh-cn#onCreate(" target="_blank" rel="noopener">Application.oncreate()</a>)，系统会调用自定义app对象的<code>onCreate()</code>方法。此后，应用会创建主线程，并在主线程中创建主activity。</p><p>此后，系统层面和应用层面进程继续按照<a href="https://developer.android.google.cn/guide/topics/processes/process-lifecycle.html?hl=zh-cn" target="_blank" rel="noopener">app lifecycle stages</a>进行。</p><h3 id="Activity-creation"><a href="#Activity-creation" class="headerlink" title="Activity creation"></a>Activity creation</h3><p>应用进程创建activity之后，activity执行下列操作：</p><ol><li>初始化</li><li>调用构造方法</li><li>调用跟当前生命周期对应的回调方法，比如<code>Activity.onCreate()</code></li></ol><p>通常<code>onCreate()</code>方法对加载时间影响最大，因为它承受最大负载：加载view，以及初始化activity运行所需要的对象。</p><h2 id="Warm-start"><a href="#Warm-start" class="headerlink" title="Warm start"></a>Warm start</h2><p>warm start比cold start简单得多，开销也小。warm start中系统要做的不过是将activity调到前台。如果应用中的activity仍然存活，应用不需要再次初始化对象，加载和渲染布局。</p><p>某些对象可能在响应<code>onTrimMemory()</code>时被释放掉了，则需要在warm start时重新创建。</p><p>warm start跟cold start场景有相同的开场：系统会显示一个空白窗口直到应用渲染完activity。</p><h2 id="Lukewark-start"><a href="#Lukewark-start" class="headerlink" title="Lukewark start"></a>Lukewark start</h2><p>lukewarm start包含cold start中的某些操作。同时，它比warm start又少了一些开销。下列状态可以视为lukewarm start。比如：</p><ul><li>用户退出应用然后重新启动。进程可能还在运行，但应用必须完全创建activity</li><li>系统从内存中移除应用，然后用户重新打开应用。进程和activity都要重启，但重启时可以使用<code>onCreate()</code>中的instance state bundle参数</li></ul><h1 id="分析启动性能"><a href="#分析启动性能" class="headerlink" title="分析启动性能"></a>分析启动性能</h1><p>为了诊断启动时间，可以观察应用启动时花了多长时间。</p><blockquote><p><strong>注意：</strong> 使用non-debuggable模式的app进行分析。debuggable模式会开启debug特性，可能导致跟真实用户不一样的启动时间。</p></blockquote><h2 id="初次显示时间"><a href="#初次显示时间" class="headerlink" title="初次显示时间"></a>初次显示时间</h2><p>有两种方式统计初次显示时间，一种是在logcat日志中找包含<code>Displayed</code>的行，另一种是使用<a href="https://developer.android.google.cn/studio/command-line/shell.html?hl=zh-cn#am" target="_blank" rel="noopener">ADB Shell Activity Manager</a>。下面分别介绍：</p><p>从Android 4.4(API level 19)开始，logcat会输出包含<code>Displayed</code>的行。<code>Displayed</code>表示启动进程到将activity绘制到屏幕耗费的时间。这个时间包含以下事件：</p><ol><li>启动进程</li><li>初始化对象</li><li>创建和初始化activity</li><li>加载布局</li><li>绘制activity</li></ol><p><code>Displayed</code>类似这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityManager: Displayed com.android.myexample/.StartupTiming: +3s534ms</span><br></pre></td></tr></table></figure><blockquote><p>The Displayed metric in the logcat output does not necessarily capture the amount of time until all resources are loaded and displayed: it leaves out resources that are not referenced in the layout file or that the app creates as part of object initialization. It excludes these resources because loading them is an inline process, and does not block the app’s initial display.</p></blockquote><p>有时<code>Displayed</code>行中还包含一个额外的total time字段。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityManager: Displayed com.android.myexample/.StartupTiming: +3s534ms (total +1m22s643ms)</span><br></pre></td></tr></table></figure><blockquote><p>In this case, the first time measurement is only for the activity that was first drawn. The total time measurement begins at the app process start, and could include another activity that was started first but did not display anything to the screen. The total time measurement is only shown when there is a difference between the single activity and total startup times.</p></blockquote><p>也可以使用<a href="https://developer.android.google.cn/studio/command-line/shell.html?hl=zh-cn#am" target="_blank" rel="noopener">ADB Shell Activity Manager</a>。使用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb [-d|-e|-s &lt;serialNumber&gt;] shell am start -S -W</span><br><span class="line">com.example.app/.MainActivity</span><br><span class="line">-c android.intent.category.LAUNCHER</span><br><span class="line">-a android.intent.action.MAIN</span><br></pre></td></tr></table></figure><p>logcat中仍然输出<code>Displayed</code>日志。而终端以上命令输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Starting: Intent</span><br><span class="line">Activity: com.example.app/.MainActivity</span><br><span class="line">ThisTime: 2044</span><br><span class="line">TotalTime: 2044</span><br><span class="line">WaitTime: 2054</span><br><span class="line">Complete</span><br></pre></td></tr></table></figure><p>具体到我们的app是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -S -W com.tc.igame/.view.common.activity.SplashActivity -c android.intent.category.LAUNCHER -a android.intent.action.MAIN</span><br><span class="line">Stopping: com.tc.igame</span><br><span class="line">Starting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.tc.igame/.view.common.activity.SplashActivity &#125;</span><br><span class="line">Status: ok</span><br><span class="line">Activity: com.tc.igame/.view.common.activity.IndexActivity</span><br><span class="line">ThisTime: 1312</span><br><span class="line">TotalTime: 2128</span><br><span class="line">WaitTime: 2131</span><br><span class="line">Complete</span><br></pre></td></tr></table></figure><h2 id="完整显示时间"><a href="#完整显示时间" class="headerlink" title="完整显示时间"></a>完整显示时间</h2><p>可以使用<a href="https://developer.android.google.cn/reference/android/app/Activity.html?hl=zh-cn#reportFullyDrawn(" target="_blank" rel="noopener">reportFullyDrawn()</a>)来统计应用启动到完全显示所有资源和视图的时间。如果应用使用延迟加载，这个方法就非常有价值。在延迟加载过程中，应用并不会阻塞窗口的初始绘制，而是异步加载资源并更新视图。</p><p>如果由于延迟加载导致应用的初次展示时并不包含所有资源，可以考虑将完整加载和显示所有资源及视图作为另一种度量标准。</p><p>为了解决这种问题，可以手动调用<a href="https://developer.android.google.cn/reference/android/app/Activity.html?hl=zh-cn#reportFullyDrawn(" target="_blank" rel="noopener">reportFullyDrawn()</a>)通知系统activity已经完成延迟加载。使用这个方法时，logcat中输出的值是app对象创建到<a href="https://developer.android.google.cn/reference/android/app/Activity.html?hl=zh-cn#reportFullyDrawn(" target="_blank" rel="noopener">reportFullyDrawn()</a>)被调用的时间。输出类似这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system_process I/ActivityManager: Fully drawn &#123;package&#125;/.MainActivity: +1s54ms</span><br></pre></td></tr></table></figure><p>注意：这个时间包含前面提到的<code>total</code></p><p>定位瓶颈</p><p>定位启动性能瓶颈的两个好方式是使用Android Studio提供的<a href="https://developer.android.google.cn/studio/profile/am-methodtrace.html?hl=zh-cn" target="_blank" rel="noopener">Method Tracer tool</a>。注意，现在被新的工具CPU Profiler替换，见<a href="https://developer.android.google.cn/studio/profile/cpu-profiler.html?hl=zh-cn" target="_blank" rel="noopener">这里</a>。</p><p>如果不能使用Method Tracer tool，或者无法在准确的时机启动工具来获取日志信息，也可以在app和activity的<code>onCreate()</code>方法中使用inline tracing来获取日志。具体见<a href="https://developer.android.google.cn/reference/android/os/Trace.html?hl=zh-cn" target="_blank" rel="noopener">Trace</a>和<a href="https://developer.android.google.cn/studio/profile/systrace-commandline.html?hl=zh-cn" target="_blank" rel="noopener">Systrace</a>。</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="过重的app初始化"><a href="#过重的app初始化" class="headerlink" title="过重的app初始化"></a>过重的app初始化</h2><p>这一部分讨论会影响启动性能的若干严重问题。这些问题主要是关于初始化app和activity对象的，以及加载窗口(the loading of screens)</p><h2 id="过重的activity初始化"><a href="#过重的activity初始化" class="headerlink" title="过重的activity初始化"></a>过重的activity初始化</h2><p>如果你重载了<code>Application</code>对象，并且执行了过重或过复杂的逻辑来初始化这个对象，可能导致启动时的性能问题。如果你做了目前还不需要的初始化，其实是在浪费时间。而某些初始化则完全没必要。比如，for example, initializing state information for the main activity, when the app has actually started up in response to an intent. With an intent, the app uses only a subset of the previously initialized state data</p><p>另一个问题是应用初始化时的GC事件有影响或过多，或者初始化时正在发生磁盘IO，进一步阻塞初始化。Dalvik运行时中GC是一个需要考虑的影响因素，而Art运行时GC基本是并发的，已经最小化GC对应用的影响。</p><h3 id="诊断问题"><a href="#诊断问题" class="headerlink" title="诊断问题"></a>诊断问题</h3><p>可以使用Method tracing或inline tracing来诊断问题</p><h4 id="Method-tracing"><a href="#Method-tracing" class="headerlink" title="Method tracing"></a>Method tracing</h4><p>使用Method Tracer tool找到<a href="https://developer.android.google.cn/reference/android/app/Instrumentation.html?hl=zh-cn#callApplicationOnCreate(android.app.Application" target="_blank" rel="noopener">callApplicationOnCreate()</a>)方法，该方法最终会调用自定义的<code>Application.onCreate()</code>方法。如果显示这个方法执行时间过长，则需要进一步看看具体原因。</p><h4 id="Inline-tracing"><a href="#Inline-tracing" class="headerlink" title="Inline tracing"></a>Inline tracing</h4><p>使用inline tracing分析可疑的地方，包括：</p><ul><li>app的<code>onCreate()</code>方法</li><li>app初始化的全局单例对象</li><li>磁盘IO，反序列化，瓶颈中可能出现的循环</li></ul><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>可能有很多潜在的瓶颈，但有两个常见的问题及解决办法：</p><ul><li>view层级越深，app需要越多的时间来加载。解决这个问题的两个步骤：<ul><li>通过减少冗余或嵌套的布局来对view层级平坦化</li><li>启动期间不需要可见的某些UI，不必加载。可以使用<a href="https://developer.android.google.cn/reference/android/view/ViewStub.html?hl=zh-cn" target="_blank" rel="noopener">ViewStub</a>替换，并在更恰当的时机加载这些布局</li></ul></li><li>在主线程中初始化全部资源会拖慢启动速度。按下列方式解决这个问题：<ul><li>将全部的资源初始化过程放在别的地方，app可以在其他线程中延迟加载</li><li>允许应用加载和显示view，但此后再更新那些依赖bitmap和其他资源的视觉属性</li></ul></li></ul><h2 id="Themed-launch-screens"><a href="#Themed-launch-screens" class="headerlink" title="Themed launch screens"></a>Themed launch screens</h2><p>可能你修改应用的加载体验进行样式化，以便app的启动页看起来跟app的其他部分一致，而非系统样式。这个办法可以从体验上加快activity的体验速度(实际并没有)。</p><p>一种常见的实现方式是使用<a href="https://developer.android.google.cn/reference/android/R.attr.html?hl=zh-cn#windowDisablePreview" target="_blank" rel="noopener">windowDisablePreview</a>来关闭初始的空白窗口。但是这种方法可能导致更长的启动时间。另外，它强制用户在activity启动时必须等待且无任何反馈，让用户以为app功能不正常。</p><h3 id="诊断问题-1"><a href="#诊断问题-1" class="headerlink" title="诊断问题"></a>诊断问题</h3><p>当用户启动应用时发现响应很慢。并且屏幕像是”冻”住了，或者对输入无响应。</p><h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><p>建议不要关闭preview window。可以使用activity的<code>windowBackground</code>来提供一个简单的自定义drawable</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layer-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> <span class="attr">android:opacity</span>=<span class="string">"opaque"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- The background color, preferably the same as your normal theme --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@android:color/white"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Your product logo - 144dp color version of your app icon --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bitmap</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:src</span>=<span class="string">"@drawable/product_logo_144dp"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:gravity</span>=<span class="string">"center"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity ...</span><br><span class="line">android:theme=&quot;@style/AppTheme.Launcher&quot; /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure this is before calling super.onCreate</span></span><br><span class="line">    setTheme(R.style.Theme_MyApp);</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在manifest文件中引用定义好的drawable文件。之后可以在<code>onCreate()</code>方法中的<code>super.onCreate()</code>之前调用<a href="https://developer.android.google.cn/reference/android/view/ContextThemeWrapper.html?hl=zh-cn#setTheme(int" target="_blank" rel="noopener">setTheme(R.style.AppTheme)</a>)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android之输出Handler日志</title>
      <link href="2017/12/15/looper-log/"/>
      <url>2017/12/15/looper-log/</url>
      
        <content type="html"><![CDATA[<p>今天看到一篇文章提到了给Looper加日志以观察GC，发现这个Looper打日志这个小技巧有助于调试UI卡顿问题，我们学学这个技巧吧。<br><a id="more"></a></p><p>通过统计主线程<code>Looper</code>中每个Message的耗时，很容易找出主线程耗时过多的操作。这些操作往往是导致UI卡顿的罪魁祸首。</p><p>你可能会说，我在<code>Handler.handMessage()</code>中也可以添加计时代码呀，在<code>Looper</code>中统计有什么好处？如果是你自己写的<code>Handler</code>的确也很容易统计，但如果是别人写的呢，如果是第三方库中的呢？另一方面，即便自己写的，如何保证新加的<code>Handler</code>不会遗漏计时代码？所以这种做法并不可取。看看更好的做法是怎样的。</p><h1 id="setMessageLogging"><a href="#setMessageLogging" class="headerlink" title="setMessageLogging()"></a>setMessageLogging()</h1><p>注释文档中说，<code>setMessageLogging()</code>用于当前Looper处理Message时打印日志。</p><ul><li>传null参数关闭日志功能，传非null的<code>printer</code>开启日志功能</li><li>开启日志功能后，会在每个Message分发的开始以及结束时输出日志信息到<code>printer</code>，具体的日志信息包括区分Message的目标Hander以及Message内容</li></ul><p>对照<code>loop()</code>方法源码(省略无关部分)，跟上面描述一致。所以这里不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.os.Looper.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Control logging of messages as they are processed by this Looper.  If</span></span><br><span class="line"><span class="comment"> * enabled, a log message will be written to &lt;var&gt;printer&lt;/var&gt;</span></span><br><span class="line"><span class="comment"> * at the beginning and ending of each message dispatch, identifying the</span></span><br><span class="line"><span class="comment"> * target Handler and message contents.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> printer A Printer object that will receive log messages, or</span></span><br><span class="line"><span class="comment"> * null to disable message logging.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessageLogging</span><span class="params">(@Nullable Printer printer)</span> </span>&#123;</span><br><span class="line">    mLogging = printer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="输出Handler日志"><a href="#输出Handler日志" class="headerlink" title="输出Handler日志"></a>输出Handler日志</h1><p>界面上有一个使用<code>Handler</code>实现的轮播图，每隔5秒发消息切换到下一张图片。我们给它加上日志功能，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Looper.getMainLooper().setMessageLogging(<span class="keyword">new</span> Printer() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 为了便于logcat中观察, 我们只输出当前页面的日志</span></span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span> &amp;&amp; x.contains(<span class="string">"EventCenterFragment"</span>)) &#123;</span><br><span class="line">            Log.i(CmPerf.TAG, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="looper-log.gif" alt></p><p>每次切换图片时会输出如下格式的日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12-12 10:35:38.614 9542-9542 I: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (com.tc.igame.view.common.fragment.EventCenterFragment$1) &#123;101c258&#125; null: 1</span><br><span class="line">12-12 10:35:38.615 9542-9542 I: &lt;&lt;&lt;&lt;&lt; Finished to Handler (com.tc.igame.view.common.fragment.EventCenterFragment$1) &#123;101c258&#125; null</span><br><span class="line">12-12 10:35:43.617 9542-9542 I: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (com.tc.igame.view.common.fragment.EventCenterFragment$1) &#123;101c258&#125; null: 1</span><br><span class="line">12-12 10:35:43.618 9542-9542 I: &lt;&lt;&lt;&lt;&lt; Finished to Handler (com.tc.igame.view.common.fragment.EventCenterFragment$1) &#123;101c258&#125; null</span><br></pre></td></tr></table></figure><p><code>Dispatching to Handler</code>和<code>Finished to Handler</code>对应首一次Message处理过程。我们可以根据这种特定的日志格式为每个Message处理加上耗时统计。具体做这可参考《为你的android程序加上gc监控吧！》，这里不展开。</p><hr><p>补充</p><p>《为你的android程序加上gc监控吧！》中提到的gc监控做法太过复杂，并不可取。实际上，Android 6.0(API 23)之后art虚拟机支持如下方式获取gc次数和gc耗时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Debug.getRuntimeStat(<span class="string">"art.gc.gc-count"</span>);</span><br><span class="line">Debug.getRuntimeStat(<span class="string">"art.gc.gc-time"</span>);</span><br></pre></td></tr></table></figure><p>我们直接调用系统API即可很方便地获取到gc次数和gc耗时。</p><p>添加如下代码并在Android Monitor中强制gc，观察输出的日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Looper.getMainLooper().setMessageLogging(<span class="keyword">new</span> Printer() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span> &amp;&amp; x.contains(<span class="string">"EventCenter"</span>) &amp;&amp; x.contains(<span class="string">"Finished to Handler"</span>)) &#123;</span><br><span class="line">            Log.i(CmPerf.TAG, <span class="string">"looper println: count="</span> + Debug.getRuntimeStat(<span class="string">"art.gc.gc-count"</span>));</span><br><span class="line">            <span class="comment">//Log.i(CmPerf.TAG, "looper println: time=" + Debug.getRuntimeStat("art.gc.gc-time"));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><video src="art-gc-count.mp4" type="video/mp4" controls="controls" width="100%" height="100%"><br></video><p>GC日志参考</p><ul><li><a href="http://www.ayqy.net/blog/android-gc-log%E8%A7%A3%E8%AF%BB/" target="_blank" rel="noopener">Android GC Log解读 | 黯羽轻扬</a></li><li><a href="https://juejin.im/entry/5625144060b2b199f769ef74" target="_blank" rel="noopener">Android GC 那点事 - Android - 掘金</a></li><li><a href="http://gityuan.com/2015/10/03/Android-GC/" target="_blank" rel="noopener">Dalvik与ART的GC调试 - Gityuan博客 | 袁辉辉博客</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown之贴图小技巧</title>
      <link href="2017/12/14/improve-markdown-workflow/"/>
      <url>2017/12/14/improve-markdown-workflow/</url>
      
        <content type="html"><![CDATA[<p>最近使用Markdown写博客比较勤，发现Markdown中贴图十分烦琐。而作为程序员又经常有博客中贴代码截图的需求，那么如何快速贴图呢？<br><a id="more"></a><br>在你继续阅读前，我需要申明一下：</p><ul><li>我在Mac系统上使用Markdown写博客</li><li>我的博客图片不使用第三方图床，而是直接放在GitHub</li></ul><p>如果你的工作环境跟我不同，我的做法可能未必适合你！</p><h1 id="常规贴图方式的问题"><a href="#常规贴图方式的问题" class="headerlink" title="常规贴图方式的问题"></a>常规贴图方式的问题</h1><p>Mac上有两种截图方式。一是 <code>Control + Shift + Command + 4</code> 截图到剪贴板，二是 <code>Shift + Command + 4</code> 截图保存到桌面。</p><ul><li>第一种方式并不方便直接粘贴到Markdown文本中</li><li>第二种方式是将截好的图片保存到桌面</li></ul><p>我使用第二种方式截图。但为了把这张图片放在博客中，我必须手动将其移到博客中的图片文件夹，然后在博客中使用<code>![]()</code>来引用这张图片。想想你就知道有多繁琐，尤其连续给代码截图时会非常不便。难怪写博客效率低！</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>解决方案是将剪切板中的图片保存到博客中指定的目录，并以<code>![]()</code>这种格式自动生成该图片的引用，并将这个引用写入剪切板。这样，我们就可以直接使用<code>Command + V</code>将图片引用复制到博客。听起来很方便一样，如何操作呢？我们先看有哪几个关键点：</p><ul><li>如何访问剪切板图片</li><li>如何生成图片引用</li><li>如何将图片引用写入剪切板</li><li>如何自动化</li></ul><p>第四点是最最重要的，我们会用到Mac自带的Automator来实现自动化。</p><h2 id="如何访问剪切板图片"><a href="#如何访问剪切板图片" class="headerlink" title="如何访问剪切板图片"></a>如何访问剪切板图片</h2><p>直接上代码，代码来自<a href="http://www.jianshu.com/p/7bd4e6ed99be" target="_blank" rel="noopener">简化markdown写作中的贴图流程 - 简书</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># clipboard2.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> AppKit <span class="keyword">import</span> NSPasteboard, NSPasteboardTypePNG, NSPasteboardTypeTIFF</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">BLOG = <span class="string">'/Users/kingcmchen/blog/source/images/'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy_to_blog</span><span class="params">(img_path)</span>:</span></span><br><span class="line">    img_input = file(img_path, <span class="string">'rb'</span>)</span><br><span class="line">    name = os.path.basename(img_input.name)</span><br><span class="line">    img_output = file(BLOG + name, <span class="string">'wb'</span>)</span><br><span class="line">    img_output.writelines(img_input.readlines())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'![](/images/'</span> + name + <span class="string">')'</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_paste_img_file</span><span class="params">()</span>:</span></span><br><span class="line">    pb = NSPasteboard.generalPasteboard()</span><br><span class="line">    data_type = pb.types()</span><br><span class="line">    <span class="comment"># if img file</span></span><br><span class="line">    <span class="comment">#print data_type</span></span><br><span class="line">    now = int(time.time() * <span class="number">1000</span>) <span class="comment"># used for filename</span></span><br><span class="line">    <span class="keyword">if</span> NSPasteboardTypePNG <span class="keyword">in</span> data_type:</span><br><span class="line">        <span class="comment"># png</span></span><br><span class="line">        data = pb.dataForType_(NSPasteboardTypePNG)</span><br><span class="line">        filename = <span class="string">'%s.png'</span> % now</span><br><span class="line">        filepath = <span class="string">'/tmp/%s'</span> % filename</span><br><span class="line">        ret = data.writeToFile_atomically_(filepath, <span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            <span class="keyword">return</span> filepath</span><br><span class="line">    <span class="keyword">elif</span> NSPasteboardTypeTIFF <span class="keyword">in</span> data_type:</span><br><span class="line">        <span class="comment"># tiff</span></span><br><span class="line">        data = pb.dataForType_(NSPasteboardTypeTIFF)</span><br><span class="line">        filename = <span class="string">'%s.tiff'</span> % now</span><br><span class="line">        filepath = <span class="string">'/tmp/%s'</span> % filename</span><br><span class="line">        ret = data.writeToFile_atomically_(filepath, <span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            <span class="keyword">return</span> filepath</span><br><span class="line">    <span class="keyword">elif</span> NSPasteboardTypeString <span class="keyword">in</span> data_type:</span><br><span class="line">        <span class="comment"># string todo, recognise url of png &amp; jpg</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#print(get_paste_img_file())</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(copy_to_blog(get_paste_img_file()))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>代码含义如下：</p><ul><li><code>get_paste_img_file()</code> - 获取保存到剪贴板中的截图路径</li><li><code>copy_to_blog()</code> - 将剪贴板截图保存到我的博客中的<code>images</code>目录下，并返回markdown格式的图片路径</li></ul><!--# Alfred自动化1. 下载安装[Alfred - Productivity App for Mac OS X](https://www.alfredapp.com/)2. 解锁Alfred Workflows功能。好吧，这个花钱的，19美元3. ...今天没有带信用卡，搞不定...http://www.jianshu.com/p/7bd4e6ed99behttps://www.zhihu.com/question/20656680http://www.jianshu.com/p/e9f3352c785fhttp://www.jianshu.com/p/0e78168da7ab--><h2 id="Automator自动化"><a href="#Automator自动化" class="headerlink" title="Automator自动化"></a>Automator自动化</h2><p>原本打算使用Alfred自动化生成图片引用，但发现利用Mac自带的Automator也可改进贴图流程。只需要在Automator中配置好<code>clipboard2.py</code>这个脚本，我们可以非常便捷地向markdown贴图：</p><p><img src="/images/1513241525096.webp" alt></p><p>完整的操作流程如下：</p><ol><li>先使用<code>Control + Shift + Command + 4</code>命令截图到剪贴板</li><li>在Automator中点击”运行”，执行<code>clipboard2.py</code>脚本</li><li>在Markdown文件中<code>Command + V</code>，以<code>![]()</code>这种格式粘贴刚才的截图</li></ol><p>比手工操作方便快捷多了吧?</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><ul><li>Gifox</li><li><a href="https://jietu.qq.com/" target="_blank" rel="noopener">Jietu</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 读写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我收集的技术博客</title>
      <link href="2017/12/14/favorite-blogs/"/>
      <url>2017/12/14/favorite-blogs/</url>
      
        <content type="html"><![CDATA[<p>本文收集了一些值得我学习的博客，备忘。<br><a id="more"></a></p><p><a href="http://gityuan.com/tags/#android" target="_blank" rel="noopener">Category - Gityuan博客 | 袁辉辉博客</a></p><p><a href="http://yifeng.studio/2017/11/27/20-excellent-resources-for-learning-kotlin/" target="_blank" rel="noopener">http://yifeng.studio/2017/11/27/20-excellent-resources-for-learning-kotlin/</a></p><p><a href="http://whuhan2013.github.io/" target="_blank" rel="noopener">良有以也</a> 这个人知识面非常广</p><p><a href="http://whuhan2013.github.io/blog/2016/05/15/android-sharp-blog/" target="_blank" rel="noopener">Android开发相关的Blog推荐 - 良有以也</a></p><p><a href="http://whuhan2013.github.io/blog/2016/04/23/mobil-read-book/" target="_blank" rel="noopener">移动开发必读书单 - 良有以也</a></p><p><a href="http://blog.topspeedsnail.com/archives/3299" target="_blank" rel="noopener">Linux：fg, bg 和 jobs 命令示例 – WTF Daily Blog</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 读写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown之使用技巧收集</title>
      <link href="2017/12/14/writing-tools/"/>
      <url>2017/12/14/writing-tools/</url>
      
        <content type="html"><![CDATA[<p>本文收集了一些Markdown使用技巧。<br><a id="more"></a></p><p><a href="http://www.sunmoonblog.com/2017/12/14/improve-markdown-workflow/">改进Markdown贴图流程 | Sunmoon的博客</a></p><p><a href="https://www.zhihu.com/question/21065229" target="_blank" rel="noopener">Markdown中插入图片有什么技巧？ - 知乎</a> 来自知乎</p><p><a href="https://jiantuku.com/#/" target="_blank" rel="noopener">极简图床</a> 不知靠谱否</p><p><a href="http://www.jianshu.com/p/7bd4e6ed99be" target="_blank" rel="noopener">简化markdown写作中的贴图流程 - 简书</a> 贴图真是个麻烦事。这篇文章中提到了Alfred工作流，可以提高效率</p><p><a href="http://whuhan2013.github.io/blog/2015/09/19/markdown-simple-grammar/" target="_blank" rel="noopener">Markdown 简明语法参考 - 良有以也</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 读写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Android多进程应用</title>
      <link href="2017/12/14/multi-process-android-app-1/"/>
      <url>2017/12/14/multi-process-android-app-1/</url>
      
        <content type="html"><![CDATA[<p>Android官网上只是简单地提到了进程，但应用开发中使用多进程会遇到各种各样的问题。本文讨论了其中一些问题，也许能给你解决问题的思路。</p><a id="more"></a><p>原文：<a href="http://engineering.life360.com/engineering/2016/06/10/multi-process-android-apps/" target="_blank" rel="noopener">Making Multi-process Android applications</a><br>译文：<a href="#">译文</a></p><p>可以让Android应用中的不同组件运行在不同的进程。有时这种做法是必要的，可以改进应用性能。但你必须意识到，官方网站上并没有太多关于Android多进程应用的文档，而且多进程应用也不容易理解。我们看看何时它会很有用，有何挑战以及如何解决。</p><p>缺省时所有Android应用组件都运行在相同的Linux进程中。但也可以让不同组件运行在不同的进程。许多场景下多进程很有用。我们来看看。</p><p>Android会不时杀死进程回收内存，以提供给更重要的进程。Android使用重要性等级来决定该杀死和保留哪个进程。占用内存高的后台进程更可能被Android杀死。如果你将后台组件(service, content provider)和前台组件(activity)放在同一个进程，该进程会使用更多的内存。当应用进入后台，它更可能被杀死。Android杀死进程时后杀死其中所有的组件。为了将后台组件跟UI的生命周期解耦，最好将其独立到一个独立的进程。</p><p>比如，如果应用需要在客户端和服务器端之间同步数据时，它可以在独立进程中的service中进行同步。这可以让后台进程更少重启，让其独立于UI进程的生命周期。另外，UI进程中的崩溃和异常对后台进程没有任何影响。反之亦然。</p><p>使用多进程的另一个原因是多个特性完全不同且独立。比如，如果应用支持Email, Calendar, Contacts, Notes以及Tasks，其中每个特性可以在独立进程中运行以保持各自的生命周期独立。</p><h1 id="如何运行多进程"><a href="#如何运行多进程" class="headerlink" title="如何运行多进程"></a>如何运行多进程</h1><p><code>&lt;activity&gt;</code>, <code>&lt;service&gt;</code>, <code>&lt;receiver&gt;</code>以及<code>&lt;provider&gt;</code>都支持<code>&lt;android:process&gt;</code>属性，该属性可以指定组件运行的进程。多个组件也可以共享同一个进程，指定多少进程就能启动多少进程。</p><h1 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h1><p>当Android应用使用多进程时，需要处理进程间的数据一致性。甚至你的代码结构良好，在运行时也不太容易知道哪段代码在哪个进程运行。</p><h2 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h2><p>尽管可以在多个独立进程中运行不同独立逻辑，某些时候它们仍然需要共享数据。如果你使用文件，数据库或者shared preferences，你可能遇到跨进程数据不一致问题。如果使用文件，你需要监听其他进程对文件进行的修改。如果从多个进程访问数据库，你可能会遇到非常难以调试的数据库冲突或死锁问题。如果使用shared preferences，必须使用多进程模式打开它，并且使用<code>OnSharedPreferenceChangeListener</code>监听其他进程导致的变化。</p><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>单例是在Android应用中跨组件共享状态信息和数据的简单办法。可以使用<code>synchronized</code>关键字保证单例的方法是线程安全的。但如果在多进程应用中使用单例，可能生成的单例对象数量跟进程数量一样多。因为进程并不共享地址空间，所以一个进程中的单例对象对其他进程并不可见。如果使用shared preferences，数据库或文件中的数据初始化单例，要让(不同进程中的)每个单例对象保持一致的数据非常困难，而且很可能它们在运行时有不同的数据状态。另外，<code>synchronized</code>对这种情况不起作用。看看代码中单例的通常用法。</p><p><img src="http://engineering.life360.com/images/android-multiproc-singletons.webp" alt></p><p>假设我们有一个单例类，不妨称之为<code>SubscriptionManager</code>，它会跟踪用户订阅。在这个类中更新订阅内容。同时你将数据保存到文件以供离线访问。如果数据文件存在的话，由这些文件初始化单例。有两个进程：主进程和后台进程。在一个工具类中检查用户是否订阅了某个内容，该类会被主进程和后台进程调用。用户调用<code>SubscriptionManager.getInstance(context).updateSubscription(feature, subscription);</code>从主进程订阅。这个调用更新了订阅内容，发送到后台并且更新了文件。</p><p>在这种情况下，后台进程中的<code>SubscriptionManager</code>并不知道主进程中发生的这次订阅，除非你在数据文件中设置了<code>FileObserver</code>，监听数据变化更进行相应更新。或者，你也可以使用广播机制来通知这次订阅。所以说，使用这些方式在进程间共享数据非常复杂，并不是最佳方案。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>Android通过<code>Binder</code>接口提供进程间通信(IPC)。<a href="https://developer.android.com/guide/topics/providers/content-providers.html" target="_blank" rel="noopener">Content providers</a>和<a href="https://developer.android.com/guide/components/services.html#CreatingBoundService" target="_blank" rel="noopener">Bound services</a>使用binder接口来跨进程通信。所以本方案使用这种方式来维护多进程间数据和状态的一致性。</p><h2 id="Content-Provider"><a href="#Content-Provider" class="headerlink" title="Content Provider"></a>Content Provider</h2><p>ContentProvider用于管理对结构化数据的访问。它们封装数据并且提供数据安全机制。ContentProvider是在当前进程的数据跟其他进程的代码之间建立联系的标准接口。(Content providers are the standard interface that connects data in one process with code running in another process)</p><p><img src="http://engineering.life360.com/images/android-multiproc-content-providers.webp" alt></p><p>尽管ContentProvider本是用于应用间共享数据，它也可以用于在多进程之间共享数据。Android保证跨进程时ContentProvider的单一性。<a href="https://developer.android.com/reference/android/content/ContentResolver.html" target="_blank" rel="noopener">ContentResolver</a>提供易用的接口，所以应用代码不必担心IPC细节。</p><p>注意：如果不想在应用外共享数据， <strong>不要</strong> 在manifest中对外暴露ContentProvider(<code>android:export=&quot;false&quot;</code>)</p><p>尽管ContentProvider和ContentResolver的”CURD” API主要被设计为共享SQL数据库中的数据，也可以扩展更通用的<a href="https://developer.android.com/reference/android/content/ContentResolver.html" target="_blank" rel="noopener"><code>call(android.net.Uri, java.lang.String, java.lang.String, android.os.Bundle)</code></a> API以实现应用特定的目的。</p><p>比如：在上述例子的<code>SubscriptionManager</code>，你可以提供如下API来检查和更新订阅：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ContentResolver resolver = getContentResolver(); </span><br><span class="line">Bundle result = resolver.call(“SubcriptionCheck”, arg, extras);</span><br></pre></td></tr></table></figure><h2 id="Bound-Service"><a href="#Bound-Service" class="headerlink" title="Bound Service"></a>Bound Service</h2><p>Bound service是客户端-服务器接口中的服务器端。Bound service允许组件(比如activity)绑定到service，发送请求，接收响应，甚至执行IPC</p><p><img src="http://engineering.life360.com/images/android-multiproc-bound-service.webp" alt></p><p>有两种方式实现IPC：Messengers和AIDL。Messenger方式更简单一些。两种方式中Android框架都做好了IPC底层工作(marshalling, unmarshalling, RPC)，IPC对调用方是透明的。跟service通信的步骤如下：</p><ul><li>bindService</li><li>连接到service时收到回调</li><li>使用binder接口发送请求，或调用service API</li><li>从service接收响应</li></ul><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>可以使用intent在另一个进程中启动service，或者从代码中的任何地方发送广播，并且在另外的进程中接收该广播并启动一个service来处理它。</p><p>比如你有一个测量系统用于捕获应用中的某些事件，可以将每次测量发送到service，让service将其写入数据库或发送到后台，而不是让代码中到处都是数据库或网络操作。</p><h1 id="Application类的坑"><a href="#Application类的坑" class="headerlink" title="Application类的坑"></a>Application类的坑</h1><p>你可以实现<code>Application</code>的子类，并且在<code>AndroidManifest.xml</code>的<code>&lt;application&gt;</code>标签的<code>&lt;android:name</code>&gt;属性中指定这个类的全名。当应用进程启动时，你实现的<code>Application</code>子类会最先初始化。</p><p>要注意的是，应用中启动的每一个进程都会执行上述初始化。不幸的是，并不能为不同的进程指定不同的Application类。</p><p><img src="http://engineering.life360.com/images/android-multiproc-application.webp" alt></p><p>如果你使用Application类，很可能你会在它的<code>onCreate()</code>方法中做一些初始化工作。 <strong>请确保这些初始化工作对进程是恰当且必要的</strong>  也在<code>Application.onCreate()</code>中使用下面的代码确定进程上下文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid = android.os.Process.myPid(); </span><br><span class="line">ActivityManager manager = (ActivityManager) <span class="keyword">this</span>.getSystemService(Context.ACTIVITY_SERVICE); </span><br><span class="line"><span class="keyword">for</span> (ActivityManager.RunningAppProcessInfo processInfo : manager.getRunningAppProcesses()) &#123; </span><br><span class="line">    <span class="keyword">if</span> (processInfo.pid == pid) &#123; </span><br><span class="line">        String currentProcName = processInfo.processName; </span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(currentProcName) &amp;&amp; currentProcName.equals(<span class="string">":background"</span>)) &#123;</span><br><span class="line">           <span class="comment">//Rest of the initializations are not needed for the background</span></span><br><span class="line">           <span class="comment">//process</span></span><br><span class="line">           <span class="keyword">return</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initializations for the UI process */</span></span><br></pre></td></tr></table></figure><p>通过这种方式你可以降低内存占用，避免某些大块内存分配，甚至有可能加快应用启动速度。这里提到初始化包括：加载专有字体，初始化Google Maps，及以初始化第三方SDK。通常只需要在主进程中做这些初始化。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>希望这篇博客能帮助你理解多进程应用，知道使用多进程中会遇到的问题，以及如何去解决这些问题。</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>如果不必在应用外访问provider和service，就不要暴露它们</li><li>限制广播的只对自己的应用可见</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用RecyclerView实现居中的GridView</title>
      <link href="2017/12/13/recyclerview-spansizelookup/"/>
      <url>2017/12/13/recyclerview-spansizelookup/</url>
      
        <content type="html"><![CDATA[<p>使用<code>SpanSizeLookup</code>接口可以基于RecyclerView实现居中效果的GridView。本文介绍了具体做法。<br><a id="more"></a></p><h1 id="居中的Grid"><a href="#居中的Grid" class="headerlink" title="居中的Grid"></a>居中的Grid</h1><p>使用<code>RecyclerView</code>，很容易实现如下Grid效果：</p><p><img src="recyclerview.webp" alt></p><p>但视觉对此不满意，认为更理想的效果应该是这样：</p><p><img src="recyclerview-and-linearlayout.webp" alt></p><p>注意看红色区域，它是 <strong>居中</strong> 而非靠左</p><p>怎么办？很简单，我们耍点”小聪明”就能实现上述布局。”聪明”的布局如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:gravity</span>=<span class="string">"center_horizontal"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/rv_roles"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:clipToPadding</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:padding</span>=<span class="string">"2dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:scrollbarStyle</span>=<span class="string">"outsideOverlay"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:scrollbars</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:transitionGroup</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layoutManager</span>=<span class="string">"android.support.v7.widget.GridLayoutManager"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:spanCount</span>=<span class="string">"2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:ignore</span>=<span class="string">"UnusedAttribute"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- tail, 用作最后一个居中的Item --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/rl_role"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">layout</span>=<span class="string">"@layout/tc_dialog_confirm_select_role_item"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:visibility</span>=<span class="string">"gone"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;RecyclerView&gt;</code>后跟着一个<code>&lt;LinearLayout&gt;</code>，其中包含着一个跟RecyclerView中item完全一样的布局。它其实是个”假”item，不妨称之为<code>tail</code>。</p><p>假设RecyclerView上待显示的数据为itemList，itemList的大小为n，对<code>tail</code>进行如下处理：</p><ul><li>当n为奇数时，RecyclerView中仅加载itemList中前<code>n - 1</code>个数据；显示<code>tail</code>并加载itemList中最后一条数据</li><li>当n为偶数时，RecyclerView中加载itemList中全部数据；隐藏<code>tail</code></li></ul><h1 id="支持选中态"><a href="#支持选中态" class="headerlink" title="支持选中态"></a>支持选中态</h1><p>需求发生变化了。在视觉要求Grid中最后一个item居中的基础上， 交互要求Grid中的item支持选中状态，如下图：</p><p><img src="recyclerview-can-be-selected.webp" alt></p><p>问题来了：<font color="red">原来耍小聪明的方案变得不很适用了，因为在<code>RecyclerView</code>和<code>tail</code>之间保持选中态的不好同步，写代码比较麻烦</font></p><p>从<a href="https://stackoverflow.com/questions/39303632/set-last-grid-to-full-width-using-gridlayoutmanager-recyclerview" target="_blank" rel="noopener">这里</a>找到了一个优雅的解决方案，利用<code>SpanSizeLookup()</code>接口调整item占用的列数以实现居中效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GridLayoutManager layoutManager = <span class="keyword">new</span> GridLayoutManager(mContext, <span class="number">2</span>);</span><br><span class="line">layoutManager.setOrientation(LinearLayoutManager.VERTICAL);</span><br><span class="line">layoutManager.setSpanSizeLookup(<span class="keyword">new</span> GridLayoutManager.SpanSizeLookup() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpanSize</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果共奇数个item，则最后一个item占两列。否则，一个item只占一列</span></span><br><span class="line">        <span class="keyword">if</span> (position % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; position == mSelectRoleAdapter.getItemCount() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">rv.setLayoutManager(layoutManager);</span><br></pre></td></tr></table></figure><p>这个方案只是调整<code>GridLayoutManager</code>，并不需要额外的”假”item，自然也就不存在选中状态同步的问题，代码写起来方便不易出错。截图如下：</p><p><img src="recyclerview-span-size-looup.webp" alt></p><p>上图跟我们期望的效果还有点差距，但已经解决了居中的关键问题。</p><p>我们微调一下item的布局代码即可实现最终效果。微调布局的两个关键点：</p><ol><li>将item背景图设置在<code>rl_real_root</code>上，而非<code>rl_fake_root</code></li><li>将<code>rl_real_root</code>的<code>width</code>设置为<code>wrap_content</code>，</li><li>将<code>rl_fake_root</code>的<code>width</code>设置为<code>match_parent</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/rl_fake_root"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@color/transparent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:ignore</span>=<span class="string">"UnusedAttribute"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/rl_real_root"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerInParent</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@color/b_G7"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginLeft</span>=<span class="string">"5dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginStart</span>=<span class="string">"5dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">"5dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginBottom</span>=<span class="string">"5dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/iv_role_head"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"36dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"36dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">"@drawable/tc_user_icon_circle_default"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginEnd</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginLeft</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginRight</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginStart</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_toEndOf</span>=<span class="string">"@id/iv_role_head"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_toRightOf</span>=<span class="string">"@id/iv_role_head"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/tv_role_name"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:text</span>=<span class="string">"肉盾"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:textColor</span>=<span class="string">"@color/t_G1"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:textSize</span>=<span class="string">"@dimen/campus_textsize_m"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/tv_role_desc"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_marginTop</span>=<span class="string">"3dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:text</span>=<span class="string">"建议边路"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:textColor</span>=<span class="string">"@color/t_G2"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:textSize</span>=<span class="string">"@dimen/campus_textsize_s"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>给张最后的效果图：</p><p><img src="recyclerview-select-item.gif" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何联调TCP API</title>
      <link href="2017/11/07/how-to-test-tcp-api/"/>
      <url>2017/11/07/how-to-test-tcp-api/</url>
      
        <content type="html"><![CDATA[<p>HTTP RESTful API是主流的API形式，易于测试。但一些系统当中使用TCP形式的接口，我们如何方便地对其进行测试呢？我的思路是将TCP接口适配成HTTP接口，然后用Postman等工具进行测试。本文详细描述了该适配方案的实现方案，以及实际测试中如何操作。</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin代理</title>
      <link href="2017/10/20/kotlin-delegate-tutorial/"/>
      <url>2017/10/20/kotlin-delegate-tutorial/</url>
      
        <content type="html"><![CDATA[<p>Java中的代理很烦很繁，而Kotlin中的代理却看起来很简单。我们来学学Kotlin中代理的用法吧。</p><a id="more"></a><p>本文整理自<a href="https://kotlinlang.org/docs/reference/delegated-properties.html" target="_blank" rel="noopener">Delegated Properties</a>。</p><p>有些通用类型的属性，尽管我们可以在需要每次都自己实现对于某些常用类型的属性，尽管我们可以在需要用于这些属性时每次都自行实现，但如果能一次性实现所有这些属性，并将其封装到库中可能是更好的方式。比如：</p><ul><li>懒加载属性： 这些属性的值在首次使用时才生成</li><li>observable属性：每当属性值发生变化时监听器会收到通知</li><li>将属性值保存到map，而不是为每个属性定义一个单独的字段</li></ul><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>针对这类情形Kotlin提供了<em>代理属性</em> ，语法是<code>val/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt;</code>。 <code>by</code>关键字后面的表达式即<em>代理</em> 。 属性对应的<code>get()</code>和<code>set()</code>方法会被代理到<code>&lt;expression&gt;</code>对应对象的<code>getValue()</code>和<code>setValue()</code>方法。属性代理不必实现任何接口，但必须满足以下条件：</p><ul><li>为<code>val</code>属性提供<code>getValue()</code>方法</li><li>为<code>var</code>性提供<code>getValue()</code>和<code>setValue()</code>方法</li></ul><p>当然，Kotlin标准库中提供了<code>ReadOnlyProperty</code>和<code>ReadOnlyProperty</code>接口包含这里提到的方法。<code>Delegate</code>可以实现这两个接口。</p><p>比如这里的<code>Delegate</code>就是一个代理：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="variable">$thisRef</span>, thank you for delegating '<span class="subst">$&#123;property.name&#125;</span>' to me!"</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$value</span> has been assigned to '<span class="subst">$&#123;property.name&#125;</span> in <span class="variable">$thisRef</span>.'"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如有以下<code>Example</code> ：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p: String <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你读取<code>Example.p</code>字段的值时，由于它被代理到一个<code>Deleage</code>实例，这个<code>Delegate</code>实例的<code>getValue()</code>方法会被调用。<code>getValue()</code> 的参数如下：</p><ol><li>第一个参数为<code>Example</code>实例，即你读取p字段时的那个实例</li><li>第二个参数是关于p的描述，它在Kotlin中被封装与<code>KProperty</code>对象</li></ol><p>所以最终<code>getValue()</code>输出<code>Example@33a17727, thank you for delegating ‘p’ to me!</code></p><p>注意：</p><ul><li><code>getValue()</code>方法参数的必须是<code>thisRef: Example?, property: KProperty&lt;*&gt;</code> 。 <code>thisRef</code>的类型必须跟属性的类型相同，或者是属性类型的父类。也可以放宽为<code>Any?</code> ，这样能让 <code>Delegate</code> 更加通用。<code>property</code>必须为<code>KProperty&lt;*&gt;</code>或其父类</li><li><code>getValue()</code>方法的返回值必须跟属性类型相同，或者是属性类型的父类</li><li><code>setValue()</code>方法的第三个参数new value，必须跟属性类型相同或是其父类</li><li><code>getValue()</code>和<code>setValue()</code>可以是Delegate的成员方法，也可是其扩展方法。对于原先并没有定义这些方法的对象而言，扩展方法更为方便。但无论是作为成员方法还是扩展方法，都需要添加<code>operator</code>修饰符</li></ul><p>为什么对<code>getValue()</code>和<code>setValue()</code>方法有上述规定呢，我们看看Kotlin编译器是如何处理Delegate的。实际上，对于每个代理属性，Kotlin编译器都会生成一个辅助的属性。比如，对于<code>prop</code>属性，会生成一个隐藏的<code>prop$delegate</code>属性，而<code>get()</code>和<code>set()</code>方法最后只是简单地代理到这个辅助属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prop: Type <span class="keyword">by</span> MyDelegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this code is generated by the compiler instead:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> prop$delegate = MyDelegate()</span><br><span class="line">    <span class="keyword">var</span> prop: Type</span><br><span class="line">        <span class="keyword">get</span>() = prop$delegate.getValue(<span class="keyword">this</span>, <span class="keyword">this</span>::prop)</span><br><span class="line">        <span class="keyword">set</span>(value: Type) = prop$delegate.setValue(<span class="keyword">this</span>, <span class="keyword">this</span>::prop, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在Idea中通过Tools &gt; Kotlin &gt; Show Kotlin Bytecode &gt; Decompile看到对应的Java代码，确实如这里所述。</p><h1 id="标准代理"><a href="#标准代理" class="headerlink" title="标准代理"></a>标准代理</h1><h2 id="Lazy代理"><a href="#Lazy代理" class="headerlink" title="Lazy代理"></a>Lazy代理</h2><p>lazy()是一个可接收lambda表达式作为参数的方法，它返回一个<code>Lazy&lt;T&gt;</code>实例，该实例作为代理来实现懒加载功能。第一次调用<code>get()</code>时会执行传给<code>lazy()</code>方法的lambda并且保留其结果，之后再调用<code>get()</code>时会直接返回该结果。缺省情况下对懒加载属性的计算是同步的</p><ul><li>LazyThreadSafetyMode.SYNCHRONIZED - 默认的懒加载方式，会锁定当前属性以保证仅在一个线程中对其初始化</li><li>LazyThreadSafetyMode.PUBLICATION - 初始化方法在并发访问未被初始化的属性时可多次被调用，但仅最先被返回的值作为属性的值</li><li>LazyThreadSafetyMode.NONE - 对属性的访问不加任何锁。如果当前对象在多个线程中被访问，则属性的值不确定</li></ul><h2 id="Observable代理"><a href="#Observable代理" class="headerlink" title="Observable代理"></a>Observable代理</h2><p><code>Delegate.observable()</code>有两个参数：属性的初始值和监听器。当给属性赋值时(即执行赋值操作后)监听器会被调用。监听器被调用时会接收到三个参数：被赋值的属性，属性的旧值，属性的新值。</p><p><code>vetoable()</code>跟<code>observable()</code>类似，但它会在属性赋值前被调用。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>一个常用的场景是在map中保存属性值。这种场景在解析JSON或类似的”动态”编程时很常见。这时可以使用map实例作为属性的代理。类似这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> map: Map&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> map</span><br><span class="line">  <span class="keyword">val</span> age: <span class="built_in">Int</span>     <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> user = User(mapOf(</span><br><span class="line"><span class="string">"name"</span> to <span class="string">"King"</span></span><br><span class="line">  <span class="string">"age"</span> to <span class="number">25</span></span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>代理属性(例如<code>name</code>从map)中获取值，取值时的key即为属性的名字。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retrofit如何支持TCP</title>
      <link href="2017/08/09/retrofit-basic/"/>
      <url>2017/08/09/retrofit-basic/</url>
      
        <content type="html"><![CDATA[<p>Retrofit通常用于处理HTTP接口，那它是否能支持TCP接口呢？答案是肯定的，本文提供了一种不必修改Retrofit源码就可支持访问TCP接口的文案。</p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><a href="https://github.com/square/retrofit" target="_blank" rel="noopener">Retrofit</a>号称是”Type-safe HTTP client for Android and Java”，它使用Java接口来定义HTTP API，并且支持JSON、Protobuf、XML等各种数据格式 ，使用非常方便。</p><p>实践中，我们的项目后台接口由原有的TCP接口 + Protobuf协议切换到HTTP接口 + JSON协议之后，Android客户端相应地引入Retrofit，大大地简化了接口访问代码的开发工作。配合使用<a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=zh-CN" target="_blank" rel="noopener">Postman</a>(Postman独立版本见<a href="https://www.getpostman.com/" target="_blank" rel="noopener">这里</a>)，原来让人抓狂容易扯皮的接口联调过程变得轻松愉快。</p><p><img src="chrome_2017-08-09_10-42-23.webp" alt="postman截图"></p><p>最近加入到另一个项目，发现后台接口也是TCP接口 + Protobuf协议，于是接口联调过程又回到以前状态，变得较为困难：一是PB二进制数据不可读，且难以像JSON文本数据一样可快速手工构造；二是TCP协议上进行私有加解密，导致没有类似Postman现成可用的接口测试工具。</p><p>校园项目有过推倒重来的阶段，由原有的TCP接口 + Protobuf协议切换到HTTP接口 + JSON协议时没有任何包袱换和顾虑。而这个项目后台、iOS终端、Android终端仍在快速迭代，切换后台接口工作量大，可能导致较多不稳定。</p><p>换个思路，我们能否做以下工作呢？</p><ol><li>让Retrofit支持TCP接口</li><li>像Postman测试HTTP接口一样方便地测试TCP接口</li></ol><p>本文尝试解决这里的第一个问题。主要内容包括Retrofit介绍，工作原理分析，然后讨论了如何让Retrofit支持TCP接口，以及如何实现自定义Converter。</p><h1 id="Retrofit简介"><a href="#Retrofit简介" class="headerlink" title="Retrofit简介"></a>Retrofit简介</h1><blockquote><p>Type-safe HTTP client for Android and Java by Square, Inc.</p></blockquote><p><a href="https://github.com/square/retrofit" target="_blank" rel="noopener">Retrofit</a>是Android和Java平台的类型安全的HTTP客户端。还不够具体？接下来看</p><blockquote><p>Retrofit adapts a Java interface to HTTP calls by using annotations on the declared methods to define how requests are made. Create instances using the builder and pass your interface to create to generate an implementation.</p></blockquote><p>Retrofit中使用注解来描述HTTP请求，动态代理生成可以发起相应HTTP请求的Java接口。举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">   .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">   .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">   .build();</span><br><span class="line"></span><br><span class="line">GitHubService api = retrofit.create(GitHubService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Response&lt;List&lt;Repo&gt;&gt; user = api.listRepos(<span class="string">"张三"</span>).execute();</span><br></pre></td></tr></table></figure><p><code>Retrofit</code>负责生成<code>GitHubService</code>接口的具体实现。我们只管调用，不必手写后台接口访问代码，够简单吧。Retrofit是如何做到的呢？</p><p><em>作者评论 ：其实原本就应该这么简单！ 想想看，接口访问代码难道多数不是样板代码？很多时候你不过复制粘贴，然后修改下确保参数正确而已。 </em></p><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>看下Retrofit工作原理。Retrofit包含以下关键类：</p><ul><li><strong>Retrofit</strong> - 它是整个模块的管理者，采用Builder模式。Retrofit可以将不同的<code>Converter.Factory</code>, <code>CallAdapter.Factory</code>, <code>Call.Factory</code>组合起来</li><li><strong>Converter</strong> - 负责对象到HTTP以及HTTP到对象的转换。回想下，我们是不是经常在做数据转换，比如你通过HTTP接口从后台拉取一条数据，然后将HTTP响应体转换成需要的对象，这就是所谓的Converter</li><li><strong>Converter.Factory</strong> - Converter工厂</li><li><strong>Call</strong> - 表示一个准备执行的请求。准确地说，Call是OkHttp的接口(Retrofit 2依赖OkHttp)。Call接口规定：它可以被cancel，它代表单独的一对请求和响应，所以不能多次执行</li><li><strong>Call.Factory</strong> - Call工厂。Call工厂是我们让Retroifit支持TCP接口的关键</li><li><strong>CallAdapter</strong> - 不同于Converter，CallAdapter相对就不那么容易理解。简单来说，Retrofit接口不仅仅可以返回Call，也可以将Call适配成<code>AsyncTask</code>、<code>Future</code>、RxJava的<code>Observable</code>, 或其他的任何支持异步操作的对象，只要提供了相应的CallAdapter</li><li><strong>CallAdapter.Factory</strong> - CallAdapter工厂</li><li><strong>ServiceMethod</strong> - 与上面几个类不同，ServiceMethod不是公开的。只有<code>toRequest()</code>和<code>toResponse()</code>两个方法。  ServiceMethod也是Builder模式，ServiceMethod.Builder主要方法包括<ul><li><code>ServiceMethod.Builder.createCallAdapter()</code></li><li><code>ServiceMethod.Builder.createResponseConverter()</code></li><li><code>ServiceMethod.Builder.parseParameterAnnotation()</code></li></ul></li></ul><p>Retrofit的原理是使用动态代理依据注解生成需要的代码，关键步骤在于<code>Retrofit.create()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            ServiceMethod serviceMethod = loadServiceMethod(method);</span><br><span class="line">            OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>坦白地说，原理你绝对都懂。不过Java中反射、泛型、注解等编码工作较为繁琐，另外Retrofit源码中参数检查、异常处理、调试信息、bug规避等代码占了相当大篇幅，抛开这些，核心代码其实很容易看明白，所以本文就不展开。<a href="http://www.jianshu.com/p/cd69c75d053e" target="_blank" rel="noopener">Retrofit原理浅析</a>中有较为清晰的分析，可以参考。</p><h1 id="支持TCP"><a href="#支持TCP" class="headerlink" title="支持TCP"></a>支持TCP</h1><p>如何让Retrofit支持TCP？一开始的想法是修改源码不就行了。但修改源码会给后续工作带来很多不便，比如代码维护、项目构建、Retrofit库升级等等。</p><p>Retrofit支持HTTP，而HTTP是基于TCP的。实际上HTTP虽然是应用层协议，使用起来感觉比TCP简单多了，但其实现应该不会比TCP更简单。从这个层面来讲，能实现更复杂的功能，不可能搞不定简单的功能，对不对？ (看源码，其实OkHttp内部不仅实现了TCP连接，还有完善的TCP连接池)</p><p>上一节讲到<code>Call.Factory</code>是让Retrofit支持TCP的关键。使用Builder模式构适Retrofit时，除了使用最基本的<code>Builder.client(OkHttpClient client)</code>方式给Builder塞进一个OkHttpClient对象，还可以使用<code>callFactory</code>方法。实际上以下两个方法作用类似，都是设置Call.Fractory：</p><ul><li><code>Builder.client(OkHttpClient client)</code></li><li><code>Builder callFactory(okhttp3.Call.Factory factory)</code></li></ul><p>后者是更通用的形式，前者只是一个特例。是的，<code>OkHttpClient</code>也是一个<code>Call.Factory</code>，代码为证。</p><p><img src="okhttpclient.webp" alt="OkHttpClient"></p><p>明白了吧，只要我们实现<code>Call.Factory</code>接口，就可以基于<code>HttpURLConnection</code>写一个”KoHttpClient”，或是基于Apache HttpClient写一个”NotOkHttpClient”，然后替换Retrofit缺省依赖的OkHttpClient。所谓解耦或是扩展性，说的也许就是这个。那<code>Call.Factory</code>到底何方神圣？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> okhttp3;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Call</span> <span class="keyword">extends</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isExecuted</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Call <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Call <span class="title">newCall</span><span class="params">(Request request)</span></span>;</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是简单得出乎你的意料。注意，OkHttp并规定Call必须是HTTP Call而不能是TCP Call。那好吧，我们来实现一个<code>TcpCall</code>以及<code>TcpCallFactory</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpCallFactory</span> <span class="keyword">implements</span> <span class="title">Call</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TcpCallFactory</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TcpCall(<span class="keyword">this</span>, request);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpCall</span> <span class="keyword">implements</span> <span class="title">Call</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的项目中有现成的TcpClient，最终<code>TcpCall</code>是基于它来实现的。如果你没有直接可用的TcpClient，不妨看看<code>okhttp3.internal.io.RealConnection</code>源码，或许用得上。</p><p><code>Call</code>同时支持同步请求和异步请求，见<a href="https://inthecheesefactory.com/blog/retrofit-2.0/en" target="_blank" rel="noopener">Retrofit 2.0：有史以来最大的改进</a> (<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0915/3460.html" target="_blank" rel="noopener">翻译</a>)，对应的方法分别为<code>execute()</code>和<code>enqueue()</code>。前者如何实现非常直观，而后者的实现则有一定技巧。具体代码可以参考<a href="https://github.com/square/okhttp/blob/master/okhttp/src/main/java/okhttp3/Dispatcher.java" target="_blank" rel="noopener">okhttp3.Dispatcher</a>源码。</p><p>另一个小细节就是<code>Call.execute()</code>的返回值，只要没有<code>IOException</code>异常，我们永远返回如下对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Response.Builder()</span><br><span class="line">    .protocol(Protocol.HTTP_1_1)</span><br><span class="line">    .code(<span class="number">200</span>)</span><br><span class="line">    .message(<span class="string">"OK"</span>)</span><br><span class="line">    .request(originalRequest)</span><br><span class="line">    .body(ResponseBody.create(<span class="keyword">null</span>, rsp))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>最后看看如何创建一个使用<code>TcpCallFactory</code>发送请求的Retrofit实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    <span class="comment">// 我们访问tcp接口，所以这行代码无实际意义</span></span><br><span class="line">    <span class="comment">// 仅仅是保证能通过retrofit内部参数检查</span></span><br><span class="line">    .baseUrl(<span class="string">"http://localhost:4000"</span>)</span><br><span class="line">    .callFactory(<span class="keyword">new</span> TcpCallFactory(host, port))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h1 id="自定义Converter"><a href="#自定义Converter" class="headerlink" title="自定义Converter"></a>自定义Converter</h1><p>Retrofit中<code>Convert</code>是接口，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F value)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,</span><br><span class="line">            Retrofit retrofit) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class="line">            Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations,</span><br><span class="line">            Retrofit retrofit) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Retrofit以独立模块的形式提供了几种<a href="https://github.com/square/retrofit/tree/master/retrofit-converters" target="_blank" rel="noopener">常用格式的Converter</a>。</p><p>上一节中我们已经让Retrofit支持通过TCP收发数据了。但TCP是传输层协议，如何在输入输出流中确定一条二进制消息的开始和结束，还需要自定义格式才行。所以客户端通过TCP接口访问后台并不是简单地使用标准Protobuf协议发送和接收数据，不能直接使用<a href="https://github.com/square/retrofit/tree/master/retrofit-converters/wire" target="_blank" rel="noopener">Wire Converter</a>。</p><p>我们的消息格式大致是这样：</p><table><thead><tr><th>消息长度len</th><th>命令字cmd</th><th>消息体body</th></tr></thead><tbody><tr><td>4字节</td><td>4字节</td><td>不定长，PB</td></tr></tbody></table><p>请求消息 </p><table><thead><tr><th>消息长度len</th><th>错误码error</th><th>消息体body</th></tr></thead><tbody><tr><td>4字节</td><td>4字节</td><td>不定长，PB</td></tr></tbody></table><p>响应消息</p><p><em>注意：请求消息中的消息体并不是必须的，某些查询请求就没有消息体</em></p><!-- TODO 图示 --><p>需要根据消息格式实现自定义Converter。先看看<a href="https://github.com/square/retrofit/tree/master/retrofit-converters/wire" target="_blank" rel="noopener">Wire Converter</a>，它的两个Converter功能分别如下</p><ul><li>WireRequestBodyConverter - Message对象转换为字节流(okhttp3.RequestBody)</li><li>WireResponseBodyConverter - 字节流(okhttp3.ResponseBody)转换为Message对象</li></ul><p>HTTP中url本身就是命名良好的命令字，而响应码可以作为错误码，所以<a href="https://github.com/square/retrofit/tree/master/retrofit-converters/wire" target="_blank" rel="noopener">Wire Converter</a>用于HTTP接口数据转换时并不用关心命令字和错误码的问题。但就TCP接口而言，数据转换时需要关心命令字和错误码。设计如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带命令字的请求</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CmdRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cmd;</span><br><span class="line">    Message message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带错误码的响应</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatusResponse</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    T message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Custom Wire Converter与<a href="https://github.com/square/retrofit/tree/master/retrofit-converters/wire" target="_blank" rel="noopener">Wire Converter</a>差异如下：</p><ul><li>CustomWireRequestBodyConverter - CmdRequest对象转换为字节流(okhttp3.RequestBody)</li><li>CustomWireResponseBodyConverter - 字节流(okhttp3.ResponseBody)转换为StatusResponse对象</li></ul><p>剩下的就是一些具体的编码细节了，这里不过多展开。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后给出一个完整的用法，基本上跟添加TCP支持前的<a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit用法</a>完全一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddressService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AddressService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 固定写法，有@Body参数时为'@POST("/")'，无@Body参数时为'@GET("/")'</span></span><br><span class="line">    <span class="meta">@POST</span>(<span class="string">"/"</span>)</span><br><span class="line">    Call&lt;StatusResponse&lt;SetUserAddressRsp&gt;&gt; modifyAddress(<span class="meta">@Body</span> CmdRequest message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Demo.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">        <span class="comment">// 我们访问tcp接口，所以这行代码无实际意义</span></span><br><span class="line">        <span class="comment">// 仅仅是保证能通过retrofit内部参数检查    </span></span><br><span class="line">        .baseUrl(<span class="string">"http://localhost:4000"</span>)</span><br><span class="line">        .callFactory(<span class="keyword">new</span> TcpClient(Env.getHostAddr(), Env.getHostPort()))</span><br><span class="line">        .addConverterFactory(CustomWireConverterFactory.create(mRetrofitLogic.context()))</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">// 获取service实例</span></span><br><span class="line">    AddressService addressService = retrofit.create(AddressService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 创建修改地址请求</span></span><br><span class="line">    SetUserAddressReq setUserAddressReq = ...</span><br><span class="line">    <span class="comment">// 创建请求参数</span></span><br><span class="line">    CmdRequest cmdMessage = ...</span><br><span class="line">    <span class="comment">// 获取call对象</span></span><br><span class="line">    Call&lt;StatusResponse&lt;SetUserAddressRsp&gt;&gt; call = addressService.modifyAddress(cmdMessage);</span><br><span class="line">    call.enqueue(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加RxJava依赖之后，你还可以这么写，是不是有种很潮的感觉？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddressService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AddressService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 固定写法，有@Body参数时为'@POST("/")'，无@Body参数时为'@GET("/")'</span></span><br><span class="line">    <span class="meta">@POST</span>(<span class="string">"/"</span>)</span><br><span class="line">    Observable&lt;StatusResponse&lt;SetUserAddressRsp&gt;&gt; modifyAddress2(<span class="meta">@Body</span> CmdRequest message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Demo.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Retrofit retrofit = ...</span><br><span class="line">    <span class="comment">// 获取service实例</span></span><br><span class="line">    AddressService addressService = retrofit.create(AddressService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 创建修改地址请求</span></span><br><span class="line">    SetUserAddressReq setUserAddressReq = ...</span><br><span class="line">    <span class="comment">// 创建请求参数</span></span><br><span class="line">    CmdRequest cmdMessage = ...</span><br><span class="line">    <span class="comment">// 获取call对象</span></span><br><span class="line">    Observable&lt;StatusResponse&lt;SetUserAddressRsp&gt;&gt; observable = addressService.modifyAddress2(cmdMessage);</span><br><span class="line">    observable.subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>支持rxjava需要添加以下依赖</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;io.reactivex:rxjava:1.1.6&apos;</span><br><span class="line">compile &apos;com.squareup.retrofit2:adapter-rxjava:2.0.0&apos;</span><br><span class="line">compile &apos;io.reactivex:rxandroid:1.2.1&apos;</span><br></pre></td></tr></table></figure><!--https://blog.robinchutaux.com/blog/a-smart-way-to-use-retrofit/https://news.realm.io/cn/news/droidcon-jake-wharton-simple-http-retrofit-2/你真的会用Retrofit2吗?Retrofit2完全教程http://www.jianshu.com/p/308f3c54abddRetrofit 2.0：有史以来最大的改进http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0915/3460.html你不知道的Retrofit缓存库RxCachehttp://www.jcodecraeer.com/a/anzhuokaifa/2017/0112/7005.htmlRetrofit 源码解读之离线缓存策略的实现http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0115/3873.html使用Mockito、Robolectric和RxJava及Retrofit进行单元测试http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0915/3458.htmlhttp://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0915/3460.htmlhttp://www.jianshu.com/p/308f3c54abddhttps://news.realm.io/cn/news/droidcon-jake-wharton-simple-http-retrofit-2/-->]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript中的getter和setter</title>
      <link href="2017/07/13/js-getter-setter/"/>
      <url>2017/07/13/js-getter-setter/</url>
      
        <content type="html"><![CDATA[<p>本文是《Eloquent Javascript》 “The Secret Lift of Objects”这一章节的学习笔记，记录了Javascript中对象的getter/setter的用法。</p><a id="more"></a><p>类似于Java，Javascript中也提倡使用getter/setter而不是直接访问对象属性。但getter/setter的问题是你不得额外写大量的方法。</p><p>Javascript提供了一种兼有属性和getter/setter优势的技巧。可以给对象定义一个属性，从外部看来是一个正常的属性，但实际上是方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pile = &#123;</span><br><span class="line">    elements: [<span class="string">"eggshell"</span>, <span class="string">"orange peel"</span>, <span class="string">"worm"</span>],</span><br><span class="line">    <span class="keyword">get</span> height() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.elements.length;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> height(value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Ignoring attempt to set height to"</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(pile.height);</span><br><span class="line"><span class="comment">// → 3</span></span><br><span class="line">pile.height = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// → Ignoring attempt to set height to 100</span></span><br></pre></td></tr></table></figure><p>给属性添加<code>get</code>和<code>set</code>注解允许你定义相应的方法，这些方法会在访问属性时被调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextCell</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.text = text.split(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(TextCell.prototype , <span class="string">"heightProp"</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.text.length; &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cell = <span class="keyword">new</span> TextCell(<span class="string">"no\nway"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cell.heightProp);</span><br><span class="line"><span class="comment">// → 2</span></span><br><span class="line">cell.heightProp = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(cell.heightProp);</span><br><span class="line"><span class="comment">// → 2</span></span><br></pre></td></tr></table></figure><p>可以使用类似的方式定义<code>set</code>属性来指定setter方法。当有getter而没有setter时，向属性写入值时会被忽略。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存泄露分析</title>
      <link href="2017/06/09/memory-leak-case/"/>
      <url>2017/06/09/memory-leak-case/</url>
      
        <content type="html"><![CDATA[<p>Android应用中很容易出现内存泄漏，而泄漏的主要原因归根结底是应用组件生命周期方法处理不当。本文使用<a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCanary</a>分析了几个内存泄露的例子，记录如下。<br><a id="more"></a></p><h1 id="Context泄露"><a href="#Context泄露" class="headerlink" title="Context泄露"></a>Context泄露</h1><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p><img src="case_1.webp" alt></p><p><img src="case_1_code.webp" alt></p><p>分析</p><ul><li><code>Foregrounds</code>用于记录app前后台切换</li><li><code>Foregrounds</code>调用MTA SDK的<code>StatService.trackCustomEndEvent()</code>方法进行事件统计</li></ul><p>我们将一个activity实例作为参数传给<code>StatService.trackCustomEndEvent()</code>方法，结果MTA SDK内部持有这个activity的引用，导致activity无法释放。</p><p>安全的调用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StatService.trackCustomEndEvent(</span><br><span class="line">    activity.getApplicationContext(),  <span class="comment">// 使用application context</span></span><br><span class="line">    <span class="string">"AppTime"</span>, </span><br><span class="line">    <span class="string">"time_on_page"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>不过从业务上来讲这段统计代码没有意义，所以干脆去掉。</p><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><p><img src="case_2.webp" alt></p><p><img src="case_2_code.webp" alt></p><p>分析</p><p>这个例子跟前一个类似，也是Context相关的问题。</p><ul><li><code>AudioPlayManger</code>是单例</li><li><code>AudioPlayManger.getInstance()</code>的参数是Context</li></ul><p>如果不小心将activity实例作为Context参数，这个activity将无法释放。<font color="red">很不幸，方法调用方太容易犯这种错误了</font>。</p><p>同上，安全的做法是不要直接使用<code>context</code>对象，而是<code>context.getApplicationContext()</code>。</p><h1 id="线程泄露"><a href="#线程泄露" class="headerlink" title="线程泄露"></a>线程泄露</h1><p><img src="case_3.webp" alt></p><p><img src="case_3_code.webp" alt></p><p>分析</p><p><img src="case_3.2.gif" alt></p><ul><li>继承自<code>TextSwitcher</code>实现了自定义控件用于文本轮播效果，代码中使用了Timer以及TimerTask</li><li>Timer会启动新的线程</li></ul><p>自定义控件中没有考虑到退出activity时中止Timer相关线程，导致activity泄露。</p><p>Handler机制相较Timer更优雅些，不必启动新的线程自然也就没有停止线程的问题。可以用Handler替换Timer以避免线程导致activity泄露的问题，不过仍然要注意中止消息以停止这里的轮播效果。</p><p>一个好的参考例子是<code>android.widget.ViewFlipper</code>，<code>ViewFlipper</code>是在<code>onDetachedFromWindow()</code>方法中停止消息更新的。我们可以借鉴这种处理方式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArgbEvaluator的用法</title>
      <link href="2017/05/27/argb-evaluator-usage/"/>
      <url>2017/05/27/argb-evaluator-usage/</url>
      
        <content type="html"><![CDATA[<p>安卓微信滑动Tab页时底部栏背景色有一个平滑的渐变效果，这个渐变效果是使用<code>ArgbEvaluator</code>实现的。本文介绍了<code>ArgbEvaluator</code>的用法。<br><a id="more"></a></p><p><a href="https://github.com/jiang111/awesome-android-tips" target="_blank" rel="noopener">这篇文章</a>提到了ArgbEvaluator </p><blockquote><p>ArgbEvaluator ArgbEvaluator.evaluate(float fraction, Object startValue, Object endValue);根据一个起始颜色值和一个结束颜色值以及一个偏移量生成一个新的颜色，分分钟实现类似于微信底部栏滑动颜色渐变。</p></blockquote><p>ArgbEvaluator继承自TypeEvaluator，TypeEvaluator的定义相当简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本接口用于ValueAnimator.setEvaluator(TypeEvaluator)方法。Evaluator可用于给任意属性类型创建动画，它允许给不能自动被动画系统理解和使用的类型创建自定义evaluator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeEvaluator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法返回起始值和结束值的一个线性插值，fraction参数代表起始值和结束值之间的一个比例。这个方法是一个简单的参数计算：result = x0 + t * (x1 - x0)</span></span><br><span class="line"><span class="comment">     * 这里的x0是起始值，x1是结束值，t是fraction</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, T startValue, T endValue)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个evaluator用于ARGB色值插值计算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArgbEvaluator</span> <span class="keyword">implements</span> <span class="title">TypeEvaluator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法对ARGB色值的每一个通道进行插值计算，返回合并后的色值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, Object startValue, Object endValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> startInt = (Integer) startValue;</span><br><span class="line">        <span class="keyword">int</span> startA = (startInt &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="keyword">int</span> startR = (startInt &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="keyword">int</span> startG = (startInt &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="keyword">int</span> startB = startInt &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> endInt = (Integer) endValue;</span><br><span class="line">        <span class="keyword">int</span> endA = (endInt &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="keyword">int</span> endR = (endInt &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="keyword">int</span> endG = (endInt &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="keyword">int</span> endB = endInt &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)((startA + (<span class="keyword">int</span>)(fraction * (endA - startA))) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">                (<span class="keyword">int</span>)((startR + (<span class="keyword">int</span>)(fraction * (endR - startR))) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">                (<span class="keyword">int</span>)((startG + (<span class="keyword">int</span>)(fraction * (endG - startG))) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">                (<span class="keyword">int</span>)((startB + (<span class="keyword">int</span>)(fraction * (endB - startB))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里写了一个demo用于演示ArgbEvaluator的用法，完整代码见<a href="https://github.com/410063005/demos.git" target="_blank" rel="noopener">这里</a>。</p><p><img src="screen.gif" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArgbEvaluatorDemo</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ArgbEvaluatorDemo"</span>;</span><br><span class="line"></span><br><span class="line">    TabLayout mTabLayout;</span><br><span class="line">    ViewPager mViewPager;</span><br><span class="line">    ArgbEvaluator mEvaluator;</span><br><span class="line">    <span class="keyword">int</span> mStartColor;</span><br><span class="line">    <span class="keyword">int</span> mEndColor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_argb_evaluator_demo);</span><br><span class="line"></span><br><span class="line">        mStartColor = ContextCompat.getColor(ArgbEvaluatorDemo.<span class="keyword">this</span>, R.color.colorAccent);</span><br><span class="line">        mEndColor = ContextCompat.getColor(ArgbEvaluatorDemo.<span class="keyword">this</span>, R.color.colorPrimary);</span><br><span class="line"></span><br><span class="line">        mTabLayout = (TabLayout) findViewById(R.id.pager_titles);</span><br><span class="line">        mViewPager = (ViewPager) findViewById(R.id.viewpager);</span><br><span class="line">        mViewPager.setAdapter(<span class="keyword">new</span> FragmentPagerAdapter(getSupportFragmentManager()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (position) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> Fragment1();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> Fragment2();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mTabLayout.setupWithViewPager(mViewPager);</span></span><br><span class="line">        mTabLayout.setTabMode(TabLayout.MODE_FIXED);</span><br><span class="line">        mTabLayout.setTabGravity(TabLayout.GRAVITY_CENTER);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mEvaluator = <span class="keyword">new</span> ArgbEvaluator();</span><br><span class="line"></span><br><span class="line">        mViewPager.addOnPageChangeListener(<span class="keyword">new</span> TabLayout.TabLayoutOnPageChangeListener(mTabLayout) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> positionOffset, <span class="keyword">int</span> positionOffsetPixels)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onPageScrolled(position, positionOffset, positionOffsetPixels);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (positionOffset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">"onPageScrolled: "</span> + position + <span class="string">" "</span> + (position + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                    TabLayout.Tab t = mTabLayout.getTabAt(position);</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.getCustomView() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        TextView tv = (TextView) t.getCustomView().findViewById(android.R.id.text1);</span><br><span class="line">                        tv.setTextColor((<span class="keyword">int</span>) mEvaluator.evaluate(positionOffset, mStartColor, mEndColor));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    TabLayout.Tab t2 = mTabLayout.getTabAt(position + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (t2 != <span class="keyword">null</span> &amp;&amp; t2.getCustomView() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        TextView tv2 = (TextView) t2.getCustomView().findViewById(android.R.id.text1);</span><br><span class="line">                        tv2.setTextColor((<span class="keyword">int</span>) mEvaluator.evaluate(positionOffset, mEndColor, mStartColor));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Log.i(TAG, "onPageScrolled: " + position + " " + (position + 1));</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mTabLayout.addOnTabSelectedListener(<span class="keyword">new</span> TabLayout.ViewPagerOnTabSelectedListener(mViewPager));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Fragment1</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            TextView tv = <span class="keyword">new</span> TextView(getContext());</span><br><span class="line">            tv.setText(<span class="string">"#1"</span>);</span><br><span class="line">            <span class="keyword">return</span> tv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Fragment2</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            TextView tv = <span class="keyword">new</span> TextView(getContext());</span><br><span class="line">            tv.setText(<span class="string">"#2"</span>);</span><br><span class="line">            <span class="keyword">return</span> tv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bug系列之proguard的坑</title>
      <link href="2017/03/30/bug-proguard/"/>
      <url>2017/03/30/bug-proguard/</url>
      
        <content type="html"><![CDATA[<p>2.6.7发版本时碰到几个跟proguard混淆相关的问题，记录下备忘。</p><a id="more"></a><h1 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h1><p>测试同事反馈某个赠送礼物的功能不正常。发现debug包中该功能完全正常，而release包里面则有问题。</p><p>想起之前Android Studio对相关代码检查时，提示礼物的model类中某些字段未被用到，可删除。所以第一反应是：会不会proguard也认为这个字段未用到，所以给删除了。检查proguard的输出文件<code>usage.txt</code>中是否存在删除model类的记录，发现并没有。但<code>mapping.txt</code>中却有如下记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com.tc.xx.api.GiftsService$InnerGift -&gt; com.tc.xx.c.f$a:</span><br><span class="line">    int num -&gt; a</span><br><span class="line">    java.lang.String content -&gt; b</span><br><span class="line">    java.lang.String receiver -&gt; c</span><br><span class="line">    void &lt;init&gt;(java.lang.String) -&gt; &lt;init&gt;</span><br></pre></td></tr></table></figure><p>原来是礼物的model类被混淆了！这种情况下GSON生成的json数据不正确，导致跟后台的通信失败。</p><p><strong>总结：之前赶进度偷懒将model类放在不正确的package下， 结果被混淆了，最终引发问题。</strong></p><p>我们的proguard配置中已经指定model所在的package不被混淆，所以解决办法很简单，将相关的类放到该package下即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Application classes that will be serialized/deserialized over Gson</span><br><span class="line">-keep class com.tc.xx.model.** &#123; *; &#125;</span><br></pre></td></tr></table></figure><h1 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h1><p>测试同事反馈更换头像或首次发送语音消息时app会crash，必现。两个功能都涉及到一个上传库。</p><p>跟前一个问题类似，debug包中该功能完全正常，而release包里面则有问题。找到了一个比较奇怪的崩溃日志，发生crash的地方并不是我们自己的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoSuchFieldError: no &quot;J&quot; field &quot;mNativeContext&quot; in class &quot;Lcom/tc/upload/network/base/ConnectionImpl;&quot; or its superclasses</span><br><span class="line">com.tc.upload.network.base.ConnectionImpl.native_init(Native Method)</span><br><span class="line">com.tc.upload.network.base.ConnectionImpl.&lt;clinit&gt;(Unknown Source)</span><br><span class="line">com.tc.upload.network.base.a.&lt;init&gt;(Unknown Source)</span><br><span class="line">com.tc.upload.network.base.f.&lt;init&gt;(Unknown Source)</span><br><span class="line">com.tc.upload.network.b.g.a(Unknown Source)</span><br><span class="line">com.tc.upload.network.b.g.a(Unknown Source)</span><br><span class="line">com.tc.upload.network.b.c.a(Unknown Source)</span><br><span class="line">com.tc.upload.network.b.c.d(Unknown Source)</span><br></pre></td></tr></table></figure><p>显然，又是某个第三方库代码被不正确地混淆了，导致上传时crash。</p><p>分析后发现调用了来自uploadlib.jar的方法，不清楚具体实现的代码，还是不混淆为妙！ 添加以下配置后问题解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># uploadlib</span><br><span class="line">-keep class com.tc.upload.** &#123;*;&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：无论来自哪里的第三方库，一定要注明来源(最好是官网地址)，并添加官方给出的proguard配置</strong></p><p>注：不知道uploadlib.jar的来源，只好简单地配置为完整不混淆。</p><hr><p>为什么这么多的混淆问题之前没有发现呢？不得不说一样腾讯云IM SDK的包结构非常坑，很多类放在<code>com.tc</code>包下，而它的<a href="https://www.qcloud.com/document/product/269/1557#1.6-.E4.BB.A3.E7.A0.81.E6.B7.B7.E6.B7.86.E8.A7.84.E5.88.99" target="_blank" rel="noopener">官网</a>给出的混淆配置居然是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-keep class com.tc.** &#123;*;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这明摆着是要让用了云IM SDK的、使用标准package命名方式的腾讯app没法好好混淆吗？</p><p>我们之前的版本一直被这个问题困扰，某个版本中优化了<code>-keep class com.tc.**{*;}</code>这个不合理的配置，让<code>com.tc</code>包下大量原本可被混淆的代码能正确地混淆。但同时，之前一些错误的或是遗漏的混淆引发的问题也暴露出来了，如上面提到的两个问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RecyclerView.OnItemTouchListener的用法</title>
      <link href="2017/02/24/rv-on-item-touch-listener/"/>
      <url>2017/02/24/rv-on-item-touch-listener/</url>
      
        <content type="html"><![CDATA[<p>如何给<code>RecyclerView</code>中的Item添加点击事件呢？本文介绍了几种不同的方法。<br><a id="more"></a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>给RecyclverView中的item添加点击处理事件最简单的做法是给item中的view添加OnClickListener监听器。这是一个实际的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(<span class="keyword">final</span> ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    holder.rlRoot.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://stackoverflow.com/questions/24471109/recyclerview-onclick" target="_blank" rel="noopener">这篇帖子</a>中提出了一个疑问，认为虽然这种做法并没有严重不妥，但每次绑定数据时就重新创建一个listener总觉得不是很自然。有没有更好的办法呢？比如说类似ListView的OnItemClickListener，用起来应该方便很多。</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>一种建议的做法是从Fragment或Activity中向Adapter传一个listener。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Activity的代码</span></span><br><span class="line"><span class="keyword">private</span> View.OnClickListener mItemClick = <span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        MainActivity.start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MainAdapter mainAdapter = <span class="keyword">new</span> MainAdapter(<span class="keyword">this</span>, mItemClick);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adapter的代码</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> MainAdapter.<span class="function">ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup viewGroup, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    View itemView = activity.getLayoutInflater().inflate(R.layout.main_adapter_item, viewGroup, <span class="keyword">false</span>);</span><br><span class="line">    ViewHolder holder = <span class="keyword">new</span> ViewHolder(itemView);</span><br><span class="line">    itemView.setOnClickListener(mItemClick);</span><br><span class="line">    <span class="keyword">return</span> holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><a href="http://stackoverflow.com/questions/24471109/recyclerview-onclick/26196831#26196831" target="_blank" rel="noopener">这里</a>给出了一种更好的做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RecyclerView recyclerView = findViewById(R.id.recycler);</span><br><span class="line">recyclerView.addOnItemTouchListener(</span><br><span class="line">    <span class="keyword">new</span> RecyclerItemClickListener(context, recyclerView ,<span class="keyword">new</span> RecyclerItemClickListener.OnItemClickListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do whatever</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongItemClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do whatever</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>而<code>RecyclerItemClickListener</code>的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerItemClickListener</span> <span class="keyword">implements</span> <span class="title">RecyclerView</span>.<span class="title">OnItemTouchListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> OnItemClickListener mListener;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnItemClickListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongItemClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  GestureDetector mGestureDetector;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RecyclerItemClickListener</span><span class="params">(Context context, <span class="keyword">final</span> RecyclerView recyclerView, OnItemClickListener listener)</span> </span>&#123;</span><br><span class="line">    mListener = listener;</span><br><span class="line">    mGestureDetector = <span class="keyword">new</span> GestureDetector(context, <span class="keyword">new</span> GestureDetector.SimpleOnGestureListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapUp</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mChildView != <span class="keyword">null</span> &amp;&amp; mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pos = mRecyclerView.getChildAdapterPosition(mChildView);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pos != RecyclerView.NO_POSITION) &#123;</span><br><span class="line">                    mListener.onItemClick(mChildView, pos);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">            View child = recyclerView.findChildViewUnder(e.getX(), e.getY());</span><br><span class="line">            <span class="keyword">if</span> (child != <span class="keyword">null</span> &amp;&amp; mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mListener.onLongItemClick(child, recyclerView.getChildAdapterPosition(child));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(RecyclerView view, MotionEvent e)</span> </span>&#123;</span><br><span class="line">    View childView = view.findChildViewUnder(e.getX(), e.getY());</span><br><span class="line">    <span class="keyword">if</span> (childView != <span class="keyword">null</span> &amp;&amp; mListener != <span class="keyword">null</span> &amp;&amp; mGestureDetector.onTouchEvent(e)) &#123;</span><br><span class="line">      mListener.onItemClick(childView, view.getChildAdapterPosition(childView));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTouchEvent</span><span class="params">(RecyclerView view, MotionEvent motionEvent)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestDisallowInterceptTouchEvent</span> <span class="params">(<span class="keyword">boolean</span> disallowIntercept)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最开始的需求如下面的截图，它只是一个好友列表。点击列表中的每一个item要求跳转到个人主页。可以看到，这里非常适合使用上述的RecyclerItemClickListener方案，可以避免每次绑定数据时创建listener的问题，简直跟ListView的OnItemClickListener一样好用。</p><p><img src="rv_demo1.webp" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RecyclerView recyclerView = findViewById(R.id.recycler);</span><br><span class="line">recyclerView.addOnItemTouchListener(</span><br><span class="line">    <span class="keyword">new</span> RecyclerItemClickListener(context, recyclerView ,<span class="keyword">new</span> RecyclerItemClickListener.OnItemClickListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 跳转到个人主页</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongItemClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do whatever</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>一开始上面的做法的确非常不错。不幸的是，最近需求发生了变化。该页面除了是好友列表，还要求在某些条件下会出来以下两种情形。</p><p><img src="rv_demo2.webp" alt><br><img src="rv_demo3.webp" alt></p><p>注意：这里的绿色方框中的内容是由RecyclerView的特殊item来实现的。</p><ol><li>第一个截图中，需求是蓝色按钮点击跳转到加好友页面</li><li>第二个截图中，需求是绿色方框中的用户区域点击跳转到个人主页，蓝色按钮点击跳转加好友页面</li></ol><p>使用RecyclerItemClickListener不太好实现，看来它有其局限性，所以还是乖乖给需要点击事件的控件添加相应的OnClickListener吧。给”绑定手机”，”加好友”，以及用户区域添加OnClickListener后，问题来了：</p><ol><li>第一个截图中，点击”绑定手机”不起作用，双击倒是可以跳转到加好友页面</li><li>第二个截图中，点击绿色方框中的用户区域不起作用，点击”加好友”也不起作用</li></ol><p>怎么办？完全去掉<code>RecyclerItemClickListener</code>，然后回退到给需求点击事件的控件单独添加OnClickListener？又作了如下尝试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RecyclerView recyclerView = findViewById(R.id.recycler);</span><br><span class="line">recyclerView.addOnItemTouchListener(</span><br><span class="line">    <span class="keyword">new</span> RecyclerItemClickListener(context, recyclerView ,<span class="keyword">new</span> RecyclerItemClickListener.OnItemClickListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在这里进行处理</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongItemClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do whatever</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li>第一个截图中，点击绿色方框部分任何一处，均可跳转到加好友页面</li><li>第二个截图中，点击绿色方框中的用户区域任何一处，均可跳转到加好友页面，点击”加好友”不起作用</li></ol><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>为什么上述场景中点击事件不起任何作用？</p><p>先来看一下<code>RecyclerView.OnItemTouchListener</code>。OnItemTouchListener允许应用拦截RecyclerView的view hierarchy level处理过程中的触摸事件，以防这些事件被认为是RecyclerView的滚动操作。</p><p>再来看<code>RecyclerView.addOnItemTouchListener()</code>。该方法用于添加RecyclerView.OnItemTouchListener，在touch事件被分发到child view或被用作view的标准滚动行为之前拦截这些事件。客户端代码可以使用监听器来实现item的操作行为。一旦从<code>RecyclerView.OnItemTouchListener.onInterceptTouchEvent(RecyclerView, MotionEvent)</code>返回true，则对应的<code>RecyclerView.OnItemTouchListener.onTouchEvent(RecyclerView, MotionEvent)</code>方法会在收到每个MotionEvent事件时被调用，直到手势结束。</p><p>所以很明显，<code>viewHolder.button.setOnClickListener</code>这种方式设置的监听器不起作用是因为touch事件被OnItemTouchListener给拦截了。</p><p>分析RecyclerItemClickListener的实现，不难找到问题的关键在于：<font color="red">如果找到了mChildView在RecyclerView中的位置，会直接调用mListener.onItemClick()并返回true。而返回true意味着touch事件被消费掉了，再也没可能被分发到child view</font>。所以类似<code>viewHolder.button.setOnClickListener</code>这种方式设置的监听器必然不起作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerItemClickListener</span> <span class="keyword">implements</span> <span class="title">RecyclerView</span>.<span class="title">OnItemTouchListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RecyclerItemClickListener</span><span class="params">(Context context, <span class="keyword">final</span> RecyclerView recyclerView, OnItemClickListener listener)</span> </span>&#123;</span><br><span class="line">    mListener = listener;</span><br><span class="line">    mGestureDetector = <span class="keyword">new</span> GestureDetector(context, <span class="keyword">new</span> GestureDetector.SimpleOnGestureListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapUp</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mChildView != <span class="keyword">null</span> &amp;&amp; mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pos = mRecyclerView.getChildAdapterPosition(mChildView);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pos != RecyclerView.NO_POSITION) &#123;</span><br><span class="line">                    mListener.onItemClick(mChildView, pos);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何修复这里的问题？暂时想不到比较通用的解决方案，但对于我们这里的问题还是不难处理的。解决办法就是针对那些特殊viewType对应的item，保证一定不会消费其touch事件，而是允许分发出去让child view处理。修改后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; mSpecialViewTypes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpecialViewTypes</span><span class="params">(List&lt;Integer&gt; specialViewTypes)</span> </span>&#123;</span><br><span class="line">    mSpecialViewTypes = specialViewTypes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; mSpecialViewTypes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RecyclerItemClickListener</span><span class="params">(Context context, OnItemClickListener listener)</span> </span>&#123;</span><br><span class="line">    mListener = listener;</span><br><span class="line">    mGestureDetector = <span class="keyword">new</span> GestureDetector(context, <span class="keyword">new</span> GestureDetector.SimpleOnGestureListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapUp</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mChildView != <span class="keyword">null</span> &amp;&amp; mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pos = mRecyclerView.getChildAdapterPosition(mChildView);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//========================================</span></span><br><span class="line">                <span class="comment">// 对于特殊的viewType, onSingleTapUp()返回false</span></span><br><span class="line">                <span class="keyword">int</span> viewType = mRecyclerView.getAdapter().getItemViewType(pos);</span><br><span class="line">                <span class="keyword">if</span> (mSpecialViewTypes != <span class="keyword">null</span> &amp;&amp; mSpecialViewTypes.contains(viewType)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//========================================                    </span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pos != RecyclerView.NO_POSITION) &#123;</span><br><span class="line">                    mListener.onItemClick(mChildView, pos);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体到我们的例子，<code>view type 1</code>和<code>view type 2</code>就是所谓的特殊viewType，我们不应在<code>onSingleTapUp()</code>方法中拦截那些会分发到它们的touch事件。修改后问题完美解决。</p><p><img src="rv_demo2.webp" alt><br><img src="rv_demo3.webp" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bug系列之onFailedToRecycleView引发的诡异问题</title>
      <link href="2017/02/21/bug-rv-on-failed-to-recycle-view/"/>
      <url>2017/02/21/bug-rv-on-failed-to-recycle-view/</url>
      
        <content type="html"><![CDATA[<p>项目中遇到了一个<code>RecyclerView</code>相关的诡异问题，跟到最后发现是<code>View</code>复用失败引起的。<code>RecyclerView.onFailedToRecycleView()</code>方法用于处理<code>View</code>复用失败的情况，本文介绍了其用法。</p><a id="more"></a><h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>页面结构如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">XRecyclerView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RefreshHeader</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ContentHeader</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">View</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">View</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">弹幕</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ContentHeader</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">RecyclerViewItem</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">RecyclerViewItem</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">XRecyclerView</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>外层的<a href="https://github.com/jianghejie/XRecyclerView" target="_blank" rel="noopener">XRecyclerView</a>继承自RecyclerView，支持下拉刷新</li><li>这里的RefreshHeader是由XRecyclerView自动添加以支持下拉刷新的</li><li>ContentHeader中有一个使用RecyclerView实现的弹幕。弹幕条数多于4条时会循环播放，少于3条时播放完成后逐渐隐藏</li></ol><p>注意，上面的结构中使用了嵌套RecyclerView。这也许是个坑。问题现象是，当滚动列表到底部再回到顶部时，<contentheader>代表的View错乱，变成了一个空的RecyclerViewItem。但也不一定要滚动到底部，只要弹幕移出可见区域，问题就可能发生。</contentheader></p><video src="demo.mp4" type="video/mp4" controls="controls" width="30%" height="30%"><br></video><p>一开始百思不得奇解，凭经验认为应该是RecyclerView中View复用的问题。但怪就怪在为什么ContentHeader会变成RecyclerViewItem。还有几个诡异的地方：</p><ol><li>弹幕循环播放时，问题不复现</li><li>RecyclerViewItem数量为0时，问题不复现</li></ol><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>打印日志看一下。(好吧，其实在准确的位置打印日志并展开分析之前我各种折腾浪费了不少时间)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"onCreateViewHolder viewType="</span> + viewType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现两个不符合预期的地方：</p><ol><li>日志输出为<code>onCreateViewHolder viewType=10002</code>，而10002并不是我们自己在<code>getItemViewType(int position)</code>中定义的。10002从哪里来？</li><li><code>onCreateViewHolder viewType=10002</code>会输出两次。为什么<code>onCreateViewHolder</code>调用两次？</li></ol><h2 id="10002从哪里来"><a href="#10002从哪里来" class="headerlink" title="10002从哪里来"></a>10002从哪里来</h2><p>这要从XRecyclerView特性说起来。XRecyclerView继承自RecyclerView，支持header和footer，有点类似于ListView。</p><p>Google官方明确地从RecyclerView中移除了对header和footer的支持，不知到底是为了保持API简单(移除长尾特性)，还是说明header和footer是不好的做法，因为特殊item完全也能实现header和footer，当然实现起来不如直接支持header和footer来得方便。<a href="https://www.youtube.com/watch?v=LqBlYJTfLP4" target="_blank" rel="noopener">RecyclerView ins and outs - Google I/O 2016</a></p><p>这里只就header展开分析，footer情况类似。直接上代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHeaderView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pullRefreshEnabled &amp;&amp; !(mHeaderViews.get(<span class="number">0</span>) <span class="keyword">instanceof</span> ArrowRefreshHeader)) &#123;</span><br><span class="line">        ArrowRefreshHeader refreshHeader = <span class="keyword">new</span> ArrowRefreshHeader(mContext);</span><br><span class="line">        mHeaderViews.add(<span class="number">0</span>, refreshHeader);</span><br><span class="line">        mRefreshHeader = refreshHeader;</span><br><span class="line">        mRefreshHeader.setProgressStyle(mRefreshProgressStyle);</span><br><span class="line">    &#125;</span><br><span class="line">    mHeaderViews.add(view);</span><br><span class="line">    sHeaderTypes.add(HEADER_INIT_INDEX + mHeaderViews.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">(Adapter adapter)</span> </span>&#123;</span><br><span class="line">    mAdapter = adapter;</span><br><span class="line">    mWrapAdapter = <span class="keyword">new</span> WrapAdapter(mHeaderViews, mFootViews, adapter);</span><br><span class="line">    <span class="keyword">super</span>.setAdapter(mWrapAdapter);</span><br><span class="line">    mAdapter.registerAdapterDataObserver(mDataObserver);</span><br><span class="line">    mDataObserver.onChanged();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">ViewHolder</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RecyclerView.<span class="function">ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (viewType == TYPE_REFRESH_HEADER) &#123;</span><br><span class="line">            mCurrentPosition++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleViewHolder(mHeaderViews.get(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isContentHeader(mCurrentPosition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (viewType == sHeaderTypes.get(mCurrentPosition - <span class="number">1</span>)) &#123;</span><br><span class="line">                mCurrentPosition++;</span><br><span class="line">                View view = mHeaderViews.get(headerPosition++);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SimpleViewHolder(view);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (viewType == TYPE_FOOTER) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleViewHolder(mFootViews.get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> adapter.onCreateViewHolder(parent, viewType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>XRecyclerView.addHeaderView()</code>方法用于添加头部，XRecyclerView会持有作为header的View</li><li><code>XRecyclerView.setAdapter()</code>是关键所在，它会将原始的Adapter包装成WrapAdapter</li><li>WrapAdapter的特别之处在于它为header创建SimpleViewHolder，非header则代理给原始的Adapter</li></ul><p>上面最后一点，可以解释我们遇到的问题。可能因为某种原因，有个header没被正确地识别出来，结果走到了<code>return adapter.onCreateViewHolder(parent, viewType)</code>这个分支。于是我们的自己的Adapter中看到了10002这个预期外的viewType。</p><p>为什么XRecyclerView的header没被正确地识别出来？分析<code>WrapAdapter.onCreateViewHolder()</code>，可以看出其实它对<code>mCurrentPosition</code>的计算很有问题。如果<code>onCreateViewHolder()</code>重复调用，<code>mCurrentPosition</code>肯定会算错。原本以为这是个bug，但另一方面考虑到header数量的不确定性，这里的<code>mCurrentPosition</code>好像的确没有更好的计算方式。</p><p>联系起来思考：会不会是<code>onCreateViewHolder()</code>调用两次，导致<code>mCurrentPosition</code>不对，进一步导致header没有识别出来。最终引起后面的一系列错误。</p><h2 id="为什么onCreateViewHolder调用两次"><a href="#为什么onCreateViewHolder调用两次" class="headerlink" title="为什么onCreateViewHolder调用两次"></a>为什么onCreateViewHolder调用两次</h2><p>正常来说<code>onCreateViewHolder()</code>肯定只为每个位置调用一次，调用后创建出来的ViewHolder是可以回收复用的。有没有异常情况？搜到了<code>RecyclerView.Adapter.onFailedToRecycleView(ViewHolder holder)</code>这个方法。</p><h2 id="onFailedToRecycleView"><a href="#onFailedToRecycleView" class="headerlink" title="onFailedToRecycleView"></a>onFailedToRecycleView</h2><blockquote><p>Called by the RecyclerView if a ViewHolder created by this Adapter cannot be recycled due to its transient state. Upon receiving this callback, Adapter can clear the animation(s) that effect the View’s transient state and return true so that the View can be recycled. Keep in mind that the View in question is already removed from the RecyclerView.<br>In some cases, it is acceptable to recycle a View although it has transient state. Most of the time, this is a case where the transient state will be cleared in onBindViewHolder(RecyclerView.ViewHolder, int) call when View is rebound to a new position. For this reason, RecyclerView leaves the decision to the Adapter and uses the return value of this method to decide whether the View should be recycled or not.<br>Note that when all animations are created by RecyclerView.ItemAnimator, you should never receive this callback because RecyclerView keeps those Views as children until their animations are complete. This callback is useful when children of the item views create animations which may not be easy to implement using an RecyclerView.ItemAnimator.<br>You should never fix this issue by calling holder.itemView.setHasTransientState(false); unless you’ve previously called holder.itemView.setHasTransientState(true);. Each View.setHasTransientState(true) call must be matched by a View.setHasTransientState(false) call, otherwise, the state of the View may become inconsistent. You should always prefer to end or cancel animations that are triggering the transient state instead of handling it manually.</p></blockquote><p>翻译一下</p><blockquote><p>如果当前Adapter创建的ViewHolder由于其临时状态不能被回收复用，则RecyclerView会调用onFailedToRecycleView方法。Adapter可以在这个回调方法中清理影响/导致ViewHolder临时状态的动画并返回<code>true</code>。返回<code>true</code>可以让View被回收复用。但要注意，这个有问题的View此时已经从RecyclerView中移除。<br>某些情况下，一些View虽然有临时状态但仍然可被回收复用。大多数时候，这些临时状态会在当前View绑定到新的位置 时由<code>onBindViewHolder(RecyclerView.ViewHolder, int)</code>给清理掉。所以RecyclerView把决定权留给Adapter，并使用<code>onFailedToRecycleView()</code>方法的返回值作为View是否被回收的依据。<br>注意，所有由RecyclerView.ItemAnimator创建的动画，都不会导致<code>onFailedToRecycleView()</code>调用，因为RecyclerView会一直保留带这种动画的View直到动画完成。<code>onFailedToRecycleView()</code>回调对于处理那些创建复杂动画的View非常有效。这里的复杂动画指的是那些无法用RecyclerView.ItemAnimator实现的动画<br>注意，你不能简单地调用<code>holder.itemView.setHasTransientState(false);</code>来避免这个问题，除非你之前调用过<code>holder.itemView.setHasTransientState(true);</code>。每个<code>View.setHasTransientState(true)</code>调用必须跟<code>View.setHasTransientState(false)</code>调用配对。否则View的状态不一致。你通常应当结束或取消引起View临时状态的动画，而不是手动调用<code>View.setHasTransientState(false)</code>来应对这种情况</p></blockquote><p>文档说得很明白，<code>onFailedToRecycleView(ViewHolder holder)</code>是View不能被RecyclerView回收复用时的回调方法。我们可以在这个方法清理View的临时状态。</p><ol><li>ContentHeader是不是不能被回收？</li><li>是不是弹幕的动画导致ContentHeader不能被回收？</li></ol><p>在<code>WrapAdapter.onFailedToRecycleView()</code>中打印日志，发现该方法果然被调用了，证明ContentHeader回收失败，所以下次使用ContentHeader会重新创建而不是直接绑定数据。这解释了为什么<code>onCreateViewHolder()</code>调用两次。</p><p>弹幕条数多于4条时会循环播放，少于3条时播放完成后逐渐隐藏。前者是使用RecyclerView.ItemAnimator实现的，而后者是自定义动画。根据文档，正是这里的自定义动画导致ContentHeader不能被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFailedToRecycleView</span><span class="params">(ViewHolder holder)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"create 10002: onFailedToRecycleView"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onFailedToRecycleView(holder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RecyclerView.<span class="function">ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (viewType == <span class="number">10002</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"create 10002"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">02-21 11:36:13.462 15618-15618/com.tencent.PmdCampus I/System.out: create 10002</span><br><span class="line">02-21 11:36:20.022 15618-15618/com.tencent.PmdCampus I/System.out: create 10002</span><br><span class="line">02-21 11:36:23.802 15618-15618/com.tencent.PmdCampus I/System.out: create 10002: onFailedToRecycleView</span><br><span class="line">02-21 11:36:23.812 15618-15618/com.tencent.PmdCampus I/System.out: create 10002</span><br></pre></td></tr></table></figure><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>找到原因后问题其实就解决了一半。重写<code>WrapAdapter.onFailedToRecycleView()</code>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFailedToRecycleView</span><span class="params">(ViewHolder holder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (holder <span class="keyword">instanceof</span> WrapAdapter.SimpleViewHolder) &#123;</span><br><span class="line">        WrapAdapter.SimpleViewHolder h = (SimpleViewHolder) holder;</span><br><span class="line">        BBViewImpl v = (BBViewImpl) h.itemView.findViewById(R.id.bb);</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 清理动画</span></span><br><span class="line">            v.stop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onFailedToRecycleView(holder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>界面错乱问题解决！</p><p>总结：</p><ol><li>注意View的动画可能导致出现临时状态，对于有临时状态的View，RecyclerView默认是不回收的</li><li>我们在使用RecyclerView时，通常只关注<code>onCreateViewHolder()</code>和<code>onBindViewHolder()</code>。但必要时也应关注<code>onFailedToRecycleView()</code>等方法，一些无法解释的问题很可能源于View无法回收</li></ol><!--# 补充还出现一个现象， 某些情况下， 弹幕会卡住。 -->]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好，2017</title>
      <link href="2017/02/09/hello-2017/"/>
      <url>2017/02/09/hello-2017/</url>
      
        <content type="html"><![CDATA[<p>2017年，如何让自己做点改变？</p><a id="more"></a><p>好吧，今天是2016年除夕，快十点。皮皮睡得正香。</p><p>回顾一年，又像是虚度。其实我也不知想说些什么。就随意吧，所以思维可能有些跳跃性。</p><p>我是个悲观的人。其实自己并不享受放假，因为假期总是这么短，总像是还没开始就要结束一样。放假第一天后我就会在心里默默地数着还是多少天，假期快结束时心里开始焦虑。我最享受的是放假前的那两天，十天的假何等享受，于是很开心地等待着。</p><p>我觉得自己很聪明却又比较失败。我想改变些什么。2017年。</p><p><strong>我最大的问题可能是不够专注，方向没有聚焦</strong>。就拿写博客来说吧。从最早的javaeye还是iteye上写了几篇博客，那大概是五六年前，真的好遥远。iteye不支持markdown，放弃了。到2013年又在oschina上零散地写过几篇。又觉得自己搭建博客才过瘾，于是再后来又有一段时间折腾Octopress搭建自己的博客。还专门申请了个5年的域名用于自建博客。Octopress容易因为markdown语法不规范编译失败，默认主题太丑自己又懒得找漂亮的主题，所以到了2015年开始付费使用farbox。渐渐又感觉farbox不好使用，原因是公司网络需要走代理，每2个小时需求重新连接。我根本就不知FarborEditor什么时候同步成功！</p><p>工作开始就使用为知笔记(我2011年开始工作)，记录了相当多的知识点了。再加上浏览器书签里的各种技术文章。还有散落在腾讯微云里的笔记。以及滴答清单任务里的记录，微信收藏里的技术文章。发现自己一直在收集各种资料，却没有足够的精力去看去学习去分析总结。打个比方说，我很勤快地从锅里夹菜，却从不按时吃，自然饿肚子，久了甚至营养不良。</p><p>写博客是一种学习的方式，我却又弄得相当凌乱。输入很多，输出很少。2017年希望自己能聚焦Android开发，将重心放在这一块。是时候清理我分散的博客了。<strong>关键字：聚焦，专注</strong>。</p><p>新技术很多，工作中很多其实是体力活，做多了很乏味，所以常常忘记方向、三分钟热度地去瞎折腾些东西，耗时耗力。有些东西原本很零碎，不好好总结、记录、输出，它永远那么零碎。零碎的知识是最难掌握最容易遗忘的。如果知识是网状的，则相对没有那么容易遗忘。我的工作经验已不算少，了解的东西也很多，但总觉得很肤浅，不够系统化。一些知识点系统化之后，只要你愿意，深入了解只是时间问题。<strong>关键字：系统化</strong>。</p><p>我知道自己是个情绪控制力很差的人，我也不知道怎么会这样。比如工作中有时克制不住会向别人发火。再比如有时会为很小的事向家人发火。我觉得跟自己身体状态比较差有一定关系，从2015年开始腰肌劳损的问题好像变得明显，高强度工作时这多少会影响到我的情绪。还有挫败感会让我非常焦虑。<strong>关键字：运动，情绪控制</strong>。</p><p>高效工作。有时方式并不高效，比如迟迟不引进热修复，忽略代码警告引起更大问题，总结后不及时输出导致无限期拖延。自动化不够<br><strong>关键字：工作效率</strong></p><p>扯了这么多，总结下顺便定个2017年计划。</p><ol><li>每周一，三，五中午健身房运动半小时，具体哪天可调整但 <em>每周不少于3次</em></li><li><em>每周写1000字</em>，可以是技术博客、读书笔记或者其他什么东西</li><li>整理博客，将过去几年 <em>全部博客内容整理到<a href="http://wwww.sunmoonblog.com" target="_blank" rel="noopener">http://wwww.sunmoonblog.com</a></em></li><li><em>好的心态，加强情绪控制力</em>。看3本以上关于情绪控制的书，网易云音乐上的《自控力》听1遍以上。别人的需求有问题并不代表自己就可以不好好干活，就可以没追求。偶尔看下娱乐节目和脑残节目，看似浪费时间但真的可以让大脑放松。</li><li><em>周三按时下班</em></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
