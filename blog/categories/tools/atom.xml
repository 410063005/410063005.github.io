<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tools | 点点滴滴]]></title>
  <link href="http://www.sunmoonblog.com/blog/categories/tools/atom.xml" rel="self"/>
  <link href="http://www.sunmoonblog.com/"/>
  <updated>2015-06-09T17:12:38+08:00</updated>
  <id>http://www.sunmoonblog.com/</id>
  <author>
    <name><![CDATA[Sunmoon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gradle学习笔记(Android)]]></title>
    <link href="http://www.sunmoonblog.com/blog/2015/06/05/gradle-tutorial-android/"/>
    <updated>2015-06-05T11:53:42+08:00</updated>
    <id>http://www.sunmoonblog.com/blog/2015/06/05/gradle-tutorial-android</id>
    <content type="html"><![CDATA[<p>原文来自<a href="http://tools.android.com/tech-docs/new-build-system/user-guide">这里</a>。基本上是对其翻译，挑选关键内容以及并加上自己的一些理解。</p>

<h1>介绍</h1>

<p>新编译系统的目标：</p>

<ul>
<li>代码和资源易重用</li>
<li>易创建应用的多版本</li>
<li>构建过程易配置</li>
<li>良好的IDE集成</li>
</ul>


<h2>为什么选择Gradle</h2>

<p>Gradle是种高级的构建系统，也是个允许通过插件创建自定义逻辑的构建工具。以下特征让我们选择Gradle：</p>

<ul>
<li>DSL用于描述和操作构建逻辑</li>
<li>构建文件基于Groovy，允许使用DSL描述性元素和使用代码操作DSL元素来提供自定义逻辑</li>
<li>内置的依赖管理(Maven和Ivy)</li>
<li>非常灵活。允许最佳实践，但不限制使用方式</li>
<li>插件可以暴露自己的DSL和API用于构建文件</li>
<li>良好的工具API供IDE集成</li>
</ul>


<h1>安装要求</h1>

<ul>
<li>Gradle 1.10以上，Gradle插件0.11.1以上</li>
<li>SDK with Build Tools 19.0.0以上</li>
</ul>


<h1>基本项目</h1>

<p>Gradle项目在根目录的<code>build.gradle</code>文件中描述其构建。</p>

<h2>简单构建文件</h2>

<p>最简单的Java项目使用以下<code>build.gradle</code>，这里使用Java插件，它跟Gradle一起安装。这个插件供Java项目构建和测试。</p>

<pre><code>apply plugin: 'java'
</code></pre>

<p>最简单的Android项目使用以下<code>build.gradle</code>：</p>

<pre><code>buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath 'com.android.tools.build:gradle:0.11.1'
    }
}

apply plugin: 'android'

android {
    compileSdkVersion 19
    buildToolsVersion "19.0.0"
}
</code></pre>

<p>这个Android构建脚本中有三个主要部分：</p>

<p><code>buildscript { ... }</code> 驱动构建。buildscript声明使用Maven中央库，对Manven库的Gradle插件(版本为v0.11.1)有依赖。注意：这里的依赖仅影响运行构建的代码而不影响项目。项目需要声明自己的库和依赖。</p>

<p>然后是类似之前Java插件的<code>android</code>插件。</p>

<p>最后，<code>android { ... }</code>设置所有的Android构建参数。它是Android DSL的入口点。缺省时只需要配置编译目标(<code>compileSdkVersion</code>)以及构建工具版本(<code>buildToolsVersion</code>)。编译目标跟旧的编译系统中<code>project.properties</code>的<code>target</code>属性是一样的。可以使用整型值(api level)或字符串给新的属性赋值。</p>

<p><strong>重要：</strong> 你应该只使用<code>android</code>插件。同时还使用<code>java</code>插件会引起构建错误。</p>

<p><strong>注意：</strong> 在新的构建系统中同样也需要一个<code>local.properties</code>文件，用于<code>sdk.dir</code>属性设置SDK的位置。另外，也可以设置<code>ANDROID_HOME</code>环境变量。两种方式没有区别。</p>

<h2>项目结构</h2>

<p>上面这种最基本的构建文件需要使用缺省的目录结构。Gradle遵循约定优于配置的原则，尽可能提供合理的默认值。</p>

<p>基本的项目中两个称为&#8221;source sets&#8221;的组件，分别是源码和测试代码。分别位于：</p>

<ul>
<li>src/main/</li>
<li>src/androidTest/</li>
</ul>


<p>每个目录下存放的是源码组件。对Java和Android插件，Java代码和Java资源文件分别位于：</p>

<ul>
<li>java/</li>
<li>resources/</li>
</ul>


<p>对Android插件，还有些额外的文件：</p>

<ul>
<li>AndroidManifest.xml</li>
<li>res/</li>
<li>assets/</li>
<li>aidl/</li>
<li>rs/</li>
<li>jni/</li>
</ul>


<p>注意：<code>src/androidTest/AndroidManifest.xml</code>不是必须的，这个文件自动生成。</p>

<p>当缺省的项目结构不满足要求时，可以重新配置。根据Gradle文档，可以使用如下方式重新配置<code>sourceSets</code>：</p>

<pre><code>sourceSets {
    main {
        java {
            srcDir 'src/java'
        }
        resources {
            srcDir 'src/resources'
        }
    }
}
</code></pre>

<p>注意：<code>srcDir</code>会添加指定的目录到已有的源码目录中(Gradle文档中没有提到这点，但确实是这样)。想替换掉缺省的源码目录，可以使用<code>srcDirs</code>，这个属性接收一组路径。下面演示了这种使用方式：</p>

<pre><code>sourceSets {
    main.java.srcDirs = ['src/java']
    main.resources.srcDirs = ['src/resources']
}
</code></pre>

<p>更多详细信息参考Gradle文档中<a href="http://gradle.org/docs/current/userguide/java_plugin.html">关于Java插件的部分</a>。</p>

<p>Android插件使用类似的语法，但由于是我们自己的<code>sourceSets</code>，所以应该对<code>android</code>对象执行这些操作。下面是例子，使用旧的项目结构，并将<code>androidTest</code>这个sourceSet映射到<code>tests</code>目录：</p>

<pre><code>android {
    sourceSets {
        main {
            manifest.srcFile 'AndroidManifest.xml'
            java.srcDirs = ['src']
            resources.srcDirs = ['src']
            aidl.srcDirs = ['src']
            renderscript.srcDirs = ['src']
            res.srcDirs = ['res']
            assets.srcDirs = ['assets']
        }

        androidTest.setRoot('tests')
    }
}
</code></pre>

<p>注意：由于旧的结构将所有的源码(java, aidl, renderscript以及java resources)放到同一个目录，所以需要将sourceSet中所有这些组件重新映射到同一个<code>src</code>目录。</p>

<p>注意：<code>setRoots()</code>将整个sourceSet(以及其子目录)移动到新的目录。这里会将<code>src/androidTest/*</code>移动到<code>tests/*</code>。这里Android特有的，Java项目的sourceSets并不支持。</p>

<h2>构建任务</h2>

<h3>通用任务</h3>

<p>在构建文件中使用插件会自动创建一些构建任务。Java插件和Android插件都如此。</p>

<p>通常的tasks包括：</p>

<ul>
<li><code>assemble</code> - 编译输出</li>
<li><code>check</code> - 运行所有校验</li>
<li><code>build</code> - 运行<code>assemble</code>和<code>check</code></li>
<li><code>clean</code> - 清除编译输出</li>
</ul>


<p><code>assemble</code>，<code>check</code>和<code>build</code>并没有做任何实际工作。它们是anchor tasks，用于插件来添加实际task来完成工作。</p>

<p>上述anchor tasks允许你无论是什么类型的项目、无论什么插件，都可以使用相同的tasks。比如，使用<code>findbugs</code>插件会创建新的task并让<code>check</code>依赖于它，无论<code>check</code>何时被调用这个新的task都会被调用。</p>

<p>在命令行中可以通过如下命令得到high level tasks：</p>

<pre><code>gradle tasks
</code></pre>

<p>想得到全部的tasks，运行以下命令：</p>

<pre><code>gradle tasks --all
</code></pre>

<p>注意：Gradle自动监视task的输入和输出。重复运行<code>build</code>时Gradle会输出<code>UP-TO-DATE</code>，指已是最新。这样可以避免没必要地重新构建。</p>

<h3>Java任务</h3>

<p>Java插件主要创建两种任务，它们是anchor task的主要依赖：</p>

<ul>
<li><code>assemble</code></li>
<li><code>jar</code> 这个task创建output</li>
<li><code>check</code></li>
<li><code>test</code> 这个task运行测试</li>
</ul>


<p><code>jar</code> task 本身直接和间接依赖于其他 tasks，比如依赖<code>classes</code>以编译Java代码。<code>testClasses</code>用于编译测试代码，但直接调用这个task没什么意义，<code>test</code>依赖于<code>testClasses</code>和<code>classes</code>。</p>

<p>通常，你会调用<code>assemble</code>或<code>check</code>，而忽略其他tasks。可以在<a href="http://gradle.org/docs/current/userguide/java_plugin.html">这里</a>找到完整的tasks描述。</p>

<h3>Android任务</h3>

<p>Android插件使用相同的惯例，保持跟其他插件兼容。Android插件添加以下anchor task：</p>

<ul>
<li><code>assemble</code> - 编译输出</li>
<li><code>check</code> - 运行所有校验</li>
<li><code>connectedCheck</code> - 运行所有需要有已连接设备或模拟器的检验</li>
<li><code>deviceCheck</code> - 使用API连接远程设备(用于持续集成服务器)</li>
<li><code>build</code> - 运行<code>assemble</code>和<code>check</code></li>
<li><code>clean</code> - 清除编译输出</li>
</ul>


<p>Android插件有必要添加新的anchor tasks，以便能在没有连接设备的情况下运行所有常规校验。注意<code>build</code>并不依赖<code>deviceCheck</code>或<code>connectedCheck</code>。</p>

<p>Android项目至少有两个输出：一个debug APK和一个release APK。每种都有自己的anchor tasks，以独立构建：</p>

<ul>
<li><code>assemble</code></li>
<li><code>assembleDebug</code></li>
<li><code>assembleRelease</code></li>
</ul>


<p>它们都依赖于其他构建APK必需的tasks。<code>assemble</code>依赖于<code>assembleDebug</code>和<code>assembleRelease</code>。</p>

<p>小贴士：Gradle支持命令行中的驼峰命名法。比如：<code>gradle aR</code>跟<code>gradle assembleRelease</code>是一样的，只要没有其他的task能跟<code>aR</code>匹配。</p>

<p><code>check</code> anchor task有其自己的依赖：</p>

<ul>
<li><code>check</code></li>
<li><code>lint</code></li>
<li><code>connectedCheck</code></li>
<li><code>connctedAndroidTest</code></li>
<li><code>connectedUiAutomatorTest</code> (尚未实现)</li>
<li><code>deviceCheck</code> This depends on tasks created when other plugins implement test extension points.</li>
</ul>


<p>最后，Android插件还针对所有构建类型(<code>debug</code>, <code>release</code>,<code>test</code>)创建了用于安装和卸载的任务，只要它们可被安装(需要签名)。</p>

<h2>基本自定义</h2>

<p>Android插件提供DSL用于从构建系统中直接配置大部分参数。</p>

<h3>Manifest条目</h3>

<p>通过DSL可以配置如下Manifest条目：</p>

<ul>
<li>minSdkVersion</li>
<li>targetSdkVersion</li>
<li>versionCode</li>
<li>versionName</li>
<li>applicationId (实际就是包名, 见 <a href="http://tools.android.com/tech-docs/new-build-system/applicationid-vs-packagename">ApplicationId versus PackageName</a>)</li>
<li>测试程序的package name</li>
<li>Instrumentation test runner</li>
</ul>


<p>示例：</p>

<pre><code>android {
    compileSdkVersion 19
    buildToolsVersion "19.0.0"

    defaultConfig {
        versionCode 12
        versionName "2.0"
        minSdkVersion 16
        targetSdkVersion 16
    }
}
</code></pre>

<p><code>android</code>元素内的<code>defaultConfig</code>元素定义了所有的配置。</p>

<p>前一个版本的Android插件使用 packageName 来配置manifest中的&#8217;packageName&#8217;属性。从Gradle插件v0.11.0开始，使用 applicationId 来配置manifest中的&#8217;packageName&#8217;属性。改名主要是为了消除应用包名(即ID)跟Java包名之间的歧义。</p>

<p>在构建文件内描述各种属性的威力在于它是动态的。比如，可以从文件读取或使用某种自定义逻辑计算出version name：</p>

<pre><code>def computeVersionName() {
    ...
}

android {
    compileSdkVersion 19
    buildToolsVersion "19.0.0"

    defaultConfig {
        versionCode 12
        versionName computeVersionName()
        minSdkVersion 16
        targetSdkVersion 16
    }
}
</code></pre>

<p>注意：不要使用可能跟当前范围内已有的 getters 的名字冲突的函数名。比如，<code>defaultConfig {...}</code>调用<code>getVersionName()</code>，将会自动使用<code>defaultConfig.getVersionName()</code>而不是自定义<code>getVersionName()</code>函数。</p>

<p>如果没有通过DSL定义属性，将使用缺省值。见下表</p>

<table>
<thead>
<tr>
<th>Property Name</th>
<th>Default value in DSL object</th>
<th>Default value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>versionCode</code></td>
<td>-1</td>
<td>如果manifest中有，则使用manifest中的值</td>
</tr>
<tr>
<td><code>versionName</code></td>
<td>null</td>
<td>如果manifest中有，则使用manifest中的值</td>
</tr>
<tr>
<td><code>minSdkVersion</code></td>
<td>-1</td>
<td>如果manifest中有，则使用manifest中的值</td>
</tr>
<tr>
<td><code>targetSdkVersion</code></td>
<td>-1</td>
<td>如果manifest中有，则使用manifest中的值</td>
</tr>
<tr>
<td><code>applicationId</code></td>
<td>null</td>
<td>如果manifest中有，则使用manifest中的值</td>
</tr>
<tr>
<td><code>testApplicationId</code></td>
<td>null</td>
<td>applicationId + &ldquo;.test&rdquo;</td>
</tr>
<tr>
<td><code>testInstrumentationRunner</code></td>
<td>null</td>
<td>android.test.InstrumentationTestRunner</td>
</tr>
<tr>
<td><code>signingConfig</code></td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td><code>proguardFile</code></td>
<td>N/A(set only)</td>
<td>N/A(set only)</td>
</tr>
<tr>
<td><code>proguardFiles</code></td>
<td>N/A(set only)</td>
<td>N/A(set only)</td>
</tr>
</tbody>
</table>


<p>第2列的值在你想在构建脚本中使用自定义逻辑查询这些属性时非常重要，比如，你可以这样写：</p>

<pre><code>if (android.defaultConfig.testInstrumentationRunner == null) {
    // assign a better default...
}
</code></pre>

<p>如果返回null，将在构建时使用第3列的实际缺省值替换。但DSL元素不包含这个缺省值所以不能查询。(注：原文是 If the value remains null, then it is replaced at build time by the actual default from column 3, but the DSL element does not contain this default value so you can&rsquo;t query against it.
This is to prevent parsing the manifest of the application unless it’s really needed. )</p>

<h3>构建类型</h3>

<p>缺省时，Android插件会自动将项目设置为能同时编译debug和release版本。这两种构建类型生成不同版本的应用，它们在非开发手机上的调试能力及APK如何被签名上所区别。</p>

<p>debug版本使用已知的用户名/密码(不必在构建时提示输入)自动创建的key/certificate来签名。构建过程中并不给自动release版本的APK签名，需要后续操作。</p>

<p>通过一个称为<code>BuildType</code>的对象进行这些配置。缺省时，两个实例被创建，一个是<code>debug</code>，一个是<code>release</code>。Android插件允许自定义这两个对象，也允许创建别的构建类型。使用 <code>buildTypes</code> DSL容器创建：</p>

<pre><code>android {
    buildTypes {
        debug {
            applicationIdSuffix ".debug"
        }

        jnidebug.initWith(buildTypes.debug)
        jnidebug {
            packageNameSuffix ".jnidebug"
            jniDebuggable true
        }
    }
}
</code></pre>

<p>上面代码达到以下目的：</p>

<ul>
<li>配置缺省的<code>debug</code>构建类型：</li>
<li>将它的包名设置为<code>&lt;app applicationId&gt;.debug</code>，允许在一台设备上同时安装debug和release版本的APK</li>
<li>使用debug实例创建一个名为<code>jnidebug</code>的新的构建类型，这个新实例使用<code>debug</code>相同的配置</li>
<li>继续配置<code>jnidebug</code>，打开<code>jniDebuggable</code>开关，并添加不同的后缀</li>
</ul>


<p>调用<code>initWith()</code>或使用闭包配置，在<code>buildTypes</code>容器内创建新的构建类型跟使用新的元素一样容易。</p>

<p>下面是属性列表及缺省值：</p>

<table>
<thead>
<tr>
<th>Property Name</th>
<th>Default value for debug</th>
<th>Default value for release/other</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>debuggable</code></td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td><code>jniDebuggable</code></td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td><code>renderscriptDebuggable</code></td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td><code>renderscriptOptimLevel</code></td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td><code>applicationIdSuffix</code></td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td><code>versionNameSuffix</code></td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td><code>signingConfig</code></td>
<td>android.signingConfigs.debug</td>
<td>null</td>
</tr>
<tr>
<td><code>zipAlignEnabled</code></td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td><code>minifyEnabled</code></td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td><code>proguardFile</code></td>
<td>N/A(set only)</td>
<td>N/A(set only)</td>
</tr>
<tr>
<td><code>proguardFiles</code></td>
<td>N/A(set only)</td>
<td>N/A(set only)</td>
</tr>
</tbody>
</table>


<p>除了这些属性，构建类型还能提供代码和资源。对每个构建类型，会有相应的 <code>sourceSet</code> 创建，其缺省位置是<code>src/&lt;buildtypename&gt;</code>。这意味着构建类型的名字不能是main或androidTest，且必须唯一。</p>

<p>跟其他的source sets一样，构建类型的source set也可以使用新的位置：</p>

<pre><code>android {
    sourceSets.jnidebug.setRoot('foo/jnidebug')
}
</code></pre>

<p>另外，对每个构建类型，会有一个<code>assemble&lt;BuildTypeName&gt;</code> task被创建。</p>

<p>之前提到过<code>assembleDebug</code>和<code>assembleRelease</code>，这就是它们的由来。当<code>debug</code>和<code>release</code>构建类型被创建后，会自动创建对应的<code>assemble</code> task。</p>

<p>上面的<code>build.gradle</code>代码片断同样会生成一个<code>assembleJnidebug</code> task，而<code>assemble</code>会像依赖<code>assembleDebug</code>及<code>assembleRelease</code>一样依赖<code>assembleJnidebug</code>。</p>

<p>小贴士：记住，可以输入<code>gradle aJ</code>来运行<code>assembleJnidebug</code> task。</p>

<p>可能的使用场景：</p>

<ul>
<li>仅在debug模式下才能使用的权限，而release版本中不行</li>
<li>用于debugging的自定义实现</li>
<li>debug模式时提供不同的资源(比如当resource value跟signing certificate绑定时)</li>
</ul>


<p>BuildType的code和resources有以下使用方式：</p>

<ul>
<li>合并manifest到app的manifest</li>
<li>The code acts as just another source folder</li>
<li>resources覆盖main resources，替换已存在的值</li>
</ul>


<h3>签名配置</h3>

<p>给应用签名需要以下条件：</p>

<ul>
<li>keystore</li>
<li>keystore password</li>
<li>key alias name</li>
<li>key password</li>
<li>store type</li>
</ul>


<p>文件位置，key name以及password和 store type一起组成Signing Configuration(type SigningConfig)</p>

<p>缺省时，有一个<code>debug</code>配置用于使用debug keystore，它使用已知的password以及一个使用已知密码的key。debug keystore位于<code>$HOME/.android/debug.keystore</code>，不存在时自动创建。</p>

<p><code>debug</code>构建类型自动使用<code>debug</code> SigningConfig。也可以创建其他的配置，使用修改缺省内置的配置。通过<code>signingConfigs</code> DSL容器完成：</p>

<pre><code>android {
    signingConfigs {
        debug {
            storeFile file("debug.keystore")
        }

        myConfig {
            storeFile file("other.keystore")
            storePassword "android"
            keyAlias "androiddebugkey"
            keyPassword "android"
        }
    }

    buildTypes {
        foo {
            debuggable true
            jniDebuggable true
            signingConfig signingConfigs.myConfig
        }
    }
}
</code></pre>

<p>上述代码修改debug keystore的为项目根目录。这会自动影响任何使用它的构建类型。这里还创建了一个新的 Signing Config 以及一个新的将用到该 Signing Config的构建类型。</p>

<p>注意：只有缺省位置的debug keystores会自动被创建。修改debug keystore的位置后，它不会自动被创建。使用不同的名字创建 一个会用到debug keystore的SigningConfig，会导致debug keystore被自动创建。In other words, it’s tied to the location of the keystore, not the name of the configuration.</p>

<p>注意：keystores的位置通常是相对于项目的根目录，也可以是绝对路径。但不建议使用绝对路径(除非使用自动生成的debug keystore)。</p>

<p><strong>注意：当把这些文件提交到版本控制系统后，你可能不想将密码保存在文件中。下面这个来自Stack Overflow的帖子演示如何读取控制台输入或从环境变量。<a href="http://stackoverflow.com/questions/18328730/how-to-create-a-release-signed-apk-file-using-gradle">参考</a>。我们后续会在这份指导中提供更多的详细信息。</strong></p>

<h3>ProGuard</h3>

<p>ProGuard is supported through the Gradle plugin for ProGuard version 4.10。ProGuard插件会自动被使用，如果将<code>minfyEnabled</code>属性设置为true，构建类型将会运行ProGuard，相应的tasks也会被创建。</p>

<pre><code>android {
    buildTypes {
        release {
            minifyEnabled true
            proguardFile getDefaultProguardFile('proguard-android.txt')
        }
    }

    productFlavors {
        flavor1 {
        }
        flavor2 {
            proguardFile 'some-other-rules.txt'
        }
    }
}
</code></pre>

<p>不同版本使用各自的规则文件。有两个缺省的规则文件：</p>

<ul>
<li>proguard-android.txt</li>
<li>proguard-android-optimize.txt</li>
</ul>


<p>它们包含在SDK中。使用<code>getDefaultProguardFile()</code>会返回完整的文件路径。除是否开启优化外，它们完全相同。</p>

<h3>压缩资源</h3>

<p>也可以在构建时去掉无用的资源。更多信息参见<a href="http://tools.android.com/tech-docs/new-build-system/resource-shrinking">Resources压缩</a>。</p>

<h1>依赖管理和库项目/多项目设置</h1>

<p>Gradle项目会依赖其他组件。这些组件可能是外部的二进制包或其他Gradle项目。</p>

<h2>二进制依赖</h2>

<h3>本地包</h3>

<p>当依赖外部库时，需要给<code>compile</code>配置添加依赖：</p>

<pre><code>dependencies {
    compile files('libs/foo.jar')
}

android {
    ...
}
</code></pre>

<p>注意：<code>dependencies</code>DSL元素是标准的Gradle API，不属于<code>android</code>元素。</p>

<p><code>compile</code>配置用于编译主应用。 <code>compile</code>指定的二进制包会添加到编译时的classpath时且会打包到最终的APK中。其他可能需要依赖的配置包括：</p>

<ul>
<li><code>compile</code> - 主应用</li>
<li><code>androidTestCompile</code> - 测试应用</li>
<li><code>debugCompile</code> - debug构建类型</li>
<li><code>releaseCompile</code> - release构建类型</li>
</ul>


<p>不可能构建一个不跟构建类型关联的APK，所以APK通常使用<code>compile</code>和<code>&lt;buildtype&gt;Compile</code>配置。创建新的构建类型将基于它的名字自动创建新的配置。</p>

<p>这个特性在某些时候非常有用，比如在debug版本需要使用自定义库(比如上报异常)而release版本时，或者依赖不同版本的库时。</p>

<h3>远程文件</h3>

<p>Gradle可以从Maven和Ivy库下载文件。首先，必须添加相应的仓库。然后，必须以Maven或Ivy支持的方式声明所依赖的文件。</p>

<pre><code>repositories {
    mavenCentral()
}


dependencies {
    compile 'com.google.guava:guava:11.0.2'
}

android {
    ...
}
</code></pre>

<p>注意：<code>mavenCentral()</code>是指定仓库URL的快捷方式。Gradle支持远程和本地仓库。Gradle will follow all dependencies transitively. 即，某个项目依赖又依赖别的文件时，这个文件也会一起被下载。(This means that if a dependency has dependencies of its own, those are pulled in as well.)</p>

<p>关于设置依赖的更多信息，可以参考<a href="http://gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html">Gradle user guide</a>，和<a href="http://gradle.org/docs/current/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html">DSL文档</a>。</p>

<h2>多项目设置</h2>

<p>通过设置&#8217;multi-project&#8217;，Gradle项目也可以依赖其他Gradle项目。所有项目作为某个指定的根目录的子目录就可以支持multi-project。</p>

<p>比如，下面的目录结构：</p>

<pre><code>MyProject/
 + app/
 + libraries/
    + lib1/
    + lib2/
</code></pre>

<p>我们指定3个项目。Gradle可以通过以下名字引用它们：</p>

<pre><code>:app
:libraries:lib1
:libraries:lib2
</code></pre>

<p>每个项目可以有自己的build.gradle来指定如何构建。另外，根目录下有个叫<code>settings.gradle</code>的文件。完整结构如下：</p>

<pre><code>MyProject/
 | settings.gradle
 + app/
    | build.gradle
 + libraries/
    + lib1/
       | build.gradle
    + lib2/
       | build.gradle
</code></pre>

<p>settings.gradle文件内容非常简单：</p>

<pre><code>include ':app', ':libraries:lib1', ':libraries:lib2'
</code></pre>

<p>上述内容定义哪个目录是Gradle项目。</p>

<p><code>:app</code>项目依赖于库项目(在这里是libraries下的lib1)，通过下面的方式声明依赖：</p>

<pre><code>dependencies {
    compile project(':libraries:lib1')
}
</code></pre>

<p>关于multi-project可以参考<a href="http://gradle.org/docs/current/userguide/multi_project_builds.html">这里</a></p>

<h2>库项目</h2>

<p>在上面的multi-project设置中，<code>:libraries:lib1</code>和<code>:libraries:lib2</code>可以是Java项目，而<code>:app</code>这个Android项目会使用它们编译输出的jar文件。</p>

<p>如果你想共享需要访问Android API的代码或使用Android风格的资源，则库项目不能是常规的Java项目，它们必须是Android Library项目。</p>

<h3>创建库项目</h3>

<p>库项目跟常规的Android项目有少量不同。构建库跟构建应用不同，所以使用不同的插件。在内部这两个插件共享大部分代码(由相同的<code>com.android.tools.build.gradle jar</code>提供)。</p>

<pre><code>buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath 'com.android.tools.build:gradle:0.5.6'
    }
}

apply plugin: 'android-library'

android {
    compileSdkVersion 15
}
</code></pre>

<p>上面的代码创建一个库项目，使用API level 15的SDK来编译。库项目使用相同的方式处理SourceSets以及依赖，也可使用相同的方式自定义。</p>

<h3>常规项目跟库项目的差异</h3>

<p>库项目的主要输出是<code>.aar</code>包(代表Android archive)。它由编译后的代码(jar文件或.so文件)以及资源文件(manifest, res, assets)组成。库项目也可以产生一个测试apk用于独立测试库。</p>

<p>库项目使用相同的anchor tasks(<code>assembleDebug</code>和<code>assembleRelease</code>)，所以在命令行编译库项目跟常规项目没有任何区别。除此之外，库项目跟应用项目完全一样。它们也有构建类型和product flavors，也可以生成不同版本的aar文件。</p>

<p>注意：构建类型的大部分配置都不能应用于库项目。但是你可以根据库项目是被其他项目使用还是在测试，使用自定义的<code>sourceSet</code>来修改库的内容。</p>

<h3>Referencing a Library</h3>

<p>引用库跟引用其他项目一样：</p>

<pre><code>dependencies {
    compile project(':libraries:lib1')
    compile project(':libraries:lib2')
}
</code></pre>

<p>注意：如果你有多个库项目的话，那么这里的顺序非常重要。跟旧的编译系统中<code>project.properties</code>文件中依赖项的顺序很重要类似。</p>

<h3>发布Library</h3>

<p>缺省时只发布库的<code>release variant</code>版本。这个版本用于其他项目引用本库，其他版本会被忽略。这是Gradle目前的限制，很快就被解除。</p>

<p>你可以控制发布哪个版本：</p>

<pre><code>android {
    defaultPublishConfig "debug"
}
</code></pre>

<p>注意这里的publishing配置引用完整的variant name。没有其他flavor时只可使用release和debug。如果想使用flavor来修改缺省的发布版本，可以这么写：</p>

<pre><code>android {
    defaultPublishConfig "flavor1Debug"
}
</code></pre>

<p>也可以一次发布所有版本的库。We are planning to allow this while using a normal project-to-project dependency (like shown above), but this is not possible right now due to limitations in Gradle (we are working toward fixing those as well).缺省不开启这个功能，使用如下代码打开：</p>

<pre><code>android {
    publishNonDefault true
}
</code></pre>

<p>应该明白发布多个版本指的是发布多个aar文件，而不是一个aar文件包含多个版本。每个aar文件包含单个版本。发布aar表示让其作为Gradle项目的输出文件。这个文件既可以发布到Maven库，也可以作为另的项目的依赖。</p>

<p>Gradle has a concept of default&#8221; artifact. This is the one that is used when writing:</p>

<pre><code>compile project(':libraries:lib2')
</code></pre>

<p>依赖另一个项目的发布版本时，需要指定使用哪个：</p>

<pre><code>dependencies {
    flavor1Compile project(path: ':lib1', configuration: 'flavor1Release')
    flavor2Compile project(path: ':lib1', configuration: 'flavor2Release')
}
</code></pre>

<p><strong>重要：</strong> Note that the published configuration is a full variant, including the build type, and needs to be referenced as such.</p>

<p><strong>重要：</strong> 发布非缺省版本时，Maven发布插件会将其他版本输出额外的包(带修饰名)。它跟发布到Maven库不完全兼容。要么发布一个版本到Maven库，要么为内部项目依赖发布所有版本。</p>

<h1>测试</h1>

<p>构建测试程序也已集成到项目中。没必要再建立专门的独立测试项目。</p>

<h2>单元测试</h2>

<p>Android Studio v1.1中开始支持单元测试(作为试验功能)，具体见<a href="http://tools.android.com/tech-docs/unit-testing-support">这里</a>。</p>

<p>Android Studio v1.2中正式支持单元测试。 <a href=""></a></p>

<p>下面部分讲的是&#8221;instrmentation test&#8221;，它需要在设备或模拟器上运行，也需要构建一个用于测试的APK。</p>

<h2>Instrumentation测试</h2>

<h2>基础</h2>

<p>前面提到过，<code>main</code> sourceSet后面是 <code>androidTest</code> sourceSet，缺省位于<code>src/androidTest</code>。这个sourceSet会创建一个用于测试的APK。它可以包含单元测试，instrumentation测试(以后还包括uiautomator测试)。</p>

<p>测试应用manifest中的<code>&lt;instrmentation&gt;</code>节点自动生成，但你也可以创建<code>src/androidTest/AndroidManifest.xml</code>文件以增加其他组件。</p>

<p>可以为测试应用配置少量参数：</p>

<ul>
<li><code>testPackageName</code></li>
<li><code>testInstrumentationRunner</code></li>
<li><code>testHandleProfiling</code></li>
<li><code>testFunctionalTest</code></li>
</ul>


<p>如前面看到的那样，通过<code>defaultConfig</code>对象配置：</p>

<pre><code>android {
    defaultConfig {
        testPackageName "com.test.foo"
        testInstrumentationRunner "android.test.InstrumentationTestRunner"
        testHandleProfiling true
        testFunctionalTest true
    }
}
</code></pre>

<p>即使通过<code>defaultConfig</code>或Build Type对象配置， 测试应用的manifest中<code>instrmentation</code>节点的<code>targetPackage</code>属性还是会自动使用被测应用的包名填充。另外，<code>sourceSet</code>可以有自己的依赖。缺省时，应用以及它的依赖会添加到测试应用的路径，还可以通过下面的方式扩展</p>

<pre><code>dependencies {
    androidTestCompile 'com.google.guava:guava:11.0.2'
}
</code></pre>

<p>测试应用使用<code>assembleTest</code>构建。<code>assemble</code>并不依赖于它。<code>assembleTest</code>在测试运行时自动执行。目前只会测试一个Build Type。缺省时是<code>debug</code> Build Type，也可以重新配置：</p>

<pre><code>android {
    ...
    testBuildType "staging"
}
</code></pre>

<h2>运行测试</h2>

<p>前面提到过，需要在连接的设备上使用<code>connectedCheck</code>这个anchor task发起检验。它依赖于<code>androidTest</code>。<code>connectedCheck</code>执行以下操作：</p>

<ul>
<li>确保app和test app被构建(分别依赖于<code>assembleDebug</code>和<code>assembleTest</code>)</li>
<li>安装app和test app</li>
<li>运行测试</li>
<li>卸载app和test app</li>
</ul>


<p>如果一个以上的设备连接，所有的测试将在已连接的设备上同时运行。如果任一个设备上的测试失败，构建将失败。所有的测试结果以XML文件形式保存在<code>build/androidTest-results</code>。(跟常规的JUnit测试结果保存在build/test-results类似)。可以进行配置：</p>

<pre><code>android {
    ...

    testOptions {
        resultsDir = "$project.buildDir/foo/results"
    }
}
</code></pre>

<p>使用<code>Project.file(String)</code>对<code>android.testOptions.resultsDir</code>进行求值。</p>

<h2>测试Android库</h2>

<p>测试Android库项目跟应用完全一样。唯一不同的是整个库以及其依赖会自动作为test app的库依赖。结果是测试APK不仅包含自己的代码，还包括库本身以及其依赖。库项目的manifest合并到test app的manifest(就跟任何项目引用这个库一样)。</p>

<p><code>androidTest</code>仅安装和卸载test APK(因为没有其他APK可安装)。</p>

<h2>测试报告</h2>

<p>运行单元测试，Gradle输出HTML报告以便查看结果。Android插件构建基于此，并从所有已连接设备统计HTML报告。</p>

<h3>单个项目</h3>

<p>缺省位置是<code>build/reports/androidTests</code>。跟JUnit的<code>build/reports/tests</code>类似。其他报告通常在<code>build/reports/&lt;plugin&gt;/</code>。可以对位置进行配置：</p>

<pre><code>android {
    ...

    testOptions {
        reportDir = "$project.buildDir/foo/report"
    }
}
</code></pre>

<p>报告统计了不同设备的运行结果。</p>

<h3>多项目</h3>

<p>在既有应用也有库的多项目中，当同时运行所有测试时，在同一个报告中统计所有测试结果可能很有用。可以使用Gradle包中的另一个插件实现这一目的：</p>

<pre><code>buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath 'com.android.tools.build:gradle:0.5.6'
    }
}

apply plugin: 'android-reporting'
</code></pre>

<p>在根项目中的build.gradle使用该配置。然后在根项目中，执行以下命令：</p>

<pre><code>gradle deviceCheck mergeAndroidReports --continue
</code></pre>

<p>注意：<code>--continue</code>参数保证运行所有测试，就算某个测试失败。如果不使用这个参数，第一个运行失败的测试会中断整个过程。</p>

<h2>Lint报告</h2>

<p>从v0.7.0开始，可以为某个特定的版本或所有版本运行lint。也可以通过添加如下<code>lintOptions</code>(下面显示了所有的可选项，而通常只需修改其中的某几个)：</p>

<pre><code>android {
    lintOptions {
        // set to true to turn off analysis progress reporting by lint
        quiet true
        // if true, stop the gradle build if errors are found
        abortOnError false
        // if true, only report errors
        ignoreWarnings true
        // if true, emit full/absolute paths to files with errors (true by default)
        //absolutePaths true
        // if true, check all issues, including those that are off by default
        checkAllWarnings true
        // if true, treat all warnings as errors
        warningsAsErrors true
        // turn off checking the given issue id's
        disable 'TypographyFractions','TypographyQuotes'
        // turn on the given issue id's
        enable 'RtlHardcoded','RtlCompat', 'RtlEnabled'
        // check *only* the given issue id's
        check 'NewApi', 'InlinedApi'
        // if true, don't include source code lines in the error output
        noLines true
        // if true, show all locations for an error, do not truncate lists, etc.
        showAll true
        // Fallback lint configuration (default severities, etc.)
        lintConfig file("default-lint.xml")
        // if true, generate a text report of issues (false by default)
        textReport true
        // location to write the output; can be a file or 'stdout'
        textOutput 'stdout'
        // if true, generate an XML report for use by for example Jenkins
        xmlReport false
        // file to write report to (if not specified, defaults to lint-results.xml)
        xmlOutput file("lint-report.xml")
        // if true, generate an HTML report (with issue explanations, sourcecode, etc)
        htmlReport true
        // optional path to report (default will be lint-results.html in the builddir)
        htmlOutput file("lint-report.html")

   // set to true to have all release builds run lint on issues with severity=fatal
   // and abort the build (controlled by abortOnError above) if fatal issues are found
   checkReleaseBuilds true
        // Set the severity of the given issues to fatal (which means they will be
        // checked during release builds (even if the lint target is not included)
        fatal 'NewApi', 'InlineApi'
        // Set the severity of the given issues to error
        error 'Wakelock', 'TextViewEdits'
        // Set the severity of the given issues to warning
        warning 'ResourceAsColor'
        // Set the severity of the given issues to ignore (same as disabling the check)
        ignore 'TypographyQuotes'
    }
}
</code></pre>

<h1>Build Variants</h1>

<p>新构建系统的一个目标就是允许创建同一个应用的不同版本。</p>

<p>这里有两种使用场景：</p>

<ol>
<li>同一个应用的不同版本。比如，分免费/演示版本和专业付费版本。</li>
<li>Same application packaged differently for multi-apk in Google Play Store. 更多信息参见<a href="http://developer.android.com/google/play/publishing/multiple-apks.html">这里</a></li>
</ol>


<p>目标是从同一个项目输出不同的APK，而需要使用同一库项目的两个项目。</p>

<h2>Product flavors</h2>

<p>product flavor定义同一项目构建的不同版本的应用。一个项目可以用不同的flavors，生成不同的应用。</p>

<p>这个新的概念用于解决版本差异很小的问题。问&#8221;是否同一个项目&#8221;，如果答案是&#8221;是&#8221;，那flavor可以就是比库项目更好的方式。</p>

<p>Product flavor使用<code>productFlavors</code> DSL容器声明：</p>

<pre><code>android {
    ....

    productFlavors {
        flavor1 {
            ...
        }

        flavor2 {
            ...
        }
    }
}
</code></pre>

<p>上面代码创建了两个flavor，分别是<code>flavor1</code>和<code>flavor2</code>。注意，flavor的名字不能跟已存在的Build Type名字，或<code>androidTest</code> sourceSet名字冲突。</p>

<h2>Build Type + Product Flavor = Build Variant</h2>

<p>前面知道，每个Build Type会产生一个新的APK。Product Flavor也是：每个项目的输出是Build Type和Product Flavor(如果可用的话)的所有组合。每种(Build Type, Product Flavor)组合是一个Build Variant。比如，使用缺省的<code>debug</code>和<code>release</code> Build Type，上面的例子将产生四个Build Variants：</p>

<ul>
<li>Flavor1 - debug</li>
<li>Flavor1 - release</li>
<li>Flavor2 - debug</li>
<li>Flavor2 - release</li>
</ul>


<p>没有flavor的项目同样也有Build Variants，但是会使用缺省的flavor/config，没名字，所以Variants列表跟Build Types列表完全一样。</p>

<h2>Product Flavor配置</h2>

<p>每个flavor均使用闭包配置：</p>

<pre><code>android {
    ...

    defaultConfig {
        minSdkVersion 8
        versionCode 10
    }

    productFlavors {
        flavor1 {
            packageName "com.example.flavor1"
            versionCode 20
        }

        flavor2 {
            packageName "com.example.flavor2"
            minSdkVersion 14
        }
    }
}
</code></pre>

<p>注意：<code>android.productFlavors.*</code>对象类型跟<code>android.defaultConfig</code>对象类型一样，均为ProductFlavor。所有它们有相同的属性。</p>

<p><code>defaultConfig</code>提供所有flavors的基本配置，每个flavor可以覆盖这些值。上面的例子中：</p>

<ul>
<li><code>flavor1</code></li>
<li><code>packageName</code>: com.example.flavor1</li>
<li><code>minSdkVersion</code>: 8</li>
<li><code>versionCode</code>: 20</li>
<li><code>flavor2</code></li>
<li><code>packageName</code>: com.example.flavor2</li>
<li><code>minSdkVersion</code>: 14</li>
<li><code>versionCode</code>: 10</li>
</ul>


<p>通常Build Type配置会覆盖其他配置。比如，Build Type的<code>packageNameSuffix</code>会添加到<code>packageName</code>。</p>

<p>有些时候可能一个配置既可以在Build Type也可以在Product Flavor中进行。In this case, it’s is on a case by case basis.</p>

<p>For instance, <code>signingConfig</code> is one of these properties.
This enables either having all release packages share the same SigningConfig, by setting <code>android.buildTypes.release.signingConfig</code>, or have each release package use their own SigningConfig by setting each <code>android.productFlavors.*.signingConfig</code> objects separately.</p>

<h2>SourceSets和依赖</h2>

<p>跟Build Types类似，Product Flavors也可以通过sourceSets提供代码和资源。上面的例子创建以下四个sourceSets：</p>

<ul>
<li><code>android.sourceSets.flavor1</code> - 位于 <code>src/flavor1/</code></li>
<li><code>android.sourceSets.flavor2</code> - 位于 <code>src/flavor2/</code></li>
<li><code>android.sourceSets.androidTestFlavor1</code> - 位于 <code>src/androidTestFlavor1/</code></li>
<li><code>android.sourceSets.androidTestFlavor2</code> - 位于 <code>src/androidTestFlavor2/</code></li>
</ul>


<p>这些sourceSets以及<code>android.sourceSets.main</code>和Build Type的sourceSet用于构建APK。以下规则用于处理所有用于构建单个APK的sourceSets：</p>

<ul>
<li>所有源码(<code>src/*/java</code>)用于生成单个输出</li>
<li>所有manifest用于合并到单个manifest。这个特点允许不同Product Flavor有不同组件或权限(跟Build Type类似)。</li>
<li>所有资源(Android res和assets)遵守覆盖优先级，Build Type覆盖Product Flavor，而Product Flavor又可覆盖<code>main</code> sourceSet。</li>
<li>每个Build Variant从相应的资源生成自己的R类文件(以及其他的自动生成代码)</li>
</ul>


<p>最后，跟Build Types很像，Product Flavors也可以有自己的依赖。比如，如果flavor用于生成有广告的免费app和无广告的付费app，那其中有个flavor会依赖Ads SDK，而另一个则不依赖。</p>

<pre><code>dependencies {
    flavor1Compile "..."
}
</code></pre>

<p>这个例子中，<code>src/flavor1/AndroidManifest.xml</code>很可能需要包含internet权限。每个variant还会产生其他的sourceSet：</p>

<ul>
<li><code>android.sourceSets.flavor1Debug</code> - 位于 <code>src/flavor1Debug/</code></li>
<li><code>android.sourceSets.flavor1Release</code> - 位于 <code>src/flavor1Release/</code></li>
<li><code>android.sourceSets.flavor2Debug</code> - 位于 <code>src/flavor2Debug/</code></li>
<li><code>android.sourceSets.flavor2Release</code> - 位于 <code>src/flavor2Release/</code></li>
</ul>


<p>它们的优先级比build type sourceSets高，允许在variant级别上配置。</p>

<h2>构建和任务</h2>

<p>之前看到，每个Build Type创建自己的<code>assemble&lt;name&gt;</code>任务，但Build Variants是Build Type和Product Flavor的组合。使用Product Flavors时，会创建多个 assemble-task。它们是：</p>

<ol>
<li>assemble<Variant Name> - 直接构建单个variant，比如<code>assembleFlavor1Debug</code></li>
<li>assemble<Build Type Name> - 构建某个Build Type的所有APK，比如<code>assembleDebug</code>将构建<code>Flavor1Debug</code>和<code>Flavor2Debug</code></li>
<li>assemble<Product Flavor Name> - 构建某个Flavor的所有APK，比如<code>Flavor1Debug</code>和<code>Flavor1Release</code></li>
</ol>


<p>而<code>assemble</code>将构建所有可能的variant</p>

<h2>测试</h2>

<p>测试multi-flavors项目跟测试简单工程类似。<code>androidTest</code> sourceSet用于所有flavor的通用测试，每个flavor可以有自己的测试。前面提到，用于测试每个flavor的sourceSets将创建：</p>

<ul>
<li><code>android.sourceSets.androidTestFlavor1</code> - 位于 <code>src/androidTestFlavor1/</code></li>
<li><code>android.sourceSets.androidTestFlavor2</code> - 位于 <code>src/androidTestFlavor2/</code></li>
</ul>


<p>类似的，它们也可以有自己的依赖：</p>

<pre><code>dependencies {
    androidTestFlavor1Compile "..."
}
</code></pre>

<p>可以通过<code>deviceCheck</code>运行测试，或者，当flavor被使用时<code>androidTest</code>将作为一个anchor task。每个flavor可以运行自己的测试：<code>androidTest&lt;VariantName&gt;</code>。比如：</p>

<ul>
<li><code>androidTestFlavor1Debug</code></li>
<li><code>androidTestFlavor2Debug</code></li>
</ul>


<p>类似地，每个variant也有各自的test apk构建任务和install/uninstall任务：</p>

<ul>
<li><code>assembleFlavor1Test</code></li>
<li><code>installFlavor1Debug</code></li>
<li><code>installFlavor1Test</code></li>
<li><code>uninstallFlavor1Debug</code></li>
</ul>


<p>最后，HTML报告也可以根据flavor统计。测试结果和报告位置如下，首先是每个flavor版本的，然后是总的统计结果：</p>

<ul>
<li><code>build/androidTest-results/flavors/&lt;FlavorName&gt;</code></li>
<li><code>build/androidTest-results/all/</code></li>
<li><code>build/reports/androidTests/flavors&lt;FlavorName&gt;</code></li>
<li><code>build/reports/androidTests/all/</code></li>
</ul>


<h1>高级构建配置</h1>

<h2>构建选项</h2>

<h3>Java编译选项</h3>

<pre><code>android {
    compileOptions {
        sourceCompatibility = "1.6"
        targetCompatibility = "1.6"
    }
}
</code></pre>

<p>缺省值是&#8221;1.6&#8221;。这个会影响所有的编译Java源码的任务。</p>

<h3>appt选项</h3>

<pre><code>android {
    aaptOptions {
        noCompress 'foo', 'bar'
        ignoreAssetsPattern "!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir&gt;_*:!CVS:!thumbs.db:!picasa.ini:!*~"
    }
}
</code></pre>

<p>这个会影响所有使用<code>aapt</code>的任务。</p>

<h3>dex选项</h3>

<pre><code>android {
    dexOptions {
        incremental false
        preDexLibraries = false
        jumboMode = false
        javaMaxHeapSize "2048M"
    }
}
</code></pre>

<h2>操作多任务</h2>

<p>基本Java项目只有有限的task用于创建输出。<code>classes</code> task用于编译Java源码。It’s easy to access from build.gradle by simply using classes in a script. This is a shortcut for project.tasks.classes.</p>

<p>在Android项目中，由于名字基于Build Types和Product Flavor会有大量相同的task。为了避免这个问题，<code>android</code>对象有以下属性：</p>

<ul>
<li><code>applicationVariants</code> (仅用于app plugin)</li>
<li><code>libraryVariants</code> (仅用于library plugin)</li>
<li><code>testVariants</code> (用于app plugin和library plugin)</li>
</ul>


<p>以上三者分别返回 <code>ApplicationVariant</code>, <code>LibraryVariant</code>和<code>TestVariant</code>的<a href="http://www.gradle.org/docs/current/javadoc/org/gradle/api/DomainObjectCollection.html">DomainObjectCollection</a>。</p>

<p>(略)</p>

<h2>BuildType和Product Flavor引用</h2>

<p>coming soon.</p>

<h2>使用sourceCompatibility 1.7</h2>

<p>从Android KitKat(buildToolsVersion 19)开始可以使用>操作符，multi-catch, strings in switches, try with resources等等。要支持这些新特性，在构建文件中添加如下代码：</p>

<pre><code>android {
    compileSdkVersion 19
    buildToolsVersion "19.0.0"

    defaultConfig {
        minSdkVersion 7
        targetSdkVersion 19
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
}
</code></pre>

<p>注意：<code>minSdkVersion</code>使用小于19的值时，可以使用除 try with resources 以外的所有语言特性。如果想使用 try with resources，必须让 minSdkVersion至少为19。当然，还必须保证Gradle是使用JDK 1.7或更新版本(Android Gradle插件为0.6.1或更新)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim-pandoc基本用法]]></title>
    <link href="http://www.sunmoonblog.com/blog/2015/05/28/vim-pandoc-tutorial/"/>
    <updated>2015-05-28T10:45:20+08:00</updated>
    <id>http://www.sunmoonblog.com/blog/2015/05/28/vim-pandoc-tutorial</id>
    <content type="html"><![CDATA[<p><code>vim-pandoc</code>可以集成Vim和Pandoc，用于写Markdown文档非常方便。</p>

<blockquote><p><code>vim-pandoc</code> provides facilities to integrate Vim with the pandoc document converter
<code>vim-pandoc</code>&rsquo;s goals are 1) to provide advanced integration with pandoc, 2) a comfortable document writing environment, and 3) great configurability.</p></blockquote>

<p>今天试用了一下，操作过程记录如下。</p>

<h1>安装Vundle</h1>

<p>平常主要在Windows上工作和写博客，下面主要讲<a href="https://github.com/gmarik/Vundle.vim/wiki/Vundle-for-Windows">Windows上如何安装Vundle</a>。(Linux平台上安装应该更简单)</p>

<p>安装Vundle要求先安装如下软件：</p>

<ul>
<li>Git</li>
<li>Curl</li>
</ul>


<p>通常在Windows上我们是使用<a href="http://msysgit.github.io/">msysgit</a>。安装msysgit后，Git和Curl都会安装好。我的电脑上安装情况如下。</p>

<pre><code>C:\&gt;git --version
git version 1.9.0.msysgit.0

C:\&gt;d:\Git\bin\curl.exe --version
curl 7.30.0 (i386-pc-win32) libcurl/7.30.0 OpenSSL/0.9.8y zlib/1.2.7
Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s
 rtsp smtp smtps telnet tftp
Features: AsynchDNS GSS-Negotiate IPv6 Largefile NTLM SPNEGO SSL SSPI libz
</code></pre>

<h2>下载Vundle</h2>

<pre><code>cd &lt;vim dir&gt;
git clone https://github.com/gmarik/Vundle.vim.git vimfiles/bundle/Vundle.vim
gvim _vimrc
</code></pre>

<h2>修改vim配置</h2>

<p>参考<a href="https://github.com/gmarik/Vundle.vim/wiki/Vundle-for-Windows">官网配置</a>在<code>_vimrc</code>中开始部分添加如下代码：</p>

<pre><code>set nocompatible              " be iMproved, required
filetype off                  " required

" set the runtime path to include Vundle and initialize
set rtp+=$VIM/vimfiles/bundle/Vundle.vim/
let path='$VIM/vimfiles/bundle'
call vundle#begin(path)
" alternatively, pass a path where Vundle should install plugins
"call vundle#begin('~/some/path/here')

" let Vundle manage Vundle, required
Plugin 'gmarik/Vundle.vim'

" The following are examples of different formats supported.
" Keep Plugin commands between vundle#begin/end.
" plugin on GitHub repo
Plugin 'vim-pandoc/vim-pandoc'
Plugin 'vim-pandoc/vim-pandoc-syntax' 

" All of your Plugins must be added before the following line
call vundle#end()            " required
filetype plugin indent on    " required
" To ignore plugin indent changes, instead use:
"filetype plugin on
"
" Brief help
" :PluginList       - lists configured plugins
" :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate
" :PluginSearch foo - searches for foo; append `!` to refresh local cache
" :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal
"
" see :h vundle for more details or wiki for FAQ
" Put your non-Plugin stuff after this line
</code></pre>

<p><font color="red">注意：&#8217;set rtp&#8217;部分的配置跟官网上有所不同。</font>按官网配置VIM一直出错，提示<code>Unknown function:</code>。了解了下<a href="http://vimdoc.sourceforge.net/htmldoc/options.html#%27runtimepath%27">什么是VIM rtp</a>(rtp, runtimepath)，修改为<code>set rtp+=$VIM/vimfiles/bundle/Vundle.vim/</code>后正常。</p>

<h1>安装vim-pandoc</h1>

<p>以下代码指定了我们需要安装的插件</p>

<pre><code>Plugin 'vim-pandoc/vim-pandoc'
Plugin 'vim-pandoc/vim-pandoc-syntax'
</code></pre>

<p>运行<code>:PluginInstall</code>安装插件。</p>

<p>安装后运行<code>:Pandoc</code>生成指定格式的文档。我电脑上装了Python但没有加入到PATH环境变量中，结果一直出现<code>WindowError</code>。参考<a href="https://github.com/vim-pandoc/vim-pandoc/issues/29">这个帖子</a>将Python加到PATH环境变量，问题解决。</p>

<h1>总结</h1>

<p>终于安装成功了，但是悲剧地发现vim-pandoc似乎并不比在<a href="http://zhouyichu.com/misc/Pandoc.html">Vim自定义函数</a>方便多少(不过它的<code>:TOC</code>命令确实不错，VIM编辑Markdown时文档内导航相当方便)。可能我是vim-pandoc新手，它的强大功能还没发现。后面慢慢体会吧。</p>

<h1>参考</h1>

<ul>
<li><a href="https://github.com/gmarik/Vundle.vim">Vundle</a></li>
<li><a href="https://github.com/vim-pandoc/vim-pandoc">vim-pandoc</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的效率工具列表]]></title>
    <link href="http://www.sunmoonblog.com/blog/2015/05/27/my-tools-list/"/>
    <updated>2015-05-27T10:40:57+08:00</updated>
    <id>http://www.sunmoonblog.com/blog/2015/05/27/my-tools-list</id>
    <content type="html"><![CDATA[<h1>编辑器</h1>

<h2><a href="http://pandoc.org/">Pandoc</a></h2>

<p>一个用于将Markdown文档转换成其他格式的命令工具。支持的格式包括HTML，EPUB，docx，PDF等等。Pandoc是用Haskell编写的(貌似非常小众的编程语言)，<a href="https://github.com/jgm/pandoc">源码</a>托管在Github上。Pandoc使用UTF-8编码方式来处理输入和输出。注意，像HTML之类的文档会在头部加上字符编码信息，只有使用<code>-s/--standalone</code>选项时才会生成这些头部信息。</p>

<p>一些有用选项：</p>

<ul>
<li><code>--toc</code> - 生成Table Of Content目录列表</li>
<li><code>-s</code> - 独立模式</li>
<li><code>-c &lt;css-file&gt;</code> - 指定CSS样式表</li>
<li><code>--self-contained</code> - 将所有的外部文件保存到单个HTML中</li>
</ul>


<blockquote><p>Pandoc uses the UTF-8 character encoding for both input and output. If your local character encoding is not UTF-8, you should pipe input and output through iconv:
<code>iconv -t utf-8 input.txt | pandoc | iconv -f utf-8</code>
Note that in some output formats (such as HTML, LaTeX, ConTeXt, RTF, OPML, DocBook, and Texinfo), information about the character encoding is included in the document header, which will only be included if you use the -s/&ndash;standalone option. <a href="http://pandoc.org/README.html">引用来源</a></p></blockquote>

<p>Pandoc可谓Markdown转换神器，要是能跟Vim结合起来写博客，岂不完美？参考<a href="http://zhouyichu.com/misc/Pandoc.html">这篇博客</a>，做法很简单。在Vim的_vimrc文件中添加以下代码：</p>

<pre><code>function! ToHtml()
    exec 'w'
    exec "!pandoc  -s -S --self-contained -c style.css % -o %&lt;.html "
endfunction

:nmap &lt;silent&gt; &lt;F5&gt; :call ToHtml()&lt;CR&gt;
</code></pre>

<p>上述代码中定义<code>ToHtml</code>函数用来调用pandoc生成HTML文档，映射<code>&lt;F5&gt;</code>去调用<code>ToHtml</code>函数。可以直接在Vim中<code>&lt;F5&gt;</code>生成HTML，避免了命令行的繁琐。
(比如octopress的<code>rake generate</code>, <code>rake preview</code>也简单多了)。</p>

<h2>Vundle</h2>

<p>Vim虽好，但是没有默认的插件管理器，配置Vim插件相当繁琐。可以试试<a href="http://zuyunfei.com/2013/04/12/killer-plugin-of-vim-vundle/">Vim的vundle插件</a>，它是用来Vim管理插件的。</p>

<h1>快捷键</h1>

<h2>WinHotKey</h2>

<p>可以在Windows上自定义各种快捷键打开应用或目录，非常方便</p>

<h2><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb">Vimium</a></h2>

<p>Chrome中的插件，快捷键的使用非常类似于Vim。习惯使用&#8221;J&#8221;和&#8221;K&#8221;翻页后，鼠标简直是多余的。关于插件的介绍以及快捷键的用法可以看<a href="http://www.chromein.com/crx_5411.html">这里</a></p>

<h2><a href="http://jingyan.baidu.com/article/359911f516583d57fe0306ae.html">Chrome自带快捷键</a></h2>

<h1>文档管理</h1>

<h2>Everything</h2>

<p>搜索本地文档非常方便，再也不用担心记不清文件放哪了</p>

<h1>在线工具</h1>

<p><a href="https://tinypng.com/">TinyPNG</a>可以用于压缩PNG图片的大小。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gradle学习笔记]]></title>
    <link href="http://www.sunmoonblog.com/blog/2015/05/21/gradle-tutorial/"/>
    <updated>2015-05-21T12:10:51+08:00</updated>
    <id>http://www.sunmoonblog.com/blog/2015/05/21/gradle-tutorial</id>
    <content type="html"><![CDATA[<h1>Gradle简介</h1>

<h2>Projects和tasks</h2>

<p>Gradle中一切都由两个基本概念构成：<code>projects</code>和<code>tasks</code>。</p>

<p>projects - 每个Gradle构建由一个或多个<code>projects</code>组成。一个<code>project</code>代表软件中可被构建的某种组件。比如，可以是一个JAR包或Web应用。
tasks - 每个<code>project</code>由一个或多个<code>tasks</code>组成。一个<code>task</code>代表构建过程中的某些原子操作。比如，可以是编译某些类，创建一个JAR文件，生成文档，或者是将某些归档文件发布到代码库。</p>

<h2>Hello world</h2>

<p>使用<code>gradle</code>命令执行Gradle构建。<code>gradle</code>命令在当前目录中搜索<code>build.gradle</code>文件。这个<code>build.gradle</code>文件称为构建脚本。严格来说是构建配置脚本。构建脚本定义了<code>project</code>和它的<code>tasks</code>。</p>

<p>最简单的构建脚本如下：</p>

<pre><code>task hello {
    doLast {
        println 'Hello world!'
    }
}
</code></pre>

<p>这个构建脚本定义了一个名为<code>hello</code>的<code>task</code>。运行<code>gradle hello</code>时Gradle会执行<code>hello</code>任务。该任务简单地执行一行Groovy代码。</p>

<p>Gradle中的<code>tasks</code>跟Ant中的targets类似，但更强大更具表现力。<code>tasks</code>之间可以有依赖。</p>

<pre><code>task hello {
    doLast {
        println 'Hello world!'
    }
}

task intro(dependsOn: hello) &lt;&lt; {
    println "I'm cm"
}
</code></pre>

<p>被依赖的<code>task</code>不需要事先定义。</p>

<pre><code>task intro(dependsOn: 'hello') &lt;&lt; {
    println "I'm cm"
}

task hello {
    doLast {
        println 'Hello world!'
    }
}
</code></pre>

<p>Gradle中允许定义一个或多个缺省的tasks。</p>

<h1>Gradle编译Java项目</h1>

<p>Gradle是通用的构建工具。但是如果不编写相应的代码，Gradle无法真正用于构建。下面看看怎么用Gradle构建Java项目。多数Java项目构建过程基本类似：编译Java源文件，运行单元测试，将class文件打包成JAR文件。你不必重头为每个Java项目编写Gradle构建脚本，Gradle已有专门的<code>plugins</code>用于Java项目构建。</p>

<blockquote><p>A plugin is an extension to Gradle which configures your project in some way, typically by adding some pre-configured tasks which together do something useful.</p></blockquote>

<h2>Java Plugin</h2>

<p>要使用Java Plugin，只需要在构建脚本中添加如下代码(简单吧:))：</p>

<pre><code>apply plugin 'java'
</code></pre>

<p>使用Java Plugin应注意：</p>

<ol>
<li>源码位于<code>src/main/java</code>目录</li>
<li>测试代码位于<code>src/test/java</code>目录</li>
<li><code>src/main/resources</code>目录下的文件作为资源打包到JAR文件</li>
<li><code>src/test/resources</code>目录下的文件添加到classpath用于运行单元测试</li>
<li>构建结果输出到<code>build</code>目录，JAR文件输出到<code>build/libs</code>目录</li>
</ol>


<p>Java Plugin常用task包括：</p>

<ol>
<li><code>build</code> - 完整构建，编译并单元测试，生成JAR文件</li>
<li><code>clean</code> - 删除<code>build</code>目录，删除所有编译生成的文件</li>
<li><code>check</code> - 编译并单元测试</li>
</ol>


<h2>外部依赖</h2>

<p>Java项目通常依赖外部JAR文件。应告诉Gradle从哪里能找到项目中引用的JAR文件。这些JAR文件位于<code>repository</code>。<code>repository</code>用于下载项目依赖的JAR。通常使用公开的Maven仓库。</p>

<pre><code>repositories {
    mavenCentral()
}
</code></pre>

<p>按下面的方式添加项目依赖。这里声明production classes对<code>commons collections</code>有编译时依赖，而test classes对<code>junit</code>有编译时依赖：</p>

<pre><code>dependencies {
    compile group: 'commons-collections', name: 'commons-collections', version: '3.2'
    testCompile group: 'junit', name: 'junit', version: '4.+'
}
</code></pre>

<h2>创建Eclipse项目</h2>

<p>Gradle要求的目录结构跟Eclipse Java项目有所不同，如何用创建一个既可以用Gradle编译、又可以在Eclipse中开发的Java项目呢？很简单，只需要在构建脚本中添加Eclipse plugin即可。</p>

<pre><code>apply plugin: 'eclipse'
</code></pre>

<p>然后执行<code>gradle eclipse</code>命令生成Eclipse项目文件，生成后该项目就能通过Eclipse的&#8221;Import Existing Projects into Workspace&#8221;导入进来。导入成功后可使用Eclipse进行项目开发:)。</p>

<h1>依赖管理</h1>

<p>依赖由两部分构成，首先Gradle应知道编译和运行项目需要的依赖项，以找到它们。这些外来的输入文件称为项目的<code>dependencies</code>。另一方面，Gradle要编译并上传项目的构建结果。这些向外输出的文件称为项目的<code>publications</code>。</p>

<p>可能需要从远程的Maven库或Ivy库，本地目录下载依赖项，或者从其他项目编译产生依赖项。这个过程称为<code>dependency resolution</code>。有些依赖项本身也有依赖，它们称为<code>transitive dependency</code>。</p>

<p>使用<code>dependencies</code> 声明依赖，如下：</p>

<pre><code>dependencies {
    compile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'
}
</code></pre>

<p>Gradle依赖分为不同的<code>configurations</code>。Java Plugin定义了几类标准的configurations。常见的几种如下</p>

<ul>
<li>compile - 编译项目源码所需的依赖</li>
<li>runtime - 运行production classes所需的依赖。缺省情况下也包含compile time dependencies</li>
<li>testCompile - 编译项目测试代码所需的依赖。缺省情况下也包含production classes和compile time dependencies</li>
<li>testRuntime - 运行测试代码所需的依赖。缺省情况下，也包含上述三种依赖</li>
</ul>


<p>不同的plugins有不同的标准configurations。也可以定义自己的configurations。</p>

<p>依赖又分不同的情况，一种是<code>external dependency</code>。这种依赖是当前构建以外的某种文件，通常保存在某种仓库中，比如Maven中央库或本地目录。使用<code>group</code>，<code>name</code>和<code>version</code>属性来标识依赖。一种简写方式是<code>"group:name:version"</code>.</p>

<p>依赖配置也用于发布文件，这些文件称为<code>publication artifacts</code>。使用Java Plugin通常不用告诉Gradle发布什么文件，只需要指定<code>uploadArchives task</code>的发布路径。</p>

<p>发布地本地目录</p>

<pre><code>uploadArchives {
    repositories {
        flatDir {
            dirs 'repos'
        }
    }
}
</code></pre>

<p>发布到Ivy库</p>

<pre><code>uploadArchives {
    repositories {
        ivy {
            credentials {
                username "username"
                password "pw"
            }
            url "http://repo.mycompany.com"
        }
    }
}
</code></pre>

<p>当运行<code>gradle uploadArchives</code>时Gradle将编译并上传JAR文件到<code>repositories</code>。</p>

<h1>常用Gradle命令</h1>

<ul>
<li><code>gradle &lt;task-name&gt;</code> - 执行指定的task</li>
<li><code>gradle &lt;task-a&gt; -x &lt;task-b&gt;</code> - 在忽略指定的task的情况下执行task</li>
<li>运行Gradle命令时不必指定task的全名，只需要提供可区分的缩写即可。比如使用<code>di</code>作为<code>dist</code>的缩写，或使用<code>aD</code>作为<code>assembleDebug</code>的缩写</li>
<li><code>gradle -b &lt;build-file&gt;</code> - 指定构建脚本</li>
<li><code>gradle -p &lt;dir&gt;</code> - 指定项目目录</li>
<li><code>gradle -q projects</code> - 输出项目信息</li>
<li><code>build.gradle</code>中添加<code>description = 'Your Description'</code> - 提供项目描述</li>
<li><code>gradle tasks</code> - 输出tasks信息</li>
<li><code>gradle tasks -all</code> - 输出项目中全部的tasks信息</li>
<li><code>gradle help --task &lt;someTask&gt;</code> - 输出指定task的详细信息</li>
<li><code>gradle dependencies app:dependencies</code> - 输出依赖信息</li>
<li><code>gradle properties</code> - 输出properties</li>
<li><code>gradle -q &lt;module&gt;:properties</code> - 输出指定module的properties</li>
<li><code>gradle --profile &lt;task&gt;</code> - 记录构建消耗的时间并输出到<code>build/reports/profile</code>目录。文件名以构建时间命名</li>
<li><code>gradle -m &lt;task&gt;</code> - 仅查询tasks执行情况而不真正构建</li>
<li><code>gradle --gui</code> - 启动Gradle的GUI界面</li>
</ul>


<h1>Gradle GUI</h1>

<p>Gradle提供一个简单易用的GUI界面。通过<code>gradle --gui</code>可以启动Gradle GUI。Gradle GUI主要分为Task Tree、Favorites、Command Line和Setup四个标签页</p>

<p>Task Tree以层级方式显示所有的projects和对应的tasks。双击可以执行相应的task。可以使用filter隐藏不常用的tasks，也可以将将常用的tasks添加到Favorites中。</p>

<p>Favorites用于显示常用的命令。可以非常复杂的命令，还能给它设置名字。比如，可以自定义一个构建命令用于快速编译以忽略单元测试、文档生成等步骤。</p>

<p>Command Line标签页用于直接运行单个的Gradle命令。只用输入&#8217;gradle&#8217;后的部分。可以在添加自定义命令前在这里进行尝试。</p>

<h1>Gradle插件</h1>

<p>Gradle自身提供的功能在实际的自动化过程中并不是非常有用。所有的实用功能，比如编译Java源码，是由<code>plugins</code>提供的。</p>

<p>一般会说<code>apply plugin</code>(使用插件)，对应的方法是<code>Project.apply()</code>。</p>

<pre><code>apply plugin: 'java'
</code></pre>

<p>Plugin有缩写名，比如使用&#8217;java&#8217;作为<code>JavaPlugin</code>的缩写名。也可以通过类型来使用插件，比如</p>

<pre><code>apply plugin: org.gradle.api.plugins.JavaPlugin
</code></pre>

<p>由于Gradle有缺省导入，所以也可写作</p>

<pre><code>apply plugin: JavaPlugin
</code></pre>

<p><code>plugin</code>的使用是幂等的(可以多次<code>apply</code>)。插件不过是实现了<code>Plugin</code>接口的类。</p>

<h1>疑难</h1>

<h2>代理上网问题</h2>

<p>在公司一般通过代理，Gradle没有设置正确的代理的话，很可能无法从repository下载依赖的JAR文件，提示构建失败。Gradle中可以使用标准的JVM系统属性来设置代理。可以直接在构建脚本中设置代理相关的属性，如<code>System.setProperty('http.proxyHost', 'www.somehost.org')</code>。也可以在项目根目录或Gradle主目录中的<code>gradle.properties</code>文件中指定这些属性。<code>gradle.properties</code>内容如下</p>

<pre><code>systemProp.http.proxyHost=www.somehost.org
systemProp.http.proxyPort=8080
systemProp.http.proxyUser=userid
systemProp.http.proxyPassword=password
systemProp.http.nonProxyHosts=*.nonproxyrepos.com|localhost
</code></pre>

<h2>官方Maven库下载慢</h2>

<p>如果当前网络条件下从官方Maven库下载文件过慢，可以通过修改构建脚本切换到国内的Maven镜像仓库，或者换成自建的Maven私服。比如，切换成<a href="http://maven.oschina.net/index.html">开源中国的Maven库</a></p>

<pre><code>repositories {
    maven{ url 'http://maven.oschina.net/content/groups/public/'}
}
</code></pre>

<p>也可以在<code>gradle.properties</code>中添加<code>REPO_URL=&lt;url&gt;</code>，然后在<code>build.gradle</code>中使用<code>project.REPO_URL</code>引用这个url</p>

<h2>其他问题</h2>

<p>错误：<code>Connection to https://jcenter.bintray.com refused</code></p>

<p>原因：没有配置HTTPS代理，在<code>gradle.properties</code>上配置HTTPS代理即可</p>

<p>错误：<code>Could not create plugin of type 'AppPlugin'</code></p>

<p>原因：Gradle版本过低。使用独立安装的Gradle(v1.12)会出现这个问题，使用Android Studio自带的Gradle(v2.2.1)完全正常</p>

<p>错误：JDK编译失败</p>

<p>原因：Android Studio自带JDK 7编译，源码中使用了Java 7的语法。命令行中使用Gradle编译时使用JDK 6进行编译，所以报错。<code>gradle.properties</code>使用<code>org.gradle.java.home</code>属性指定Gradle编译时使用的JDK路径。<a href="https://docs.gradle.org/current/userguide/build_environment.html">官方文档</a></p>

<hr />

<p>参考资料：</p>

<ul>
<li>Gradle Userguide</li>
<li><a href="http://www.yrom.net/blog/2015/02/07/change-gradle-maven-repo-url/">Gradle 修改 Maven 仓库地址</a></li>
<li><a href="http://www.huangyunkun.com/2014/04/26/libgdx-gradle-change-source/">使用Gradle构建速度慢的问题</a></li>
</ul>


<p>To Read:</p>

<ul>
<li><a href="http://avatarqing.gitbooks.io/gradlepluginuserguidechineseverision/content/">Gradle Android插件用户指南</a></li>
<li><a href="http://sinojelly.sinaapp.com/2014/02/201402-gradle-use-notes/">201402 Gradle使用笔记</a></li>
<li><a href="http://rileybrewer.com/blog/2013/10/4/building-faster-with-gradle-in-android-studio">BUILDING FAST(ER) WITH GRADLE IN ANDROID STUDIO</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
